/* eslint-disable */
// @ts-nocheck
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.server = (function() {

    /**
     * Namespace server.
     * @exports server
     * @namespace
     */
    var server = {};

    server.UploadAvatar = (function() {

        /**
         * Properties of an UploadAvatar.
         * @memberof server
         * @interface IUploadAvatar
         * @property {string|null} [id] UploadAvatar id
         * @property {Uint8Array|null} [data] UploadAvatar data
         * @property {Uint8Array|null} [fullData] UploadAvatar fullData
         */

        /**
         * Constructs a new UploadAvatar.
         * @memberof server
         * @classdesc Represents an UploadAvatar.
         * @implements IUploadAvatar
         * @constructor
         * @param {server.IUploadAvatar=} [properties] Properties to set
         */
        function UploadAvatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadAvatar id.
         * @member {string} id
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.id = "";

        /**
         * UploadAvatar data.
         * @member {Uint8Array} data
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.data = $util.newBuffer([]);

        /**
         * UploadAvatar fullData.
         * @member {Uint8Array} fullData
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.fullData = $util.newBuffer([]);

        /**
         * Creates a new UploadAvatar instance using the specified properties.
         * @function create
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar=} [properties] Properties to set
         * @returns {server.UploadAvatar} UploadAvatar instance
         */
        UploadAvatar.create = function create(properties) {
            return new UploadAvatar(properties);
        };

        /**
         * Encodes the specified UploadAvatar message. Does not implicitly {@link server.UploadAvatar.verify|verify} messages.
         * @function encode
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar} message UploadAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadAvatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.fullData != null && Object.hasOwnProperty.call(message, "fullData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fullData);
            return writer;
        };

        /**
         * Encodes the specified UploadAvatar message, length delimited. Does not implicitly {@link server.UploadAvatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar} message UploadAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadAvatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadAvatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadAvatar} UploadAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadAvatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadAvatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.fullData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadAvatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadAvatar} UploadAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadAvatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadAvatar message.
         * @function verify
         * @memberof server.UploadAvatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadAvatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                if (!(message.fullData && typeof message.fullData.length === "number" || $util.isString(message.fullData)))
                    return "fullData: buffer expected";
            return null;
        };

        /**
         * Creates an UploadAvatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadAvatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadAvatar} UploadAvatar
         */
        UploadAvatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadAvatar)
                return object;
            var message = new $root.server.UploadAvatar();
            if (object.id != null)
                message.id = String(object.id);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.fullData != null)
                if (typeof object.fullData === "string")
                    $util.base64.decode(object.fullData, message.fullData = $util.newBuffer($util.base64.length(object.fullData)), 0);
                else if (object.fullData.length)
                    message.fullData = object.fullData;
            return message;
        };

        /**
         * Creates a plain object from an UploadAvatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadAvatar
         * @static
         * @param {server.UploadAvatar} message UploadAvatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadAvatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.fullData = "";
                else {
                    object.fullData = [];
                    if (options.bytes !== Array)
                        object.fullData = $util.newBuffer(object.fullData);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                object.fullData = options.bytes === String ? $util.base64.encode(message.fullData, 0, message.fullData.length) : options.bytes === Array ? Array.prototype.slice.call(message.fullData) : message.fullData;
            return object;
        };

        /**
         * Converts this UploadAvatar to JSON.
         * @function toJSON
         * @memberof server.UploadAvatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadAvatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UploadAvatar;
    })();

    server.Avatar = (function() {

        /**
         * Properties of an Avatar.
         * @memberof server
         * @interface IAvatar
         * @property {string|null} [id] Avatar id
         * @property {number|Long|null} [uid] Avatar uid
         */

        /**
         * Constructs a new Avatar.
         * @memberof server
         * @classdesc Represents an Avatar.
         * @implements IAvatar
         * @constructor
         * @param {server.IAvatar=} [properties] Properties to set
         */
        function Avatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Avatar id.
         * @member {string} id
         * @memberof server.Avatar
         * @instance
         */
        Avatar.prototype.id = "";

        /**
         * Avatar uid.
         * @member {number|Long} uid
         * @memberof server.Avatar
         * @instance
         */
        Avatar.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Avatar instance using the specified properties.
         * @function create
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar=} [properties] Properties to set
         * @returns {server.Avatar} Avatar instance
         */
        Avatar.create = function create(properties) {
            return new Avatar(properties);
        };

        /**
         * Encodes the specified Avatar message. Does not implicitly {@link server.Avatar.verify|verify} messages.
         * @function encode
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar} message Avatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified Avatar message, length delimited. Does not implicitly {@link server.Avatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar} message Avatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Avatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.Avatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Avatar} Avatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Avatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Avatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Avatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Avatar} Avatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Avatar message.
         * @function verify
         * @memberof server.Avatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Avatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Avatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Avatar} Avatar
         */
        Avatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Avatar)
                return object;
            var message = new $root.server.Avatar();
            if (object.id != null)
                message.id = String(object.id);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Avatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Avatar
         * @static
         * @param {server.Avatar} message Avatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Avatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this Avatar to JSON.
         * @function toJSON
         * @memberof server.Avatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Avatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Avatar;
    })();

    server.Avatars = (function() {

        /**
         * Properties of an Avatars.
         * @memberof server
         * @interface IAvatars
         * @property {Array.<server.IAvatar>|null} [avatars] Avatars avatars
         */

        /**
         * Constructs a new Avatars.
         * @memberof server
         * @classdesc Represents an Avatars.
         * @implements IAvatars
         * @constructor
         * @param {server.IAvatars=} [properties] Properties to set
         */
        function Avatars(properties) {
            this.avatars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Avatars avatars.
         * @member {Array.<server.IAvatar>} avatars
         * @memberof server.Avatars
         * @instance
         */
        Avatars.prototype.avatars = $util.emptyArray;

        /**
         * Creates a new Avatars instance using the specified properties.
         * @function create
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars=} [properties] Properties to set
         * @returns {server.Avatars} Avatars instance
         */
        Avatars.create = function create(properties) {
            return new Avatars(properties);
        };

        /**
         * Encodes the specified Avatars message. Does not implicitly {@link server.Avatars.verify|verify} messages.
         * @function encode
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars} message Avatars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.avatars != null && message.avatars.length)
                for (var i = 0; i < message.avatars.length; ++i)
                    $root.server.Avatar.encode(message.avatars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Avatars message, length delimited. Does not implicitly {@link server.Avatars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars} message Avatars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Avatars message from the specified reader or buffer.
         * @function decode
         * @memberof server.Avatars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Avatars} Avatars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Avatars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.avatars && message.avatars.length))
                        message.avatars = [];
                    message.avatars.push($root.server.Avatar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Avatars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Avatars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Avatars} Avatars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Avatars message.
         * @function verify
         * @memberof server.Avatars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Avatars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                if (!Array.isArray(message.avatars))
                    return "avatars: array expected";
                for (var i = 0; i < message.avatars.length; ++i) {
                    var error = $root.server.Avatar.verify(message.avatars[i]);
                    if (error)
                        return "avatars." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Avatars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Avatars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Avatars} Avatars
         */
        Avatars.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Avatars)
                return object;
            var message = new $root.server.Avatars();
            if (object.avatars) {
                if (!Array.isArray(object.avatars))
                    throw TypeError(".server.Avatars.avatars: array expected");
                message.avatars = [];
                for (var i = 0; i < object.avatars.length; ++i) {
                    if (typeof object.avatars[i] !== "object")
                        throw TypeError(".server.Avatars.avatars: object expected");
                    message.avatars[i] = $root.server.Avatar.fromObject(object.avatars[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Avatars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Avatars
         * @static
         * @param {server.Avatars} message Avatars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Avatars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.avatars = [];
            if (message.avatars && message.avatars.length) {
                object.avatars = [];
                for (var j = 0; j < message.avatars.length; ++j)
                    object.avatars[j] = $root.server.Avatar.toObject(message.avatars[j], options);
            }
            return object;
        };

        /**
         * Converts this Avatars to JSON.
         * @function toJSON
         * @memberof server.Avatars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Avatars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Avatars;
    })();

    server.UploadGroupAvatar = (function() {

        /**
         * Properties of an UploadGroupAvatar.
         * @memberof server
         * @interface IUploadGroupAvatar
         * @property {string|null} [gid] UploadGroupAvatar gid
         * @property {Uint8Array|null} [data] UploadGroupAvatar data
         * @property {Uint8Array|null} [fullData] UploadGroupAvatar fullData
         */

        /**
         * Constructs a new UploadGroupAvatar.
         * @memberof server
         * @classdesc Represents an UploadGroupAvatar.
         * @implements IUploadGroupAvatar
         * @constructor
         * @param {server.IUploadGroupAvatar=} [properties] Properties to set
         */
        function UploadGroupAvatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadGroupAvatar gid.
         * @member {string} gid
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.gid = "";

        /**
         * UploadGroupAvatar data.
         * @member {Uint8Array} data
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.data = $util.newBuffer([]);

        /**
         * UploadGroupAvatar fullData.
         * @member {Uint8Array} fullData
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.fullData = $util.newBuffer([]);

        /**
         * Creates a new UploadGroupAvatar instance using the specified properties.
         * @function create
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar=} [properties] Properties to set
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar instance
         */
        UploadGroupAvatar.create = function create(properties) {
            return new UploadGroupAvatar(properties);
        };

        /**
         * Encodes the specified UploadGroupAvatar message. Does not implicitly {@link server.UploadGroupAvatar.verify|verify} messages.
         * @function encode
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar} message UploadGroupAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadGroupAvatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.fullData != null && Object.hasOwnProperty.call(message, "fullData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fullData);
            return writer;
        };

        /**
         * Encodes the specified UploadGroupAvatar message, length delimited. Does not implicitly {@link server.UploadGroupAvatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar} message UploadGroupAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadGroupAvatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadGroupAvatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadGroupAvatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadGroupAvatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.fullData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadGroupAvatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadGroupAvatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadGroupAvatar message.
         * @function verify
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadGroupAvatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                if (!(message.fullData && typeof message.fullData.length === "number" || $util.isString(message.fullData)))
                    return "fullData: buffer expected";
            return null;
        };

        /**
         * Creates an UploadGroupAvatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         */
        UploadGroupAvatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadGroupAvatar)
                return object;
            var message = new $root.server.UploadGroupAvatar();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.fullData != null)
                if (typeof object.fullData === "string")
                    $util.base64.decode(object.fullData, message.fullData = $util.newBuffer($util.base64.length(object.fullData)), 0);
                else if (object.fullData.length)
                    message.fullData = object.fullData;
            return message;
        };

        /**
         * Creates a plain object from an UploadGroupAvatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.UploadGroupAvatar} message UploadGroupAvatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadGroupAvatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.fullData = "";
                else {
                    object.fullData = [];
                    if (options.bytes !== Array)
                        object.fullData = $util.newBuffer(object.fullData);
                }
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                object.fullData = options.bytes === String ? $util.base64.encode(message.fullData, 0, message.fullData.length) : options.bytes === Array ? Array.prototype.slice.call(message.fullData) : message.fullData;
            return object;
        };

        /**
         * Converts this UploadGroupAvatar to JSON.
         * @function toJSON
         * @memberof server.UploadGroupAvatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadGroupAvatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UploadGroupAvatar;
    })();

    server.CertMessage = (function() {

        /**
         * Properties of a CertMessage.
         * @memberof server
         * @interface ICertMessage
         * @property {number|Long|null} [timestamp] CertMessage timestamp
         * @property {Uint8Array|null} [serverKey] CertMessage serverKey
         */

        /**
         * Constructs a new CertMessage.
         * @memberof server
         * @classdesc Represents a CertMessage.
         * @implements ICertMessage
         * @constructor
         * @param {server.ICertMessage=} [properties] Properties to set
         */
        function CertMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof server.CertMessage
         * @instance
         */
        CertMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CertMessage serverKey.
         * @member {Uint8Array} serverKey
         * @memberof server.CertMessage
         * @instance
         */
        CertMessage.prototype.serverKey = $util.newBuffer([]);

        /**
         * Creates a new CertMessage instance using the specified properties.
         * @function create
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage=} [properties] Properties to set
         * @returns {server.CertMessage} CertMessage instance
         */
        CertMessage.create = function create(properties) {
            return new CertMessage(properties);
        };

        /**
         * Encodes the specified CertMessage message. Does not implicitly {@link server.CertMessage.verify|verify} messages.
         * @function encode
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage} message CertMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverKey);
            return writer;
        };

        /**
         * Encodes the specified CertMessage message, length delimited. Does not implicitly {@link server.CertMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage} message CertMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertMessage message from the specified reader or buffer.
         * @function decode
         * @memberof server.CertMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CertMessage} CertMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CertMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.serverKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CertMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CertMessage} CertMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertMessage message.
         * @function verify
         * @memberof server.CertMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                if (!(message.serverKey && typeof message.serverKey.length === "number" || $util.isString(message.serverKey)))
                    return "serverKey: buffer expected";
            return null;
        };

        /**
         * Creates a CertMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CertMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CertMessage} CertMessage
         */
        CertMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CertMessage)
                return object;
            var message = new $root.server.CertMessage();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.serverKey != null)
                if (typeof object.serverKey === "string")
                    $util.base64.decode(object.serverKey, message.serverKey = $util.newBuffer($util.base64.length(object.serverKey)), 0);
                else if (object.serverKey.length)
                    message.serverKey = object.serverKey;
            return message;
        };

        /**
         * Creates a plain object from a CertMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CertMessage
         * @static
         * @param {server.CertMessage} message CertMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.serverKey = "";
                else {
                    object.serverKey = [];
                    if (options.bytes !== Array)
                        object.serverKey = $util.newBuffer(object.serverKey);
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                object.serverKey = options.bytes === String ? $util.base64.encode(message.serverKey, 0, message.serverKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverKey) : message.serverKey;
            return object;
        };

        /**
         * Converts this CertMessage to JSON.
         * @function toJSON
         * @memberof server.CertMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CertMessage;
    })();

    server.ClientMode = (function() {

        /**
         * Properties of a ClientMode.
         * @memberof server
         * @interface IClientMode
         * @property {server.ClientMode.Mode|null} [mode] ClientMode mode
         */

        /**
         * Constructs a new ClientMode.
         * @memberof server
         * @classdesc Represents a ClientMode.
         * @implements IClientMode
         * @constructor
         * @param {server.IClientMode=} [properties] Properties to set
         */
        function ClientMode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientMode mode.
         * @member {server.ClientMode.Mode} mode
         * @memberof server.ClientMode
         * @instance
         */
        ClientMode.prototype.mode = 0;

        /**
         * Creates a new ClientMode instance using the specified properties.
         * @function create
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode=} [properties] Properties to set
         * @returns {server.ClientMode} ClientMode instance
         */
        ClientMode.create = function create(properties) {
            return new ClientMode(properties);
        };

        /**
         * Encodes the specified ClientMode message. Does not implicitly {@link server.ClientMode.verify|verify} messages.
         * @function encode
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode} message ClientMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            return writer;
        };

        /**
         * Encodes the specified ClientMode message, length delimited. Does not implicitly {@link server.ClientMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode} message ClientMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientMode message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientMode} ClientMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientMode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientMode} ClientMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientMode message.
         * @function verify
         * @memberof server.ClientMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ClientMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientMode} ClientMode
         */
        ClientMode.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientMode)
                return object;
            var message = new $root.server.ClientMode();
            switch (object.mode) {
            case "ACTIVE":
            case 0:
                message.mode = 0;
                break;
            case "PASSIVE":
            case 1:
                message.mode = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientMode
         * @static
         * @param {server.ClientMode} message ClientMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mode = options.enums === String ? "ACTIVE" : 0;
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.server.ClientMode.Mode[message.mode] : message.mode;
            return object;
        };

        /**
         * Converts this ClientMode to JSON.
         * @function toJSON
         * @memberof server.ClientMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Mode enum.
         * @name server.ClientMode.Mode
         * @enum {number}
         * @property {number} ACTIVE=0 ACTIVE value
         * @property {number} PASSIVE=1 PASSIVE value
         */
        ClientMode.Mode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ACTIVE"] = 0;
            values[valuesById[1] = "PASSIVE"] = 1;
            return values;
        })();

        return ClientMode;
    })();

    server.ClientVersion = (function() {

        /**
         * Properties of a ClientVersion.
         * @memberof server
         * @interface IClientVersion
         * @property {string|null} [version] ClientVersion version
         * @property {number|Long|null} [expiresInSeconds] ClientVersion expiresInSeconds
         */

        /**
         * Constructs a new ClientVersion.
         * @memberof server
         * @classdesc Represents a ClientVersion.
         * @implements IClientVersion
         * @constructor
         * @param {server.IClientVersion=} [properties] Properties to set
         */
        function ClientVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientVersion version.
         * @member {string} version
         * @memberof server.ClientVersion
         * @instance
         */
        ClientVersion.prototype.version = "";

        /**
         * ClientVersion expiresInSeconds.
         * @member {number|Long} expiresInSeconds
         * @memberof server.ClientVersion
         * @instance
         */
        ClientVersion.prototype.expiresInSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ClientVersion instance using the specified properties.
         * @function create
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion=} [properties] Properties to set
         * @returns {server.ClientVersion} ClientVersion instance
         */
        ClientVersion.create = function create(properties) {
            return new ClientVersion(properties);
        };

        /**
         * Encodes the specified ClientVersion message. Does not implicitly {@link server.ClientVersion.verify|verify} messages.
         * @function encode
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion} message ClientVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.expiresInSeconds != null && Object.hasOwnProperty.call(message, "expiresInSeconds"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiresInSeconds);
            return writer;
        };

        /**
         * Encodes the specified ClientVersion message, length delimited. Does not implicitly {@link server.ClientVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion} message ClientVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientVersion message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientVersion} ClientVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.expiresInSeconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientVersion} ClientVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientVersion message.
         * @function verify
         * @memberof server.ClientVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (!$util.isInteger(message.expiresInSeconds) && !(message.expiresInSeconds && $util.isInteger(message.expiresInSeconds.low) && $util.isInteger(message.expiresInSeconds.high)))
                    return "expiresInSeconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a ClientVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientVersion} ClientVersion
         */
        ClientVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientVersion)
                return object;
            var message = new $root.server.ClientVersion();
            if (object.version != null)
                message.version = String(object.version);
            if (object.expiresInSeconds != null)
                if ($util.Long)
                    (message.expiresInSeconds = $util.Long.fromValue(object.expiresInSeconds)).unsigned = false;
                else if (typeof object.expiresInSeconds === "string")
                    message.expiresInSeconds = parseInt(object.expiresInSeconds, 10);
                else if (typeof object.expiresInSeconds === "number")
                    message.expiresInSeconds = object.expiresInSeconds;
                else if (typeof object.expiresInSeconds === "object")
                    message.expiresInSeconds = new $util.LongBits(object.expiresInSeconds.low >>> 0, object.expiresInSeconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ClientVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientVersion
         * @static
         * @param {server.ClientVersion} message ClientVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiresInSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresInSeconds = options.longs === String ? "0" : 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (typeof message.expiresInSeconds === "number")
                    object.expiresInSeconds = options.longs === String ? String(message.expiresInSeconds) : message.expiresInSeconds;
                else
                    object.expiresInSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.expiresInSeconds) : options.longs === Number ? new $util.LongBits(message.expiresInSeconds.low >>> 0, message.expiresInSeconds.high >>> 0).toNumber() : message.expiresInSeconds;
            return object;
        };

        /**
         * Converts this ClientVersion to JSON.
         * @function toJSON
         * @memberof server.ClientVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientVersion;
    })();

    server.DeviceInfo = (function() {

        /**
         * Properties of a DeviceInfo.
         * @memberof server
         * @interface IDeviceInfo
         * @property {string|null} [device] DeviceInfo device
         * @property {string|null} [osVersion] DeviceInfo osVersion
         */

        /**
         * Constructs a new DeviceInfo.
         * @memberof server
         * @classdesc Represents a DeviceInfo.
         * @implements IDeviceInfo
         * @constructor
         * @param {server.IDeviceInfo=} [properties] Properties to set
         */
        function DeviceInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceInfo device.
         * @member {string} device
         * @memberof server.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.device = "";

        /**
         * DeviceInfo osVersion.
         * @member {string} osVersion
         * @memberof server.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.osVersion = "";

        /**
         * Creates a new DeviceInfo instance using the specified properties.
         * @function create
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo=} [properties] Properties to set
         * @returns {server.DeviceInfo} DeviceInfo instance
         */
        DeviceInfo.create = function create(properties) {
            return new DeviceInfo(properties);
        };

        /**
         * Encodes the specified DeviceInfo message. Does not implicitly {@link server.DeviceInfo.verify|verify} messages.
         * @function encode
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
            if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.osVersion);
            return writer;
        };

        /**
         * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link server.DeviceInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeviceInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.device = reader.string();
                    break;
                case 2:
                    message.osVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceInfo message.
         * @function verify
         * @memberof server.DeviceInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                if (!$util.isString(message.osVersion))
                    return "osVersion: string expected";
            return null;
        };

        /**
         * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeviceInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeviceInfo} DeviceInfo
         */
        DeviceInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeviceInfo)
                return object;
            var message = new $root.server.DeviceInfo();
            if (object.device != null)
                message.device = String(object.device);
            if (object.osVersion != null)
                message.osVersion = String(object.osVersion);
            return message;
        };

        /**
         * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeviceInfo
         * @static
         * @param {server.DeviceInfo} message DeviceInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.device = "";
                object.osVersion = "";
            }
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                object.osVersion = message.osVersion;
            return object;
        };

        /**
         * Converts this DeviceInfo to JSON.
         * @function toJSON
         * @memberof server.DeviceInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceInfo;
    })();

    server.ClientLog = (function() {

        /**
         * Properties of a ClientLog.
         * @memberof server
         * @interface IClientLog
         * @property {Array.<server.ICount>|null} [counts] ClientLog counts
         * @property {Array.<server.IEventData>|null} [events] ClientLog events
         */

        /**
         * Constructs a new ClientLog.
         * @memberof server
         * @classdesc Represents a ClientLog.
         * @implements IClientLog
         * @constructor
         * @param {server.IClientLog=} [properties] Properties to set
         */
        function ClientLog(properties) {
            this.counts = [];
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientLog counts.
         * @member {Array.<server.ICount>} counts
         * @memberof server.ClientLog
         * @instance
         */
        ClientLog.prototype.counts = $util.emptyArray;

        /**
         * ClientLog events.
         * @member {Array.<server.IEventData>} events
         * @memberof server.ClientLog
         * @instance
         */
        ClientLog.prototype.events = $util.emptyArray;

        /**
         * Creates a new ClientLog instance using the specified properties.
         * @function create
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog=} [properties] Properties to set
         * @returns {server.ClientLog} ClientLog instance
         */
        ClientLog.create = function create(properties) {
            return new ClientLog(properties);
        };

        /**
         * Encodes the specified ClientLog message. Does not implicitly {@link server.ClientLog.verify|verify} messages.
         * @function encode
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog} message ClientLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.counts != null && message.counts.length)
                for (var i = 0; i < message.counts.length; ++i)
                    $root.server.Count.encode(message.counts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.server.EventData.encode(message.events[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientLog message, length delimited. Does not implicitly {@link server.ClientLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog} message ClientLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientLog message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientLog} ClientLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.counts && message.counts.length))
                        message.counts = [];
                    message.counts.push($root.server.Count.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.server.EventData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientLog} ClientLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientLog message.
         * @function verify
         * @memberof server.ClientLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.counts != null && message.hasOwnProperty("counts")) {
                if (!Array.isArray(message.counts))
                    return "counts: array expected";
                for (var i = 0; i < message.counts.length; ++i) {
                    var error = $root.server.Count.verify(message.counts[i]);
                    if (error)
                        return "counts." + error;
                }
            }
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.server.EventData.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientLog} ClientLog
         */
        ClientLog.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientLog)
                return object;
            var message = new $root.server.ClientLog();
            if (object.counts) {
                if (!Array.isArray(object.counts))
                    throw TypeError(".server.ClientLog.counts: array expected");
                message.counts = [];
                for (var i = 0; i < object.counts.length; ++i) {
                    if (typeof object.counts[i] !== "object")
                        throw TypeError(".server.ClientLog.counts: object expected");
                    message.counts[i] = $root.server.Count.fromObject(object.counts[i]);
                }
            }
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".server.ClientLog.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".server.ClientLog.events: object expected");
                    message.events[i] = $root.server.EventData.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientLog
         * @static
         * @param {server.ClientLog} message ClientLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.counts = [];
                object.events = [];
            }
            if (message.counts && message.counts.length) {
                object.counts = [];
                for (var j = 0; j < message.counts.length; ++j)
                    object.counts[j] = $root.server.Count.toObject(message.counts[j], options);
            }
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.server.EventData.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientLog to JSON.
         * @function toJSON
         * @memberof server.ClientLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientLog;
    })();

    server.Count = (function() {

        /**
         * Properties of a Count.
         * @memberof server
         * @interface ICount
         * @property {string|null} [namespace] Count namespace
         * @property {string|null} [metric] Count metric
         * @property {number|Long|null} [count] Count count
         * @property {Array.<server.IDim>|null} [dims] Count dims
         */

        /**
         * Constructs a new Count.
         * @memberof server
         * @classdesc Represents a Count.
         * @implements ICount
         * @constructor
         * @param {server.ICount=} [properties] Properties to set
         */
        function Count(properties) {
            this.dims = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Count namespace.
         * @member {string} namespace
         * @memberof server.Count
         * @instance
         */
        Count.prototype.namespace = "";

        /**
         * Count metric.
         * @member {string} metric
         * @memberof server.Count
         * @instance
         */
        Count.prototype.metric = "";

        /**
         * Count count.
         * @member {number|Long} count
         * @memberof server.Count
         * @instance
         */
        Count.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Count dims.
         * @member {Array.<server.IDim>} dims
         * @memberof server.Count
         * @instance
         */
        Count.prototype.dims = $util.emptyArray;

        /**
         * Creates a new Count instance using the specified properties.
         * @function create
         * @memberof server.Count
         * @static
         * @param {server.ICount=} [properties] Properties to set
         * @returns {server.Count} Count instance
         */
        Count.create = function create(properties) {
            return new Count(properties);
        };

        /**
         * Encodes the specified Count message. Does not implicitly {@link server.Count.verify|verify} messages.
         * @function encode
         * @memberof server.Count
         * @static
         * @param {server.ICount} message Count message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Count.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
            if (message.metric != null && Object.hasOwnProperty.call(message, "metric"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.metric);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.count);
            if (message.dims != null && message.dims.length)
                for (var i = 0; i < message.dims.length; ++i)
                    $root.server.Dim.encode(message.dims[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Count message, length delimited. Does not implicitly {@link server.Count.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Count
         * @static
         * @param {server.ICount} message Count message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Count.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Count message from the specified reader or buffer.
         * @function decode
         * @memberof server.Count
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Count} Count
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Count.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Count();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.namespace = reader.string();
                    break;
                case 2:
                    message.metric = reader.string();
                    break;
                case 3:
                    message.count = reader.int64();
                    break;
                case 4:
                    if (!(message.dims && message.dims.length))
                        message.dims = [];
                    message.dims.push($root.server.Dim.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Count message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Count
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Count} Count
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Count.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Count message.
         * @function verify
         * @memberof server.Count
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Count.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                if (!$util.isString(message.namespace))
                    return "namespace: string expected";
            if (message.metric != null && message.hasOwnProperty("metric"))
                if (!$util.isString(message.metric))
                    return "metric: string expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
                if (!Array.isArray(message.dims))
                    return "dims: array expected";
                for (var i = 0; i < message.dims.length; ++i) {
                    var error = $root.server.Dim.verify(message.dims[i]);
                    if (error)
                        return "dims." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Count message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Count
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Count} Count
         */
        Count.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Count)
                return object;
            var message = new $root.server.Count();
            if (object.namespace != null)
                message.namespace = String(object.namespace);
            if (object.metric != null)
                message.metric = String(object.metric);
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            if (object.dims) {
                if (!Array.isArray(object.dims))
                    throw TypeError(".server.Count.dims: array expected");
                message.dims = [];
                for (var i = 0; i < object.dims.length; ++i) {
                    if (typeof object.dims[i] !== "object")
                        throw TypeError(".server.Count.dims: object expected");
                    message.dims[i] = $root.server.Dim.fromObject(object.dims[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Count message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Count
         * @static
         * @param {server.Count} message Count
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Count.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dims = [];
            if (options.defaults) {
                object.namespace = "";
                object.metric = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
            }
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                object.namespace = message.namespace;
            if (message.metric != null && message.hasOwnProperty("metric"))
                object.metric = message.metric;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            if (message.dims && message.dims.length) {
                object.dims = [];
                for (var j = 0; j < message.dims.length; ++j)
                    object.dims[j] = $root.server.Dim.toObject(message.dims[j], options);
            }
            return object;
        };

        /**
         * Converts this Count to JSON.
         * @function toJSON
         * @memberof server.Count
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Count.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Count;
    })();

    server.Dim = (function() {

        /**
         * Properties of a Dim.
         * @memberof server
         * @interface IDim
         * @property {string|null} [name] Dim name
         * @property {string|null} [value] Dim value
         */

        /**
         * Constructs a new Dim.
         * @memberof server
         * @classdesc Represents a Dim.
         * @implements IDim
         * @constructor
         * @param {server.IDim=} [properties] Properties to set
         */
        function Dim(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dim name.
         * @member {string} name
         * @memberof server.Dim
         * @instance
         */
        Dim.prototype.name = "";

        /**
         * Dim value.
         * @member {string} value
         * @memberof server.Dim
         * @instance
         */
        Dim.prototype.value = "";

        /**
         * Creates a new Dim instance using the specified properties.
         * @function create
         * @memberof server.Dim
         * @static
         * @param {server.IDim=} [properties] Properties to set
         * @returns {server.Dim} Dim instance
         */
        Dim.create = function create(properties) {
            return new Dim(properties);
        };

        /**
         * Encodes the specified Dim message. Does not implicitly {@link server.Dim.verify|verify} messages.
         * @function encode
         * @memberof server.Dim
         * @static
         * @param {server.IDim} message Dim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dim.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Dim message, length delimited. Does not implicitly {@link server.Dim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Dim
         * @static
         * @param {server.IDim} message Dim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dim.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dim message from the specified reader or buffer.
         * @function decode
         * @memberof server.Dim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Dim} Dim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dim.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Dim();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Dim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Dim} Dim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dim.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dim message.
         * @function verify
         * @memberof server.Dim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dim.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Dim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Dim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Dim} Dim
         */
        Dim.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Dim)
                return object;
            var message = new $root.server.Dim();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Dim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Dim
         * @static
         * @param {server.Dim} message Dim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dim.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Dim to JSON.
         * @function toJSON
         * @memberof server.Dim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dim.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Dim;
    })();

    server.Contact = (function() {

        /**
         * Properties of a Contact.
         * @memberof server
         * @interface IContact
         * @property {server.Contact.Action|null} [action] Contact action
         * @property {string|null} [raw] Contact raw
         * @property {string|null} [normalized] Contact normalized
         * @property {number|Long|null} [uid] Contact uid
         * @property {string|null} [avatarId] Contact avatarId
         * @property {string|null} [name] Contact name
         * @property {number|Long|null} [numPotentialFriends] Contact numPotentialFriends
         * @property {number|Long|null} [numPotentialCloseFriends] Contact numPotentialCloseFriends
         * @property {number|Long|null} [invitationRank] Contact invitationRank
         */

        /**
         * Constructs a new Contact.
         * @memberof server
         * @classdesc Represents a Contact.
         * @implements IContact
         * @constructor
         * @param {server.IContact=} [properties] Properties to set
         */
        function Contact(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Contact action.
         * @member {server.Contact.Action} action
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.action = 0;

        /**
         * Contact raw.
         * @member {string} raw
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.raw = "";

        /**
         * Contact normalized.
         * @member {string} normalized
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.normalized = "";

        /**
         * Contact uid.
         * @member {number|Long} uid
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contact avatarId.
         * @member {string} avatarId
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.avatarId = "";

        /**
         * Contact name.
         * @member {string} name
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.name = "";

        /**
         * Contact numPotentialFriends.
         * @member {number|Long} numPotentialFriends
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.numPotentialFriends = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contact numPotentialCloseFriends.
         * @member {number|Long} numPotentialCloseFriends
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.numPotentialCloseFriends = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contact invitationRank.
         * @member {number|Long} invitationRank
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.invitationRank = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Contact instance using the specified properties.
         * @function create
         * @memberof server.Contact
         * @static
         * @param {server.IContact=} [properties] Properties to set
         * @returns {server.Contact} Contact instance
         */
        Contact.create = function create(properties) {
            return new Contact(properties);
        };

        /**
         * Encodes the specified Contact message. Does not implicitly {@link server.Contact.verify|verify} messages.
         * @function encode
         * @memberof server.Contact
         * @static
         * @param {server.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.raw != null && Object.hasOwnProperty.call(message, "raw"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.raw);
            if (message.normalized != null && Object.hasOwnProperty.call(message, "normalized"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.normalized);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.uid);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.numPotentialFriends != null && Object.hasOwnProperty.call(message, "numPotentialFriends"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.numPotentialFriends);
            if (message.numPotentialCloseFriends != null && Object.hasOwnProperty.call(message, "numPotentialCloseFriends"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.numPotentialCloseFriends);
            if (message.invitationRank != null && Object.hasOwnProperty.call(message, "invitationRank"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.invitationRank);
            return writer;
        };

        /**
         * Encodes the specified Contact message, length delimited. Does not implicitly {@link server.Contact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Contact
         * @static
         * @param {server.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Contact message from the specified reader or buffer.
         * @function decode
         * @memberof server.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Contact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.raw = reader.string();
                    break;
                case 3:
                    message.normalized = reader.string();
                    break;
                case 4:
                    message.uid = reader.int64();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.numPotentialFriends = reader.int64();
                    break;
                case 9:
                    message.numPotentialCloseFriends = reader.int64();
                    break;
                case 10:
                    message.invitationRank = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Contact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Contact message.
         * @function verify
         * @memberof server.Contact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Contact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.raw != null && message.hasOwnProperty("raw"))
                if (!$util.isString(message.raw))
                    return "raw: string expected";
            if (message.normalized != null && message.hasOwnProperty("normalized"))
                if (!$util.isString(message.normalized))
                    return "normalized: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.numPotentialFriends != null && message.hasOwnProperty("numPotentialFriends"))
                if (!$util.isInteger(message.numPotentialFriends) && !(message.numPotentialFriends && $util.isInteger(message.numPotentialFriends.low) && $util.isInteger(message.numPotentialFriends.high)))
                    return "numPotentialFriends: integer|Long expected";
            if (message.numPotentialCloseFriends != null && message.hasOwnProperty("numPotentialCloseFriends"))
                if (!$util.isInteger(message.numPotentialCloseFriends) && !(message.numPotentialCloseFriends && $util.isInteger(message.numPotentialCloseFriends.low) && $util.isInteger(message.numPotentialCloseFriends.high)))
                    return "numPotentialCloseFriends: integer|Long expected";
            if (message.invitationRank != null && message.hasOwnProperty("invitationRank"))
                if (!$util.isInteger(message.invitationRank) && !(message.invitationRank && $util.isInteger(message.invitationRank.low) && $util.isInteger(message.invitationRank.high)))
                    return "invitationRank: integer|Long expected";
            return null;
        };

        /**
         * Creates a Contact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Contact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Contact} Contact
         */
        Contact.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Contact)
                return object;
            var message = new $root.server.Contact();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.raw != null)
                message.raw = String(object.raw);
            if (object.normalized != null)
                message.normalized = String(object.normalized);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.name != null)
                message.name = String(object.name);
            if (object.numPotentialFriends != null)
                if ($util.Long)
                    (message.numPotentialFriends = $util.Long.fromValue(object.numPotentialFriends)).unsigned = false;
                else if (typeof object.numPotentialFriends === "string")
                    message.numPotentialFriends = parseInt(object.numPotentialFriends, 10);
                else if (typeof object.numPotentialFriends === "number")
                    message.numPotentialFriends = object.numPotentialFriends;
                else if (typeof object.numPotentialFriends === "object")
                    message.numPotentialFriends = new $util.LongBits(object.numPotentialFriends.low >>> 0, object.numPotentialFriends.high >>> 0).toNumber();
            if (object.numPotentialCloseFriends != null)
                if ($util.Long)
                    (message.numPotentialCloseFriends = $util.Long.fromValue(object.numPotentialCloseFriends)).unsigned = false;
                else if (typeof object.numPotentialCloseFriends === "string")
                    message.numPotentialCloseFriends = parseInt(object.numPotentialCloseFriends, 10);
                else if (typeof object.numPotentialCloseFriends === "number")
                    message.numPotentialCloseFriends = object.numPotentialCloseFriends;
                else if (typeof object.numPotentialCloseFriends === "object")
                    message.numPotentialCloseFriends = new $util.LongBits(object.numPotentialCloseFriends.low >>> 0, object.numPotentialCloseFriends.high >>> 0).toNumber();
            if (object.invitationRank != null)
                if ($util.Long)
                    (message.invitationRank = $util.Long.fromValue(object.invitationRank)).unsigned = false;
                else if (typeof object.invitationRank === "string")
                    message.invitationRank = parseInt(object.invitationRank, 10);
                else if (typeof object.invitationRank === "number")
                    message.invitationRank = object.invitationRank;
                else if (typeof object.invitationRank === "object")
                    message.invitationRank = new $util.LongBits(object.invitationRank.low >>> 0, object.invitationRank.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Contact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Contact
         * @static
         * @param {server.Contact} message Contact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Contact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                object.raw = "";
                object.normalized = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.avatarId = "";
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numPotentialFriends = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numPotentialFriends = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numPotentialCloseFriends = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numPotentialCloseFriends = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.invitationRank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.invitationRank = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.Contact.Action[message.action] : message.action;
            if (message.raw != null && message.hasOwnProperty("raw"))
                object.raw = message.raw;
            if (message.normalized != null && message.hasOwnProperty("normalized"))
                object.normalized = message.normalized;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.numPotentialFriends != null && message.hasOwnProperty("numPotentialFriends"))
                if (typeof message.numPotentialFriends === "number")
                    object.numPotentialFriends = options.longs === String ? String(message.numPotentialFriends) : message.numPotentialFriends;
                else
                    object.numPotentialFriends = options.longs === String ? $util.Long.prototype.toString.call(message.numPotentialFriends) : options.longs === Number ? new $util.LongBits(message.numPotentialFriends.low >>> 0, message.numPotentialFriends.high >>> 0).toNumber() : message.numPotentialFriends;
            if (message.numPotentialCloseFriends != null && message.hasOwnProperty("numPotentialCloseFriends"))
                if (typeof message.numPotentialCloseFriends === "number")
                    object.numPotentialCloseFriends = options.longs === String ? String(message.numPotentialCloseFriends) : message.numPotentialCloseFriends;
                else
                    object.numPotentialCloseFriends = options.longs === String ? $util.Long.prototype.toString.call(message.numPotentialCloseFriends) : options.longs === Number ? new $util.LongBits(message.numPotentialCloseFriends.low >>> 0, message.numPotentialCloseFriends.high >>> 0).toNumber() : message.numPotentialCloseFriends;
            if (message.invitationRank != null && message.hasOwnProperty("invitationRank"))
                if (typeof message.invitationRank === "number")
                    object.invitationRank = options.longs === String ? String(message.invitationRank) : message.invitationRank;
                else
                    object.invitationRank = options.longs === String ? $util.Long.prototype.toString.call(message.invitationRank) : options.longs === Number ? new $util.LongBits(message.invitationRank.low >>> 0, message.invitationRank.high >>> 0).toNumber() : message.invitationRank;
            return object;
        };

        /**
         * Converts this Contact to JSON.
         * @function toJSON
         * @memberof server.Contact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Contact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.Contact.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        Contact.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return Contact;
    })();

    server.ContactList = (function() {

        /**
         * Properties of a ContactList.
         * @memberof server
         * @interface IContactList
         * @property {server.ContactList.Type|null} [type] ContactList type
         * @property {string|null} [syncId] ContactList syncId
         * @property {number|null} [batchIndex] ContactList batchIndex
         * @property {boolean|null} [isLast] ContactList isLast
         * @property {Array.<server.IContact>|null} [contacts] ContactList contacts
         * @property {boolean|null} [hasPermissions] ContactList hasPermissions
         */

        /**
         * Constructs a new ContactList.
         * @memberof server
         * @classdesc Represents a ContactList.
         * @implements IContactList
         * @constructor
         * @param {server.IContactList=} [properties] Properties to set
         */
        function ContactList(properties) {
            this.contacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactList type.
         * @member {server.ContactList.Type} type
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.type = 0;

        /**
         * ContactList syncId.
         * @member {string} syncId
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.syncId = "";

        /**
         * ContactList batchIndex.
         * @member {number} batchIndex
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.batchIndex = 0;

        /**
         * ContactList isLast.
         * @member {boolean} isLast
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.isLast = false;

        /**
         * ContactList contacts.
         * @member {Array.<server.IContact>} contacts
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.contacts = $util.emptyArray;

        /**
         * ContactList hasPermissions.
         * @member {boolean} hasPermissions
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.hasPermissions = false;

        /**
         * Creates a new ContactList instance using the specified properties.
         * @function create
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList=} [properties] Properties to set
         * @returns {server.ContactList} ContactList instance
         */
        ContactList.create = function create(properties) {
            return new ContactList(properties);
        };

        /**
         * Encodes the specified ContactList message. Does not implicitly {@link server.ContactList.verify|verify} messages.
         * @function encode
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList} message ContactList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.syncId != null && Object.hasOwnProperty.call(message, "syncId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.syncId);
            if (message.batchIndex != null && Object.hasOwnProperty.call(message, "batchIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchIndex);
            if (message.isLast != null && Object.hasOwnProperty.call(message, "isLast"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isLast);
            if (message.contacts != null && message.contacts.length)
                for (var i = 0; i < message.contacts.length; ++i)
                    $root.server.Contact.encode(message.contacts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.hasPermissions != null && Object.hasOwnProperty.call(message, "hasPermissions"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasPermissions);
            return writer;
        };

        /**
         * Encodes the specified ContactList message, length delimited. Does not implicitly {@link server.ContactList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList} message ContactList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactList message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactList} ContactList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.syncId = reader.string();
                    break;
                case 3:
                    message.batchIndex = reader.int32();
                    break;
                case 4:
                    message.isLast = reader.bool();
                    break;
                case 5:
                    if (!(message.contacts && message.contacts.length))
                        message.contacts = [];
                    message.contacts.push($root.server.Contact.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.hasPermissions = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactList} ContactList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactList message.
         * @function verify
         * @memberof server.ContactList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.syncId != null && message.hasOwnProperty("syncId"))
                if (!$util.isString(message.syncId))
                    return "syncId: string expected";
            if (message.batchIndex != null && message.hasOwnProperty("batchIndex"))
                if (!$util.isInteger(message.batchIndex))
                    return "batchIndex: integer expected";
            if (message.isLast != null && message.hasOwnProperty("isLast"))
                if (typeof message.isLast !== "boolean")
                    return "isLast: boolean expected";
            if (message.contacts != null && message.hasOwnProperty("contacts")) {
                if (!Array.isArray(message.contacts))
                    return "contacts: array expected";
                for (var i = 0; i < message.contacts.length; ++i) {
                    var error = $root.server.Contact.verify(message.contacts[i]);
                    if (error)
                        return "contacts." + error;
                }
            }
            if (message.hasPermissions != null && message.hasOwnProperty("hasPermissions"))
                if (typeof message.hasPermissions !== "boolean")
                    return "hasPermissions: boolean expected";
            return null;
        };

        /**
         * Creates a ContactList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactList} ContactList
         */
        ContactList.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactList)
                return object;
            var message = new $root.server.ContactList();
            switch (object.type) {
            case "FULL":
            case 0:
                message.type = 0;
                break;
            case "DELTA":
            case 1:
                message.type = 1;
                break;
            case "NORMAL":
            case 2:
                message.type = 2;
                break;
            case "FRIEND_NOTICE":
            case 3:
                message.type = 3;
                break;
            case "INVITER_NOTICE":
            case 4:
                message.type = 4;
                break;
            case "DELETE_NOTICE":
            case 5:
                message.type = 5;
                break;
            case "CONTACT_NOTICE":
            case 6:
                message.type = 6;
                break;
            }
            if (object.syncId != null)
                message.syncId = String(object.syncId);
            if (object.batchIndex != null)
                message.batchIndex = object.batchIndex | 0;
            if (object.isLast != null)
                message.isLast = Boolean(object.isLast);
            if (object.contacts) {
                if (!Array.isArray(object.contacts))
                    throw TypeError(".server.ContactList.contacts: array expected");
                message.contacts = [];
                for (var i = 0; i < object.contacts.length; ++i) {
                    if (typeof object.contacts[i] !== "object")
                        throw TypeError(".server.ContactList.contacts: object expected");
                    message.contacts[i] = $root.server.Contact.fromObject(object.contacts[i]);
                }
            }
            if (object.hasPermissions != null)
                message.hasPermissions = Boolean(object.hasPermissions);
            return message;
        };

        /**
         * Creates a plain object from a ContactList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactList
         * @static
         * @param {server.ContactList} message ContactList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contacts = [];
            if (options.defaults) {
                object.type = options.enums === String ? "FULL" : 0;
                object.syncId = "";
                object.batchIndex = 0;
                object.isLast = false;
                object.hasPermissions = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ContactList.Type[message.type] : message.type;
            if (message.syncId != null && message.hasOwnProperty("syncId"))
                object.syncId = message.syncId;
            if (message.batchIndex != null && message.hasOwnProperty("batchIndex"))
                object.batchIndex = message.batchIndex;
            if (message.isLast != null && message.hasOwnProperty("isLast"))
                object.isLast = message.isLast;
            if (message.contacts && message.contacts.length) {
                object.contacts = [];
                for (var j = 0; j < message.contacts.length; ++j)
                    object.contacts[j] = $root.server.Contact.toObject(message.contacts[j], options);
            }
            if (message.hasPermissions != null && message.hasOwnProperty("hasPermissions"))
                object.hasPermissions = message.hasPermissions;
            return object;
        };

        /**
         * Converts this ContactList to JSON.
         * @function toJSON
         * @memberof server.ContactList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ContactList.Type
         * @enum {number}
         * @property {number} FULL=0 FULL value
         * @property {number} DELTA=1 DELTA value
         * @property {number} NORMAL=2 NORMAL value
         * @property {number} FRIEND_NOTICE=3 FRIEND_NOTICE value
         * @property {number} INVITER_NOTICE=4 INVITER_NOTICE value
         * @property {number} DELETE_NOTICE=5 DELETE_NOTICE value
         * @property {number} CONTACT_NOTICE=6 CONTACT_NOTICE value
         */
        ContactList.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FULL"] = 0;
            values[valuesById[1] = "DELTA"] = 1;
            values[valuesById[2] = "NORMAL"] = 2;
            values[valuesById[3] = "FRIEND_NOTICE"] = 3;
            values[valuesById[4] = "INVITER_NOTICE"] = 4;
            values[valuesById[5] = "DELETE_NOTICE"] = 5;
            values[valuesById[6] = "CONTACT_NOTICE"] = 6;
            return values;
        })();

        return ContactList;
    })();

    server.ContactHash = (function() {

        /**
         * Properties of a ContactHash.
         * @memberof server
         * @interface IContactHash
         * @property {Uint8Array|null} [hash] ContactHash hash
         */

        /**
         * Constructs a new ContactHash.
         * @memberof server
         * @classdesc Represents a ContactHash.
         * @implements IContactHash
         * @constructor
         * @param {server.IContactHash=} [properties] Properties to set
         */
        function ContactHash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactHash hash.
         * @member {Uint8Array} hash
         * @memberof server.ContactHash
         * @instance
         */
        ContactHash.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new ContactHash instance using the specified properties.
         * @function create
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash=} [properties] Properties to set
         * @returns {server.ContactHash} ContactHash instance
         */
        ContactHash.create = function create(properties) {
            return new ContactHash(properties);
        };

        /**
         * Encodes the specified ContactHash message. Does not implicitly {@link server.ContactHash.verify|verify} messages.
         * @function encode
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash} message ContactHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified ContactHash message, length delimited. Does not implicitly {@link server.ContactHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash} message ContactHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactHash message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactHash} ContactHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactHash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactHash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactHash} ContactHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactHash message.
         * @function verify
         * @memberof server.ContactHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a ContactHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactHash} ContactHash
         */
        ContactHash.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactHash)
                return object;
            var message = new $root.server.ContactHash();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a ContactHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactHash
         * @static
         * @param {server.ContactHash} message ContactHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this ContactHash to JSON.
         * @function toJSON
         * @memberof server.ContactHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactHash;
    })();

    server.ContactSyncError = (function() {

        /**
         * Properties of a ContactSyncError.
         * @memberof server
         * @interface IContactSyncError
         * @property {number|null} [retryAfterSecs] ContactSyncError retryAfterSecs
         */

        /**
         * Constructs a new ContactSyncError.
         * @memberof server
         * @classdesc Represents a ContactSyncError.
         * @implements IContactSyncError
         * @constructor
         * @param {server.IContactSyncError=} [properties] Properties to set
         */
        function ContactSyncError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactSyncError retryAfterSecs.
         * @member {number} retryAfterSecs
         * @memberof server.ContactSyncError
         * @instance
         */
        ContactSyncError.prototype.retryAfterSecs = 0;

        /**
         * Creates a new ContactSyncError instance using the specified properties.
         * @function create
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError=} [properties] Properties to set
         * @returns {server.ContactSyncError} ContactSyncError instance
         */
        ContactSyncError.create = function create(properties) {
            return new ContactSyncError(properties);
        };

        /**
         * Encodes the specified ContactSyncError message. Does not implicitly {@link server.ContactSyncError.verify|verify} messages.
         * @function encode
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError} message ContactSyncError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactSyncError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retryAfterSecs != null && Object.hasOwnProperty.call(message, "retryAfterSecs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retryAfterSecs);
            return writer;
        };

        /**
         * Encodes the specified ContactSyncError message, length delimited. Does not implicitly {@link server.ContactSyncError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError} message ContactSyncError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactSyncError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactSyncError message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactSyncError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactSyncError} ContactSyncError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactSyncError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactSyncError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retryAfterSecs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactSyncError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactSyncError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactSyncError} ContactSyncError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactSyncError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactSyncError message.
         * @function verify
         * @memberof server.ContactSyncError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactSyncError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (!$util.isInteger(message.retryAfterSecs))
                    return "retryAfterSecs: integer expected";
            return null;
        };

        /**
         * Creates a ContactSyncError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactSyncError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactSyncError} ContactSyncError
         */
        ContactSyncError.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactSyncError)
                return object;
            var message = new $root.server.ContactSyncError();
            if (object.retryAfterSecs != null)
                message.retryAfterSecs = object.retryAfterSecs | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContactSyncError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactSyncError
         * @static
         * @param {server.ContactSyncError} message ContactSyncError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactSyncError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.retryAfterSecs = 0;
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                object.retryAfterSecs = message.retryAfterSecs;
            return object;
        };

        /**
         * Converts this ContactSyncError to JSON.
         * @function toJSON
         * @memberof server.ContactSyncError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactSyncError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactSyncError;
    })();

    server.MomentInfo = (function() {

        /**
         * Properties of a MomentInfo.
         * @memberof server
         * @interface IMomentInfo
         * @property {number|Long|null} [notificationTimestamp] MomentInfo notificationTimestamp
         * @property {number|Long|null} [timeTaken] MomentInfo timeTaken
         * @property {number|Long|null} [numTakes] MomentInfo numTakes
         * @property {number|Long|null} [numSelfieTakes] MomentInfo numSelfieTakes
         * @property {number|Long|null} [notificationId] MomentInfo notificationId
         * @property {server.MomentInfo.ContentType|null} [contentType] MomentInfo contentType
         */

        /**
         * Constructs a new MomentInfo.
         * @memberof server
         * @classdesc Represents a MomentInfo.
         * @implements IMomentInfo
         * @constructor
         * @param {server.IMomentInfo=} [properties] Properties to set
         */
        function MomentInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentInfo notificationTimestamp.
         * @member {number|Long} notificationTimestamp
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.notificationTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentInfo timeTaken.
         * @member {number|Long} timeTaken
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.timeTaken = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentInfo numTakes.
         * @member {number|Long} numTakes
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.numTakes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentInfo numSelfieTakes.
         * @member {number|Long} numSelfieTakes
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.numSelfieTakes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentInfo notificationId.
         * @member {number|Long} notificationId
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.notificationId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentInfo contentType.
         * @member {server.MomentInfo.ContentType} contentType
         * @memberof server.MomentInfo
         * @instance
         */
        MomentInfo.prototype.contentType = 0;

        /**
         * Creates a new MomentInfo instance using the specified properties.
         * @function create
         * @memberof server.MomentInfo
         * @static
         * @param {server.IMomentInfo=} [properties] Properties to set
         * @returns {server.MomentInfo} MomentInfo instance
         */
        MomentInfo.create = function create(properties) {
            return new MomentInfo(properties);
        };

        /**
         * Encodes the specified MomentInfo message. Does not implicitly {@link server.MomentInfo.verify|verify} messages.
         * @function encode
         * @memberof server.MomentInfo
         * @static
         * @param {server.IMomentInfo} message MomentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MomentInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notificationTimestamp != null && Object.hasOwnProperty.call(message, "notificationTimestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.notificationTimestamp);
            if (message.timeTaken != null && Object.hasOwnProperty.call(message, "timeTaken"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeTaken);
            if (message.numTakes != null && Object.hasOwnProperty.call(message, "numTakes"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.numTakes);
            if (message.numSelfieTakes != null && Object.hasOwnProperty.call(message, "numSelfieTakes"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.numSelfieTakes);
            if (message.notificationId != null && Object.hasOwnProperty.call(message, "notificationId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.notificationId);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified MomentInfo message, length delimited. Does not implicitly {@link server.MomentInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MomentInfo
         * @static
         * @param {server.IMomentInfo} message MomentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MomentInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MomentInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.MomentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MomentInfo} MomentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MomentInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.notificationTimestamp = reader.int64();
                    break;
                case 2:
                    message.timeTaken = reader.int64();
                    break;
                case 3:
                    message.numTakes = reader.int64();
                    break;
                case 4:
                    message.numSelfieTakes = reader.int64();
                    break;
                case 5:
                    message.notificationId = reader.int64();
                    break;
                case 6:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MomentInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MomentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MomentInfo} MomentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MomentInfo message.
         * @function verify
         * @memberof server.MomentInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MomentInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.notificationTimestamp != null && message.hasOwnProperty("notificationTimestamp"))
                if (!$util.isInteger(message.notificationTimestamp) && !(message.notificationTimestamp && $util.isInteger(message.notificationTimestamp.low) && $util.isInteger(message.notificationTimestamp.high)))
                    return "notificationTimestamp: integer|Long expected";
            if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                if (!$util.isInteger(message.timeTaken) && !(message.timeTaken && $util.isInteger(message.timeTaken.low) && $util.isInteger(message.timeTaken.high)))
                    return "timeTaken: integer|Long expected";
            if (message.numTakes != null && message.hasOwnProperty("numTakes"))
                if (!$util.isInteger(message.numTakes) && !(message.numTakes && $util.isInteger(message.numTakes.low) && $util.isInteger(message.numTakes.high)))
                    return "numTakes: integer|Long expected";
            if (message.numSelfieTakes != null && message.hasOwnProperty("numSelfieTakes"))
                if (!$util.isInteger(message.numSelfieTakes) && !(message.numSelfieTakes && $util.isInteger(message.numSelfieTakes.low) && $util.isInteger(message.numSelfieTakes.high)))
                    return "numSelfieTakes: integer|Long expected";
            if (message.notificationId != null && message.hasOwnProperty("notificationId"))
                if (!$util.isInteger(message.notificationId) && !(message.notificationId && $util.isInteger(message.notificationId.low) && $util.isInteger(message.notificationId.high)))
                    return "notificationId: integer|Long expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a MomentInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MomentInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MomentInfo} MomentInfo
         */
        MomentInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MomentInfo)
                return object;
            var message = new $root.server.MomentInfo();
            if (object.notificationTimestamp != null)
                if ($util.Long)
                    (message.notificationTimestamp = $util.Long.fromValue(object.notificationTimestamp)).unsigned = false;
                else if (typeof object.notificationTimestamp === "string")
                    message.notificationTimestamp = parseInt(object.notificationTimestamp, 10);
                else if (typeof object.notificationTimestamp === "number")
                    message.notificationTimestamp = object.notificationTimestamp;
                else if (typeof object.notificationTimestamp === "object")
                    message.notificationTimestamp = new $util.LongBits(object.notificationTimestamp.low >>> 0, object.notificationTimestamp.high >>> 0).toNumber();
            if (object.timeTaken != null)
                if ($util.Long)
                    (message.timeTaken = $util.Long.fromValue(object.timeTaken)).unsigned = false;
                else if (typeof object.timeTaken === "string")
                    message.timeTaken = parseInt(object.timeTaken, 10);
                else if (typeof object.timeTaken === "number")
                    message.timeTaken = object.timeTaken;
                else if (typeof object.timeTaken === "object")
                    message.timeTaken = new $util.LongBits(object.timeTaken.low >>> 0, object.timeTaken.high >>> 0).toNumber();
            if (object.numTakes != null)
                if ($util.Long)
                    (message.numTakes = $util.Long.fromValue(object.numTakes)).unsigned = false;
                else if (typeof object.numTakes === "string")
                    message.numTakes = parseInt(object.numTakes, 10);
                else if (typeof object.numTakes === "number")
                    message.numTakes = object.numTakes;
                else if (typeof object.numTakes === "object")
                    message.numTakes = new $util.LongBits(object.numTakes.low >>> 0, object.numTakes.high >>> 0).toNumber();
            if (object.numSelfieTakes != null)
                if ($util.Long)
                    (message.numSelfieTakes = $util.Long.fromValue(object.numSelfieTakes)).unsigned = false;
                else if (typeof object.numSelfieTakes === "string")
                    message.numSelfieTakes = parseInt(object.numSelfieTakes, 10);
                else if (typeof object.numSelfieTakes === "number")
                    message.numSelfieTakes = object.numSelfieTakes;
                else if (typeof object.numSelfieTakes === "object")
                    message.numSelfieTakes = new $util.LongBits(object.numSelfieTakes.low >>> 0, object.numSelfieTakes.high >>> 0).toNumber();
            if (object.notificationId != null)
                if ($util.Long)
                    (message.notificationId = $util.Long.fromValue(object.notificationId)).unsigned = false;
                else if (typeof object.notificationId === "string")
                    message.notificationId = parseInt(object.notificationId, 10);
                else if (typeof object.notificationId === "number")
                    message.notificationId = object.notificationId;
                else if (typeof object.notificationId === "object")
                    message.notificationId = new $util.LongBits(object.notificationId.low >>> 0, object.notificationId.high >>> 0).toNumber();
            switch (object.contentType) {
            case "IMAGE":
            case 0:
                message.contentType = 0;
                break;
            case "VIDEO":
            case 1:
                message.contentType = 1;
                break;
            case "TEXT":
            case 2:
                message.contentType = 2;
                break;
            case "ALBUM_IMAGE":
            case 3:
                message.contentType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MomentInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MomentInfo
         * @static
         * @param {server.MomentInfo} message MomentInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MomentInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.notificationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.notificationTimestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeTaken = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeTaken = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numTakes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numTakes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numSelfieTakes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numSelfieTakes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.notificationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.notificationId = options.longs === String ? "0" : 0;
                object.contentType = options.enums === String ? "IMAGE" : 0;
            }
            if (message.notificationTimestamp != null && message.hasOwnProperty("notificationTimestamp"))
                if (typeof message.notificationTimestamp === "number")
                    object.notificationTimestamp = options.longs === String ? String(message.notificationTimestamp) : message.notificationTimestamp;
                else
                    object.notificationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.notificationTimestamp) : options.longs === Number ? new $util.LongBits(message.notificationTimestamp.low >>> 0, message.notificationTimestamp.high >>> 0).toNumber() : message.notificationTimestamp;
            if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                if (typeof message.timeTaken === "number")
                    object.timeTaken = options.longs === String ? String(message.timeTaken) : message.timeTaken;
                else
                    object.timeTaken = options.longs === String ? $util.Long.prototype.toString.call(message.timeTaken) : options.longs === Number ? new $util.LongBits(message.timeTaken.low >>> 0, message.timeTaken.high >>> 0).toNumber() : message.timeTaken;
            if (message.numTakes != null && message.hasOwnProperty("numTakes"))
                if (typeof message.numTakes === "number")
                    object.numTakes = options.longs === String ? String(message.numTakes) : message.numTakes;
                else
                    object.numTakes = options.longs === String ? $util.Long.prototype.toString.call(message.numTakes) : options.longs === Number ? new $util.LongBits(message.numTakes.low >>> 0, message.numTakes.high >>> 0).toNumber() : message.numTakes;
            if (message.numSelfieTakes != null && message.hasOwnProperty("numSelfieTakes"))
                if (typeof message.numSelfieTakes === "number")
                    object.numSelfieTakes = options.longs === String ? String(message.numSelfieTakes) : message.numSelfieTakes;
                else
                    object.numSelfieTakes = options.longs === String ? $util.Long.prototype.toString.call(message.numSelfieTakes) : options.longs === Number ? new $util.LongBits(message.numSelfieTakes.low >>> 0, message.numSelfieTakes.high >>> 0).toNumber() : message.numSelfieTakes;
            if (message.notificationId != null && message.hasOwnProperty("notificationId"))
                if (typeof message.notificationId === "number")
                    object.notificationId = options.longs === String ? String(message.notificationId) : message.notificationId;
                else
                    object.notificationId = options.longs === String ? $util.Long.prototype.toString.call(message.notificationId) : options.longs === Number ? new $util.LongBits(message.notificationId.low >>> 0, message.notificationId.high >>> 0).toNumber() : message.notificationId;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.MomentInfo.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this MomentInfo to JSON.
         * @function toJSON
         * @memberof server.MomentInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MomentInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ContentType enum.
         * @name server.MomentInfo.ContentType
         * @enum {number}
         * @property {number} IMAGE=0 IMAGE value
         * @property {number} VIDEO=1 VIDEO value
         * @property {number} TEXT=2 TEXT value
         * @property {number} ALBUM_IMAGE=3 ALBUM_IMAGE value
         */
        MomentInfo.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IMAGE"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            values[valuesById[2] = "TEXT"] = 2;
            values[valuesById[3] = "ALBUM_IMAGE"] = 3;
            return values;
        })();

        return MomentInfo;
    })();

    server.MediaCounters = (function() {

        /**
         * Properties of a MediaCounters.
         * @memberof server
         * @interface IMediaCounters
         * @property {number|null} [numImages] MediaCounters numImages
         * @property {number|null} [numVideos] MediaCounters numVideos
         * @property {number|null} [numAudio] MediaCounters numAudio
         */

        /**
         * Constructs a new MediaCounters.
         * @memberof server
         * @classdesc Represents a MediaCounters.
         * @implements IMediaCounters
         * @constructor
         * @param {server.IMediaCounters=} [properties] Properties to set
         */
        function MediaCounters(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaCounters numImages.
         * @member {number} numImages
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numImages = 0;

        /**
         * MediaCounters numVideos.
         * @member {number} numVideos
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numVideos = 0;

        /**
         * MediaCounters numAudio.
         * @member {number} numAudio
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numAudio = 0;

        /**
         * Creates a new MediaCounters instance using the specified properties.
         * @function create
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters=} [properties] Properties to set
         * @returns {server.MediaCounters} MediaCounters instance
         */
        MediaCounters.create = function create(properties) {
            return new MediaCounters(properties);
        };

        /**
         * Encodes the specified MediaCounters message. Does not implicitly {@link server.MediaCounters.verify|verify} messages.
         * @function encode
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters} message MediaCounters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaCounters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numImages != null && Object.hasOwnProperty.call(message, "numImages"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numImages);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numVideos);
            if (message.numAudio != null && Object.hasOwnProperty.call(message, "numAudio"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numAudio);
            return writer;
        };

        /**
         * Encodes the specified MediaCounters message, length delimited. Does not implicitly {@link server.MediaCounters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters} message MediaCounters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaCounters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaCounters message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaCounters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaCounters} MediaCounters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaCounters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaCounters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.numImages = reader.int32();
                    break;
                case 2:
                    message.numVideos = reader.int32();
                    break;
                case 3:
                    message.numAudio = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaCounters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaCounters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaCounters} MediaCounters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaCounters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaCounters message.
         * @function verify
         * @memberof server.MediaCounters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaCounters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                if (!$util.isInteger(message.numImages))
                    return "numImages: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.numAudio != null && message.hasOwnProperty("numAudio"))
                if (!$util.isInteger(message.numAudio))
                    return "numAudio: integer expected";
            return null;
        };

        /**
         * Creates a MediaCounters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaCounters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaCounters} MediaCounters
         */
        MediaCounters.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaCounters)
                return object;
            var message = new $root.server.MediaCounters();
            if (object.numImages != null)
                message.numImages = object.numImages | 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos | 0;
            if (object.numAudio != null)
                message.numAudio = object.numAudio | 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaCounters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaCounters
         * @static
         * @param {server.MediaCounters} message MediaCounters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaCounters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numImages = 0;
                object.numVideos = 0;
                object.numAudio = 0;
            }
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                object.numImages = message.numImages;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.numAudio != null && message.hasOwnProperty("numAudio"))
                object.numAudio = message.numAudio;
            return object;
        };

        /**
         * Converts this MediaCounters to JSON.
         * @function toJSON
         * @memberof server.MediaCounters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaCounters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaCounters;
    })();

    server.Audience = (function() {

        /**
         * Properties of an Audience.
         * @memberof server
         * @interface IAudience
         * @property {server.Audience.Type|null} [type] Audience type
         * @property {Array.<number|Long>|null} [uids] Audience uids
         */

        /**
         * Constructs a new Audience.
         * @memberof server
         * @classdesc Represents an Audience.
         * @implements IAudience
         * @constructor
         * @param {server.IAudience=} [properties] Properties to set
         */
        function Audience(properties) {
            this.uids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Audience type.
         * @member {server.Audience.Type} type
         * @memberof server.Audience
         * @instance
         */
        Audience.prototype.type = 0;

        /**
         * Audience uids.
         * @member {Array.<number|Long>} uids
         * @memberof server.Audience
         * @instance
         */
        Audience.prototype.uids = $util.emptyArray;

        /**
         * Creates a new Audience instance using the specified properties.
         * @function create
         * @memberof server.Audience
         * @static
         * @param {server.IAudience=} [properties] Properties to set
         * @returns {server.Audience} Audience instance
         */
        Audience.create = function create(properties) {
            return new Audience(properties);
        };

        /**
         * Encodes the specified Audience message. Does not implicitly {@link server.Audience.verify|verify} messages.
         * @function encode
         * @memberof server.Audience
         * @static
         * @param {server.IAudience} message Audience message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Audience.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.uids != null && message.uids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.uids.length; ++i)
                    writer.int64(message.uids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Audience message, length delimited. Does not implicitly {@link server.Audience.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Audience
         * @static
         * @param {server.IAudience} message Audience message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Audience.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Audience message from the specified reader or buffer.
         * @function decode
         * @memberof server.Audience
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Audience} Audience
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Audience.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Audience();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.uids && message.uids.length))
                        message.uids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uids.push(reader.int64());
                    } else
                        message.uids.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Audience message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Audience
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Audience} Audience
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Audience.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Audience message.
         * @function verify
         * @memberof server.Audience
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Audience.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.uids != null && message.hasOwnProperty("uids")) {
                if (!Array.isArray(message.uids))
                    return "uids: array expected";
                for (var i = 0; i < message.uids.length; ++i)
                    if (!$util.isInteger(message.uids[i]) && !(message.uids[i] && $util.isInteger(message.uids[i].low) && $util.isInteger(message.uids[i].high)))
                        return "uids: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an Audience message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Audience
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Audience} Audience
         */
        Audience.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Audience)
                return object;
            var message = new $root.server.Audience();
            switch (object.type) {
            case "ALL":
            case 0:
                message.type = 0;
                break;
            case "EXCEPT":
            case 1:
                message.type = 1;
                break;
            case "ONLY":
            case 2:
                message.type = 2;
                break;
            }
            if (object.uids) {
                if (!Array.isArray(object.uids))
                    throw TypeError(".server.Audience.uids: array expected");
                message.uids = [];
                for (var i = 0; i < object.uids.length; ++i)
                    if ($util.Long)
                        (message.uids[i] = $util.Long.fromValue(object.uids[i])).unsigned = false;
                    else if (typeof object.uids[i] === "string")
                        message.uids[i] = parseInt(object.uids[i], 10);
                    else if (typeof object.uids[i] === "number")
                        message.uids[i] = object.uids[i];
                    else if (typeof object.uids[i] === "object")
                        message.uids[i] = new $util.LongBits(object.uids[i].low >>> 0, object.uids[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an Audience message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Audience
         * @static
         * @param {server.Audience} message Audience
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Audience.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.uids = [];
            if (options.defaults)
                object.type = options.enums === String ? "ALL" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Audience.Type[message.type] : message.type;
            if (message.uids && message.uids.length) {
                object.uids = [];
                for (var j = 0; j < message.uids.length; ++j)
                    if (typeof message.uids[j] === "number")
                        object.uids[j] = options.longs === String ? String(message.uids[j]) : message.uids[j];
                    else
                        object.uids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uids[j]) : options.longs === Number ? new $util.LongBits(message.uids[j].low >>> 0, message.uids[j].high >>> 0).toNumber() : message.uids[j];
            }
            return object;
        };

        /**
         * Converts this Audience to JSON.
         * @function toJSON
         * @memberof server.Audience
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Audience.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Audience.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} EXCEPT=1 EXCEPT value
         * @property {number} ONLY=2 ONLY value
         */
        Audience.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "EXCEPT"] = 1;
            values[valuesById[2] = "ONLY"] = 2;
            return values;
        })();

        return Audience;
    })();

    server.Post = (function() {

        /**
         * Properties of a Post.
         * @memberof server
         * @interface IPost
         * @property {string|null} [id] Post id
         * @property {number|Long|null} [publisherUid] Post publisherUid
         * @property {Uint8Array|null} [payload] Post payload
         * @property {server.IAudience|null} [audience] Post audience
         * @property {number|Long|null} [timestamp] Post timestamp
         * @property {string|null} [publisherName] Post publisherName
         * @property {Uint8Array|null} [encPayload] Post encPayload
         * @property {server.IMediaCounters|null} [mediaCounters] Post mediaCounters
         * @property {server.Post.Tag|null} [tag] Post tag
         * @property {string|null} [psaTag] Post psaTag
         * @property {number|Long|null} [momentUnlockUid] Post momentUnlockUid
         * @property {boolean|null} [showPostShareScreen] Post showPostShareScreen
         * @property {server.IMomentInfo|null} [momentInfo] Post momentInfo
         * @property {boolean|null} [isExpired] Post isExpired
         */

        /**
         * Constructs a new Post.
         * @memberof server
         * @classdesc Represents a Post.
         * @implements IPost
         * @constructor
         * @param {server.IPost=} [properties] Properties to set
         */
        function Post(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Post id.
         * @member {string} id
         * @memberof server.Post
         * @instance
         */
        Post.prototype.id = "";

        /**
         * Post publisherUid.
         * @member {number|Long} publisherUid
         * @memberof server.Post
         * @instance
         */
        Post.prototype.publisherUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Post payload.
         * @member {Uint8Array} payload
         * @memberof server.Post
         * @instance
         */
        Post.prototype.payload = $util.newBuffer([]);

        /**
         * Post audience.
         * @member {server.IAudience|null|undefined} audience
         * @memberof server.Post
         * @instance
         */
        Post.prototype.audience = null;

        /**
         * Post timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Post
         * @instance
         */
        Post.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Post publisherName.
         * @member {string} publisherName
         * @memberof server.Post
         * @instance
         */
        Post.prototype.publisherName = "";

        /**
         * Post encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.Post
         * @instance
         */
        Post.prototype.encPayload = $util.newBuffer([]);

        /**
         * Post mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.Post
         * @instance
         */
        Post.prototype.mediaCounters = null;

        /**
         * Post tag.
         * @member {server.Post.Tag} tag
         * @memberof server.Post
         * @instance
         */
        Post.prototype.tag = 0;

        /**
         * Post psaTag.
         * @member {string} psaTag
         * @memberof server.Post
         * @instance
         */
        Post.prototype.psaTag = "";

        /**
         * Post momentUnlockUid.
         * @member {number|Long} momentUnlockUid
         * @memberof server.Post
         * @instance
         */
        Post.prototype.momentUnlockUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Post showPostShareScreen.
         * @member {boolean} showPostShareScreen
         * @memberof server.Post
         * @instance
         */
        Post.prototype.showPostShareScreen = false;

        /**
         * Post momentInfo.
         * @member {server.IMomentInfo|null|undefined} momentInfo
         * @memberof server.Post
         * @instance
         */
        Post.prototype.momentInfo = null;

        /**
         * Post isExpired.
         * @member {boolean} isExpired
         * @memberof server.Post
         * @instance
         */
        Post.prototype.isExpired = false;

        /**
         * Creates a new Post instance using the specified properties.
         * @function create
         * @memberof server.Post
         * @static
         * @param {server.IPost=} [properties] Properties to set
         * @returns {server.Post} Post instance
         */
        Post.create = function create(properties) {
            return new Post(properties);
        };

        /**
         * Encodes the specified Post message. Does not implicitly {@link server.Post.verify|verify} messages.
         * @function encode
         * @memberof server.Post
         * @static
         * @param {server.IPost} message Post message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Post.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.publisherUid != null && Object.hasOwnProperty.call(message, "publisherUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.publisherUid);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.audience != null && Object.hasOwnProperty.call(message, "audience"))
                $root.server.Audience.encode(message.audience, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.publisherName);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.encPayload);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.tag);
            if (message.psaTag != null && Object.hasOwnProperty.call(message, "psaTag"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.psaTag);
            if (message.momentUnlockUid != null && Object.hasOwnProperty.call(message, "momentUnlockUid"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.momentUnlockUid);
            if (message.showPostShareScreen != null && Object.hasOwnProperty.call(message, "showPostShareScreen"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.showPostShareScreen);
            if (message.momentInfo != null && Object.hasOwnProperty.call(message, "momentInfo"))
                $root.server.MomentInfo.encode(message.momentInfo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.isExpired != null && Object.hasOwnProperty.call(message, "isExpired"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isExpired);
            return writer;
        };

        /**
         * Encodes the specified Post message, length delimited. Does not implicitly {@link server.Post.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Post
         * @static
         * @param {server.IPost} message Post message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Post.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Post message from the specified reader or buffer.
         * @function decode
         * @memberof server.Post
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Post} Post
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Post.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Post();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.publisherUid = reader.int64();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    message.audience = $root.server.Audience.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.publisherName = reader.string();
                    break;
                case 7:
                    message.encPayload = reader.bytes();
                    break;
                case 8:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.tag = reader.int32();
                    break;
                case 10:
                    message.psaTag = reader.string();
                    break;
                case 11:
                    message.momentUnlockUid = reader.int64();
                    break;
                case 12:
                    message.showPostShareScreen = reader.bool();
                    break;
                case 13:
                    message.momentInfo = $root.server.MomentInfo.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.isExpired = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Post message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Post
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Post} Post
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Post.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Post message.
         * @function verify
         * @memberof server.Post
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Post.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (!$util.isInteger(message.publisherUid) && !(message.publisherUid && $util.isInteger(message.publisherUid.low) && $util.isInteger(message.publisherUid.high)))
                    return "publisherUid: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.audience != null && message.hasOwnProperty("audience")) {
                var error = $root.server.Audience.verify(message.audience);
                if (error)
                    return "audience." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                if (!$util.isString(message.publisherName))
                    return "publisherName: string expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                switch (message.tag) {
                default:
                    return "tag: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.psaTag != null && message.hasOwnProperty("psaTag"))
                if (!$util.isString(message.psaTag))
                    return "psaTag: string expected";
            if (message.momentUnlockUid != null && message.hasOwnProperty("momentUnlockUid"))
                if (!$util.isInteger(message.momentUnlockUid) && !(message.momentUnlockUid && $util.isInteger(message.momentUnlockUid.low) && $util.isInteger(message.momentUnlockUid.high)))
                    return "momentUnlockUid: integer|Long expected";
            if (message.showPostShareScreen != null && message.hasOwnProperty("showPostShareScreen"))
                if (typeof message.showPostShareScreen !== "boolean")
                    return "showPostShareScreen: boolean expected";
            if (message.momentInfo != null && message.hasOwnProperty("momentInfo")) {
                var error = $root.server.MomentInfo.verify(message.momentInfo);
                if (error)
                    return "momentInfo." + error;
            }
            if (message.isExpired != null && message.hasOwnProperty("isExpired"))
                if (typeof message.isExpired !== "boolean")
                    return "isExpired: boolean expected";
            return null;
        };

        /**
         * Creates a Post message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Post
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Post} Post
         */
        Post.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Post)
                return object;
            var message = new $root.server.Post();
            if (object.id != null)
                message.id = String(object.id);
            if (object.publisherUid != null)
                if ($util.Long)
                    (message.publisherUid = $util.Long.fromValue(object.publisherUid)).unsigned = false;
                else if (typeof object.publisherUid === "string")
                    message.publisherUid = parseInt(object.publisherUid, 10);
                else if (typeof object.publisherUid === "number")
                    message.publisherUid = object.publisherUid;
                else if (typeof object.publisherUid === "object")
                    message.publisherUid = new $util.LongBits(object.publisherUid.low >>> 0, object.publisherUid.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.audience != null) {
                if (typeof object.audience !== "object")
                    throw TypeError(".server.Post.audience: object expected");
                message.audience = $root.server.Audience.fromObject(object.audience);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.publisherName != null)
                message.publisherName = String(object.publisherName);
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.Post.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            switch (object.tag) {
            case "EMPTY":
            case 0:
                message.tag = 0;
                break;
            case "MOMENT":
            case 1:
                message.tag = 1;
                break;
            case "PUBLIC_MOMENT":
            case 2:
                message.tag = 2;
                break;
            case "PUBLIC_POST":
            case 3:
                message.tag = 3;
                break;
            }
            if (object.psaTag != null)
                message.psaTag = String(object.psaTag);
            if (object.momentUnlockUid != null)
                if ($util.Long)
                    (message.momentUnlockUid = $util.Long.fromValue(object.momentUnlockUid)).unsigned = false;
                else if (typeof object.momentUnlockUid === "string")
                    message.momentUnlockUid = parseInt(object.momentUnlockUid, 10);
                else if (typeof object.momentUnlockUid === "number")
                    message.momentUnlockUid = object.momentUnlockUid;
                else if (typeof object.momentUnlockUid === "object")
                    message.momentUnlockUid = new $util.LongBits(object.momentUnlockUid.low >>> 0, object.momentUnlockUid.high >>> 0).toNumber();
            if (object.showPostShareScreen != null)
                message.showPostShareScreen = Boolean(object.showPostShareScreen);
            if (object.momentInfo != null) {
                if (typeof object.momentInfo !== "object")
                    throw TypeError(".server.Post.momentInfo: object expected");
                message.momentInfo = $root.server.MomentInfo.fromObject(object.momentInfo);
            }
            if (object.isExpired != null)
                message.isExpired = Boolean(object.isExpired);
            return message;
        };

        /**
         * Creates a plain object from a Post message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Post
         * @static
         * @param {server.Post} message Post
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Post.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publisherUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publisherUid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.audience = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.publisherName = "";
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.mediaCounters = null;
                object.tag = options.enums === String ? "EMPTY" : 0;
                object.psaTag = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.momentUnlockUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.momentUnlockUid = options.longs === String ? "0" : 0;
                object.showPostShareScreen = false;
                object.momentInfo = null;
                object.isExpired = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (typeof message.publisherUid === "number")
                    object.publisherUid = options.longs === String ? String(message.publisherUid) : message.publisherUid;
                else
                    object.publisherUid = options.longs === String ? $util.Long.prototype.toString.call(message.publisherUid) : options.longs === Number ? new $util.LongBits(message.publisherUid.low >>> 0, message.publisherUid.high >>> 0).toNumber() : message.publisherUid;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.audience != null && message.hasOwnProperty("audience"))
                object.audience = $root.server.Audience.toObject(message.audience, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                object.publisherName = message.publisherName;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = options.enums === String ? $root.server.Post.Tag[message.tag] : message.tag;
            if (message.psaTag != null && message.hasOwnProperty("psaTag"))
                object.psaTag = message.psaTag;
            if (message.momentUnlockUid != null && message.hasOwnProperty("momentUnlockUid"))
                if (typeof message.momentUnlockUid === "number")
                    object.momentUnlockUid = options.longs === String ? String(message.momentUnlockUid) : message.momentUnlockUid;
                else
                    object.momentUnlockUid = options.longs === String ? $util.Long.prototype.toString.call(message.momentUnlockUid) : options.longs === Number ? new $util.LongBits(message.momentUnlockUid.low >>> 0, message.momentUnlockUid.high >>> 0).toNumber() : message.momentUnlockUid;
            if (message.showPostShareScreen != null && message.hasOwnProperty("showPostShareScreen"))
                object.showPostShareScreen = message.showPostShareScreen;
            if (message.momentInfo != null && message.hasOwnProperty("momentInfo"))
                object.momentInfo = $root.server.MomentInfo.toObject(message.momentInfo, options);
            if (message.isExpired != null && message.hasOwnProperty("isExpired"))
                object.isExpired = message.isExpired;
            return object;
        };

        /**
         * Converts this Post to JSON.
         * @function toJSON
         * @memberof server.Post
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Post.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Tag enum.
         * @name server.Post.Tag
         * @enum {number}
         * @property {number} EMPTY=0 EMPTY value
         * @property {number} MOMENT=1 MOMENT value
         * @property {number} PUBLIC_MOMENT=2 PUBLIC_MOMENT value
         * @property {number} PUBLIC_POST=3 PUBLIC_POST value
         */
        Post.Tag = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EMPTY"] = 0;
            values[valuesById[1] = "MOMENT"] = 1;
            values[valuesById[2] = "PUBLIC_MOMENT"] = 2;
            values[valuesById[3] = "PUBLIC_POST"] = 3;
            return values;
        })();

        return Post;
    })();

    server.Comment = (function() {

        /**
         * Properties of a Comment.
         * @memberof server
         * @interface IComment
         * @property {string|null} [id] Comment id
         * @property {string|null} [postId] Comment postId
         * @property {string|null} [parentCommentId] Comment parentCommentId
         * @property {number|Long|null} [publisherUid] Comment publisherUid
         * @property {string|null} [publisherName] Comment publisherName
         * @property {Uint8Array|null} [payload] Comment payload
         * @property {number|Long|null} [timestamp] Comment timestamp
         * @property {Uint8Array|null} [encPayload] Comment encPayload
         * @property {server.IMediaCounters|null} [mediaCounters] Comment mediaCounters
         * @property {server.Comment.CommentType|null} [commentType] Comment commentType
         */

        /**
         * Constructs a new Comment.
         * @memberof server
         * @classdesc Represents a Comment.
         * @implements IComment
         * @constructor
         * @param {server.IComment=} [properties] Properties to set
         */
        function Comment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Comment id.
         * @member {string} id
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.id = "";

        /**
         * Comment postId.
         * @member {string} postId
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.postId = "";

        /**
         * Comment parentCommentId.
         * @member {string} parentCommentId
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.parentCommentId = "";

        /**
         * Comment publisherUid.
         * @member {number|Long} publisherUid
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.publisherUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Comment publisherName.
         * @member {string} publisherName
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.publisherName = "";

        /**
         * Comment payload.
         * @member {Uint8Array} payload
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.payload = $util.newBuffer([]);

        /**
         * Comment timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Comment encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.encPayload = $util.newBuffer([]);

        /**
         * Comment mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.mediaCounters = null;

        /**
         * Comment commentType.
         * @member {server.Comment.CommentType} commentType
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.commentType = 0;

        /**
         * Creates a new Comment instance using the specified properties.
         * @function create
         * @memberof server.Comment
         * @static
         * @param {server.IComment=} [properties] Properties to set
         * @returns {server.Comment} Comment instance
         */
        Comment.create = function create(properties) {
            return new Comment(properties);
        };

        /**
         * Encodes the specified Comment message. Does not implicitly {@link server.Comment.verify|verify} messages.
         * @function encode
         * @memberof server.Comment
         * @static
         * @param {server.IComment} message Comment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Comment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.postId);
            if (message.parentCommentId != null && Object.hasOwnProperty.call(message, "parentCommentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentCommentId);
            if (message.publisherUid != null && Object.hasOwnProperty.call(message, "publisherUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.publisherUid);
            if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.publisherName);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encPayload);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.commentType != null && Object.hasOwnProperty.call(message, "commentType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.commentType);
            return writer;
        };

        /**
         * Encodes the specified Comment message, length delimited. Does not implicitly {@link server.Comment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Comment
         * @static
         * @param {server.IComment} message Comment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Comment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Comment message from the specified reader or buffer.
         * @function decode
         * @memberof server.Comment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Comment} Comment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Comment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Comment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.postId = reader.string();
                    break;
                case 3:
                    message.parentCommentId = reader.string();
                    break;
                case 4:
                    message.publisherUid = reader.int64();
                    break;
                case 5:
                    message.publisherName = reader.string();
                    break;
                case 6:
                    message.payload = reader.bytes();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.encPayload = reader.bytes();
                    break;
                case 9:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.commentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Comment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Comment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Comment} Comment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Comment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Comment message.
         * @function verify
         * @memberof server.Comment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Comment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isString(message.postId))
                    return "postId: string expected";
            if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
                if (!$util.isString(message.parentCommentId))
                    return "parentCommentId: string expected";
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (!$util.isInteger(message.publisherUid) && !(message.publisherUid && $util.isInteger(message.publisherUid.low) && $util.isInteger(message.publisherUid.high)))
                    return "publisherUid: integer|Long expected";
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                if (!$util.isString(message.publisherName))
                    return "publisherName: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            if (message.commentType != null && message.hasOwnProperty("commentType"))
                switch (message.commentType) {
                default:
                    return "commentType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Comment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Comment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Comment} Comment
         */
        Comment.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Comment)
                return object;
            var message = new $root.server.Comment();
            if (object.id != null)
                message.id = String(object.id);
            if (object.postId != null)
                message.postId = String(object.postId);
            if (object.parentCommentId != null)
                message.parentCommentId = String(object.parentCommentId);
            if (object.publisherUid != null)
                if ($util.Long)
                    (message.publisherUid = $util.Long.fromValue(object.publisherUid)).unsigned = false;
                else if (typeof object.publisherUid === "string")
                    message.publisherUid = parseInt(object.publisherUid, 10);
                else if (typeof object.publisherUid === "number")
                    message.publisherUid = object.publisherUid;
                else if (typeof object.publisherUid === "object")
                    message.publisherUid = new $util.LongBits(object.publisherUid.low >>> 0, object.publisherUid.high >>> 0).toNumber();
            if (object.publisherName != null)
                message.publisherName = String(object.publisherName);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.Comment.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            switch (object.commentType) {
            case "COMMENT":
            case 0:
                message.commentType = 0;
                break;
            case "COMMENT_REACTION":
            case 1:
                message.commentType = 1;
                break;
            case "POST_REACTION":
            case 2:
                message.commentType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Comment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Comment
         * @static
         * @param {server.Comment} message Comment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Comment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.postId = "";
                object.parentCommentId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publisherUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publisherUid = options.longs === String ? "0" : 0;
                object.publisherName = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.mediaCounters = null;
                object.commentType = options.enums === String ? "COMMENT" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.postId != null && message.hasOwnProperty("postId"))
                object.postId = message.postId;
            if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
                object.parentCommentId = message.parentCommentId;
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (typeof message.publisherUid === "number")
                    object.publisherUid = options.longs === String ? String(message.publisherUid) : message.publisherUid;
                else
                    object.publisherUid = options.longs === String ? $util.Long.prototype.toString.call(message.publisherUid) : options.longs === Number ? new $util.LongBits(message.publisherUid.low >>> 0, message.publisherUid.high >>> 0).toNumber() : message.publisherUid;
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                object.publisherName = message.publisherName;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            if (message.commentType != null && message.hasOwnProperty("commentType"))
                object.commentType = options.enums === String ? $root.server.Comment.CommentType[message.commentType] : message.commentType;
            return object;
        };

        /**
         * Converts this Comment to JSON.
         * @function toJSON
         * @memberof server.Comment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Comment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CommentType enum.
         * @name server.Comment.CommentType
         * @enum {number}
         * @property {number} COMMENT=0 COMMENT value
         * @property {number} COMMENT_REACTION=1 COMMENT_REACTION value
         * @property {number} POST_REACTION=2 POST_REACTION value
         */
        Comment.CommentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COMMENT"] = 0;
            values[valuesById[1] = "COMMENT_REACTION"] = 1;
            values[valuesById[2] = "POST_REACTION"] = 2;
            return values;
        })();

        return Comment;
    })();

    server.ShareStanza = (function() {

        /**
         * Properties of a ShareStanza.
         * @memberof server
         * @interface IShareStanza
         * @property {number|Long|null} [uid] ShareStanza uid
         * @property {Array.<string>|null} [postIds] ShareStanza postIds
         * @property {string|null} [result] ShareStanza result
         * @property {string|null} [reason] ShareStanza reason
         */

        /**
         * Constructs a new ShareStanza.
         * @memberof server
         * @classdesc Represents a ShareStanza.
         * @implements IShareStanza
         * @constructor
         * @param {server.IShareStanza=} [properties] Properties to set
         */
        function ShareStanza(properties) {
            this.postIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareStanza uid.
         * @member {number|Long} uid
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ShareStanza postIds.
         * @member {Array.<string>} postIds
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.postIds = $util.emptyArray;

        /**
         * ShareStanza result.
         * @member {string} result
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.result = "";

        /**
         * ShareStanza reason.
         * @member {string} reason
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.reason = "";

        /**
         * Creates a new ShareStanza instance using the specified properties.
         * @function create
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza=} [properties] Properties to set
         * @returns {server.ShareStanza} ShareStanza instance
         */
        ShareStanza.create = function create(properties) {
            return new ShareStanza(properties);
        };

        /**
         * Encodes the specified ShareStanza message. Does not implicitly {@link server.ShareStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza} message ShareStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.postIds != null && message.postIds.length)
                for (var i = 0; i < message.postIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.postIds[i]);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ShareStanza message, length delimited. Does not implicitly {@link server.ShareStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza} message ShareStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ShareStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ShareStanza} ShareStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ShareStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    if (!(message.postIds && message.postIds.length))
                        message.postIds = [];
                    message.postIds.push(reader.string());
                    break;
                case 3:
                    message.result = reader.string();
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShareStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ShareStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ShareStanza} ShareStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareStanza message.
         * @function verify
         * @memberof server.ShareStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.postIds != null && message.hasOwnProperty("postIds")) {
                if (!Array.isArray(message.postIds))
                    return "postIds: array expected";
                for (var i = 0; i < message.postIds.length; ++i)
                    if (!$util.isString(message.postIds[i]))
                        return "postIds: string[] expected";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ShareStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ShareStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ShareStanza} ShareStanza
         */
        ShareStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ShareStanza)
                return object;
            var message = new $root.server.ShareStanza();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.postIds) {
                if (!Array.isArray(object.postIds))
                    throw TypeError(".server.ShareStanza.postIds: array expected");
                message.postIds = [];
                for (var i = 0; i < object.postIds.length; ++i)
                    message.postIds[i] = String(object.postIds[i]);
            }
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ShareStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ShareStanza
         * @static
         * @param {server.ShareStanza} message ShareStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShareStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.postIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.result = "";
                object.reason = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.postIds && message.postIds.length) {
                object.postIds = [];
                for (var j = 0; j < message.postIds.length; ++j)
                    object.postIds[j] = message.postIds[j];
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ShareStanza to JSON.
         * @function toJSON
         * @memberof server.ShareStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShareStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShareStanza;
    })();

    server.FeedItem = (function() {

        /**
         * Properties of a FeedItem.
         * @memberof server
         * @interface IFeedItem
         * @property {server.FeedItem.Action|null} [action] FeedItem action
         * @property {server.IPost|null} [post] FeedItem post
         * @property {server.IComment|null} [comment] FeedItem comment
         * @property {Array.<server.IShareStanza>|null} [shareStanzas] FeedItem shareStanzas
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] FeedItem senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] FeedItem senderState
         * @property {string|null} [senderClientVersion] FeedItem senderClientVersion
         */

        /**
         * Constructs a new FeedItem.
         * @memberof server
         * @classdesc Represents a FeedItem.
         * @implements IFeedItem
         * @constructor
         * @param {server.IFeedItem=} [properties] Properties to set
         */
        function FeedItem(properties) {
            this.shareStanzas = [];
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedItem action.
         * @member {server.FeedItem.Action} action
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.action = 0;

        /**
         * FeedItem post.
         * @member {server.IPost|null|undefined} post
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.post = null;

        /**
         * FeedItem comment.
         * @member {server.IComment|null|undefined} comment
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.comment = null;

        /**
         * FeedItem shareStanzas.
         * @member {Array.<server.IShareStanza>} shareStanzas
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.shareStanzas = $util.emptyArray;

        /**
         * FeedItem senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.senderStateBundles = $util.emptyArray;

        /**
         * FeedItem senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.senderState = null;

        /**
         * FeedItem senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.senderClientVersion = "";

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * FeedItem item.
         * @member {"post"|"comment"|undefined} item
         * @memberof server.FeedItem
         * @instance
         */
        Object.defineProperty(FeedItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["post", "comment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FeedItem instance using the specified properties.
         * @function create
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem=} [properties] Properties to set
         * @returns {server.FeedItem} FeedItem instance
         */
        FeedItem.create = function create(properties) {
            return new FeedItem(properties);
        };

        /**
         * Encodes the specified FeedItem message. Does not implicitly {@link server.FeedItem.verify|verify} messages.
         * @function encode
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem} message FeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                $root.server.Post.encode(message.post, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                $root.server.Comment.encode(message.comment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.shareStanzas != null && message.shareStanzas.length)
                for (var i = 0; i < message.shareStanzas.length; ++i)
                    $root.server.ShareStanza.encode(message.shareStanzas[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified FeedItem message, length delimited. Does not implicitly {@link server.FeedItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem} message FeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedItem message from the specified reader or buffer.
         * @function decode
         * @memberof server.FeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FeedItem} FeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FeedItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.post = $root.server.Post.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.comment = $root.server.Comment.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.shareStanzas && message.shareStanzas.length))
                        message.shareStanzas = [];
                    message.shareStanzas.push($root.server.ShareStanza.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FeedItem} FeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedItem message.
         * @function verify
         * @memberof server.FeedItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.post != null && message.hasOwnProperty("post")) {
                properties.item = 1;
                {
                    var error = $root.server.Post.verify(message.post);
                    if (error)
                        return "post." + error;
                }
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    var error = $root.server.Comment.verify(message.comment);
                    if (error)
                        return "comment." + error;
                }
            }
            if (message.shareStanzas != null && message.hasOwnProperty("shareStanzas")) {
                if (!Array.isArray(message.shareStanzas))
                    return "shareStanzas: array expected";
                for (var i = 0; i < message.shareStanzas.length; ++i) {
                    var error = $root.server.ShareStanza.verify(message.shareStanzas[i]);
                    if (error)
                        return "shareStanzas." + error;
                }
            }
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a FeedItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FeedItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FeedItem} FeedItem
         */
        FeedItem.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FeedItem)
                return object;
            var message = new $root.server.FeedItem();
            switch (object.action) {
            case "PUBLISH":
            case 0:
                message.action = 0;
                break;
            case "RETRACT":
            case 1:
                message.action = 1;
                break;
            case "SHARE":
            case 2:
                message.action = 2;
                break;
            case "PUBLIC_UPDATE_PUBLISH":
            case 3:
                message.action = 3;
                break;
            case "EXPIRE":
            case 4:
                message.action = 4;
                break;
            case "PUBLIC_UPDATE_RETRACT":
            case 5:
                message.action = 5;
                break;
            }
            if (object.post != null) {
                if (typeof object.post !== "object")
                    throw TypeError(".server.FeedItem.post: object expected");
                message.post = $root.server.Post.fromObject(object.post);
            }
            if (object.comment != null) {
                if (typeof object.comment !== "object")
                    throw TypeError(".server.FeedItem.comment: object expected");
                message.comment = $root.server.Comment.fromObject(object.comment);
            }
            if (object.shareStanzas) {
                if (!Array.isArray(object.shareStanzas))
                    throw TypeError(".server.FeedItem.shareStanzas: array expected");
                message.shareStanzas = [];
                for (var i = 0; i < object.shareStanzas.length; ++i) {
                    if (typeof object.shareStanzas[i] !== "object")
                        throw TypeError(".server.FeedItem.shareStanzas: object expected");
                    message.shareStanzas[i] = $root.server.ShareStanza.fromObject(object.shareStanzas[i]);
                }
            }
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.FeedItem.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.FeedItem.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.FeedItem.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a FeedItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FeedItem
         * @static
         * @param {server.FeedItem} message FeedItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.shareStanzas = [];
                object.senderStateBundles = [];
            }
            if (options.defaults) {
                object.action = options.enums === String ? "PUBLISH" : 0;
                object.senderState = null;
                object.senderClientVersion = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.FeedItem.Action[message.action] : message.action;
            if (message.post != null && message.hasOwnProperty("post")) {
                object.post = $root.server.Post.toObject(message.post, options);
                if (options.oneofs)
                    object.item = "post";
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                object.comment = $root.server.Comment.toObject(message.comment, options);
                if (options.oneofs)
                    object.item = "comment";
            }
            if (message.shareStanzas && message.shareStanzas.length) {
                object.shareStanzas = [];
                for (var j = 0; j < message.shareStanzas.length; ++j)
                    object.shareStanzas[j] = $root.server.ShareStanza.toObject(message.shareStanzas[j], options);
            }
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this FeedItem to JSON.
         * @function toJSON
         * @memberof server.FeedItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.FeedItem.Action
         * @enum {number}
         * @property {number} PUBLISH=0 PUBLISH value
         * @property {number} RETRACT=1 RETRACT value
         * @property {number} SHARE=2 SHARE value
         * @property {number} PUBLIC_UPDATE_PUBLISH=3 PUBLIC_UPDATE_PUBLISH value
         * @property {number} EXPIRE=4 EXPIRE value
         * @property {number} PUBLIC_UPDATE_RETRACT=5 PUBLIC_UPDATE_RETRACT value
         */
        FeedItem.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUBLISH"] = 0;
            values[valuesById[1] = "RETRACT"] = 1;
            values[valuesById[2] = "SHARE"] = 2;
            values[valuesById[3] = "PUBLIC_UPDATE_PUBLISH"] = 3;
            values[valuesById[4] = "EXPIRE"] = 4;
            values[valuesById[5] = "PUBLIC_UPDATE_RETRACT"] = 5;
            return values;
        })();

        return FeedItem;
    })();

    server.FeedItems = (function() {

        /**
         * Properties of a FeedItems.
         * @memberof server
         * @interface IFeedItems
         * @property {number|Long|null} [uid] FeedItems uid
         * @property {Array.<server.IFeedItem>|null} [items] FeedItems items
         */

        /**
         * Constructs a new FeedItems.
         * @memberof server
         * @classdesc Represents a FeedItems.
         * @implements IFeedItems
         * @constructor
         * @param {server.IFeedItems=} [properties] Properties to set
         */
        function FeedItems(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedItems uid.
         * @member {number|Long} uid
         * @memberof server.FeedItems
         * @instance
         */
        FeedItems.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeedItems items.
         * @member {Array.<server.IFeedItem>} items
         * @memberof server.FeedItems
         * @instance
         */
        FeedItems.prototype.items = $util.emptyArray;

        /**
         * Creates a new FeedItems instance using the specified properties.
         * @function create
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems=} [properties] Properties to set
         * @returns {server.FeedItems} FeedItems instance
         */
        FeedItems.create = function create(properties) {
            return new FeedItems(properties);
        };

        /**
         * Encodes the specified FeedItems message. Does not implicitly {@link server.FeedItems.verify|verify} messages.
         * @function encode
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems} message FeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.FeedItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedItems message, length delimited. Does not implicitly {@link server.FeedItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems} message FeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedItems message from the specified reader or buffer.
         * @function decode
         * @memberof server.FeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FeedItems} FeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FeedItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.FeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FeedItems} FeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedItems message.
         * @function verify
         * @memberof server.FeedItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.FeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FeedItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FeedItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FeedItems} FeedItems
         */
        FeedItems.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FeedItems)
                return object;
            var message = new $root.server.FeedItems();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.FeedItems.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.FeedItems.items: object expected");
                    message.items[i] = $root.server.FeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FeedItems
         * @static
         * @param {server.FeedItems} message FeedItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.FeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this FeedItems to JSON.
         * @function toJSON
         * @memberof server.FeedItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedItems;
    })();

    /**
     * PublicFeedContentType enum.
     * @name server.PublicFeedContentType
     * @enum {number}
     * @property {number} MOMENTS=0 MOMENTS value
     * @property {number} POSTS=1 POSTS value
     */
    server.PublicFeedContentType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MOMENTS"] = 0;
        values[valuesById[1] = "POSTS"] = 1;
        return values;
    })();

    server.PublicFeedRequest = (function() {

        /**
         * Properties of a PublicFeedRequest.
         * @memberof server
         * @interface IPublicFeedRequest
         * @property {string|null} [cursor] PublicFeedRequest cursor
         * @property {server.PublicFeedContentType|null} [publicFeedContentType] PublicFeedRequest publicFeedContentType
         * @property {server.IGpsLocation|null} [gpsLocation] PublicFeedRequest gpsLocation
         * @property {boolean|null} [showDevContent] PublicFeedRequest showDevContent
         */

        /**
         * Constructs a new PublicFeedRequest.
         * @memberof server
         * @classdesc Represents a PublicFeedRequest.
         * @implements IPublicFeedRequest
         * @constructor
         * @param {server.IPublicFeedRequest=} [properties] Properties to set
         */
        function PublicFeedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicFeedRequest cursor.
         * @member {string} cursor
         * @memberof server.PublicFeedRequest
         * @instance
         */
        PublicFeedRequest.prototype.cursor = "";

        /**
         * PublicFeedRequest publicFeedContentType.
         * @member {server.PublicFeedContentType} publicFeedContentType
         * @memberof server.PublicFeedRequest
         * @instance
         */
        PublicFeedRequest.prototype.publicFeedContentType = 0;

        /**
         * PublicFeedRequest gpsLocation.
         * @member {server.IGpsLocation|null|undefined} gpsLocation
         * @memberof server.PublicFeedRequest
         * @instance
         */
        PublicFeedRequest.prototype.gpsLocation = null;

        /**
         * PublicFeedRequest showDevContent.
         * @member {boolean} showDevContent
         * @memberof server.PublicFeedRequest
         * @instance
         */
        PublicFeedRequest.prototype.showDevContent = false;

        /**
         * Creates a new PublicFeedRequest instance using the specified properties.
         * @function create
         * @memberof server.PublicFeedRequest
         * @static
         * @param {server.IPublicFeedRequest=} [properties] Properties to set
         * @returns {server.PublicFeedRequest} PublicFeedRequest instance
         */
        PublicFeedRequest.create = function create(properties) {
            return new PublicFeedRequest(properties);
        };

        /**
         * Encodes the specified PublicFeedRequest message. Does not implicitly {@link server.PublicFeedRequest.verify|verify} messages.
         * @function encode
         * @memberof server.PublicFeedRequest
         * @static
         * @param {server.IPublicFeedRequest} message PublicFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cursor);
            if (message.publicFeedContentType != null && Object.hasOwnProperty.call(message, "publicFeedContentType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.publicFeedContentType);
            if (message.gpsLocation != null && Object.hasOwnProperty.call(message, "gpsLocation"))
                $root.server.GpsLocation.encode(message.gpsLocation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.showDevContent != null && Object.hasOwnProperty.call(message, "showDevContent"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.showDevContent);
            return writer;
        };

        /**
         * Encodes the specified PublicFeedRequest message, length delimited. Does not implicitly {@link server.PublicFeedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PublicFeedRequest
         * @static
         * @param {server.IPublicFeedRequest} message PublicFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicFeedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.PublicFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PublicFeedRequest} PublicFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PublicFeedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cursor = reader.string();
                    break;
                case 2:
                    message.publicFeedContentType = reader.int32();
                    break;
                case 3:
                    message.gpsLocation = $root.server.GpsLocation.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.showDevContent = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicFeedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PublicFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PublicFeedRequest} PublicFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicFeedRequest message.
         * @function verify
         * @memberof server.PublicFeedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicFeedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (!$util.isString(message.cursor))
                    return "cursor: string expected";
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                switch (message.publicFeedContentType) {
                default:
                    return "publicFeedContentType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.gpsLocation != null && message.hasOwnProperty("gpsLocation")) {
                var error = $root.server.GpsLocation.verify(message.gpsLocation);
                if (error)
                    return "gpsLocation." + error;
            }
            if (message.showDevContent != null && message.hasOwnProperty("showDevContent"))
                if (typeof message.showDevContent !== "boolean")
                    return "showDevContent: boolean expected";
            return null;
        };

        /**
         * Creates a PublicFeedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PublicFeedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PublicFeedRequest} PublicFeedRequest
         */
        PublicFeedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PublicFeedRequest)
                return object;
            var message = new $root.server.PublicFeedRequest();
            if (object.cursor != null)
                message.cursor = String(object.cursor);
            switch (object.publicFeedContentType) {
            case "MOMENTS":
            case 0:
                message.publicFeedContentType = 0;
                break;
            case "POSTS":
            case 1:
                message.publicFeedContentType = 1;
                break;
            }
            if (object.gpsLocation != null) {
                if (typeof object.gpsLocation !== "object")
                    throw TypeError(".server.PublicFeedRequest.gpsLocation: object expected");
                message.gpsLocation = $root.server.GpsLocation.fromObject(object.gpsLocation);
            }
            if (object.showDevContent != null)
                message.showDevContent = Boolean(object.showDevContent);
            return message;
        };

        /**
         * Creates a plain object from a PublicFeedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PublicFeedRequest
         * @static
         * @param {server.PublicFeedRequest} message PublicFeedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicFeedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cursor = "";
                object.publicFeedContentType = options.enums === String ? "MOMENTS" : 0;
                object.gpsLocation = null;
                object.showDevContent = false;
            }
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                object.cursor = message.cursor;
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                object.publicFeedContentType = options.enums === String ? $root.server.PublicFeedContentType[message.publicFeedContentType] : message.publicFeedContentType;
            if (message.gpsLocation != null && message.hasOwnProperty("gpsLocation"))
                object.gpsLocation = $root.server.GpsLocation.toObject(message.gpsLocation, options);
            if (message.showDevContent != null && message.hasOwnProperty("showDevContent"))
                object.showDevContent = message.showDevContent;
            return object;
        };

        /**
         * Converts this PublicFeedRequest to JSON.
         * @function toJSON
         * @memberof server.PublicFeedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicFeedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublicFeedRequest;
    })();

    server.PublicFeedResponse = (function() {

        /**
         * Properties of a PublicFeedResponse.
         * @memberof server
         * @interface IPublicFeedResponse
         * @property {server.PublicFeedResponse.Result|null} [result] PublicFeedResponse result
         * @property {server.PublicFeedResponse.Reason|null} [reason] PublicFeedResponse reason
         * @property {string|null} [cursor] PublicFeedResponse cursor
         * @property {server.PublicFeedContentType|null} [publicFeedContentType] PublicFeedResponse publicFeedContentType
         * @property {boolean|null} [cursorRestarted] PublicFeedResponse cursorRestarted
         * @property {Array.<server.IPublicFeedItem>|null} [items] PublicFeedResponse items
         * @property {string|null} [geoTag] PublicFeedResponse geoTag
         */

        /**
         * Constructs a new PublicFeedResponse.
         * @memberof server
         * @classdesc Represents a PublicFeedResponse.
         * @implements IPublicFeedResponse
         * @constructor
         * @param {server.IPublicFeedResponse=} [properties] Properties to set
         */
        function PublicFeedResponse(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicFeedResponse result.
         * @member {server.PublicFeedResponse.Result} result
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.result = 0;

        /**
         * PublicFeedResponse reason.
         * @member {server.PublicFeedResponse.Reason} reason
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.reason = 0;

        /**
         * PublicFeedResponse cursor.
         * @member {string} cursor
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.cursor = "";

        /**
         * PublicFeedResponse publicFeedContentType.
         * @member {server.PublicFeedContentType} publicFeedContentType
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.publicFeedContentType = 0;

        /**
         * PublicFeedResponse cursorRestarted.
         * @member {boolean} cursorRestarted
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.cursorRestarted = false;

        /**
         * PublicFeedResponse items.
         * @member {Array.<server.IPublicFeedItem>} items
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.items = $util.emptyArray;

        /**
         * PublicFeedResponse geoTag.
         * @member {string} geoTag
         * @memberof server.PublicFeedResponse
         * @instance
         */
        PublicFeedResponse.prototype.geoTag = "";

        /**
         * Creates a new PublicFeedResponse instance using the specified properties.
         * @function create
         * @memberof server.PublicFeedResponse
         * @static
         * @param {server.IPublicFeedResponse=} [properties] Properties to set
         * @returns {server.PublicFeedResponse} PublicFeedResponse instance
         */
        PublicFeedResponse.create = function create(properties) {
            return new PublicFeedResponse(properties);
        };

        /**
         * Encodes the specified PublicFeedResponse message. Does not implicitly {@link server.PublicFeedResponse.verify|verify} messages.
         * @function encode
         * @memberof server.PublicFeedResponse
         * @static
         * @param {server.IPublicFeedResponse} message PublicFeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.cursor);
            if (message.publicFeedContentType != null && Object.hasOwnProperty.call(message, "publicFeedContentType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.publicFeedContentType);
            if (message.cursorRestarted != null && Object.hasOwnProperty.call(message, "cursorRestarted"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.cursorRestarted);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.PublicFeedItem.encode(message.items[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.geoTag != null && Object.hasOwnProperty.call(message, "geoTag"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.geoTag);
            return writer;
        };

        /**
         * Encodes the specified PublicFeedResponse message, length delimited. Does not implicitly {@link server.PublicFeedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PublicFeedResponse
         * @static
         * @param {server.IPublicFeedResponse} message PublicFeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicFeedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.PublicFeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PublicFeedResponse} PublicFeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PublicFeedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.cursor = reader.string();
                    break;
                case 4:
                    message.publicFeedContentType = reader.int32();
                    break;
                case 5:
                    message.cursorRestarted = reader.bool();
                    break;
                case 6:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.PublicFeedItem.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.geoTag = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicFeedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PublicFeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PublicFeedResponse} PublicFeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicFeedResponse message.
         * @function verify
         * @memberof server.PublicFeedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicFeedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (!$util.isString(message.cursor))
                    return "cursor: string expected";
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                switch (message.publicFeedContentType) {
                default:
                    return "publicFeedContentType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.cursorRestarted != null && message.hasOwnProperty("cursorRestarted"))
                if (typeof message.cursorRestarted !== "boolean")
                    return "cursorRestarted: boolean expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.PublicFeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.geoTag != null && message.hasOwnProperty("geoTag"))
                if (!$util.isString(message.geoTag))
                    return "geoTag: string expected";
            return null;
        };

        /**
         * Creates a PublicFeedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PublicFeedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PublicFeedResponse} PublicFeedResponse
         */
        PublicFeedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PublicFeedResponse)
                return object;
            var message = new $root.server.PublicFeedResponse();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "OK":
            case 1:
                message.reason = 1;
                break;
            }
            if (object.cursor != null)
                message.cursor = String(object.cursor);
            switch (object.publicFeedContentType) {
            case "MOMENTS":
            case 0:
                message.publicFeedContentType = 0;
                break;
            case "POSTS":
            case 1:
                message.publicFeedContentType = 1;
                break;
            }
            if (object.cursorRestarted != null)
                message.cursorRestarted = Boolean(object.cursorRestarted);
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.PublicFeedResponse.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.PublicFeedResponse.items: object expected");
                    message.items[i] = $root.server.PublicFeedItem.fromObject(object.items[i]);
                }
            }
            if (object.geoTag != null)
                message.geoTag = String(object.geoTag);
            return message;
        };

        /**
         * Creates a plain object from a PublicFeedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PublicFeedResponse
         * @static
         * @param {server.PublicFeedResponse} message PublicFeedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicFeedResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.cursor = "";
                object.publicFeedContentType = options.enums === String ? "MOMENTS" : 0;
                object.cursorRestarted = false;
                object.geoTag = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.PublicFeedResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.PublicFeedResponse.Reason[message.reason] : message.reason;
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                object.cursor = message.cursor;
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                object.publicFeedContentType = options.enums === String ? $root.server.PublicFeedContentType[message.publicFeedContentType] : message.publicFeedContentType;
            if (message.cursorRestarted != null && message.hasOwnProperty("cursorRestarted"))
                object.cursorRestarted = message.cursorRestarted;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.PublicFeedItem.toObject(message.items[j], options);
            }
            if (message.geoTag != null && message.hasOwnProperty("geoTag"))
                object.geoTag = message.geoTag;
            return object;
        };

        /**
         * Converts this PublicFeedResponse to JSON.
         * @function toJSON
         * @memberof server.PublicFeedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicFeedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.PublicFeedResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        PublicFeedResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.PublicFeedResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} OK=1 OK value
         */
        PublicFeedResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return PublicFeedResponse;
    })();

    server.PublicFeedItem = (function() {

        /**
         * Properties of a PublicFeedItem.
         * @memberof server
         * @interface IPublicFeedItem
         * @property {server.IBasicUserProfile|null} [userProfile] PublicFeedItem userProfile
         * @property {server.IPost|null} [post] PublicFeedItem post
         * @property {Array.<server.IComment>|null} [comments] PublicFeedItem comments
         * @property {server.PublicFeedItem.Reason|null} [reason] PublicFeedItem reason
         * @property {server.IServerScore|null} [score] PublicFeedItem score
         */

        /**
         * Constructs a new PublicFeedItem.
         * @memberof server
         * @classdesc Represents a PublicFeedItem.
         * @implements IPublicFeedItem
         * @constructor
         * @param {server.IPublicFeedItem=} [properties] Properties to set
         */
        function PublicFeedItem(properties) {
            this.comments = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicFeedItem userProfile.
         * @member {server.IBasicUserProfile|null|undefined} userProfile
         * @memberof server.PublicFeedItem
         * @instance
         */
        PublicFeedItem.prototype.userProfile = null;

        /**
         * PublicFeedItem post.
         * @member {server.IPost|null|undefined} post
         * @memberof server.PublicFeedItem
         * @instance
         */
        PublicFeedItem.prototype.post = null;

        /**
         * PublicFeedItem comments.
         * @member {Array.<server.IComment>} comments
         * @memberof server.PublicFeedItem
         * @instance
         */
        PublicFeedItem.prototype.comments = $util.emptyArray;

        /**
         * PublicFeedItem reason.
         * @member {server.PublicFeedItem.Reason} reason
         * @memberof server.PublicFeedItem
         * @instance
         */
        PublicFeedItem.prototype.reason = 0;

        /**
         * PublicFeedItem score.
         * @member {server.IServerScore|null|undefined} score
         * @memberof server.PublicFeedItem
         * @instance
         */
        PublicFeedItem.prototype.score = null;

        /**
         * Creates a new PublicFeedItem instance using the specified properties.
         * @function create
         * @memberof server.PublicFeedItem
         * @static
         * @param {server.IPublicFeedItem=} [properties] Properties to set
         * @returns {server.PublicFeedItem} PublicFeedItem instance
         */
        PublicFeedItem.create = function create(properties) {
            return new PublicFeedItem(properties);
        };

        /**
         * Encodes the specified PublicFeedItem message. Does not implicitly {@link server.PublicFeedItem.verify|verify} messages.
         * @function encode
         * @memberof server.PublicFeedItem
         * @static
         * @param {server.IPublicFeedItem} message PublicFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userProfile != null && Object.hasOwnProperty.call(message, "userProfile"))
                $root.server.BasicUserProfile.encode(message.userProfile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                $root.server.Post.encode(message.post, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.comments != null && message.comments.length)
                for (var i = 0; i < message.comments.length; ++i)
                    $root.server.Comment.encode(message.comments[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reason);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                $root.server.ServerScore.encode(message.score, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PublicFeedItem message, length delimited. Does not implicitly {@link server.PublicFeedItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PublicFeedItem
         * @static
         * @param {server.IPublicFeedItem} message PublicFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicFeedItem message from the specified reader or buffer.
         * @function decode
         * @memberof server.PublicFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PublicFeedItem} PublicFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PublicFeedItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userProfile = $root.server.BasicUserProfile.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.post = $root.server.Post.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.comments && message.comments.length))
                        message.comments = [];
                    message.comments.push($root.server.Comment.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.reason = reader.int32();
                    break;
                case 5:
                    message.score = $root.server.ServerScore.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicFeedItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PublicFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PublicFeedItem} PublicFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicFeedItem message.
         * @function verify
         * @memberof server.PublicFeedItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicFeedItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
                var error = $root.server.BasicUserProfile.verify(message.userProfile);
                if (error)
                    return "userProfile." + error;
            }
            if (message.post != null && message.hasOwnProperty("post")) {
                var error = $root.server.Post.verify(message.post);
                if (error)
                    return "post." + error;
            }
            if (message.comments != null && message.hasOwnProperty("comments")) {
                if (!Array.isArray(message.comments))
                    return "comments: array expected";
                for (var i = 0; i < message.comments.length; ++i) {
                    var error = $root.server.Comment.verify(message.comments[i]);
                    if (error)
                        return "comments." + error;
                }
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.score != null && message.hasOwnProperty("score")) {
                var error = $root.server.ServerScore.verify(message.score);
                if (error)
                    return "score." + error;
            }
            return null;
        };

        /**
         * Creates a PublicFeedItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PublicFeedItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PublicFeedItem} PublicFeedItem
         */
        PublicFeedItem.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PublicFeedItem)
                return object;
            var message = new $root.server.PublicFeedItem();
            if (object.userProfile != null) {
                if (typeof object.userProfile !== "object")
                    throw TypeError(".server.PublicFeedItem.userProfile: object expected");
                message.userProfile = $root.server.BasicUserProfile.fromObject(object.userProfile);
            }
            if (object.post != null) {
                if (typeof object.post !== "object")
                    throw TypeError(".server.PublicFeedItem.post: object expected");
                message.post = $root.server.Post.fromObject(object.post);
            }
            if (object.comments) {
                if (!Array.isArray(object.comments))
                    throw TypeError(".server.PublicFeedItem.comments: array expected");
                message.comments = [];
                for (var i = 0; i < object.comments.length; ++i) {
                    if (typeof object.comments[i] !== "object")
                        throw TypeError(".server.PublicFeedItem.comments: object expected");
                    message.comments[i] = $root.server.Comment.fromObject(object.comments[i]);
                }
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "CAMPUS":
            case 1:
                message.reason = 1;
                break;
            case "FOF":
            case 2:
                message.reason = 2;
                break;
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".server.PublicFeedItem.score: object expected");
                message.score = $root.server.ServerScore.fromObject(object.score);
            }
            return message;
        };

        /**
         * Creates a plain object from a PublicFeedItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PublicFeedItem
         * @static
         * @param {server.PublicFeedItem} message PublicFeedItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicFeedItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.comments = [];
            if (options.defaults) {
                object.userProfile = null;
                object.post = null;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.score = null;
            }
            if (message.userProfile != null && message.hasOwnProperty("userProfile"))
                object.userProfile = $root.server.BasicUserProfile.toObject(message.userProfile, options);
            if (message.post != null && message.hasOwnProperty("post"))
                object.post = $root.server.Post.toObject(message.post, options);
            if (message.comments && message.comments.length) {
                object.comments = [];
                for (var j = 0; j < message.comments.length; ++j)
                    object.comments[j] = $root.server.Comment.toObject(message.comments[j], options);
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.PublicFeedItem.Reason[message.reason] : message.reason;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.server.ServerScore.toObject(message.score, options);
            return object;
        };

        /**
         * Converts this PublicFeedItem to JSON.
         * @function toJSON
         * @memberof server.PublicFeedItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicFeedItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.PublicFeedItem.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} CAMPUS=1 CAMPUS value
         * @property {number} FOF=2 FOF value
         */
        PublicFeedItem.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "CAMPUS"] = 1;
            values[valuesById[2] = "FOF"] = 2;
            return values;
        })();

        return PublicFeedItem;
    })();

    server.ServerScore = (function() {

        /**
         * Properties of a ServerScore.
         * @memberof server
         * @interface IServerScore
         * @property {number|Long|null} [score] ServerScore score
         * @property {string|null} [explanation] ServerScore explanation
         * @property {number|null} [dscore] ServerScore dscore
         */

        /**
         * Constructs a new ServerScore.
         * @memberof server
         * @classdesc Represents a ServerScore.
         * @implements IServerScore
         * @constructor
         * @param {server.IServerScore=} [properties] Properties to set
         */
        function ServerScore(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerScore score.
         * @member {number|Long} score
         * @memberof server.ServerScore
         * @instance
         */
        ServerScore.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ServerScore explanation.
         * @member {string} explanation
         * @memberof server.ServerScore
         * @instance
         */
        ServerScore.prototype.explanation = "";

        /**
         * ServerScore dscore.
         * @member {number} dscore
         * @memberof server.ServerScore
         * @instance
         */
        ServerScore.prototype.dscore = 0;

        /**
         * Creates a new ServerScore instance using the specified properties.
         * @function create
         * @memberof server.ServerScore
         * @static
         * @param {server.IServerScore=} [properties] Properties to set
         * @returns {server.ServerScore} ServerScore instance
         */
        ServerScore.create = function create(properties) {
            return new ServerScore(properties);
        };

        /**
         * Encodes the specified ServerScore message. Does not implicitly {@link server.ServerScore.verify|verify} messages.
         * @function encode
         * @memberof server.ServerScore
         * @static
         * @param {server.IServerScore} message ServerScore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerScore.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.score);
            if (message.explanation != null && Object.hasOwnProperty.call(message, "explanation"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.explanation);
            if (message.dscore != null && Object.hasOwnProperty.call(message, "dscore"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.dscore);
            return writer;
        };

        /**
         * Encodes the specified ServerScore message, length delimited. Does not implicitly {@link server.ServerScore.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ServerScore
         * @static
         * @param {server.IServerScore} message ServerScore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerScore.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerScore message from the specified reader or buffer.
         * @function decode
         * @memberof server.ServerScore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ServerScore} ServerScore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerScore.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ServerScore();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.score = reader.int64();
                    break;
                case 2:
                    message.explanation = reader.string();
                    break;
                case 3:
                    message.dscore = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerScore message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ServerScore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ServerScore} ServerScore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerScore.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerScore message.
         * @function verify
         * @memberof server.ServerScore
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerScore.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
                    return "score: integer|Long expected";
            if (message.explanation != null && message.hasOwnProperty("explanation"))
                if (!$util.isString(message.explanation))
                    return "explanation: string expected";
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                if (typeof message.dscore !== "number")
                    return "dscore: number expected";
            return null;
        };

        /**
         * Creates a ServerScore message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ServerScore
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ServerScore} ServerScore
         */
        ServerScore.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ServerScore)
                return object;
            var message = new $root.server.ServerScore();
            if (object.score != null)
                if ($util.Long)
                    (message.score = $util.Long.fromValue(object.score)).unsigned = false;
                else if (typeof object.score === "string")
                    message.score = parseInt(object.score, 10);
                else if (typeof object.score === "number")
                    message.score = object.score;
                else if (typeof object.score === "object")
                    message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber();
            if (object.explanation != null)
                message.explanation = String(object.explanation);
            if (object.dscore != null)
                message.dscore = Number(object.dscore);
            return message;
        };

        /**
         * Creates a plain object from a ServerScore message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ServerScore
         * @static
         * @param {server.ServerScore} message ServerScore
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerScore.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.score = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.score = options.longs === String ? "0" : 0;
                object.explanation = "";
                object.dscore = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score === "number")
                    object.score = options.longs === String ? String(message.score) : message.score;
                else
                    object.score = options.longs === String ? $util.Long.prototype.toString.call(message.score) : options.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber() : message.score;
            if (message.explanation != null && message.hasOwnProperty("explanation"))
                object.explanation = message.explanation;
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                object.dscore = options.json && !isFinite(message.dscore) ? String(message.dscore) : message.dscore;
            return object;
        };

        /**
         * Converts this ServerScore to JSON.
         * @function toJSON
         * @memberof server.ServerScore
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerScore.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServerScore;
    })();

    server.PublicFeedUpdate = (function() {

        /**
         * Properties of a PublicFeedUpdate.
         * @memberof server
         * @interface IPublicFeedUpdate
         * @property {string|null} [cursor] PublicFeedUpdate cursor
         * @property {server.PublicFeedContentType|null} [publicFeedContentType] PublicFeedUpdate publicFeedContentType
         * @property {Array.<server.IPublicFeedItem>|null} [items] PublicFeedUpdate items
         */

        /**
         * Constructs a new PublicFeedUpdate.
         * @memberof server
         * @classdesc Represents a PublicFeedUpdate.
         * @implements IPublicFeedUpdate
         * @constructor
         * @param {server.IPublicFeedUpdate=} [properties] Properties to set
         */
        function PublicFeedUpdate(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicFeedUpdate cursor.
         * @member {string} cursor
         * @memberof server.PublicFeedUpdate
         * @instance
         */
        PublicFeedUpdate.prototype.cursor = "";

        /**
         * PublicFeedUpdate publicFeedContentType.
         * @member {server.PublicFeedContentType} publicFeedContentType
         * @memberof server.PublicFeedUpdate
         * @instance
         */
        PublicFeedUpdate.prototype.publicFeedContentType = 0;

        /**
         * PublicFeedUpdate items.
         * @member {Array.<server.IPublicFeedItem>} items
         * @memberof server.PublicFeedUpdate
         * @instance
         */
        PublicFeedUpdate.prototype.items = $util.emptyArray;

        /**
         * Creates a new PublicFeedUpdate instance using the specified properties.
         * @function create
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {server.IPublicFeedUpdate=} [properties] Properties to set
         * @returns {server.PublicFeedUpdate} PublicFeedUpdate instance
         */
        PublicFeedUpdate.create = function create(properties) {
            return new PublicFeedUpdate(properties);
        };

        /**
         * Encodes the specified PublicFeedUpdate message. Does not implicitly {@link server.PublicFeedUpdate.verify|verify} messages.
         * @function encode
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {server.IPublicFeedUpdate} message PublicFeedUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cursor);
            if (message.publicFeedContentType != null && Object.hasOwnProperty.call(message, "publicFeedContentType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.publicFeedContentType);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.PublicFeedItem.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PublicFeedUpdate message, length delimited. Does not implicitly {@link server.PublicFeedUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {server.IPublicFeedUpdate} message PublicFeedUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicFeedUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicFeedUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PublicFeedUpdate} PublicFeedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PublicFeedUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cursor = reader.string();
                    break;
                case 2:
                    message.publicFeedContentType = reader.int32();
                    break;
                case 3:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.PublicFeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicFeedUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PublicFeedUpdate} PublicFeedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicFeedUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicFeedUpdate message.
         * @function verify
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicFeedUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (!$util.isString(message.cursor))
                    return "cursor: string expected";
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                switch (message.publicFeedContentType) {
                default:
                    return "publicFeedContentType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.PublicFeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PublicFeedUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PublicFeedUpdate} PublicFeedUpdate
         */
        PublicFeedUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PublicFeedUpdate)
                return object;
            var message = new $root.server.PublicFeedUpdate();
            if (object.cursor != null)
                message.cursor = String(object.cursor);
            switch (object.publicFeedContentType) {
            case "MOMENTS":
            case 0:
                message.publicFeedContentType = 0;
                break;
            case "POSTS":
            case 1:
                message.publicFeedContentType = 1;
                break;
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.PublicFeedUpdate.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.PublicFeedUpdate.items: object expected");
                    message.items[i] = $root.server.PublicFeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PublicFeedUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PublicFeedUpdate
         * @static
         * @param {server.PublicFeedUpdate} message PublicFeedUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicFeedUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.cursor = "";
                object.publicFeedContentType = options.enums === String ? "MOMENTS" : 0;
            }
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                object.cursor = message.cursor;
            if (message.publicFeedContentType != null && message.hasOwnProperty("publicFeedContentType"))
                object.publicFeedContentType = options.enums === String ? $root.server.PublicFeedContentType[message.publicFeedContentType] : message.publicFeedContentType;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.PublicFeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this PublicFeedUpdate to JSON.
         * @function toJSON
         * @memberof server.PublicFeedUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicFeedUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublicFeedUpdate;
    })();

    server.GpsLocation = (function() {

        /**
         * Properties of a GpsLocation.
         * @memberof server
         * @interface IGpsLocation
         * @property {number|null} [latitude] GpsLocation latitude
         * @property {number|null} [longitude] GpsLocation longitude
         */

        /**
         * Constructs a new GpsLocation.
         * @memberof server
         * @classdesc Represents a GpsLocation.
         * @implements IGpsLocation
         * @constructor
         * @param {server.IGpsLocation=} [properties] Properties to set
         */
        function GpsLocation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GpsLocation latitude.
         * @member {number} latitude
         * @memberof server.GpsLocation
         * @instance
         */
        GpsLocation.prototype.latitude = 0;

        /**
         * GpsLocation longitude.
         * @member {number} longitude
         * @memberof server.GpsLocation
         * @instance
         */
        GpsLocation.prototype.longitude = 0;

        /**
         * Creates a new GpsLocation instance using the specified properties.
         * @function create
         * @memberof server.GpsLocation
         * @static
         * @param {server.IGpsLocation=} [properties] Properties to set
         * @returns {server.GpsLocation} GpsLocation instance
         */
        GpsLocation.create = function create(properties) {
            return new GpsLocation(properties);
        };

        /**
         * Encodes the specified GpsLocation message. Does not implicitly {@link server.GpsLocation.verify|verify} messages.
         * @function encode
         * @memberof server.GpsLocation
         * @static
         * @param {server.IGpsLocation} message GpsLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpsLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.latitude);
            if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.longitude);
            return writer;
        };

        /**
         * Encodes the specified GpsLocation message, length delimited. Does not implicitly {@link server.GpsLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GpsLocation
         * @static
         * @param {server.IGpsLocation} message GpsLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GpsLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GpsLocation message from the specified reader or buffer.
         * @function decode
         * @memberof server.GpsLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GpsLocation} GpsLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpsLocation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GpsLocation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.latitude = reader.double();
                    break;
                case 2:
                    message.longitude = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GpsLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GpsLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GpsLocation} GpsLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GpsLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GpsLocation message.
         * @function verify
         * @memberof server.GpsLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GpsLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (typeof message.latitude !== "number")
                    return "latitude: number expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (typeof message.longitude !== "number")
                    return "longitude: number expected";
            return null;
        };

        /**
         * Creates a GpsLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GpsLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GpsLocation} GpsLocation
         */
        GpsLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GpsLocation)
                return object;
            var message = new $root.server.GpsLocation();
            if (object.latitude != null)
                message.latitude = Number(object.latitude);
            if (object.longitude != null)
                message.longitude = Number(object.longitude);
            return message;
        };

        /**
         * Creates a plain object from a GpsLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GpsLocation
         * @static
         * @param {server.GpsLocation} message GpsLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GpsLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.latitude = 0;
                object.longitude = 0;
            }
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
            return object;
        };

        /**
         * Converts this GpsLocation to JSON.
         * @function toJSON
         * @memberof server.GpsLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GpsLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GpsLocation;
    })();

    server.PostSubscriptionRequest = (function() {

        /**
         * Properties of a PostSubscriptionRequest.
         * @memberof server
         * @interface IPostSubscriptionRequest
         * @property {server.PostSubscriptionRequest.Action|null} [action] PostSubscriptionRequest action
         * @property {string|null} [postId] PostSubscriptionRequest postId
         */

        /**
         * Constructs a new PostSubscriptionRequest.
         * @memberof server
         * @classdesc Represents a PostSubscriptionRequest.
         * @implements IPostSubscriptionRequest
         * @constructor
         * @param {server.IPostSubscriptionRequest=} [properties] Properties to set
         */
        function PostSubscriptionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostSubscriptionRequest action.
         * @member {server.PostSubscriptionRequest.Action} action
         * @memberof server.PostSubscriptionRequest
         * @instance
         */
        PostSubscriptionRequest.prototype.action = 0;

        /**
         * PostSubscriptionRequest postId.
         * @member {string} postId
         * @memberof server.PostSubscriptionRequest
         * @instance
         */
        PostSubscriptionRequest.prototype.postId = "";

        /**
         * Creates a new PostSubscriptionRequest instance using the specified properties.
         * @function create
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {server.IPostSubscriptionRequest=} [properties] Properties to set
         * @returns {server.PostSubscriptionRequest} PostSubscriptionRequest instance
         */
        PostSubscriptionRequest.create = function create(properties) {
            return new PostSubscriptionRequest(properties);
        };

        /**
         * Encodes the specified PostSubscriptionRequest message. Does not implicitly {@link server.PostSubscriptionRequest.verify|verify} messages.
         * @function encode
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {server.IPostSubscriptionRequest} message PostSubscriptionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostSubscriptionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.postId);
            return writer;
        };

        /**
         * Encodes the specified PostSubscriptionRequest message, length delimited. Does not implicitly {@link server.PostSubscriptionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {server.IPostSubscriptionRequest} message PostSubscriptionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostSubscriptionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostSubscriptionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PostSubscriptionRequest} PostSubscriptionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostSubscriptionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PostSubscriptionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.postId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostSubscriptionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PostSubscriptionRequest} PostSubscriptionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostSubscriptionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostSubscriptionRequest message.
         * @function verify
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostSubscriptionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isString(message.postId))
                    return "postId: string expected";
            return null;
        };

        /**
         * Creates a PostSubscriptionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PostSubscriptionRequest} PostSubscriptionRequest
         */
        PostSubscriptionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PostSubscriptionRequest)
                return object;
            var message = new $root.server.PostSubscriptionRequest();
            switch (object.action) {
            case "UNKNOWN_ACTION":
            case 0:
                message.action = 0;
                break;
            case "SUBSCRIBE":
            case 1:
                message.action = 1;
                break;
            case "UNSUBSCRIBE":
            case 2:
                message.action = 2;
                break;
            }
            if (object.postId != null)
                message.postId = String(object.postId);
            return message;
        };

        /**
         * Creates a plain object from a PostSubscriptionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PostSubscriptionRequest
         * @static
         * @param {server.PostSubscriptionRequest} message PostSubscriptionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostSubscriptionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "UNKNOWN_ACTION" : 0;
                object.postId = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.PostSubscriptionRequest.Action[message.action] : message.action;
            if (message.postId != null && message.hasOwnProperty("postId"))
                object.postId = message.postId;
            return object;
        };

        /**
         * Converts this PostSubscriptionRequest to JSON.
         * @function toJSON
         * @memberof server.PostSubscriptionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostSubscriptionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.PostSubscriptionRequest.Action
         * @enum {number}
         * @property {number} UNKNOWN_ACTION=0 UNKNOWN_ACTION value
         * @property {number} SUBSCRIBE=1 SUBSCRIBE value
         * @property {number} UNSUBSCRIBE=2 UNSUBSCRIBE value
         */
        PostSubscriptionRequest.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_ACTION"] = 0;
            values[valuesById[1] = "SUBSCRIBE"] = 1;
            values[valuesById[2] = "UNSUBSCRIBE"] = 2;
            return values;
        })();

        return PostSubscriptionRequest;
    })();

    server.PostSubscriptionResponse = (function() {

        /**
         * Properties of a PostSubscriptionResponse.
         * @memberof server
         * @interface IPostSubscriptionResponse
         * @property {server.PostSubscriptionResponse.Result|null} [result] PostSubscriptionResponse result
         * @property {server.PostSubscriptionResponse.Reason|null} [reason] PostSubscriptionResponse reason
         * @property {Array.<server.IFeedItem>|null} [items] PostSubscriptionResponse items
         */

        /**
         * Constructs a new PostSubscriptionResponse.
         * @memberof server
         * @classdesc Represents a PostSubscriptionResponse.
         * @implements IPostSubscriptionResponse
         * @constructor
         * @param {server.IPostSubscriptionResponse=} [properties] Properties to set
         */
        function PostSubscriptionResponse(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostSubscriptionResponse result.
         * @member {server.PostSubscriptionResponse.Result} result
         * @memberof server.PostSubscriptionResponse
         * @instance
         */
        PostSubscriptionResponse.prototype.result = 0;

        /**
         * PostSubscriptionResponse reason.
         * @member {server.PostSubscriptionResponse.Reason} reason
         * @memberof server.PostSubscriptionResponse
         * @instance
         */
        PostSubscriptionResponse.prototype.reason = 0;

        /**
         * PostSubscriptionResponse items.
         * @member {Array.<server.IFeedItem>} items
         * @memberof server.PostSubscriptionResponse
         * @instance
         */
        PostSubscriptionResponse.prototype.items = $util.emptyArray;

        /**
         * Creates a new PostSubscriptionResponse instance using the specified properties.
         * @function create
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {server.IPostSubscriptionResponse=} [properties] Properties to set
         * @returns {server.PostSubscriptionResponse} PostSubscriptionResponse instance
         */
        PostSubscriptionResponse.create = function create(properties) {
            return new PostSubscriptionResponse(properties);
        };

        /**
         * Encodes the specified PostSubscriptionResponse message. Does not implicitly {@link server.PostSubscriptionResponse.verify|verify} messages.
         * @function encode
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {server.IPostSubscriptionResponse} message PostSubscriptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostSubscriptionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.FeedItem.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PostSubscriptionResponse message, length delimited. Does not implicitly {@link server.PostSubscriptionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {server.IPostSubscriptionResponse} message PostSubscriptionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostSubscriptionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostSubscriptionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PostSubscriptionResponse} PostSubscriptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostSubscriptionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PostSubscriptionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.FeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostSubscriptionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PostSubscriptionResponse} PostSubscriptionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostSubscriptionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostSubscriptionResponse message.
         * @function verify
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostSubscriptionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.FeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PostSubscriptionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PostSubscriptionResponse} PostSubscriptionResponse
         */
        PostSubscriptionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PostSubscriptionResponse)
                return object;
            var message = new $root.server.PostSubscriptionResponse();
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_POST_ID":
            case 1:
                message.reason = 1;
                break;
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.PostSubscriptionResponse.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.PostSubscriptionResponse.items: object expected");
                    message.items[i] = $root.server.FeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PostSubscriptionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PostSubscriptionResponse
         * @static
         * @param {server.PostSubscriptionResponse} message PostSubscriptionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostSubscriptionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.PostSubscriptionResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.PostSubscriptionResponse.Reason[message.reason] : message.reason;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.FeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this PostSubscriptionResponse to JSON.
         * @function toJSON
         * @memberof server.PostSubscriptionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostSubscriptionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.PostSubscriptionResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        PostSubscriptionResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.PostSubscriptionResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_POST_ID=1 INVALID_POST_ID value
         */
        PostSubscriptionResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_POST_ID"] = 1;
            return values;
        })();

        return PostSubscriptionResponse;
    })();

    server.SenderStateWithKeyInfo = (function() {

        /**
         * Properties of a SenderStateWithKeyInfo.
         * @memberof server
         * @interface ISenderStateWithKeyInfo
         * @property {Uint8Array|null} [publicKey] SenderStateWithKeyInfo publicKey
         * @property {number|Long|null} [oneTimePreKeyId] SenderStateWithKeyInfo oneTimePreKeyId
         * @property {Uint8Array|null} [encSenderState] SenderStateWithKeyInfo encSenderState
         */

        /**
         * Constructs a new SenderStateWithKeyInfo.
         * @memberof server
         * @classdesc Represents a SenderStateWithKeyInfo.
         * @implements ISenderStateWithKeyInfo
         * @constructor
         * @param {server.ISenderStateWithKeyInfo=} [properties] Properties to set
         */
        function SenderStateWithKeyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderStateWithKeyInfo publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.publicKey = $util.newBuffer([]);

        /**
         * SenderStateWithKeyInfo oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SenderStateWithKeyInfo encSenderState.
         * @member {Uint8Array} encSenderState
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.encSenderState = $util.newBuffer([]);

        /**
         * Creates a new SenderStateWithKeyInfo instance using the specified properties.
         * @function create
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo=} [properties] Properties to set
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo instance
         */
        SenderStateWithKeyInfo.create = function create(properties) {
            return new SenderStateWithKeyInfo(properties);
        };

        /**
         * Encodes the specified SenderStateWithKeyInfo message. Does not implicitly {@link server.SenderStateWithKeyInfo.verify|verify} messages.
         * @function encode
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo} message SenderStateWithKeyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateWithKeyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.oneTimePreKeyId);
            if (message.encSenderState != null && Object.hasOwnProperty.call(message, "encSenderState"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encSenderState);
            return writer;
        };

        /**
         * Encodes the specified SenderStateWithKeyInfo message, length delimited. Does not implicitly {@link server.SenderStateWithKeyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo} message SenderStateWithKeyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateWithKeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderStateWithKeyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateWithKeyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SenderStateWithKeyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 3:
                    message.encSenderState = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderStateWithKeyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateWithKeyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderStateWithKeyInfo message.
         * @function verify
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderStateWithKeyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.encSenderState != null && message.hasOwnProperty("encSenderState"))
                if (!(message.encSenderState && typeof message.encSenderState.length === "number" || $util.isString(message.encSenderState)))
                    return "encSenderState: buffer expected";
            return null;
        };

        /**
         * Creates a SenderStateWithKeyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         */
        SenderStateWithKeyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SenderStateWithKeyInfo)
                return object;
            var message = new $root.server.SenderStateWithKeyInfo();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.encSenderState != null)
                if (typeof object.encSenderState === "string")
                    $util.base64.decode(object.encSenderState, message.encSenderState = $util.newBuffer($util.base64.length(object.encSenderState)), 0);
                else if (object.encSenderState.length)
                    message.encSenderState = object.encSenderState;
            return message;
        };

        /**
         * Creates a plain object from a SenderStateWithKeyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.SenderStateWithKeyInfo} message SenderStateWithKeyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderStateWithKeyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encSenderState = "";
                else {
                    object.encSenderState = [];
                    if (options.bytes !== Array)
                        object.encSenderState = $util.newBuffer(object.encSenderState);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.encSenderState != null && message.hasOwnProperty("encSenderState"))
                object.encSenderState = options.bytes === String ? $util.base64.encode(message.encSenderState, 0, message.encSenderState.length) : options.bytes === Array ? Array.prototype.slice.call(message.encSenderState) : message.encSenderState;
            return object;
        };

        /**
         * Converts this SenderStateWithKeyInfo to JSON.
         * @function toJSON
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderStateWithKeyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderStateWithKeyInfo;
    })();

    server.SenderStateBundle = (function() {

        /**
         * Properties of a SenderStateBundle.
         * @memberof server
         * @interface ISenderStateBundle
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] SenderStateBundle senderState
         * @property {number|Long|null} [uid] SenderStateBundle uid
         */

        /**
         * Constructs a new SenderStateBundle.
         * @memberof server
         * @classdesc Represents a SenderStateBundle.
         * @implements ISenderStateBundle
         * @constructor
         * @param {server.ISenderStateBundle=} [properties] Properties to set
         */
        function SenderStateBundle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderStateBundle senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.SenderStateBundle
         * @instance
         */
        SenderStateBundle.prototype.senderState = null;

        /**
         * SenderStateBundle uid.
         * @member {number|Long} uid
         * @memberof server.SenderStateBundle
         * @instance
         */
        SenderStateBundle.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SenderStateBundle instance using the specified properties.
         * @function create
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle=} [properties] Properties to set
         * @returns {server.SenderStateBundle} SenderStateBundle instance
         */
        SenderStateBundle.create = function create(properties) {
            return new SenderStateBundle(properties);
        };

        /**
         * Encodes the specified SenderStateBundle message. Does not implicitly {@link server.SenderStateBundle.verify|verify} messages.
         * @function encode
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle} message SenderStateBundle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateBundle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified SenderStateBundle message, length delimited. Does not implicitly {@link server.SenderStateBundle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle} message SenderStateBundle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateBundle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderStateBundle message from the specified reader or buffer.
         * @function decode
         * @memberof server.SenderStateBundle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SenderStateBundle} SenderStateBundle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateBundle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SenderStateBundle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderStateBundle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SenderStateBundle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SenderStateBundle} SenderStateBundle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateBundle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderStateBundle message.
         * @function verify
         * @memberof server.SenderStateBundle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderStateBundle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates a SenderStateBundle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SenderStateBundle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SenderStateBundle} SenderStateBundle
         */
        SenderStateBundle.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SenderStateBundle)
                return object;
            var message = new $root.server.SenderStateBundle();
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.SenderStateBundle.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SenderStateBundle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.SenderStateBundle} message SenderStateBundle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderStateBundle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.senderState = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this SenderStateBundle to JSON.
         * @function toJSON
         * @memberof server.SenderStateBundle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderStateBundle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderStateBundle;
    })();

    server.GroupFeedItem = (function() {

        /**
         * Properties of a GroupFeedItem.
         * @memberof server
         * @interface IGroupFeedItem
         * @property {server.GroupFeedItem.Action|null} [action] GroupFeedItem action
         * @property {string|null} [gid] GroupFeedItem gid
         * @property {string|null} [name] GroupFeedItem name
         * @property {string|null} [avatarId] GroupFeedItem avatarId
         * @property {server.IPost|null} [post] GroupFeedItem post
         * @property {server.IComment|null} [comment] GroupFeedItem comment
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] GroupFeedItem senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] GroupFeedItem senderState
         * @property {Uint8Array|null} [audienceHash] GroupFeedItem audienceHash
         * @property {boolean|null} [isResentHistory] GroupFeedItem isResentHistory
         * @property {number|Long|null} [expiryTimestamp] GroupFeedItem expiryTimestamp
         * @property {string|null} [senderLogInfo] GroupFeedItem senderLogInfo
         * @property {string|null} [senderClientVersion] GroupFeedItem senderClientVersion
         */

        /**
         * Constructs a new GroupFeedItem.
         * @memberof server
         * @classdesc Represents a GroupFeedItem.
         * @implements IGroupFeedItem
         * @constructor
         * @param {server.IGroupFeedItem=} [properties] Properties to set
         */
        function GroupFeedItem(properties) {
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedItem action.
         * @member {server.GroupFeedItem.Action} action
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.action = 0;

        /**
         * GroupFeedItem gid.
         * @member {string} gid
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.gid = "";

        /**
         * GroupFeedItem name.
         * @member {string} name
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.name = "";

        /**
         * GroupFeedItem avatarId.
         * @member {string} avatarId
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.avatarId = "";

        /**
         * GroupFeedItem post.
         * @member {server.IPost|null|undefined} post
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.post = null;

        /**
         * GroupFeedItem comment.
         * @member {server.IComment|null|undefined} comment
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.comment = null;

        /**
         * GroupFeedItem senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderStateBundles = $util.emptyArray;

        /**
         * GroupFeedItem senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderState = null;

        /**
         * GroupFeedItem audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.audienceHash = $util.newBuffer([]);

        /**
         * GroupFeedItem isResentHistory.
         * @member {boolean} isResentHistory
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.isResentHistory = false;

        /**
         * GroupFeedItem expiryTimestamp.
         * @member {number|Long} expiryTimestamp
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupFeedItem senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderLogInfo = "";

        /**
         * GroupFeedItem senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderClientVersion = "";

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GroupFeedItem item.
         * @member {"post"|"comment"|undefined} item
         * @memberof server.GroupFeedItem
         * @instance
         */
        Object.defineProperty(GroupFeedItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["post", "comment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GroupFeedItem instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem=} [properties] Properties to set
         * @returns {server.GroupFeedItem} GroupFeedItem instance
         */
        GroupFeedItem.create = function create(properties) {
            return new GroupFeedItem(properties);
        };

        /**
         * Encodes the specified GroupFeedItem message. Does not implicitly {@link server.GroupFeedItem.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem} message GroupFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                $root.server.Post.encode(message.post, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                $root.server.Comment.encode(message.comment, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.audienceHash);
            if (message.isResentHistory != null && Object.hasOwnProperty.call(message, "isResentHistory"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isResentHistory);
            if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.expiryTimestamp);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedItem message, length delimited. Does not implicitly {@link server.GroupFeedItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem} message GroupFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedItem message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedItem} GroupFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.post = $root.server.Post.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.comment = $root.server.Comment.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.audienceHash = reader.bytes();
                    break;
                case 10:
                    message.isResentHistory = reader.bool();
                    break;
                case 11:
                    message.expiryTimestamp = reader.int64();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedItem} GroupFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedItem message.
         * @function verify
         * @memberof server.GroupFeedItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.post != null && message.hasOwnProperty("post")) {
                properties.item = 1;
                {
                    var error = $root.server.Post.verify(message.post);
                    if (error)
                        return "post." + error;
                }
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    var error = $root.server.Comment.verify(message.comment);
                    if (error)
                        return "comment." + error;
                }
            }
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.isResentHistory != null && message.hasOwnProperty("isResentHistory"))
                if (typeof message.isResentHistory !== "boolean")
                    return "isResentHistory: boolean expected";
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                    return "expiryTimestamp: integer|Long expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a GroupFeedItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedItem} GroupFeedItem
         */
        GroupFeedItem.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedItem)
                return object;
            var message = new $root.server.GroupFeedItem();
            switch (object.action) {
            case "PUBLISH":
            case 0:
                message.action = 0;
                break;
            case "RETRACT":
            case 1:
                message.action = 1;
                break;
            case "SHARE":
            case 2:
                message.action = 2;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.post != null) {
                if (typeof object.post !== "object")
                    throw TypeError(".server.GroupFeedItem.post: object expected");
                message.post = $root.server.Post.fromObject(object.post);
            }
            if (object.comment != null) {
                if (typeof object.comment !== "object")
                    throw TypeError(".server.GroupFeedItem.comment: object expected");
                message.comment = $root.server.Comment.fromObject(object.comment);
            }
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.GroupFeedItem.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.GroupFeedItem.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.GroupFeedItem.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.isResentHistory != null)
                message.isResentHistory = Boolean(object.isResentHistory);
            if (object.expiryTimestamp != null)
                if ($util.Long)
                    (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = false;
                else if (typeof object.expiryTimestamp === "string")
                    message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                else if (typeof object.expiryTimestamp === "number")
                    message.expiryTimestamp = object.expiryTimestamp;
                else if (typeof object.expiryTimestamp === "object")
                    message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber();
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.GroupFeedItem} message GroupFeedItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderStateBundles = [];
            if (options.defaults) {
                object.action = options.enums === String ? "PUBLISH" : 0;
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                object.senderState = null;
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.isResentHistory = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiryTimestamp = options.longs === String ? "0" : 0;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupFeedItem.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.post != null && message.hasOwnProperty("post")) {
                object.post = $root.server.Post.toObject(message.post, options);
                if (options.oneofs)
                    object.item = "post";
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                object.comment = $root.server.Comment.toObject(message.comment, options);
                if (options.oneofs)
                    object.item = "comment";
            }
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.isResentHistory != null && message.hasOwnProperty("isResentHistory"))
                object.isResentHistory = message.isResentHistory;
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (typeof message.expiryTimestamp === "number")
                    object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                else
                    object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber() : message.expiryTimestamp;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this GroupFeedItem to JSON.
         * @function toJSON
         * @memberof server.GroupFeedItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupFeedItem.Action
         * @enum {number}
         * @property {number} PUBLISH=0 PUBLISH value
         * @property {number} RETRACT=1 RETRACT value
         * @property {number} SHARE=2 SHARE value
         */
        GroupFeedItem.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUBLISH"] = 0;
            values[valuesById[1] = "RETRACT"] = 1;
            values[valuesById[2] = "SHARE"] = 2;
            return values;
        })();

        return GroupFeedItem;
    })();

    server.GroupFeedItems = (function() {

        /**
         * Properties of a GroupFeedItems.
         * @memberof server
         * @interface IGroupFeedItems
         * @property {string|null} [gid] GroupFeedItems gid
         * @property {string|null} [name] GroupFeedItems name
         * @property {string|null} [avatarId] GroupFeedItems avatarId
         * @property {Array.<server.IGroupFeedItem>|null} [items] GroupFeedItems items
         */

        /**
         * Constructs a new GroupFeedItems.
         * @memberof server
         * @classdesc Represents a GroupFeedItems.
         * @implements IGroupFeedItems
         * @constructor
         * @param {server.IGroupFeedItems=} [properties] Properties to set
         */
        function GroupFeedItems(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedItems gid.
         * @member {string} gid
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.gid = "";

        /**
         * GroupFeedItems name.
         * @member {string} name
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.name = "";

        /**
         * GroupFeedItems avatarId.
         * @member {string} avatarId
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.avatarId = "";

        /**
         * GroupFeedItems items.
         * @member {Array.<server.IGroupFeedItem>} items
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.items = $util.emptyArray;

        /**
         * Creates a new GroupFeedItems instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems=} [properties] Properties to set
         * @returns {server.GroupFeedItems} GroupFeedItems instance
         */
        GroupFeedItems.create = function create(properties) {
            return new GroupFeedItems(properties);
        };

        /**
         * Encodes the specified GroupFeedItems message. Does not implicitly {@link server.GroupFeedItems.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems} message GroupFeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.GroupFeedItem.encode(message.items[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupFeedItems message, length delimited. Does not implicitly {@link server.GroupFeedItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems} message GroupFeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedItems message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedItems} GroupFeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                case 4:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.GroupFeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedItems} GroupFeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedItems message.
         * @function verify
         * @memberof server.GroupFeedItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.GroupFeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupFeedItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedItems} GroupFeedItems
         */
        GroupFeedItems.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedItems)
                return object;
            var message = new $root.server.GroupFeedItems();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.GroupFeedItems.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.GroupFeedItems.items: object expected");
                    message.items[i] = $root.server.GroupFeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.GroupFeedItems} message GroupFeedItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.gid = "";
                object.name = "";
                object.avatarId = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.GroupFeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupFeedItems to JSON.
         * @function toJSON
         * @memberof server.GroupFeedItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupFeedItems;
    })();

    server.GroupFeedHistory = (function() {

        /**
         * Properties of a GroupFeedHistory.
         * @memberof server
         * @interface IGroupFeedHistory
         * @property {string|null} [gid] GroupFeedHistory gid
         * @property {string|null} [id] GroupFeedHistory id
         * @property {Uint8Array|null} [payload] GroupFeedHistory payload
         * @property {Uint8Array|null} [encPayload] GroupFeedHistory encPayload
         * @property {Uint8Array|null} [publicKey] GroupFeedHistory publicKey
         * @property {number|null} [oneTimePreKeyId] GroupFeedHistory oneTimePreKeyId
         * @property {string|null} [senderLogInfo] GroupFeedHistory senderLogInfo
         * @property {string|null} [senderClientVersion] GroupFeedHistory senderClientVersion
         */

        /**
         * Constructs a new GroupFeedHistory.
         * @memberof server
         * @classdesc Represents a GroupFeedHistory.
         * @implements IGroupFeedHistory
         * @constructor
         * @param {server.IGroupFeedHistory=} [properties] Properties to set
         */
        function GroupFeedHistory(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedHistory gid.
         * @member {string} gid
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.gid = "";

        /**
         * GroupFeedHistory id.
         * @member {string} id
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.id = "";

        /**
         * GroupFeedHistory payload.
         * @member {Uint8Array} payload
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.payload = $util.newBuffer([]);

        /**
         * GroupFeedHistory encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.encPayload = $util.newBuffer([]);

        /**
         * GroupFeedHistory publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.publicKey = $util.newBuffer([]);

        /**
         * GroupFeedHistory oneTimePreKeyId.
         * @member {number} oneTimePreKeyId
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.oneTimePreKeyId = 0;

        /**
         * GroupFeedHistory senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.senderLogInfo = "";

        /**
         * GroupFeedHistory senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.senderClientVersion = "";

        /**
         * Creates a new GroupFeedHistory instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory=} [properties] Properties to set
         * @returns {server.GroupFeedHistory} GroupFeedHistory instance
         */
        GroupFeedHistory.create = function create(properties) {
            return new GroupFeedHistory(properties);
        };

        /**
         * Encodes the specified GroupFeedHistory message. Does not implicitly {@link server.GroupFeedHistory.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory} message GroupFeedHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedHistory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.oneTimePreKeyId);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedHistory message, length delimited. Does not implicitly {@link server.GroupFeedHistory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory} message GroupFeedHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedHistory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedHistory message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedHistory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedHistory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    message.encPayload = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                case 6:
                    message.oneTimePreKeyId = reader.int32();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedHistory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedHistory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedHistory message.
         * @function verify
         * @memberof server.GroupFeedHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedHistory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId))
                    return "oneTimePreKeyId: integer expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a GroupFeedHistory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedHistory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         */
        GroupFeedHistory.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedHistory)
                return object;
            var message = new $root.server.GroupFeedHistory();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                message.oneTimePreKeyId = object.oneTimePreKeyId | 0;
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedHistory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.GroupFeedHistory} message GroupFeedHistory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedHistory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.oneTimePreKeyId = 0;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                object.oneTimePreKeyId = message.oneTimePreKeyId;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this GroupFeedHistory to JSON.
         * @function toJSON
         * @memberof server.GroupFeedHistory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedHistory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupFeedHistory;
    })();

    server.GroupMember = (function() {

        /**
         * Properties of a GroupMember.
         * @memberof server
         * @interface IGroupMember
         * @property {server.GroupMember.Action|null} [action] GroupMember action
         * @property {number|Long|null} [uid] GroupMember uid
         * @property {server.GroupMember.Type|null} [type] GroupMember type
         * @property {string|null} [name] GroupMember name
         * @property {string|null} [avatarId] GroupMember avatarId
         * @property {string|null} [result] GroupMember result
         * @property {string|null} [reason] GroupMember reason
         * @property {Uint8Array|null} [identityKey] GroupMember identityKey
         */

        /**
         * Constructs a new GroupMember.
         * @memberof server
         * @classdesc Represents a GroupMember.
         * @implements IGroupMember
         * @constructor
         * @param {server.IGroupMember=} [properties] Properties to set
         */
        function GroupMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMember action.
         * @member {server.GroupMember.Action} action
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.action = 0;

        /**
         * GroupMember uid.
         * @member {number|Long} uid
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupMember type.
         * @member {server.GroupMember.Type} type
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.type = 0;

        /**
         * GroupMember name.
         * @member {string} name
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.name = "";

        /**
         * GroupMember avatarId.
         * @member {string} avatarId
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.avatarId = "";

        /**
         * GroupMember result.
         * @member {string} result
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.result = "";

        /**
         * GroupMember reason.
         * @member {string} reason
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.reason = "";

        /**
         * GroupMember identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.identityKey = $util.newBuffer([]);

        /**
         * Creates a new GroupMember instance using the specified properties.
         * @function create
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember=} [properties] Properties to set
         * @returns {server.GroupMember} GroupMember instance
         */
        GroupMember.create = function create(properties) {
            return new GroupMember(properties);
        };

        /**
         * Encodes the specified GroupMember message. Does not implicitly {@link server.GroupMember.verify|verify} messages.
         * @function encode
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.reason);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.identityKey);
            return writer;
        };

        /**
         * Encodes the specified GroupMember message, length delimited. Does not implicitly {@link server.GroupMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                case 6:
                    message.result = reader.string();
                    break;
                case 7:
                    message.reason = reader.string();
                    break;
                case 8:
                    message.identityKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMember message.
         * @function verify
         * @memberof server.GroupMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            return null;
        };

        /**
         * Creates a GroupMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupMember} GroupMember
         */
        GroupMember.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupMember)
                return object;
            var message = new $root.server.GroupMember();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "REMOVE":
            case 1:
                message.action = 1;
                break;
            case "PROMOTE":
            case 2:
                message.action = 2;
                break;
            case "DEMOTE":
            case 3:
                message.action = 3;
                break;
            case "LEAVE":
            case 4:
                message.action = 4;
                break;
            case "JOIN":
            case 5:
                message.action = 5;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            switch (object.type) {
            case "MEMBER":
            case 0:
                message.type = 0;
                break;
            case "ADMIN":
            case 1:
                message.type = 1;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            return message;
        };

        /**
         * Creates a plain object from a GroupMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupMember
         * @static
         * @param {server.GroupMember} message GroupMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "MEMBER" : 0;
                object.name = "";
                object.avatarId = "";
                object.result = "";
                object.reason = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupMember.Action[message.action] : message.action;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.GroupMember.Type[message.type] : message.type;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            return object;
        };

        /**
         * Converts this GroupMember to JSON.
         * @function toJSON
         * @memberof server.GroupMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupMember.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} REMOVE=1 REMOVE value
         * @property {number} PROMOTE=2 PROMOTE value
         * @property {number} DEMOTE=3 DEMOTE value
         * @property {number} LEAVE=4 LEAVE value
         * @property {number} JOIN=5 JOIN value
         */
        GroupMember.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "REMOVE"] = 1;
            values[valuesById[2] = "PROMOTE"] = 2;
            values[valuesById[3] = "DEMOTE"] = 3;
            values[valuesById[4] = "LEAVE"] = 4;
            values[valuesById[5] = "JOIN"] = 5;
            return values;
        })();

        /**
         * Type enum.
         * @name server.GroupMember.Type
         * @enum {number}
         * @property {number} MEMBER=0 MEMBER value
         * @property {number} ADMIN=1 ADMIN value
         */
        GroupMember.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MEMBER"] = 0;
            values[valuesById[1] = "ADMIN"] = 1;
            return values;
        })();

        return GroupMember;
    })();

    server.GroupStanza = (function() {

        /**
         * Properties of a GroupStanza.
         * @memberof server
         * @interface IGroupStanza
         * @property {server.GroupStanza.Action|null} [action] GroupStanza action
         * @property {string|null} [gid] GroupStanza gid
         * @property {string|null} [name] GroupStanza name
         * @property {string|null} [avatarId] GroupStanza avatarId
         * @property {number|Long|null} [senderUid] GroupStanza senderUid
         * @property {string|null} [senderName] GroupStanza senderName
         * @property {Array.<server.IGroupMember>|null} [members] GroupStanza members
         * @property {string|null} [background] GroupStanza background
         * @property {Uint8Array|null} [audienceHash] GroupStanza audienceHash
         * @property {string|null} [description] GroupStanza description
         * @property {server.IHistoryResend|null} [historyResend] GroupStanza historyResend
         * @property {server.IExpiryInfo|null} [expiryInfo] GroupStanza expiryInfo
         * @property {server.GroupStanza.GroupType|null} [groupType] GroupStanza groupType
         * @property {number|Long|null} [maxGroupSize] GroupStanza maxGroupSize
         */

        /**
         * Constructs a new GroupStanza.
         * @memberof server
         * @classdesc Represents a GroupStanza.
         * @implements IGroupStanza
         * @constructor
         * @param {server.IGroupStanza=} [properties] Properties to set
         */
        function GroupStanza(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupStanza action.
         * @member {server.GroupStanza.Action} action
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.action = 0;

        /**
         * GroupStanza gid.
         * @member {string} gid
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.gid = "";

        /**
         * GroupStanza name.
         * @member {string} name
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.name = "";

        /**
         * GroupStanza avatarId.
         * @member {string} avatarId
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.avatarId = "";

        /**
         * GroupStanza senderUid.
         * @member {number|Long} senderUid
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.senderUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupStanza senderName.
         * @member {string} senderName
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.senderName = "";

        /**
         * GroupStanza members.
         * @member {Array.<server.IGroupMember>} members
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.members = $util.emptyArray;

        /**
         * GroupStanza background.
         * @member {string} background
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.background = "";

        /**
         * GroupStanza audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.audienceHash = $util.newBuffer([]);

        /**
         * GroupStanza description.
         * @member {string} description
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.description = "";

        /**
         * GroupStanza historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.historyResend = null;

        /**
         * GroupStanza expiryInfo.
         * @member {server.IExpiryInfo|null|undefined} expiryInfo
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.expiryInfo = null;

        /**
         * GroupStanza groupType.
         * @member {server.GroupStanza.GroupType} groupType
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.groupType = 0;

        /**
         * GroupStanza maxGroupSize.
         * @member {number|Long} maxGroupSize
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.maxGroupSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GroupStanza instance using the specified properties.
         * @function create
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza=} [properties] Properties to set
         * @returns {server.GroupStanza} GroupStanza instance
         */
        GroupStanza.create = function create(properties) {
            return new GroupStanza(properties);
        };

        /**
         * Encodes the specified GroupStanza message. Does not implicitly {@link server.GroupStanza.verify|verify} messages.
         * @function encode
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza} message GroupStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.senderUid != null && Object.hasOwnProperty.call(message, "senderUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.senderUid);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderName);
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.server.GroupMember.encode(message.members[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.background);
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.audienceHash);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.description);
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.expiryInfo != null && Object.hasOwnProperty.call(message, "expiryInfo"))
                $root.server.ExpiryInfo.encode(message.expiryInfo, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.groupType != null && Object.hasOwnProperty.call(message, "groupType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.groupType);
            if (message.maxGroupSize != null && Object.hasOwnProperty.call(message, "maxGroupSize"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.maxGroupSize);
            return writer;
        };

        /**
         * Encodes the specified GroupStanza message, length delimited. Does not implicitly {@link server.GroupStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza} message GroupStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupStanza} GroupStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.senderUid = reader.int64();
                    break;
                case 6:
                    message.senderName = reader.string();
                    break;
                case 7:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.server.GroupMember.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.background = reader.string();
                    break;
                case 9:
                    message.audienceHash = reader.bytes();
                    break;
                case 10:
                    message.description = reader.string();
                    break;
                case 11:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.expiryInfo = $root.server.ExpiryInfo.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.groupType = reader.int32();
                    break;
                case 14:
                    message.maxGroupSize = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupStanza} GroupStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupStanza message.
         * @function verify
         * @memberof server.GroupStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (!$util.isInteger(message.senderUid) && !(message.senderUid && $util.isInteger(message.senderUid.low) && $util.isInteger(message.senderUid.high)))
                    return "senderUid: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.server.GroupMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            if (message.background != null && message.hasOwnProperty("background"))
                if (!$util.isString(message.background))
                    return "background: string expected";
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                var error = $root.server.HistoryResend.verify(message.historyResend);
                if (error)
                    return "historyResend." + error;
            }
            if (message.expiryInfo != null && message.hasOwnProperty("expiryInfo")) {
                var error = $root.server.ExpiryInfo.verify(message.expiryInfo);
                if (error)
                    return "expiryInfo." + error;
            }
            if (message.groupType != null && message.hasOwnProperty("groupType"))
                switch (message.groupType) {
                default:
                    return "groupType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.maxGroupSize != null && message.hasOwnProperty("maxGroupSize"))
                if (!$util.isInteger(message.maxGroupSize) && !(message.maxGroupSize && $util.isInteger(message.maxGroupSize.low) && $util.isInteger(message.maxGroupSize.high)))
                    return "maxGroupSize: integer|Long expected";
            return null;
        };

        /**
         * Creates a GroupStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupStanza} GroupStanza
         */
        GroupStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupStanza)
                return object;
            var message = new $root.server.GroupStanza();
            switch (object.action) {
            case "SET":
            case 0:
                message.action = 0;
                break;
            case "GET":
            case 1:
                message.action = 1;
                break;
            case "CREATE":
            case 2:
                message.action = 2;
                break;
            case "DELETE":
            case 3:
                message.action = 3;
                break;
            case "LEAVE":
            case 4:
                message.action = 4;
                break;
            case "CHANGE_AVATAR":
            case 5:
                message.action = 5;
                break;
            case "CHANGE_NAME":
            case 6:
                message.action = 6;
                break;
            case "MODIFY_ADMINS":
            case 7:
                message.action = 7;
                break;
            case "MODIFY_MEMBERS":
            case 8:
                message.action = 8;
                break;
            case "AUTO_PROMOTE_ADMINS":
            case 9:
                message.action = 9;
                break;
            case "SET_NAME":
            case 10:
                message.action = 10;
                break;
            case "JOIN":
            case 11:
                message.action = 11;
                break;
            case "PREVIEW":
            case 12:
                message.action = 12;
                break;
            case "SET_BACKGROUND":
            case 13:
                message.action = 13;
                break;
            case "GET_MEMBER_IDENTITY_KEYS":
            case 14:
                message.action = 14;
                break;
            case "CHANGE_DESCRIPTION":
            case 15:
                message.action = 15;
                break;
            case "SHARE_HISTORY":
            case 16:
                message.action = 16;
                break;
            case "CHANGE_EXPIRY":
            case 17:
                message.action = 17;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.senderUid != null)
                if ($util.Long)
                    (message.senderUid = $util.Long.fromValue(object.senderUid)).unsigned = false;
                else if (typeof object.senderUid === "string")
                    message.senderUid = parseInt(object.senderUid, 10);
                else if (typeof object.senderUid === "number")
                    message.senderUid = object.senderUid;
                else if (typeof object.senderUid === "object")
                    message.senderUid = new $util.LongBits(object.senderUid.low >>> 0, object.senderUid.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".server.GroupStanza.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".server.GroupStanza.members: object expected");
                    message.members[i] = $root.server.GroupMember.fromObject(object.members[i]);
                }
            }
            if (object.background != null)
                message.background = String(object.background);
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.description != null)
                message.description = String(object.description);
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.GroupStanza.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            if (object.expiryInfo != null) {
                if (typeof object.expiryInfo !== "object")
                    throw TypeError(".server.GroupStanza.expiryInfo: object expected");
                message.expiryInfo = $root.server.ExpiryInfo.fromObject(object.expiryInfo);
            }
            switch (object.groupType) {
            case "FEED":
            case 0:
                message.groupType = 0;
                break;
            case "CHAT":
            case 1:
                message.groupType = 1;
                break;
            }
            if (object.maxGroupSize != null)
                if ($util.Long)
                    (message.maxGroupSize = $util.Long.fromValue(object.maxGroupSize)).unsigned = false;
                else if (typeof object.maxGroupSize === "string")
                    message.maxGroupSize = parseInt(object.maxGroupSize, 10);
                else if (typeof object.maxGroupSize === "number")
                    message.maxGroupSize = object.maxGroupSize;
                else if (typeof object.maxGroupSize === "object")
                    message.maxGroupSize = new $util.LongBits(object.maxGroupSize.low >>> 0, object.maxGroupSize.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GroupStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupStanza
         * @static
         * @param {server.GroupStanza} message GroupStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                object.action = options.enums === String ? "SET" : 0;
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderUid = options.longs === String ? "0" : 0;
                object.senderName = "";
                object.background = "";
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.description = "";
                object.historyResend = null;
                object.expiryInfo = null;
                object.groupType = options.enums === String ? "FEED" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.maxGroupSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxGroupSize = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupStanza.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (typeof message.senderUid === "number")
                    object.senderUid = options.longs === String ? String(message.senderUid) : message.senderUid;
                else
                    object.senderUid = options.longs === String ? $util.Long.prototype.toString.call(message.senderUid) : options.longs === Number ? new $util.LongBits(message.senderUid.low >>> 0, message.senderUid.high >>> 0).toNumber() : message.senderUid;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.server.GroupMember.toObject(message.members[j], options);
            }
            if (message.background != null && message.hasOwnProperty("background"))
                object.background = message.background;
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.historyResend != null && message.hasOwnProperty("historyResend"))
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
            if (message.expiryInfo != null && message.hasOwnProperty("expiryInfo"))
                object.expiryInfo = $root.server.ExpiryInfo.toObject(message.expiryInfo, options);
            if (message.groupType != null && message.hasOwnProperty("groupType"))
                object.groupType = options.enums === String ? $root.server.GroupStanza.GroupType[message.groupType] : message.groupType;
            if (message.maxGroupSize != null && message.hasOwnProperty("maxGroupSize"))
                if (typeof message.maxGroupSize === "number")
                    object.maxGroupSize = options.longs === String ? String(message.maxGroupSize) : message.maxGroupSize;
                else
                    object.maxGroupSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxGroupSize) : options.longs === Number ? new $util.LongBits(message.maxGroupSize.low >>> 0, message.maxGroupSize.high >>> 0).toNumber() : message.maxGroupSize;
            return object;
        };

        /**
         * Converts this GroupStanza to JSON.
         * @function toJSON
         * @memberof server.GroupStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupStanza.Action
         * @enum {number}
         * @property {number} SET=0 SET value
         * @property {number} GET=1 GET value
         * @property {number} CREATE=2 CREATE value
         * @property {number} DELETE=3 DELETE value
         * @property {number} LEAVE=4 LEAVE value
         * @property {number} CHANGE_AVATAR=5 CHANGE_AVATAR value
         * @property {number} CHANGE_NAME=6 CHANGE_NAME value
         * @property {number} MODIFY_ADMINS=7 MODIFY_ADMINS value
         * @property {number} MODIFY_MEMBERS=8 MODIFY_MEMBERS value
         * @property {number} AUTO_PROMOTE_ADMINS=9 AUTO_PROMOTE_ADMINS value
         * @property {number} SET_NAME=10 SET_NAME value
         * @property {number} JOIN=11 JOIN value
         * @property {number} PREVIEW=12 PREVIEW value
         * @property {number} SET_BACKGROUND=13 SET_BACKGROUND value
         * @property {number} GET_MEMBER_IDENTITY_KEYS=14 GET_MEMBER_IDENTITY_KEYS value
         * @property {number} CHANGE_DESCRIPTION=15 CHANGE_DESCRIPTION value
         * @property {number} SHARE_HISTORY=16 SHARE_HISTORY value
         * @property {number} CHANGE_EXPIRY=17 CHANGE_EXPIRY value
         */
        GroupStanza.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SET"] = 0;
            values[valuesById[1] = "GET"] = 1;
            values[valuesById[2] = "CREATE"] = 2;
            values[valuesById[3] = "DELETE"] = 3;
            values[valuesById[4] = "LEAVE"] = 4;
            values[valuesById[5] = "CHANGE_AVATAR"] = 5;
            values[valuesById[6] = "CHANGE_NAME"] = 6;
            values[valuesById[7] = "MODIFY_ADMINS"] = 7;
            values[valuesById[8] = "MODIFY_MEMBERS"] = 8;
            values[valuesById[9] = "AUTO_PROMOTE_ADMINS"] = 9;
            values[valuesById[10] = "SET_NAME"] = 10;
            values[valuesById[11] = "JOIN"] = 11;
            values[valuesById[12] = "PREVIEW"] = 12;
            values[valuesById[13] = "SET_BACKGROUND"] = 13;
            values[valuesById[14] = "GET_MEMBER_IDENTITY_KEYS"] = 14;
            values[valuesById[15] = "CHANGE_DESCRIPTION"] = 15;
            values[valuesById[16] = "SHARE_HISTORY"] = 16;
            values[valuesById[17] = "CHANGE_EXPIRY"] = 17;
            return values;
        })();

        /**
         * GroupType enum.
         * @name server.GroupStanza.GroupType
         * @enum {number}
         * @property {number} FEED=0 FEED value
         * @property {number} CHAT=1 CHAT value
         */
        GroupStanza.GroupType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FEED"] = 0;
            values[valuesById[1] = "CHAT"] = 1;
            return values;
        })();

        return GroupStanza;
    })();

    server.ExpiryInfo = (function() {

        /**
         * Properties of an ExpiryInfo.
         * @memberof server
         * @interface IExpiryInfo
         * @property {server.ExpiryInfo.ExpiryType|null} [expiryType] ExpiryInfo expiryType
         * @property {number|Long|null} [expiresInSeconds] ExpiryInfo expiresInSeconds
         * @property {number|Long|null} [expiryTimestamp] ExpiryInfo expiryTimestamp
         */

        /**
         * Constructs a new ExpiryInfo.
         * @memberof server
         * @classdesc Represents an ExpiryInfo.
         * @implements IExpiryInfo
         * @constructor
         * @param {server.IExpiryInfo=} [properties] Properties to set
         */
        function ExpiryInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExpiryInfo expiryType.
         * @member {server.ExpiryInfo.ExpiryType} expiryType
         * @memberof server.ExpiryInfo
         * @instance
         */
        ExpiryInfo.prototype.expiryType = 0;

        /**
         * ExpiryInfo expiresInSeconds.
         * @member {number|Long} expiresInSeconds
         * @memberof server.ExpiryInfo
         * @instance
         */
        ExpiryInfo.prototype.expiresInSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExpiryInfo expiryTimestamp.
         * @member {number|Long} expiryTimestamp
         * @memberof server.ExpiryInfo
         * @instance
         */
        ExpiryInfo.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExpiryInfo instance using the specified properties.
         * @function create
         * @memberof server.ExpiryInfo
         * @static
         * @param {server.IExpiryInfo=} [properties] Properties to set
         * @returns {server.ExpiryInfo} ExpiryInfo instance
         */
        ExpiryInfo.create = function create(properties) {
            return new ExpiryInfo(properties);
        };

        /**
         * Encodes the specified ExpiryInfo message. Does not implicitly {@link server.ExpiryInfo.verify|verify} messages.
         * @function encode
         * @memberof server.ExpiryInfo
         * @static
         * @param {server.IExpiryInfo} message ExpiryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpiryInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.expiryType != null && Object.hasOwnProperty.call(message, "expiryType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.expiryType);
            if (message.expiresInSeconds != null && Object.hasOwnProperty.call(message, "expiresInSeconds"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.expiresInSeconds);
            if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.expiryTimestamp);
            return writer;
        };

        /**
         * Encodes the specified ExpiryInfo message, length delimited. Does not implicitly {@link server.ExpiryInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExpiryInfo
         * @static
         * @param {server.IExpiryInfo} message ExpiryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExpiryInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExpiryInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExpiryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExpiryInfo} ExpiryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpiryInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExpiryInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 12:
                    message.expiryType = reader.int32();
                    break;
                case 13:
                    message.expiresInSeconds = reader.int64();
                    break;
                case 14:
                    message.expiryTimestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExpiryInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExpiryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExpiryInfo} ExpiryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExpiryInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExpiryInfo message.
         * @function verify
         * @memberof server.ExpiryInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExpiryInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.expiryType != null && message.hasOwnProperty("expiryType"))
                switch (message.expiryType) {
                default:
                    return "expiryType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (!$util.isInteger(message.expiresInSeconds) && !(message.expiresInSeconds && $util.isInteger(message.expiresInSeconds.low) && $util.isInteger(message.expiresInSeconds.high)))
                    return "expiresInSeconds: integer|Long expected";
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                    return "expiryTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExpiryInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExpiryInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExpiryInfo} ExpiryInfo
         */
        ExpiryInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExpiryInfo)
                return object;
            var message = new $root.server.ExpiryInfo();
            switch (object.expiryType) {
            case "EXPIRES_IN_SECONDS":
            case 0:
                message.expiryType = 0;
                break;
            case "NEVER":
            case 1:
                message.expiryType = 1;
                break;
            case "CUSTOM_DATE":
            case 2:
                message.expiryType = 2;
                break;
            }
            if (object.expiresInSeconds != null)
                if ($util.Long)
                    (message.expiresInSeconds = $util.Long.fromValue(object.expiresInSeconds)).unsigned = false;
                else if (typeof object.expiresInSeconds === "string")
                    message.expiresInSeconds = parseInt(object.expiresInSeconds, 10);
                else if (typeof object.expiresInSeconds === "number")
                    message.expiresInSeconds = object.expiresInSeconds;
                else if (typeof object.expiresInSeconds === "object")
                    message.expiresInSeconds = new $util.LongBits(object.expiresInSeconds.low >>> 0, object.expiresInSeconds.high >>> 0).toNumber();
            if (object.expiryTimestamp != null)
                if ($util.Long)
                    (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = false;
                else if (typeof object.expiryTimestamp === "string")
                    message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                else if (typeof object.expiryTimestamp === "number")
                    message.expiryTimestamp = object.expiryTimestamp;
                else if (typeof object.expiryTimestamp === "object")
                    message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExpiryInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExpiryInfo
         * @static
         * @param {server.ExpiryInfo} message ExpiryInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExpiryInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.expiryType = options.enums === String ? "EXPIRES_IN_SECONDS" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiresInSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresInSeconds = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiryTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.expiryType != null && message.hasOwnProperty("expiryType"))
                object.expiryType = options.enums === String ? $root.server.ExpiryInfo.ExpiryType[message.expiryType] : message.expiryType;
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (typeof message.expiresInSeconds === "number")
                    object.expiresInSeconds = options.longs === String ? String(message.expiresInSeconds) : message.expiresInSeconds;
                else
                    object.expiresInSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.expiresInSeconds) : options.longs === Number ? new $util.LongBits(message.expiresInSeconds.low >>> 0, message.expiresInSeconds.high >>> 0).toNumber() : message.expiresInSeconds;
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (typeof message.expiryTimestamp === "number")
                    object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                else
                    object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber() : message.expiryTimestamp;
            return object;
        };

        /**
         * Converts this ExpiryInfo to JSON.
         * @function toJSON
         * @memberof server.ExpiryInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExpiryInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ExpiryType enum.
         * @name server.ExpiryInfo.ExpiryType
         * @enum {number}
         * @property {number} EXPIRES_IN_SECONDS=0 EXPIRES_IN_SECONDS value
         * @property {number} NEVER=1 NEVER value
         * @property {number} CUSTOM_DATE=2 CUSTOM_DATE value
         */
        ExpiryInfo.ExpiryType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EXPIRES_IN_SECONDS"] = 0;
            values[valuesById[1] = "NEVER"] = 1;
            values[valuesById[2] = "CUSTOM_DATE"] = 2;
            return values;
        })();

        return ExpiryInfo;
    })();

    server.GroupChat = (function() {

        /**
         * Properties of a GroupChat.
         * @memberof server
         * @interface IGroupChat
         * @property {string|null} [gid] GroupChat gid
         * @property {string|null} [name] GroupChat name
         * @property {string|null} [avatarId] GroupChat avatarId
         * @property {number|Long|null} [senderUid] GroupChat senderUid
         * @property {string|null} [senderName] GroupChat senderName
         * @property {number|Long|null} [timestamp] GroupChat timestamp
         * @property {Uint8Array|null} [payload] GroupChat payload
         */

        /**
         * Constructs a new GroupChat.
         * @memberof server
         * @classdesc Represents a GroupChat.
         * @implements IGroupChat
         * @constructor
         * @param {server.IGroupChat=} [properties] Properties to set
         */
        function GroupChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChat gid.
         * @member {string} gid
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.gid = "";

        /**
         * GroupChat name.
         * @member {string} name
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.name = "";

        /**
         * GroupChat avatarId.
         * @member {string} avatarId
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.avatarId = "";

        /**
         * GroupChat senderUid.
         * @member {number|Long} senderUid
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.senderUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupChat senderName.
         * @member {string} senderName
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.senderName = "";

        /**
         * GroupChat timestamp.
         * @member {number|Long} timestamp
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupChat payload.
         * @member {Uint8Array} payload
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new GroupChat instance using the specified properties.
         * @function create
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat=} [properties] Properties to set
         * @returns {server.GroupChat} GroupChat instance
         */
        GroupChat.create = function create(properties) {
            return new GroupChat(properties);
        };

        /**
         * Encodes the specified GroupChat message. Does not implicitly {@link server.GroupChat.verify|verify} messages.
         * @function encode
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat} message GroupChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            if (message.senderUid != null && Object.hasOwnProperty.call(message, "senderUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.senderUid);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.senderName);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified GroupChat message, length delimited. Does not implicitly {@link server.GroupChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat} message GroupChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChat message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupChat} GroupChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                case 4:
                    message.senderUid = reader.int64();
                    break;
                case 5:
                    message.senderName = reader.string();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupChat} GroupChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupChat message.
         * @function verify
         * @memberof server.GroupChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (!$util.isInteger(message.senderUid) && !(message.senderUid && $util.isInteger(message.senderUid.low) && $util.isInteger(message.senderUid.high)))
                    return "senderUid: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a GroupChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupChat} GroupChat
         */
        GroupChat.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupChat)
                return object;
            var message = new $root.server.GroupChat();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.senderUid != null)
                if ($util.Long)
                    (message.senderUid = $util.Long.fromValue(object.senderUid)).unsigned = false;
                else if (typeof object.senderUid === "string")
                    message.senderUid = parseInt(object.senderUid, 10);
                else if (typeof object.senderUid === "number")
                    message.senderUid = object.senderUid;
                else if (typeof object.senderUid === "object")
                    message.senderUid = new $util.LongBits(object.senderUid.low >>> 0, object.senderUid.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a GroupChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupChat
         * @static
         * @param {server.GroupChat} message GroupChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderUid = options.longs === String ? "0" : 0;
                object.senderName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (typeof message.senderUid === "number")
                    object.senderUid = options.longs === String ? String(message.senderUid) : message.senderUid;
                else
                    object.senderUid = options.longs === String ? $util.Long.prototype.toString.call(message.senderUid) : options.longs === Number ? new $util.LongBits(message.senderUid.low >>> 0, message.senderUid.high >>> 0).toNumber() : message.senderUid;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this GroupChat to JSON.
         * @function toJSON
         * @memberof server.GroupChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupChat;
    })();

    server.GroupChatStanza = (function() {

        /**
         * Properties of a GroupChatStanza.
         * @memberof server
         * @interface IGroupChatStanza
         * @property {string|null} [gid] GroupChatStanza gid
         * @property {string|null} [name] GroupChatStanza name
         * @property {string|null} [avatarId] GroupChatStanza avatarId
         * @property {string|null} [senderPhone] GroupChatStanza senderPhone
         * @property {string|null} [senderName] GroupChatStanza senderName
         * @property {number|Long|null} [timestamp] GroupChatStanza timestamp
         * @property {Uint8Array|null} [payload] GroupChatStanza payload
         * @property {Uint8Array|null} [encPayload] GroupChatStanza encPayload
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] GroupChatStanza senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] GroupChatStanza senderState
         * @property {Uint8Array|null} [audienceHash] GroupChatStanza audienceHash
         * @property {server.IMediaCounters|null} [mediaCounters] GroupChatStanza mediaCounters
         * @property {server.GroupChatStanza.ChatType|null} [chatType] GroupChatStanza chatType
         * @property {string|null} [senderLogInfo] GroupChatStanza senderLogInfo
         * @property {string|null} [senderClientVersion] GroupChatStanza senderClientVersion
         */

        /**
         * Constructs a new GroupChatStanza.
         * @memberof server
         * @classdesc Represents a GroupChatStanza.
         * @implements IGroupChatStanza
         * @constructor
         * @param {server.IGroupChatStanza=} [properties] Properties to set
         */
        function GroupChatStanza(properties) {
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChatStanza gid.
         * @member {string} gid
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.gid = "";

        /**
         * GroupChatStanza name.
         * @member {string} name
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.name = "";

        /**
         * GroupChatStanza avatarId.
         * @member {string} avatarId
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.avatarId = "";

        /**
         * GroupChatStanza senderPhone.
         * @member {string} senderPhone
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderPhone = "";

        /**
         * GroupChatStanza senderName.
         * @member {string} senderName
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderName = "";

        /**
         * GroupChatStanza timestamp.
         * @member {number|Long} timestamp
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupChatStanza payload.
         * @member {Uint8Array} payload
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.payload = $util.newBuffer([]);

        /**
         * GroupChatStanza encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.encPayload = $util.newBuffer([]);

        /**
         * GroupChatStanza senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderStateBundles = $util.emptyArray;

        /**
         * GroupChatStanza senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderState = null;

        /**
         * GroupChatStanza audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.audienceHash = $util.newBuffer([]);

        /**
         * GroupChatStanza mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.mediaCounters = null;

        /**
         * GroupChatStanza chatType.
         * @member {server.GroupChatStanza.ChatType} chatType
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.chatType = 0;

        /**
         * GroupChatStanza senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderLogInfo = "";

        /**
         * GroupChatStanza senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.GroupChatStanza
         * @instance
         */
        GroupChatStanza.prototype.senderClientVersion = "";

        /**
         * Creates a new GroupChatStanza instance using the specified properties.
         * @function create
         * @memberof server.GroupChatStanza
         * @static
         * @param {server.IGroupChatStanza=} [properties] Properties to set
         * @returns {server.GroupChatStanza} GroupChatStanza instance
         */
        GroupChatStanza.create = function create(properties) {
            return new GroupChatStanza(properties);
        };

        /**
         * Encodes the specified GroupChatStanza message. Does not implicitly {@link server.GroupChatStanza.verify|verify} messages.
         * @function encode
         * @memberof server.GroupChatStanza
         * @static
         * @param {server.IGroupChatStanza} message GroupChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            if (message.senderPhone != null && Object.hasOwnProperty.call(message, "senderPhone"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.senderPhone);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.senderName);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encPayload);
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.audienceHash);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.chatType != null && Object.hasOwnProperty.call(message, "chatType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.chatType);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified GroupChatStanza message, length delimited. Does not implicitly {@link server.GroupChatStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupChatStanza
         * @static
         * @param {server.IGroupChatStanza} message GroupChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChatStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupChatStanza} GroupChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupChatStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                case 4:
                    message.senderPhone = reader.string();
                    break;
                case 5:
                    message.senderName = reader.string();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                case 8:
                    message.encPayload = reader.bytes();
                    break;
                case 9:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.audienceHash = reader.bytes();
                    break;
                case 12:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.chatType = reader.int32();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChatStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupChatStanza} GroupChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupChatStanza message.
         * @function verify
         * @memberof server.GroupChatStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupChatStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                if (!$util.isString(message.senderPhone))
                    return "senderPhone: string expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            if (message.chatType != null && message.hasOwnProperty("chatType"))
                switch (message.chatType) {
                default:
                    return "chatType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a GroupChatStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupChatStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupChatStanza} GroupChatStanza
         */
        GroupChatStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupChatStanza)
                return object;
            var message = new $root.server.GroupChatStanza();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.senderPhone != null)
                message.senderPhone = String(object.senderPhone);
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.GroupChatStanza.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.GroupChatStanza.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.GroupChatStanza.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.GroupChatStanza.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            switch (object.chatType) {
            case "CHAT":
            case 0:
                message.chatType = 0;
                break;
            case "CHAT_REACTION":
            case 1:
                message.chatType = 1;
                break;
            }
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a GroupChatStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupChatStanza
         * @static
         * @param {server.GroupChatStanza} message GroupChatStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChatStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderStateBundles = [];
            if (options.defaults) {
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                object.senderPhone = "";
                object.senderName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.senderState = null;
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.mediaCounters = null;
                object.chatType = options.enums === String ? "CHAT" : 0;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                object.senderPhone = message.senderPhone;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            if (message.chatType != null && message.hasOwnProperty("chatType"))
                object.chatType = options.enums === String ? $root.server.GroupChatStanza.ChatType[message.chatType] : message.chatType;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this GroupChatStanza to JSON.
         * @function toJSON
         * @memberof server.GroupChatStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChatStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ChatType enum.
         * @name server.GroupChatStanza.ChatType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} CHAT_REACTION=1 CHAT_REACTION value
         */
        GroupChatStanza.ChatType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "CHAT_REACTION"] = 1;
            return values;
        })();

        return GroupChatStanza;
    })();

    server.GroupsStanza = (function() {

        /**
         * Properties of a GroupsStanza.
         * @memberof server
         * @interface IGroupsStanza
         * @property {server.GroupsStanza.Action|null} [action] GroupsStanza action
         * @property {Array.<server.IGroupStanza>|null} [groupStanzas] GroupsStanza groupStanzas
         */

        /**
         * Constructs a new GroupsStanza.
         * @memberof server
         * @classdesc Represents a GroupsStanza.
         * @implements IGroupsStanza
         * @constructor
         * @param {server.IGroupsStanza=} [properties] Properties to set
         */
        function GroupsStanza(properties) {
            this.groupStanzas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupsStanza action.
         * @member {server.GroupsStanza.Action} action
         * @memberof server.GroupsStanza
         * @instance
         */
        GroupsStanza.prototype.action = 0;

        /**
         * GroupsStanza groupStanzas.
         * @member {Array.<server.IGroupStanza>} groupStanzas
         * @memberof server.GroupsStanza
         * @instance
         */
        GroupsStanza.prototype.groupStanzas = $util.emptyArray;

        /**
         * Creates a new GroupsStanza instance using the specified properties.
         * @function create
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza=} [properties] Properties to set
         * @returns {server.GroupsStanza} GroupsStanza instance
         */
        GroupsStanza.create = function create(properties) {
            return new GroupsStanza(properties);
        };

        /**
         * Encodes the specified GroupsStanza message. Does not implicitly {@link server.GroupsStanza.verify|verify} messages.
         * @function encode
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza} message GroupsStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupsStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.groupStanzas != null && message.groupStanzas.length)
                for (var i = 0; i < message.groupStanzas.length; ++i)
                    $root.server.GroupStanza.encode(message.groupStanzas[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupsStanza message, length delimited. Does not implicitly {@link server.GroupsStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza} message GroupsStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupsStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupsStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupsStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupsStanza} GroupsStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupsStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupsStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    if (!(message.groupStanzas && message.groupStanzas.length))
                        message.groupStanzas = [];
                    message.groupStanzas.push($root.server.GroupStanza.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupsStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupsStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupsStanza} GroupsStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupsStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupsStanza message.
         * @function verify
         * @memberof server.GroupsStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupsStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                    break;
                }
            if (message.groupStanzas != null && message.hasOwnProperty("groupStanzas")) {
                if (!Array.isArray(message.groupStanzas))
                    return "groupStanzas: array expected";
                for (var i = 0; i < message.groupStanzas.length; ++i) {
                    var error = $root.server.GroupStanza.verify(message.groupStanzas[i]);
                    if (error)
                        return "groupStanzas." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupsStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupsStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupsStanza} GroupsStanza
         */
        GroupsStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupsStanza)
                return object;
            var message = new $root.server.GroupsStanza();
            switch (object.action) {
            case "GET":
            case 0:
                message.action = 0;
                break;
            }
            if (object.groupStanzas) {
                if (!Array.isArray(object.groupStanzas))
                    throw TypeError(".server.GroupsStanza.groupStanzas: array expected");
                message.groupStanzas = [];
                for (var i = 0; i < object.groupStanzas.length; ++i) {
                    if (typeof object.groupStanzas[i] !== "object")
                        throw TypeError(".server.GroupsStanza.groupStanzas: object expected");
                    message.groupStanzas[i] = $root.server.GroupStanza.fromObject(object.groupStanzas[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupsStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupsStanza
         * @static
         * @param {server.GroupsStanza} message GroupsStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupsStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groupStanzas = [];
            if (options.defaults)
                object.action = options.enums === String ? "GET" : 0;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupsStanza.Action[message.action] : message.action;
            if (message.groupStanzas && message.groupStanzas.length) {
                object.groupStanzas = [];
                for (var j = 0; j < message.groupStanzas.length; ++j)
                    object.groupStanzas[j] = $root.server.GroupStanza.toObject(message.groupStanzas[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupsStanza to JSON.
         * @function toJSON
         * @memberof server.GroupsStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupsStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupsStanza.Action
         * @enum {number}
         * @property {number} GET=0 GET value
         */
        GroupsStanza.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            return values;
        })();

        return GroupsStanza;
    })();

    server.GroupInviteLink = (function() {

        /**
         * Properties of a GroupInviteLink.
         * @memberof server
         * @interface IGroupInviteLink
         * @property {server.GroupInviteLink.Action|null} [action] GroupInviteLink action
         * @property {string|null} [gid] GroupInviteLink gid
         * @property {string|null} [link] GroupInviteLink link
         * @property {string|null} [result] GroupInviteLink result
         * @property {string|null} [reason] GroupInviteLink reason
         * @property {server.IGroupStanza|null} [group] GroupInviteLink group
         */

        /**
         * Constructs a new GroupInviteLink.
         * @memberof server
         * @classdesc Represents a GroupInviteLink.
         * @implements IGroupInviteLink
         * @constructor
         * @param {server.IGroupInviteLink=} [properties] Properties to set
         */
        function GroupInviteLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInviteLink action.
         * @member {server.GroupInviteLink.Action} action
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.action = 0;

        /**
         * GroupInviteLink gid.
         * @member {string} gid
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.gid = "";

        /**
         * GroupInviteLink link.
         * @member {string} link
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.link = "";

        /**
         * GroupInviteLink result.
         * @member {string} result
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.result = "";

        /**
         * GroupInviteLink reason.
         * @member {string} reason
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.reason = "";

        /**
         * GroupInviteLink group.
         * @member {server.IGroupStanza|null|undefined} group
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.group = null;

        /**
         * Creates a new GroupInviteLink instance using the specified properties.
         * @function create
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink=} [properties] Properties to set
         * @returns {server.GroupInviteLink} GroupInviteLink instance
         */
        GroupInviteLink.create = function create(properties) {
            return new GroupInviteLink(properties);
        };

        /**
         * Encodes the specified GroupInviteLink message. Does not implicitly {@link server.GroupInviteLink.verify|verify} messages.
         * @function encode
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.link != null && Object.hasOwnProperty.call(message, "link"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.link);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.reason);
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                $root.server.GroupStanza.encode(message.group, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupInviteLink message, length delimited. Does not implicitly {@link server.GroupInviteLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupInviteLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.link = reader.string();
                    break;
                case 4:
                    message.result = reader.string();
                    break;
                case 5:
                    message.reason = reader.string();
                    break;
                case 6:
                    message.group = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInviteLink message.
         * @function verify
         * @memberof server.GroupInviteLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInviteLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.link != null && message.hasOwnProperty("link"))
                if (!$util.isString(message.link))
                    return "link: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.group != null && message.hasOwnProperty("group")) {
                var error = $root.server.GroupStanza.verify(message.group);
                if (error)
                    return "group." + error;
            }
            return null;
        };

        /**
         * Creates a GroupInviteLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupInviteLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupInviteLink} GroupInviteLink
         */
        GroupInviteLink.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupInviteLink)
                return object;
            var message = new $root.server.GroupInviteLink();
            switch (object.action) {
            case "UNKNOWN":
            case 0:
                message.action = 0;
                break;
            case "GET":
            case 1:
                message.action = 1;
                break;
            case "RESET":
            case 2:
                message.action = 2;
                break;
            case "JOIN":
            case 3:
                message.action = 3;
                break;
            case "PREVIEW":
            case 4:
                message.action = 4;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.link != null)
                message.link = String(object.link);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".server.GroupInviteLink.group: object expected");
                message.group = $root.server.GroupStanza.fromObject(object.group);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInviteLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.GroupInviteLink} message GroupInviteLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInviteLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "UNKNOWN" : 0;
                object.gid = "";
                object.link = "";
                object.result = "";
                object.reason = "";
                object.group = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupInviteLink.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.link != null && message.hasOwnProperty("link"))
                object.link = message.link;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.server.GroupStanza.toObject(message.group, options);
            return object;
        };

        /**
         * Converts this GroupInviteLink to JSON.
         * @function toJSON
         * @memberof server.GroupInviteLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInviteLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupInviteLink.Action
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} GET=1 GET value
         * @property {number} RESET=2 RESET value
         * @property {number} JOIN=3 JOIN value
         * @property {number} PREVIEW=4 PREVIEW value
         */
        GroupInviteLink.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "GET"] = 1;
            values[valuesById[2] = "RESET"] = 2;
            values[valuesById[3] = "JOIN"] = 3;
            values[valuesById[4] = "PREVIEW"] = 4;
            return values;
        })();

        return GroupInviteLink;
    })();

    server.AuthRequest = (function() {

        /**
         * Properties of an AuthRequest.
         * @memberof server
         * @interface IAuthRequest
         * @property {number|Long|null} [uid] AuthRequest uid
         * @property {string|null} [pwd] AuthRequest pwd
         * @property {server.IClientMode|null} [clientMode] AuthRequest clientMode
         * @property {server.IClientVersion|null} [clientVersion] AuthRequest clientVersion
         * @property {string|null} [resource] AuthRequest resource
         * @property {server.IDeviceInfo|null} [deviceInfo] AuthRequest deviceInfo
         */

        /**
         * Constructs a new AuthRequest.
         * @memberof server
         * @classdesc Represents an AuthRequest.
         * @implements IAuthRequest
         * @constructor
         * @param {server.IAuthRequest=} [properties] Properties to set
         */
        function AuthRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRequest uid.
         * @member {number|Long} uid
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AuthRequest pwd.
         * @member {string} pwd
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.pwd = "";

        /**
         * AuthRequest clientMode.
         * @member {server.IClientMode|null|undefined} clientMode
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientMode = null;

        /**
         * AuthRequest clientVersion.
         * @member {server.IClientVersion|null|undefined} clientVersion
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientVersion = null;

        /**
         * AuthRequest resource.
         * @member {string} resource
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.resource = "";

        /**
         * AuthRequest deviceInfo.
         * @member {server.IDeviceInfo|null|undefined} deviceInfo
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.deviceInfo = null;

        /**
         * Creates a new AuthRequest instance using the specified properties.
         * @function create
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest=} [properties] Properties to set
         * @returns {server.AuthRequest} AuthRequest instance
         */
        AuthRequest.create = function create(properties) {
            return new AuthRequest(properties);
        };

        /**
         * Encodes the specified AuthRequest message. Does not implicitly {@link server.AuthRequest.verify|verify} messages.
         * @function encode
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.pwd != null && Object.hasOwnProperty.call(message, "pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.clientMode != null && Object.hasOwnProperty.call(message, "clientMode"))
                $root.server.ClientMode.encode(message.clientMode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
                $root.server.ClientVersion.encode(message.clientVersion, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.resource);
            if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                $root.server.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AuthRequest message, length delimited. Does not implicitly {@link server.AuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AuthRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.clientMode = $root.server.ClientMode.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clientVersion = $root.server.ClientVersion.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.resource = reader.string();
                    break;
                case 6:
                    message.deviceInfo = $root.server.DeviceInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRequest message.
         * @function verify
         * @memberof server.AuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                if (!$util.isString(message.pwd))
                    return "pwd: string expected";
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                var error = $root.server.ClientMode.verify(message.clientMode);
                if (error)
                    return "clientMode." + error;
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                var error = $root.server.ClientVersion.verify(message.clientVersion);
                if (error)
                    return "clientVersion." + error;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                if (!$util.isString(message.resource))
                    return "resource: string expected";
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                var error = $root.server.DeviceInfo.verify(message.deviceInfo);
                if (error)
                    return "deviceInfo." + error;
            }
            return null;
        };

        /**
         * Creates an AuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AuthRequest} AuthRequest
         */
        AuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AuthRequest)
                return object;
            var message = new $root.server.AuthRequest();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.pwd != null)
                message.pwd = String(object.pwd);
            if (object.clientMode != null) {
                if (typeof object.clientMode !== "object")
                    throw TypeError(".server.AuthRequest.clientMode: object expected");
                message.clientMode = $root.server.ClientMode.fromObject(object.clientMode);
            }
            if (object.clientVersion != null) {
                if (typeof object.clientVersion !== "object")
                    throw TypeError(".server.AuthRequest.clientVersion: object expected");
                message.clientVersion = $root.server.ClientVersion.fromObject(object.clientVersion);
            }
            if (object.resource != null)
                message.resource = String(object.resource);
            if (object.deviceInfo != null) {
                if (typeof object.deviceInfo !== "object")
                    throw TypeError(".server.AuthRequest.deviceInfo: object expected");
                message.deviceInfo = $root.server.DeviceInfo.fromObject(object.deviceInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an AuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AuthRequest
         * @static
         * @param {server.AuthRequest} message AuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.pwd = "";
                object.clientMode = null;
                object.clientVersion = null;
                object.resource = "";
                object.deviceInfo = null;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                object.pwd = message.pwd;
            if (message.clientMode != null && message.hasOwnProperty("clientMode"))
                object.clientMode = $root.server.ClientMode.toObject(message.clientMode, options);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = $root.server.ClientVersion.toObject(message.clientVersion, options);
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = message.resource;
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                object.deviceInfo = $root.server.DeviceInfo.toObject(message.deviceInfo, options);
            return object;
        };

        /**
         * Converts this AuthRequest to JSON.
         * @function toJSON
         * @memberof server.AuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthRequest;
    })();

    server.AuthResult = (function() {

        /**
         * Properties of an AuthResult.
         * @memberof server
         * @interface IAuthResult
         * @property {string|null} [resultString] AuthResult resultString
         * @property {string|null} [reasonString] AuthResult reasonString
         * @property {Uint8Array|null} [propsHash] AuthResult propsHash
         * @property {number|Long|null} [versionTtl] AuthResult versionTtl
         * @property {server.AuthResult.Result|null} [result] AuthResult result
         * @property {server.AuthResult.Reason|null} [reason] AuthResult reason
         */

        /**
         * Constructs a new AuthResult.
         * @memberof server
         * @classdesc Represents an AuthResult.
         * @implements IAuthResult
         * @constructor
         * @param {server.IAuthResult=} [properties] Properties to set
         */
        function AuthResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthResult resultString.
         * @member {string} resultString
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.resultString = "";

        /**
         * AuthResult reasonString.
         * @member {string} reasonString
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.reasonString = "";

        /**
         * AuthResult propsHash.
         * @member {Uint8Array} propsHash
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.propsHash = $util.newBuffer([]);

        /**
         * AuthResult versionTtl.
         * @member {number|Long} versionTtl
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.versionTtl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AuthResult result.
         * @member {server.AuthResult.Result} result
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.result = 0;

        /**
         * AuthResult reason.
         * @member {server.AuthResult.Reason} reason
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.reason = 0;

        /**
         * Creates a new AuthResult instance using the specified properties.
         * @function create
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult=} [properties] Properties to set
         * @returns {server.AuthResult} AuthResult instance
         */
        AuthResult.create = function create(properties) {
            return new AuthResult(properties);
        };

        /**
         * Encodes the specified AuthResult message. Does not implicitly {@link server.AuthResult.verify|verify} messages.
         * @function encode
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult} message AuthResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultString != null && Object.hasOwnProperty.call(message, "resultString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.resultString);
            if (message.reasonString != null && Object.hasOwnProperty.call(message, "reasonString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reasonString);
            if (message.propsHash != null && Object.hasOwnProperty.call(message, "propsHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.propsHash);
            if (message.versionTtl != null && Object.hasOwnProperty.call(message, "versionTtl"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.versionTtl);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified AuthResult message, length delimited. Does not implicitly {@link server.AuthResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult} message AuthResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.AuthResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AuthResult} AuthResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AuthResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resultString = reader.string();
                    break;
                case 2:
                    message.reasonString = reader.string();
                    break;
                case 3:
                    message.propsHash = reader.bytes();
                    break;
                case 4:
                    message.versionTtl = reader.int64();
                    break;
                case 5:
                    message.result = reader.int32();
                    break;
                case 6:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AuthResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AuthResult} AuthResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthResult message.
         * @function verify
         * @memberof server.AuthResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultString != null && message.hasOwnProperty("resultString"))
                if (!$util.isString(message.resultString))
                    return "resultString: string expected";
            if (message.reasonString != null && message.hasOwnProperty("reasonString"))
                if (!$util.isString(message.reasonString))
                    return "reasonString: string expected";
            if (message.propsHash != null && message.hasOwnProperty("propsHash"))
                if (!(message.propsHash && typeof message.propsHash.length === "number" || $util.isString(message.propsHash)))
                    return "propsHash: buffer expected";
            if (message.versionTtl != null && message.hasOwnProperty("versionTtl"))
                if (!$util.isInteger(message.versionTtl) && !(message.versionTtl && $util.isInteger(message.versionTtl.low) && $util.isInteger(message.versionTtl.high)))
                    return "versionTtl: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates an AuthResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AuthResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AuthResult} AuthResult
         */
        AuthResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AuthResult)
                return object;
            var message = new $root.server.AuthResult();
            if (object.resultString != null)
                message.resultString = String(object.resultString);
            if (object.reasonString != null)
                message.reasonString = String(object.reasonString);
            if (object.propsHash != null)
                if (typeof object.propsHash === "string")
                    $util.base64.decode(object.propsHash, message.propsHash = $util.newBuffer($util.base64.length(object.propsHash)), 0);
                else if (object.propsHash.length)
                    message.propsHash = object.propsHash;
            if (object.versionTtl != null)
                if ($util.Long)
                    (message.versionTtl = $util.Long.fromValue(object.versionTtl)).unsigned = false;
                else if (typeof object.versionTtl === "string")
                    message.versionTtl = parseInt(object.versionTtl, 10);
                else if (typeof object.versionTtl === "number")
                    message.versionTtl = object.versionTtl;
                else if (typeof object.versionTtl === "object")
                    message.versionTtl = new $util.LongBits(object.versionTtl.low >>> 0, object.versionTtl.high >>> 0).toNumber();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "OK":
            case 1:
                message.reason = 1;
                break;
            case "SPUB_MISMATCH":
            case 2:
                message.reason = 2;
                break;
            case "INVALID_CLIENT_VERSION":
            case 3:
                message.reason = 3;
                break;
            case "INVALID_RESOURCE":
            case 4:
                message.reason = 4;
                break;
            case "ACCOUNT_DELETED":
            case 5:
                message.reason = 5;
                break;
            case "INVALID_UID_OR_PASSWORD":
            case 6:
                message.reason = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AuthResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AuthResult
         * @static
         * @param {server.AuthResult} message AuthResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resultString = "";
                object.reasonString = "";
                if (options.bytes === String)
                    object.propsHash = "";
                else {
                    object.propsHash = [];
                    if (options.bytes !== Array)
                        object.propsHash = $util.newBuffer(object.propsHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.versionTtl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.versionTtl = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "UNKNOWN" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.resultString != null && message.hasOwnProperty("resultString"))
                object.resultString = message.resultString;
            if (message.reasonString != null && message.hasOwnProperty("reasonString"))
                object.reasonString = message.reasonString;
            if (message.propsHash != null && message.hasOwnProperty("propsHash"))
                object.propsHash = options.bytes === String ? $util.base64.encode(message.propsHash, 0, message.propsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.propsHash) : message.propsHash;
            if (message.versionTtl != null && message.hasOwnProperty("versionTtl"))
                if (typeof message.versionTtl === "number")
                    object.versionTtl = options.longs === String ? String(message.versionTtl) : message.versionTtl;
                else
                    object.versionTtl = options.longs === String ? $util.Long.prototype.toString.call(message.versionTtl) : options.longs === Number ? new $util.LongBits(message.versionTtl.low >>> 0, message.versionTtl.high >>> 0).toNumber() : message.versionTtl;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.AuthResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.AuthResult.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this AuthResult to JSON.
         * @function toJSON
         * @memberof server.AuthResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.AuthResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        AuthResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.AuthResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} OK=1 OK value
         * @property {number} SPUB_MISMATCH=2 SPUB_MISMATCH value
         * @property {number} INVALID_CLIENT_VERSION=3 INVALID_CLIENT_VERSION value
         * @property {number} INVALID_RESOURCE=4 INVALID_RESOURCE value
         * @property {number} ACCOUNT_DELETED=5 ACCOUNT_DELETED value
         * @property {number} INVALID_UID_OR_PASSWORD=6 INVALID_UID_OR_PASSWORD value
         */
        AuthResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "SPUB_MISMATCH"] = 2;
            values[valuesById[3] = "INVALID_CLIENT_VERSION"] = 3;
            values[valuesById[4] = "INVALID_RESOURCE"] = 4;
            values[valuesById[5] = "ACCOUNT_DELETED"] = 5;
            values[valuesById[6] = "INVALID_UID_OR_PASSWORD"] = 6;
            return values;
        })();

        return AuthResult;
    })();

    server.Invite = (function() {

        /**
         * Properties of an Invite.
         * @memberof server
         * @interface IInvite
         * @property {string|null} [phone] Invite phone
         * @property {string|null} [result] Invite result
         * @property {string|null} [reason] Invite reason
         */

        /**
         * Constructs a new Invite.
         * @memberof server
         * @classdesc Represents an Invite.
         * @implements IInvite
         * @constructor
         * @param {server.IInvite=} [properties] Properties to set
         */
        function Invite(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Invite phone.
         * @member {string} phone
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.phone = "";

        /**
         * Invite result.
         * @member {string} result
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.result = "";

        /**
         * Invite reason.
         * @member {string} reason
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.reason = "";

        /**
         * Creates a new Invite instance using the specified properties.
         * @function create
         * @memberof server.Invite
         * @static
         * @param {server.IInvite=} [properties] Properties to set
         * @returns {server.Invite} Invite instance
         */
        Invite.create = function create(properties) {
            return new Invite(properties);
        };

        /**
         * Encodes the specified Invite message. Does not implicitly {@link server.Invite.verify|verify} messages.
         * @function encode
         * @memberof server.Invite
         * @static
         * @param {server.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified Invite message, length delimited. Does not implicitly {@link server.Invite.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Invite
         * @static
         * @param {server.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invite message from the specified reader or buffer.
         * @function decode
         * @memberof server.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Invite();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.result = reader.string();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invite message.
         * @function verify
         * @memberof server.Invite
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invite.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates an Invite message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Invite
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Invite} Invite
         */
        Invite.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Invite)
                return object;
            var message = new $root.server.Invite();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from an Invite message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Invite
         * @static
         * @param {server.Invite} message Invite
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Invite.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.result = "";
                object.reason = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this Invite to JSON.
         * @function toJSON
         * @memberof server.Invite
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Invite.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Invite;
    })();

    server.InvitesRequest = (function() {

        /**
         * Properties of an InvitesRequest.
         * @memberof server
         * @interface IInvitesRequest
         * @property {Array.<server.IInvite>|null} [invites] InvitesRequest invites
         */

        /**
         * Constructs a new InvitesRequest.
         * @memberof server
         * @classdesc Represents an InvitesRequest.
         * @implements IInvitesRequest
         * @constructor
         * @param {server.IInvitesRequest=} [properties] Properties to set
         */
        function InvitesRequest(properties) {
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvitesRequest invites.
         * @member {Array.<server.IInvite>} invites
         * @memberof server.InvitesRequest
         * @instance
         */
        InvitesRequest.prototype.invites = $util.emptyArray;

        /**
         * Creates a new InvitesRequest instance using the specified properties.
         * @function create
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest=} [properties] Properties to set
         * @returns {server.InvitesRequest} InvitesRequest instance
         */
        InvitesRequest.create = function create(properties) {
            return new InvitesRequest(properties);
        };

        /**
         * Encodes the specified InvitesRequest message. Does not implicitly {@link server.InvitesRequest.verify|verify} messages.
         * @function encode
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest} message InvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    $root.server.Invite.encode(message.invites[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InvitesRequest message, length delimited. Does not implicitly {@link server.InvitesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest} message InvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvitesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.InvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InvitesRequest} InvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InvitesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invites && message.invites.length))
                        message.invites = [];
                    message.invites.push($root.server.Invite.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvitesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InvitesRequest} InvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvitesRequest message.
         * @function verify
         * @memberof server.InvitesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvitesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i) {
                    var error = $root.server.Invite.verify(message.invites[i]);
                    if (error)
                        return "invites." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InvitesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InvitesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InvitesRequest} InvitesRequest
         */
        InvitesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InvitesRequest)
                return object;
            var message = new $root.server.InvitesRequest();
            if (object.invites) {
                if (!Array.isArray(object.invites))
                    throw TypeError(".server.InvitesRequest.invites: array expected");
                message.invites = [];
                for (var i = 0; i < object.invites.length; ++i) {
                    if (typeof object.invites[i] !== "object")
                        throw TypeError(".server.InvitesRequest.invites: object expected");
                    message.invites[i] = $root.server.Invite.fromObject(object.invites[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InvitesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InvitesRequest
         * @static
         * @param {server.InvitesRequest} message InvitesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvitesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invites = [];
            if (message.invites && message.invites.length) {
                object.invites = [];
                for (var j = 0; j < message.invites.length; ++j)
                    object.invites[j] = $root.server.Invite.toObject(message.invites[j], options);
            }
            return object;
        };

        /**
         * Converts this InvitesRequest to JSON.
         * @function toJSON
         * @memberof server.InvitesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvitesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvitesRequest;
    })();

    server.InvitesResponse = (function() {

        /**
         * Properties of an InvitesResponse.
         * @memberof server
         * @interface IInvitesResponse
         * @property {number|null} [invitesLeft] InvitesResponse invitesLeft
         * @property {number|Long|null} [timeUntilRefresh] InvitesResponse timeUntilRefresh
         * @property {Array.<server.IInvite>|null} [invites] InvitesResponse invites
         */

        /**
         * Constructs a new InvitesResponse.
         * @memberof server
         * @classdesc Represents an InvitesResponse.
         * @implements IInvitesResponse
         * @constructor
         * @param {server.IInvitesResponse=} [properties] Properties to set
         */
        function InvitesResponse(properties) {
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvitesResponse invitesLeft.
         * @member {number} invitesLeft
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.invitesLeft = 0;

        /**
         * InvitesResponse timeUntilRefresh.
         * @member {number|Long} timeUntilRefresh
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.timeUntilRefresh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InvitesResponse invites.
         * @member {Array.<server.IInvite>} invites
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.invites = $util.emptyArray;

        /**
         * Creates a new InvitesResponse instance using the specified properties.
         * @function create
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse=} [properties] Properties to set
         * @returns {server.InvitesResponse} InvitesResponse instance
         */
        InvitesResponse.create = function create(properties) {
            return new InvitesResponse(properties);
        };

        /**
         * Encodes the specified InvitesResponse message. Does not implicitly {@link server.InvitesResponse.verify|verify} messages.
         * @function encode
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse} message InvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invitesLeft != null && Object.hasOwnProperty.call(message, "invitesLeft"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.invitesLeft);
            if (message.timeUntilRefresh != null && Object.hasOwnProperty.call(message, "timeUntilRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeUntilRefresh);
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    $root.server.Invite.encode(message.invites[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InvitesResponse message, length delimited. Does not implicitly {@link server.InvitesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse} message InvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvitesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.InvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InvitesResponse} InvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InvitesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.invitesLeft = reader.int32();
                    break;
                case 2:
                    message.timeUntilRefresh = reader.int64();
                    break;
                case 3:
                    if (!(message.invites && message.invites.length))
                        message.invites = [];
                    message.invites.push($root.server.Invite.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvitesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InvitesResponse} InvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvitesResponse message.
         * @function verify
         * @memberof server.InvitesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvitesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invitesLeft != null && message.hasOwnProperty("invitesLeft"))
                if (!$util.isInteger(message.invitesLeft))
                    return "invitesLeft: integer expected";
            if (message.timeUntilRefresh != null && message.hasOwnProperty("timeUntilRefresh"))
                if (!$util.isInteger(message.timeUntilRefresh) && !(message.timeUntilRefresh && $util.isInteger(message.timeUntilRefresh.low) && $util.isInteger(message.timeUntilRefresh.high)))
                    return "timeUntilRefresh: integer|Long expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i) {
                    var error = $root.server.Invite.verify(message.invites[i]);
                    if (error)
                        return "invites." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InvitesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InvitesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InvitesResponse} InvitesResponse
         */
        InvitesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InvitesResponse)
                return object;
            var message = new $root.server.InvitesResponse();
            if (object.invitesLeft != null)
                message.invitesLeft = object.invitesLeft | 0;
            if (object.timeUntilRefresh != null)
                if ($util.Long)
                    (message.timeUntilRefresh = $util.Long.fromValue(object.timeUntilRefresh)).unsigned = false;
                else if (typeof object.timeUntilRefresh === "string")
                    message.timeUntilRefresh = parseInt(object.timeUntilRefresh, 10);
                else if (typeof object.timeUntilRefresh === "number")
                    message.timeUntilRefresh = object.timeUntilRefresh;
                else if (typeof object.timeUntilRefresh === "object")
                    message.timeUntilRefresh = new $util.LongBits(object.timeUntilRefresh.low >>> 0, object.timeUntilRefresh.high >>> 0).toNumber();
            if (object.invites) {
                if (!Array.isArray(object.invites))
                    throw TypeError(".server.InvitesResponse.invites: array expected");
                message.invites = [];
                for (var i = 0; i < object.invites.length; ++i) {
                    if (typeof object.invites[i] !== "object")
                        throw TypeError(".server.InvitesResponse.invites: object expected");
                    message.invites[i] = $root.server.Invite.fromObject(object.invites[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InvitesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InvitesResponse
         * @static
         * @param {server.InvitesResponse} message InvitesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvitesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invites = [];
            if (options.defaults) {
                object.invitesLeft = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeUntilRefresh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeUntilRefresh = options.longs === String ? "0" : 0;
            }
            if (message.invitesLeft != null && message.hasOwnProperty("invitesLeft"))
                object.invitesLeft = message.invitesLeft;
            if (message.timeUntilRefresh != null && message.hasOwnProperty("timeUntilRefresh"))
                if (typeof message.timeUntilRefresh === "number")
                    object.timeUntilRefresh = options.longs === String ? String(message.timeUntilRefresh) : message.timeUntilRefresh;
                else
                    object.timeUntilRefresh = options.longs === String ? $util.Long.prototype.toString.call(message.timeUntilRefresh) : options.longs === Number ? new $util.LongBits(message.timeUntilRefresh.low >>> 0, message.timeUntilRefresh.high >>> 0).toNumber() : message.timeUntilRefresh;
            if (message.invites && message.invites.length) {
                object.invites = [];
                for (var j = 0; j < message.invites.length; ++j)
                    object.invites[j] = $root.server.Invite.toObject(message.invites[j], options);
            }
            return object;
        };

        /**
         * Converts this InvitesResponse to JSON.
         * @function toJSON
         * @memberof server.InvitesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvitesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvitesResponse;
    })();

    server.MediaUrl = (function() {

        /**
         * Properties of a MediaUrl.
         * @memberof server
         * @interface IMediaUrl
         * @property {string|null} [get] MediaUrl get
         * @property {string|null} [put] MediaUrl put
         * @property {string|null} [patch] MediaUrl patch
         */

        /**
         * Constructs a new MediaUrl.
         * @memberof server
         * @classdesc Represents a MediaUrl.
         * @implements IMediaUrl
         * @constructor
         * @param {server.IMediaUrl=} [properties] Properties to set
         */
        function MediaUrl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaUrl get.
         * @member {string} get
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.get = "";

        /**
         * MediaUrl put.
         * @member {string} put
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.put = "";

        /**
         * MediaUrl patch.
         * @member {string} patch
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.patch = "";

        /**
         * Creates a new MediaUrl instance using the specified properties.
         * @function create
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl=} [properties] Properties to set
         * @returns {server.MediaUrl} MediaUrl instance
         */
        MediaUrl.create = function create(properties) {
            return new MediaUrl(properties);
        };

        /**
         * Encodes the specified MediaUrl message. Does not implicitly {@link server.MediaUrl.verify|verify} messages.
         * @function encode
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl} message MediaUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUrl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.get);
            if (message.put != null && Object.hasOwnProperty.call(message, "put"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.put);
            if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.patch);
            return writer;
        };

        /**
         * Encodes the specified MediaUrl message, length delimited. Does not implicitly {@link server.MediaUrl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl} message MediaUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUrl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaUrl message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaUrl} MediaUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUrl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaUrl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.get = reader.string();
                    break;
                case 2:
                    message.put = reader.string();
                    break;
                case 3:
                    message.patch = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaUrl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaUrl} MediaUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUrl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaUrl message.
         * @function verify
         * @memberof server.MediaUrl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaUrl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.get != null && message.hasOwnProperty("get"))
                if (!$util.isString(message.get))
                    return "get: string expected";
            if (message.put != null && message.hasOwnProperty("put"))
                if (!$util.isString(message.put))
                    return "put: string expected";
            if (message.patch != null && message.hasOwnProperty("patch"))
                if (!$util.isString(message.patch))
                    return "patch: string expected";
            return null;
        };

        /**
         * Creates a MediaUrl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaUrl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaUrl} MediaUrl
         */
        MediaUrl.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaUrl)
                return object;
            var message = new $root.server.MediaUrl();
            if (object.get != null)
                message.get = String(object.get);
            if (object.put != null)
                message.put = String(object.put);
            if (object.patch != null)
                message.patch = String(object.patch);
            return message;
        };

        /**
         * Creates a plain object from a MediaUrl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaUrl
         * @static
         * @param {server.MediaUrl} message MediaUrl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaUrl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.get = "";
                object.put = "";
                object.patch = "";
            }
            if (message.get != null && message.hasOwnProperty("get"))
                object.get = message.get;
            if (message.put != null && message.hasOwnProperty("put"))
                object.put = message.put;
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = message.patch;
            return object;
        };

        /**
         * Converts this MediaUrl to JSON.
         * @function toJSON
         * @memberof server.MediaUrl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaUrl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaUrl;
    })();

    server.UploadMedia = (function() {

        /**
         * Properties of an UploadMedia.
         * @memberof server
         * @interface IUploadMedia
         * @property {number|Long|null} [size] UploadMedia size
         * @property {server.IMediaUrl|null} [url] UploadMedia url
         * @property {string|null} [downloadUrl] UploadMedia downloadUrl
         * @property {server.UploadMedia.Type|null} [type] UploadMedia type
         */

        /**
         * Constructs a new UploadMedia.
         * @memberof server
         * @classdesc Represents an UploadMedia.
         * @implements IUploadMedia
         * @constructor
         * @param {server.IUploadMedia=} [properties] Properties to set
         */
        function UploadMedia(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadMedia size.
         * @member {number|Long} size
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UploadMedia url.
         * @member {server.IMediaUrl|null|undefined} url
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.url = null;

        /**
         * UploadMedia downloadUrl.
         * @member {string} downloadUrl
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.downloadUrl = "";

        /**
         * UploadMedia type.
         * @member {server.UploadMedia.Type} type
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.type = 0;

        /**
         * Creates a new UploadMedia instance using the specified properties.
         * @function create
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia=} [properties] Properties to set
         * @returns {server.UploadMedia} UploadMedia instance
         */
        UploadMedia.create = function create(properties) {
            return new UploadMedia(properties);
        };

        /**
         * Encodes the specified UploadMedia message. Does not implicitly {@link server.UploadMedia.verify|verify} messages.
         * @function encode
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia} message UploadMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadMedia.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.size);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                $root.server.MediaUrl.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.downloadUrl);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified UploadMedia message, length delimited. Does not implicitly {@link server.UploadMedia.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia} message UploadMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadMedia.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadMedia message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadMedia} UploadMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadMedia.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadMedia();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.size = reader.int64();
                    break;
                case 2:
                    message.url = $root.server.MediaUrl.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.downloadUrl = reader.string();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadMedia message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadMedia} UploadMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadMedia.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadMedia message.
         * @function verify
         * @memberof server.UploadMedia
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadMedia.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            if (message.url != null && message.hasOwnProperty("url")) {
                var error = $root.server.MediaUrl.verify(message.url);
                if (error)
                    return "url." + error;
            }
            if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
                if (!$util.isString(message.downloadUrl))
                    return "downloadUrl: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an UploadMedia message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadMedia
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadMedia} UploadMedia
         */
        UploadMedia.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadMedia)
                return object;
            var message = new $root.server.UploadMedia();
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
            if (object.url != null) {
                if (typeof object.url !== "object")
                    throw TypeError(".server.UploadMedia.url: object expected");
                message.url = $root.server.MediaUrl.fromObject(object.url);
            }
            if (object.downloadUrl != null)
                message.downloadUrl = String(object.downloadUrl);
            switch (object.type) {
            case "DEFAULT":
            case 0:
                message.type = 0;
                break;
            case "RESUMABLE":
            case 1:
                message.type = 1;
                break;
            case "DIRECT":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an UploadMedia message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadMedia
         * @static
         * @param {server.UploadMedia} message UploadMedia
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadMedia.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
                object.url = null;
                object.downloadUrl = "";
                object.type = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = $root.server.MediaUrl.toObject(message.url, options);
            if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
                object.downloadUrl = message.downloadUrl;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.UploadMedia.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this UploadMedia to JSON.
         * @function toJSON
         * @memberof server.UploadMedia
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadMedia.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.UploadMedia.Type
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} RESUMABLE=1 RESUMABLE value
         * @property {number} DIRECT=2 DIRECT value
         */
        UploadMedia.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "RESUMABLE"] = 1;
            values[valuesById[2] = "DIRECT"] = 2;
            return values;
        })();

        return UploadMedia;
    })();

    server.ChatStanza = (function() {

        /**
         * Properties of a ChatStanza.
         * @memberof server
         * @interface IChatStanza
         * @property {number|Long|null} [timestamp] ChatStanza timestamp
         * @property {Uint8Array|null} [payload] ChatStanza payload
         * @property {Uint8Array|null} [encPayload] ChatStanza encPayload
         * @property {Uint8Array|null} [publicKey] ChatStanza publicKey
         * @property {number|Long|null} [oneTimePreKeyId] ChatStanza oneTimePreKeyId
         * @property {string|null} [senderName] ChatStanza senderName
         * @property {string|null} [senderPhone] ChatStanza senderPhone
         * @property {server.IMediaCounters|null} [mediaCounters] ChatStanza mediaCounters
         * @property {server.ChatStanza.ChatType|null} [chatType] ChatStanza chatType
         * @property {string|null} [senderLogInfo] ChatStanza senderLogInfo
         * @property {string|null} [senderClientVersion] ChatStanza senderClientVersion
         */

        /**
         * Constructs a new ChatStanza.
         * @memberof server
         * @classdesc Represents a ChatStanza.
         * @implements IChatStanza
         * @constructor
         * @param {server.IChatStanza=} [properties] Properties to set
         */
        function ChatStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatStanza timestamp.
         * @member {number|Long} timestamp
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChatStanza payload.
         * @member {Uint8Array} payload
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.payload = $util.newBuffer([]);

        /**
         * ChatStanza encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.encPayload = $util.newBuffer([]);

        /**
         * ChatStanza publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.publicKey = $util.newBuffer([]);

        /**
         * ChatStanza oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChatStanza senderName.
         * @member {string} senderName
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderName = "";

        /**
         * ChatStanza senderPhone.
         * @member {string} senderPhone
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderPhone = "";

        /**
         * ChatStanza mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.mediaCounters = null;

        /**
         * ChatStanza chatType.
         * @member {server.ChatStanza.ChatType} chatType
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.chatType = 0;

        /**
         * ChatStanza senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderLogInfo = "";

        /**
         * ChatStanza senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderClientVersion = "";

        /**
         * Creates a new ChatStanza instance using the specified properties.
         * @function create
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza=} [properties] Properties to set
         * @returns {server.ChatStanza} ChatStanza instance
         */
        ChatStanza.create = function create(properties) {
            return new ChatStanza(properties);
        };

        /**
         * Encodes the specified ChatStanza message. Does not implicitly {@link server.ChatStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza} message ChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.oneTimePreKeyId);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderName);
            if (message.senderPhone != null && Object.hasOwnProperty.call(message, "senderPhone"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.senderPhone);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.chatType != null && Object.hasOwnProperty.call(message, "chatType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.chatType);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified ChatStanza message, length delimited. Does not implicitly {@link server.ChatStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza} message ChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatStanza} ChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.encPayload = reader.bytes();
                    break;
                case 4:
                    message.publicKey = reader.bytes();
                    break;
                case 5:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 6:
                    message.senderName = reader.string();
                    break;
                case 7:
                    message.senderPhone = reader.string();
                    break;
                case 8:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.chatType = reader.int32();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatStanza} ChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatStanza message.
         * @function verify
         * @memberof server.ChatStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                if (!$util.isString(message.senderPhone))
                    return "senderPhone: string expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            if (message.chatType != null && message.hasOwnProperty("chatType"))
                switch (message.chatType) {
                default:
                    return "chatType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a ChatStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatStanza} ChatStanza
         */
        ChatStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatStanza)
                return object;
            var message = new $root.server.ChatStanza();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.senderPhone != null)
                message.senderPhone = String(object.senderPhone);
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.ChatStanza.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            switch (object.chatType) {
            case "CHAT":
            case 0:
                message.chatType = 0;
                break;
            case "CHAT_REACTION":
            case 1:
                message.chatType = 1;
                break;
            }
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a ChatStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatStanza
         * @static
         * @param {server.ChatStanza} message ChatStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                object.senderName = "";
                object.senderPhone = "";
                object.mediaCounters = null;
                object.chatType = options.enums === String ? "CHAT" : 0;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                object.senderPhone = message.senderPhone;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            if (message.chatType != null && message.hasOwnProperty("chatType"))
                object.chatType = options.enums === String ? $root.server.ChatStanza.ChatType[message.chatType] : message.chatType;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this ChatStanza to JSON.
         * @function toJSON
         * @memberof server.ChatStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ChatType enum.
         * @name server.ChatStanza.ChatType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} CHAT_REACTION=1 CHAT_REACTION value
         */
        ChatStanza.ChatType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "CHAT_REACTION"] = 1;
            return values;
        })();

        return ChatStanza;
    })();

    server.SilentChatStanza = (function() {

        /**
         * Properties of a SilentChatStanza.
         * @memberof server
         * @interface ISilentChatStanza
         * @property {server.IChatStanza|null} [chatStanza] SilentChatStanza chatStanza
         */

        /**
         * Constructs a new SilentChatStanza.
         * @memberof server
         * @classdesc Represents a SilentChatStanza.
         * @implements ISilentChatStanza
         * @constructor
         * @param {server.ISilentChatStanza=} [properties] Properties to set
         */
        function SilentChatStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SilentChatStanza chatStanza.
         * @member {server.IChatStanza|null|undefined} chatStanza
         * @memberof server.SilentChatStanza
         * @instance
         */
        SilentChatStanza.prototype.chatStanza = null;

        /**
         * Creates a new SilentChatStanza instance using the specified properties.
         * @function create
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza=} [properties] Properties to set
         * @returns {server.SilentChatStanza} SilentChatStanza instance
         */
        SilentChatStanza.create = function create(properties) {
            return new SilentChatStanza(properties);
        };

        /**
         * Encodes the specified SilentChatStanza message. Does not implicitly {@link server.SilentChatStanza.verify|verify} messages.
         * @function encode
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza} message SilentChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SilentChatStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatStanza != null && Object.hasOwnProperty.call(message, "chatStanza"))
                $root.server.ChatStanza.encode(message.chatStanza, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SilentChatStanza message, length delimited. Does not implicitly {@link server.SilentChatStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza} message SilentChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SilentChatStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SilentChatStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.SilentChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SilentChatStanza} SilentChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SilentChatStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SilentChatStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatStanza = $root.server.ChatStanza.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SilentChatStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SilentChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SilentChatStanza} SilentChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SilentChatStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SilentChatStanza message.
         * @function verify
         * @memberof server.SilentChatStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SilentChatStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                var error = $root.server.ChatStanza.verify(message.chatStanza);
                if (error)
                    return "chatStanza." + error;
            }
            return null;
        };

        /**
         * Creates a SilentChatStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SilentChatStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SilentChatStanza} SilentChatStanza
         */
        SilentChatStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SilentChatStanza)
                return object;
            var message = new $root.server.SilentChatStanza();
            if (object.chatStanza != null) {
                if (typeof object.chatStanza !== "object")
                    throw TypeError(".server.SilentChatStanza.chatStanza: object expected");
                message.chatStanza = $root.server.ChatStanza.fromObject(object.chatStanza);
            }
            return message;
        };

        /**
         * Creates a plain object from a SilentChatStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.SilentChatStanza} message SilentChatStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SilentChatStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.chatStanza = null;
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza"))
                object.chatStanza = $root.server.ChatStanza.toObject(message.chatStanza, options);
            return object;
        };

        /**
         * Converts this SilentChatStanza to JSON.
         * @function toJSON
         * @memberof server.SilentChatStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SilentChatStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SilentChatStanza;
    })();

    server.Ping = (function() {

        /**
         * Properties of a Ping.
         * @memberof server
         * @interface IPing
         */

        /**
         * Constructs a new Ping.
         * @memberof server
         * @classdesc Represents a Ping.
         * @implements IPing
         * @constructor
         * @param {server.IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof server.Ping
         * @static
         * @param {server.IPing=} [properties] Properties to set
         * @returns {server.Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };

        /**
         * Encodes the specified Ping message. Does not implicitly {@link server.Ping.verify|verify} messages.
         * @function encode
         * @memberof server.Ping
         * @static
         * @param {server.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link server.Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Ping
         * @static
         * @param {server.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof server.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof server.Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Ping)
                return object;
            return new $root.server.Ping();
        };

        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Ping
         * @static
         * @param {server.Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof server.Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ping;
    })();

    server.ErrorStanza = (function() {

        /**
         * Properties of an ErrorStanza.
         * @memberof server
         * @interface IErrorStanza
         * @property {string|null} [reason] ErrorStanza reason
         */

        /**
         * Constructs a new ErrorStanza.
         * @memberof server
         * @classdesc Represents an ErrorStanza.
         * @implements IErrorStanza
         * @constructor
         * @param {server.IErrorStanza=} [properties] Properties to set
         */
        function ErrorStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ErrorStanza reason.
         * @member {string} reason
         * @memberof server.ErrorStanza
         * @instance
         */
        ErrorStanza.prototype.reason = "";

        /**
         * Creates a new ErrorStanza instance using the specified properties.
         * @function create
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza=} [properties] Properties to set
         * @returns {server.ErrorStanza} ErrorStanza instance
         */
        ErrorStanza.create = function create(properties) {
            return new ErrorStanza(properties);
        };

        /**
         * Encodes the specified ErrorStanza message. Does not implicitly {@link server.ErrorStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza} message ErrorStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ErrorStanza message, length delimited. Does not implicitly {@link server.ErrorStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza} message ErrorStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ErrorStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ErrorStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ErrorStanza} ErrorStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ErrorStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ErrorStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ErrorStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ErrorStanza} ErrorStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ErrorStanza message.
         * @function verify
         * @memberof server.ErrorStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ErrorStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates an ErrorStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ErrorStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ErrorStanza} ErrorStanza
         */
        ErrorStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ErrorStanza)
                return object;
            var message = new $root.server.ErrorStanza();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from an ErrorStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ErrorStanza
         * @static
         * @param {server.ErrorStanza} message ErrorStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ErrorStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ErrorStanza to JSON.
         * @function toJSON
         * @memberof server.ErrorStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ErrorStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ErrorStanza;
    })();

    server.Name = (function() {

        /**
         * Properties of a Name.
         * @memberof server
         * @interface IName
         * @property {number|Long|null} [uid] Name uid
         * @property {string|null} [name] Name name
         */

        /**
         * Constructs a new Name.
         * @memberof server
         * @classdesc Represents a Name.
         * @implements IName
         * @constructor
         * @param {server.IName=} [properties] Properties to set
         */
        function Name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Name uid.
         * @member {number|Long} uid
         * @memberof server.Name
         * @instance
         */
        Name.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Name name.
         * @member {string} name
         * @memberof server.Name
         * @instance
         */
        Name.prototype.name = "";

        /**
         * Creates a new Name instance using the specified properties.
         * @function create
         * @memberof server.Name
         * @static
         * @param {server.IName=} [properties] Properties to set
         * @returns {server.Name} Name instance
         */
        Name.create = function create(properties) {
            return new Name(properties);
        };

        /**
         * Encodes the specified Name message. Does not implicitly {@link server.Name.verify|verify} messages.
         * @function encode
         * @memberof server.Name
         * @static
         * @param {server.IName} message Name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Name message, length delimited. Does not implicitly {@link server.Name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Name
         * @static
         * @param {server.IName} message Name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Name message from the specified reader or buffer.
         * @function decode
         * @memberof server.Name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Name} Name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Name} Name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Name message.
         * @function verify
         * @memberof server.Name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Name} Name
         */
        Name.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Name)
                return object;
            var message = new $root.server.Name();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Name
         * @static
         * @param {server.Name} message Name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Name.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Name to JSON.
         * @function toJSON
         * @memberof server.Name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Name;
    })();

    server.EndOfQueue = (function() {

        /**
         * Properties of an EndOfQueue.
         * @memberof server
         * @interface IEndOfQueue
         * @property {boolean|null} [trimmed] EndOfQueue trimmed
         */

        /**
         * Constructs a new EndOfQueue.
         * @memberof server
         * @classdesc Represents an EndOfQueue.
         * @implements IEndOfQueue
         * @constructor
         * @param {server.IEndOfQueue=} [properties] Properties to set
         */
        function EndOfQueue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EndOfQueue trimmed.
         * @member {boolean} trimmed
         * @memberof server.EndOfQueue
         * @instance
         */
        EndOfQueue.prototype.trimmed = false;

        /**
         * Creates a new EndOfQueue instance using the specified properties.
         * @function create
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue=} [properties] Properties to set
         * @returns {server.EndOfQueue} EndOfQueue instance
         */
        EndOfQueue.create = function create(properties) {
            return new EndOfQueue(properties);
        };

        /**
         * Encodes the specified EndOfQueue message. Does not implicitly {@link server.EndOfQueue.verify|verify} messages.
         * @function encode
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue} message EndOfQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndOfQueue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trimmed != null && Object.hasOwnProperty.call(message, "trimmed"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.trimmed);
            return writer;
        };

        /**
         * Encodes the specified EndOfQueue message, length delimited. Does not implicitly {@link server.EndOfQueue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue} message EndOfQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndOfQueue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EndOfQueue message from the specified reader or buffer.
         * @function decode
         * @memberof server.EndOfQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EndOfQueue} EndOfQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndOfQueue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EndOfQueue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trimmed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EndOfQueue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EndOfQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EndOfQueue} EndOfQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndOfQueue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EndOfQueue message.
         * @function verify
         * @memberof server.EndOfQueue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EndOfQueue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trimmed != null && message.hasOwnProperty("trimmed"))
                if (typeof message.trimmed !== "boolean")
                    return "trimmed: boolean expected";
            return null;
        };

        /**
         * Creates an EndOfQueue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EndOfQueue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EndOfQueue} EndOfQueue
         */
        EndOfQueue.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EndOfQueue)
                return object;
            var message = new $root.server.EndOfQueue();
            if (object.trimmed != null)
                message.trimmed = Boolean(object.trimmed);
            return message;
        };

        /**
         * Creates a plain object from an EndOfQueue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EndOfQueue
         * @static
         * @param {server.EndOfQueue} message EndOfQueue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EndOfQueue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.trimmed = false;
            if (message.trimmed != null && message.hasOwnProperty("trimmed"))
                object.trimmed = message.trimmed;
            return object;
        };

        /**
         * Converts this EndOfQueue to JSON.
         * @function toJSON
         * @memberof server.EndOfQueue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EndOfQueue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EndOfQueue;
    })();

    server.HistoryResend = (function() {

        /**
         * Properties of a HistoryResend.
         * @memberof server
         * @interface IHistoryResend
         * @property {string|null} [gid] HistoryResend gid
         * @property {string|null} [id] HistoryResend id
         * @property {Uint8Array|null} [payload] HistoryResend payload
         * @property {Uint8Array|null} [encPayload] HistoryResend encPayload
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] HistoryResend senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] HistoryResend senderState
         * @property {Uint8Array|null} [audienceHash] HistoryResend audienceHash
         * @property {string|null} [senderLogInfo] HistoryResend senderLogInfo
         * @property {string|null} [senderClientVersion] HistoryResend senderClientVersion
         */

        /**
         * Constructs a new HistoryResend.
         * @memberof server
         * @classdesc Represents a HistoryResend.
         * @implements IHistoryResend
         * @constructor
         * @param {server.IHistoryResend=} [properties] Properties to set
         */
        function HistoryResend(properties) {
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistoryResend gid.
         * @member {string} gid
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.gid = "";

        /**
         * HistoryResend id.
         * @member {string} id
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.id = "";

        /**
         * HistoryResend payload.
         * @member {Uint8Array} payload
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.payload = $util.newBuffer([]);

        /**
         * HistoryResend encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.encPayload = $util.newBuffer([]);

        /**
         * HistoryResend senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderStateBundles = $util.emptyArray;

        /**
         * HistoryResend senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderState = null;

        /**
         * HistoryResend audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.audienceHash = $util.newBuffer([]);

        /**
         * HistoryResend senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderLogInfo = "";

        /**
         * HistoryResend senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderClientVersion = "";

        /**
         * Creates a new HistoryResend instance using the specified properties.
         * @function create
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend=} [properties] Properties to set
         * @returns {server.HistoryResend} HistoryResend instance
         */
        HistoryResend.create = function create(properties) {
            return new HistoryResend(properties);
        };

        /**
         * Encodes the specified HistoryResend message. Does not implicitly {@link server.HistoryResend.verify|verify} messages.
         * @function encode
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend} message HistoryResend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryResend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encPayload);
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.audienceHash);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified HistoryResend message, length delimited. Does not implicitly {@link server.HistoryResend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend} message HistoryResend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryResend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistoryResend message from the specified reader or buffer.
         * @function decode
         * @memberof server.HistoryResend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HistoryResend} HistoryResend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryResend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HistoryResend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    message.encPayload = reader.bytes();
                    break;
                case 6:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.audienceHash = reader.bytes();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HistoryResend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HistoryResend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HistoryResend} HistoryResend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryResend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistoryResend message.
         * @function verify
         * @memberof server.HistoryResend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistoryResend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a HistoryResend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HistoryResend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HistoryResend} HistoryResend
         */
        HistoryResend.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HistoryResend)
                return object;
            var message = new $root.server.HistoryResend();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.HistoryResend.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.HistoryResend.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.HistoryResend.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a HistoryResend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HistoryResend
         * @static
         * @param {server.HistoryResend} message HistoryResend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistoryResend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderStateBundles = [];
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.senderState = null;
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this HistoryResend to JSON.
         * @function toJSON
         * @memberof server.HistoryResend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistoryResend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistoryResend;
    })();

    /**
     * CallType enum.
     * @name server.CallType
     * @enum {number}
     * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
     * @property {number} AUDIO=1 AUDIO value
     * @property {number} VIDEO=2 VIDEO value
     */
    server.CallType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
        values[valuesById[1] = "AUDIO"] = 1;
        values[valuesById[2] = "VIDEO"] = 2;
        return values;
    })();

    server.StunServer = (function() {

        /**
         * Properties of a StunServer.
         * @memberof server
         * @interface IStunServer
         * @property {string|null} [host] StunServer host
         * @property {number|null} [port] StunServer port
         */

        /**
         * Constructs a new StunServer.
         * @memberof server
         * @classdesc Represents a StunServer.
         * @implements IStunServer
         * @constructor
         * @param {server.IStunServer=} [properties] Properties to set
         */
        function StunServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StunServer host.
         * @member {string} host
         * @memberof server.StunServer
         * @instance
         */
        StunServer.prototype.host = "";

        /**
         * StunServer port.
         * @member {number} port
         * @memberof server.StunServer
         * @instance
         */
        StunServer.prototype.port = 0;

        /**
         * Creates a new StunServer instance using the specified properties.
         * @function create
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer=} [properties] Properties to set
         * @returns {server.StunServer} StunServer instance
         */
        StunServer.create = function create(properties) {
            return new StunServer(properties);
        };

        /**
         * Encodes the specified StunServer message. Does not implicitly {@link server.StunServer.verify|verify} messages.
         * @function encode
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer} message StunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StunServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            return writer;
        };

        /**
         * Encodes the specified StunServer message, length delimited. Does not implicitly {@link server.StunServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer} message StunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StunServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StunServer message from the specified reader or buffer.
         * @function decode
         * @memberof server.StunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StunServer} StunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StunServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StunServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StunServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StunServer} StunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StunServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StunServer message.
         * @function verify
         * @memberof server.StunServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StunServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            return null;
        };

        /**
         * Creates a StunServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StunServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StunServer} StunServer
         */
        StunServer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StunServer)
                return object;
            var message = new $root.server.StunServer();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a StunServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StunServer
         * @static
         * @param {server.StunServer} message StunServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StunServer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this StunServer to JSON.
         * @function toJSON
         * @memberof server.StunServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StunServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StunServer;
    })();

    server.TurnServer = (function() {

        /**
         * Properties of a TurnServer.
         * @memberof server
         * @interface ITurnServer
         * @property {string|null} [host] TurnServer host
         * @property {number|null} [port] TurnServer port
         * @property {string|null} [username] TurnServer username
         * @property {string|null} [password] TurnServer password
         */

        /**
         * Constructs a new TurnServer.
         * @memberof server
         * @classdesc Represents a TurnServer.
         * @implements ITurnServer
         * @constructor
         * @param {server.ITurnServer=} [properties] Properties to set
         */
        function TurnServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TurnServer host.
         * @member {string} host
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.host = "";

        /**
         * TurnServer port.
         * @member {number} port
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.port = 0;

        /**
         * TurnServer username.
         * @member {string} username
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.username = "";

        /**
         * TurnServer password.
         * @member {string} password
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.password = "";

        /**
         * Creates a new TurnServer instance using the specified properties.
         * @function create
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer=} [properties] Properties to set
         * @returns {server.TurnServer} TurnServer instance
         */
        TurnServer.create = function create(properties) {
            return new TurnServer(properties);
        };

        /**
         * Encodes the specified TurnServer message. Does not implicitly {@link server.TurnServer.verify|verify} messages.
         * @function encode
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer} message TurnServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified TurnServer message, length delimited. Does not implicitly {@link server.TurnServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer} message TurnServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TurnServer message from the specified reader or buffer.
         * @function decode
         * @memberof server.TurnServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TurnServer} TurnServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TurnServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TurnServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TurnServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TurnServer} TurnServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TurnServer message.
         * @function verify
         * @memberof server.TurnServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TurnServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a TurnServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TurnServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TurnServer} TurnServer
         */
        TurnServer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TurnServer)
                return object;
            var message = new $root.server.TurnServer();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a TurnServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TurnServer
         * @static
         * @param {server.TurnServer} message TurnServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TurnServer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.username = "";
                object.password = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this TurnServer to JSON.
         * @function toJSON
         * @memberof server.TurnServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TurnServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TurnServer;
    })();

    server.GetCallServers = (function() {

        /**
         * Properties of a GetCallServers.
         * @memberof server
         * @interface IGetCallServers
         * @property {string|null} [callId] GetCallServers callId
         * @property {number|Long|null} [peerUid] GetCallServers peerUid
         * @property {server.CallType|null} [callType] GetCallServers callType
         */

        /**
         * Constructs a new GetCallServers.
         * @memberof server
         * @classdesc Represents a GetCallServers.
         * @implements IGetCallServers
         * @constructor
         * @param {server.IGetCallServers=} [properties] Properties to set
         */
        function GetCallServers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCallServers callId.
         * @member {string} callId
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.callId = "";

        /**
         * GetCallServers peerUid.
         * @member {number|Long} peerUid
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetCallServers callType.
         * @member {server.CallType} callType
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.callType = 0;

        /**
         * Creates a new GetCallServers instance using the specified properties.
         * @function create
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers=} [properties] Properties to set
         * @returns {server.GetCallServers} GetCallServers instance
         */
        GetCallServers.create = function create(properties) {
            return new GetCallServers(properties);
        };

        /**
         * Encodes the specified GetCallServers message. Does not implicitly {@link server.GetCallServers.verify|verify} messages.
         * @function encode
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers} message GetCallServers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.peerUid);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callType);
            return writer;
        };

        /**
         * Encodes the specified GetCallServers message, length delimited. Does not implicitly {@link server.GetCallServers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers} message GetCallServers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCallServers message from the specified reader or buffer.
         * @function decode
         * @memberof server.GetCallServers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GetCallServers} GetCallServers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GetCallServers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.int64();
                    break;
                case 3:
                    message.callType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCallServers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GetCallServers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GetCallServers} GetCallServers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCallServers message.
         * @function verify
         * @memberof server.GetCallServers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCallServers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetCallServers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GetCallServers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GetCallServers} GetCallServers
         */
        GetCallServers.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GetCallServers)
                return object;
            var message = new $root.server.GetCallServers();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = false;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber();
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCallServers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GetCallServers
         * @static
         * @param {server.GetCallServers} message GetCallServers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCallServers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber() : message.peerUid;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            return object;
        };

        /**
         * Converts this GetCallServers to JSON.
         * @function toJSON
         * @memberof server.GetCallServers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCallServers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCallServers;
    })();

    server.GetCallServersResult = (function() {

        /**
         * Properties of a GetCallServersResult.
         * @memberof server
         * @interface IGetCallServersResult
         * @property {server.GetCallServersResult.Result|null} [result] GetCallServersResult result
         * @property {Array.<server.IStunServer>|null} [stunServers] GetCallServersResult stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] GetCallServersResult turnServers
         * @property {server.ICallConfig|null} [callConfig] GetCallServersResult callConfig
         * @property {string|null} [callId] GetCallServersResult callId
         */

        /**
         * Constructs a new GetCallServersResult.
         * @memberof server
         * @classdesc Represents a GetCallServersResult.
         * @implements IGetCallServersResult
         * @constructor
         * @param {server.IGetCallServersResult=} [properties] Properties to set
         */
        function GetCallServersResult(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCallServersResult result.
         * @member {server.GetCallServersResult.Result} result
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.result = 0;

        /**
         * GetCallServersResult stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.stunServers = $util.emptyArray;

        /**
         * GetCallServersResult turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.turnServers = $util.emptyArray;

        /**
         * GetCallServersResult callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.callConfig = null;

        /**
         * GetCallServersResult callId.
         * @member {string} callId
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.callId = "";

        /**
         * Creates a new GetCallServersResult instance using the specified properties.
         * @function create
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult=} [properties] Properties to set
         * @returns {server.GetCallServersResult} GetCallServersResult instance
         */
        GetCallServersResult.create = function create(properties) {
            return new GetCallServersResult(properties);
        };

        /**
         * Encodes the specified GetCallServersResult message. Does not implicitly {@link server.GetCallServersResult.verify|verify} messages.
         * @function encode
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult} message GetCallServersResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServersResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.callId);
            return writer;
        };

        /**
         * Encodes the specified GetCallServersResult message, length delimited. Does not implicitly {@link server.GetCallServersResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult} message GetCallServersResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServersResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCallServersResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.GetCallServersResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GetCallServersResult} GetCallServersResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServersResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GetCallServersResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.callId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCallServersResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GetCallServersResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GetCallServersResult} GetCallServersResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServersResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCallServersResult message.
         * @function verify
         * @memberof server.GetCallServersResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCallServersResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            return null;
        };

        /**
         * Creates a GetCallServersResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GetCallServersResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GetCallServersResult} GetCallServersResult
         */
        GetCallServersResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GetCallServersResult)
                return object;
            var message = new $root.server.GetCallServersResult();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.GetCallServersResult.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.GetCallServersResult.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.GetCallServersResult.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.GetCallServersResult.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.GetCallServersResult.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            if (object.callId != null)
                message.callId = String(object.callId);
            return message;
        };

        /**
         * Creates a plain object from a GetCallServersResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.GetCallServersResult} message GetCallServersResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCallServersResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN" : 0;
                object.callConfig = null;
                object.callId = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.GetCallServersResult.Result[message.result] : message.result;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            return object;
        };

        /**
         * Converts this GetCallServersResult to JSON.
         * @function toJSON
         * @memberof server.GetCallServersResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCallServersResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.GetCallServersResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        GetCallServersResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        return GetCallServersResult;
    })();

    server.CallCapabilities = (function() {

        /**
         * Properties of a CallCapabilities.
         * @memberof server
         * @interface ICallCapabilities
         * @property {boolean|null} [preAnswer] CallCapabilities preAnswer
         * @property {boolean|null} [sdpRestart] CallCapabilities sdpRestart
         */

        /**
         * Constructs a new CallCapabilities.
         * @memberof server
         * @classdesc Represents a CallCapabilities.
         * @implements ICallCapabilities
         * @constructor
         * @param {server.ICallCapabilities=} [properties] Properties to set
         */
        function CallCapabilities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallCapabilities preAnswer.
         * @member {boolean} preAnswer
         * @memberof server.CallCapabilities
         * @instance
         */
        CallCapabilities.prototype.preAnswer = false;

        /**
         * CallCapabilities sdpRestart.
         * @member {boolean} sdpRestart
         * @memberof server.CallCapabilities
         * @instance
         */
        CallCapabilities.prototype.sdpRestart = false;

        /**
         * Creates a new CallCapabilities instance using the specified properties.
         * @function create
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities=} [properties] Properties to set
         * @returns {server.CallCapabilities} CallCapabilities instance
         */
        CallCapabilities.create = function create(properties) {
            return new CallCapabilities(properties);
        };

        /**
         * Encodes the specified CallCapabilities message. Does not implicitly {@link server.CallCapabilities.verify|verify} messages.
         * @function encode
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities} message CallCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallCapabilities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.preAnswer != null && Object.hasOwnProperty.call(message, "preAnswer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.preAnswer);
            if (message.sdpRestart != null && Object.hasOwnProperty.call(message, "sdpRestart"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.sdpRestart);
            return writer;
        };

        /**
         * Encodes the specified CallCapabilities message, length delimited. Does not implicitly {@link server.CallCapabilities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities} message CallCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallCapabilities message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallCapabilities} CallCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallCapabilities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallCapabilities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.preAnswer = reader.bool();
                    break;
                case 2:
                    message.sdpRestart = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallCapabilities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallCapabilities} CallCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallCapabilities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallCapabilities message.
         * @function verify
         * @memberof server.CallCapabilities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallCapabilities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.preAnswer != null && message.hasOwnProperty("preAnswer"))
                if (typeof message.preAnswer !== "boolean")
                    return "preAnswer: boolean expected";
            if (message.sdpRestart != null && message.hasOwnProperty("sdpRestart"))
                if (typeof message.sdpRestart !== "boolean")
                    return "sdpRestart: boolean expected";
            return null;
        };

        /**
         * Creates a CallCapabilities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallCapabilities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallCapabilities} CallCapabilities
         */
        CallCapabilities.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallCapabilities)
                return object;
            var message = new $root.server.CallCapabilities();
            if (object.preAnswer != null)
                message.preAnswer = Boolean(object.preAnswer);
            if (object.sdpRestart != null)
                message.sdpRestart = Boolean(object.sdpRestart);
            return message;
        };

        /**
         * Creates a plain object from a CallCapabilities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallCapabilities
         * @static
         * @param {server.CallCapabilities} message CallCapabilities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallCapabilities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.preAnswer = false;
                object.sdpRestart = false;
            }
            if (message.preAnswer != null && message.hasOwnProperty("preAnswer"))
                object.preAnswer = message.preAnswer;
            if (message.sdpRestart != null && message.hasOwnProperty("sdpRestart"))
                object.sdpRestart = message.sdpRestart;
            return object;
        };

        /**
         * Converts this CallCapabilities to JSON.
         * @function toJSON
         * @memberof server.CallCapabilities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallCapabilities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallCapabilities;
    })();

    server.StartCall = (function() {

        /**
         * Properties of a StartCall.
         * @memberof server
         * @interface IStartCall
         * @property {string|null} [callId] StartCall callId
         * @property {number|Long|null} [peerUid] StartCall peerUid
         * @property {server.CallType|null} [callType] StartCall callType
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] StartCall webrtcOffer
         * @property {number|null} [rerequestCount] StartCall rerequestCount
         * @property {server.ICallCapabilities|null} [callCapabilities] StartCall callCapabilities
         */

        /**
         * Constructs a new StartCall.
         * @memberof server
         * @classdesc Represents a StartCall.
         * @implements IStartCall
         * @constructor
         * @param {server.IStartCall=} [properties] Properties to set
         */
        function StartCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartCall callId.
         * @member {string} callId
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callId = "";

        /**
         * StartCall peerUid.
         * @member {number|Long} peerUid
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StartCall callType.
         * @member {server.CallType} callType
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callType = 0;

        /**
         * StartCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.webrtcOffer = null;

        /**
         * StartCall rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.rerequestCount = 0;

        /**
         * StartCall callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callCapabilities = null;

        /**
         * Creates a new StartCall instance using the specified properties.
         * @function create
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall=} [properties] Properties to set
         * @returns {server.StartCall} StartCall instance
         */
        StartCall.create = function create(properties) {
            return new StartCall(properties);
        };

        /**
         * Encodes the specified StartCall message. Does not implicitly {@link server.StartCall.verify|verify} messages.
         * @function encode
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall} message StartCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.peerUid);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callType);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rerequestCount);
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StartCall message, length delimited. Does not implicitly {@link server.StartCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall} message StartCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.StartCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StartCall} StartCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StartCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.int64();
                    break;
                case 3:
                    message.callType = reader.int32();
                    break;
                case 4:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.rerequestCount = reader.int32();
                    break;
                case 6:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StartCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StartCall} StartCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCall message.
         * @function verify
         * @memberof server.StartCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates a StartCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StartCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StartCall} StartCall
         */
        StartCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StartCall)
                return object;
            var message = new $root.server.StartCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = false;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber();
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.StartCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount | 0;
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.StartCall.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from a StartCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StartCall
         * @static
         * @param {server.StartCall} message StartCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.webrtcOffer = null;
                object.rerequestCount = 0;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber() : message.peerUid;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this StartCall to JSON.
         * @function toJSON
         * @memberof server.StartCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartCall;
    })();

    server.StartCallResult = (function() {

        /**
         * Properties of a StartCallResult.
         * @memberof server
         * @interface IStartCallResult
         * @property {server.StartCallResult.Result|null} [result] StartCallResult result
         * @property {Array.<server.IStunServer>|null} [stunServers] StartCallResult stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] StartCallResult turnServers
         * @property {number|Long|null} [timestampMs] StartCallResult timestampMs
         */

        /**
         * Constructs a new StartCallResult.
         * @memberof server
         * @classdesc Represents a StartCallResult.
         * @implements IStartCallResult
         * @constructor
         * @param {server.IStartCallResult=} [properties] Properties to set
         */
        function StartCallResult(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartCallResult result.
         * @member {server.StartCallResult.Result} result
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.result = 0;

        /**
         * StartCallResult stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.stunServers = $util.emptyArray;

        /**
         * StartCallResult turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.turnServers = $util.emptyArray;

        /**
         * StartCallResult timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StartCallResult instance using the specified properties.
         * @function create
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult=} [properties] Properties to set
         * @returns {server.StartCallResult} StartCallResult instance
         */
        StartCallResult.create = function create(properties) {
            return new StartCallResult(properties);
        };

        /**
         * Encodes the specified StartCallResult message. Does not implicitly {@link server.StartCallResult.verify|verify} messages.
         * @function encode
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult} message StartCallResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCallResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified StartCallResult message, length delimited. Does not implicitly {@link server.StartCallResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult} message StartCallResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCallResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCallResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.StartCallResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StartCallResult} StartCallResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCallResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StartCallResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCallResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StartCallResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StartCallResult} StartCallResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCallResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCallResult message.
         * @function verify
         * @memberof server.StartCallResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCallResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a StartCallResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StartCallResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StartCallResult} StartCallResult
         */
        StartCallResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StartCallResult)
                return object;
            var message = new $root.server.StartCallResult();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.StartCallResult.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.StartCallResult.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.StartCallResult.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.StartCallResult.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StartCallResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StartCallResult
         * @static
         * @param {server.StartCallResult} message StartCallResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCallResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.StartCallResult.Result[message.result] : message.result;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this StartCallResult to JSON.
         * @function toJSON
         * @memberof server.StartCallResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCallResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.StartCallResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        StartCallResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        return StartCallResult;
    })();

    server.WebRtcSessionDescription = (function() {

        /**
         * Properties of a WebRtcSessionDescription.
         * @memberof server
         * @interface IWebRtcSessionDescription
         * @property {Uint8Array|null} [encPayload] WebRtcSessionDescription encPayload
         * @property {Uint8Array|null} [publicKey] WebRtcSessionDescription publicKey
         * @property {number|null} [oneTimePreKeyId] WebRtcSessionDescription oneTimePreKeyId
         */

        /**
         * Constructs a new WebRtcSessionDescription.
         * @memberof server
         * @classdesc Represents a WebRtcSessionDescription.
         * @implements IWebRtcSessionDescription
         * @constructor
         * @param {server.IWebRtcSessionDescription=} [properties] Properties to set
         */
        function WebRtcSessionDescription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebRtcSessionDescription encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.encPayload = $util.newBuffer([]);

        /**
         * WebRtcSessionDescription publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.publicKey = $util.newBuffer([]);

        /**
         * WebRtcSessionDescription oneTimePreKeyId.
         * @member {number} oneTimePreKeyId
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.oneTimePreKeyId = 0;

        /**
         * Creates a new WebRtcSessionDescription instance using the specified properties.
         * @function create
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription=} [properties] Properties to set
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription instance
         */
        WebRtcSessionDescription.create = function create(properties) {
            return new WebRtcSessionDescription(properties);
        };

        /**
         * Encodes the specified WebRtcSessionDescription message. Does not implicitly {@link server.WebRtcSessionDescription.verify|verify} messages.
         * @function encode
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription} message WebRtcSessionDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebRtcSessionDescription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.oneTimePreKeyId);
            return writer;
        };

        /**
         * Encodes the specified WebRtcSessionDescription message, length delimited. Does not implicitly {@link server.WebRtcSessionDescription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription} message WebRtcSessionDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebRtcSessionDescription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebRtcSessionDescription message from the specified reader or buffer.
         * @function decode
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebRtcSessionDescription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WebRtcSessionDescription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encPayload = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.oneTimePreKeyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebRtcSessionDescription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebRtcSessionDescription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebRtcSessionDescription message.
         * @function verify
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebRtcSessionDescription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId))
                    return "oneTimePreKeyId: integer expected";
            return null;
        };

        /**
         * Creates a WebRtcSessionDescription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         */
        WebRtcSessionDescription.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WebRtcSessionDescription)
                return object;
            var message = new $root.server.WebRtcSessionDescription();
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                message.oneTimePreKeyId = object.oneTimePreKeyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a WebRtcSessionDescription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.WebRtcSessionDescription} message WebRtcSessionDescription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebRtcSessionDescription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.oneTimePreKeyId = 0;
            }
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                object.oneTimePreKeyId = message.oneTimePreKeyId;
            return object;
        };

        /**
         * Converts this WebRtcSessionDescription to JSON.
         * @function toJSON
         * @memberof server.WebRtcSessionDescription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebRtcSessionDescription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebRtcSessionDescription;
    })();

    server.IncomingCallPush = (function() {

        /**
         * Properties of an IncomingCallPush.
         * @memberof server
         * @interface IIncomingCallPush
         * @property {string|null} [callId] IncomingCallPush callId
         * @property {server.CallType|null} [callType] IncomingCallPush callType
         * @property {Array.<server.IStunServer>|null} [stunServers] IncomingCallPush stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] IncomingCallPush turnServers
         * @property {number|Long|null} [timestampMs] IncomingCallPush timestampMs
         * @property {server.ICallConfig|null} [callConfig] IncomingCallPush callConfig
         * @property {server.ICallCapabilities|null} [callCapabilities] IncomingCallPush callCapabilities
         */

        /**
         * Constructs a new IncomingCallPush.
         * @memberof server
         * @classdesc Represents an IncomingCallPush.
         * @implements IIncomingCallPush
         * @constructor
         * @param {server.IIncomingCallPush=} [properties] Properties to set
         */
        function IncomingCallPush(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingCallPush callId.
         * @member {string} callId
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callId = "";

        /**
         * IncomingCallPush callType.
         * @member {server.CallType} callType
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callType = 0;

        /**
         * IncomingCallPush stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.stunServers = $util.emptyArray;

        /**
         * IncomingCallPush turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.turnServers = $util.emptyArray;

        /**
         * IncomingCallPush timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCallPush callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callConfig = null;

        /**
         * IncomingCallPush callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callCapabilities = null;

        /**
         * Creates a new IncomingCallPush instance using the specified properties.
         * @function create
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush=} [properties] Properties to set
         * @returns {server.IncomingCallPush} IncomingCallPush instance
         */
        IncomingCallPush.create = function create(properties) {
            return new IncomingCallPush(properties);
        };

        /**
         * Encodes the specified IncomingCallPush message. Does not implicitly {@link server.IncomingCallPush.verify|verify} messages.
         * @function encode
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush} message IncomingCallPush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCallPush.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.callType);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestampMs);
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IncomingCallPush message, length delimited. Does not implicitly {@link server.IncomingCallPush.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush} message IncomingCallPush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCallPush.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncomingCallPush message from the specified reader or buffer.
         * @function decode
         * @memberof server.IncomingCallPush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IncomingCallPush} IncomingCallPush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCallPush.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IncomingCallPush();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.callType = reader.int32();
                    break;
                case 3:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.timestampMs = reader.int64();
                    break;
                case 6:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IncomingCallPush message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IncomingCallPush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IncomingCallPush} IncomingCallPush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCallPush.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncomingCallPush message.
         * @function verify
         * @memberof server.IncomingCallPush
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncomingCallPush.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates an IncomingCallPush message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IncomingCallPush
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IncomingCallPush} IncomingCallPush
         */
        IncomingCallPush.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IncomingCallPush)
                return object;
            var message = new $root.server.IncomingCallPush();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.IncomingCallPush.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.IncomingCallPush.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.IncomingCallPush.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.IncomingCallPush.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.IncomingCallPush.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.IncomingCallPush.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from an IncomingCallPush message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IncomingCallPush} message IncomingCallPush
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncomingCallPush.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.callId = "";
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.callConfig = null;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this IncomingCallPush to JSON.
         * @function toJSON
         * @memberof server.IncomingCallPush
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncomingCallPush.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IncomingCallPush;
    })();

    server.IncomingCall = (function() {

        /**
         * Properties of an IncomingCall.
         * @memberof server
         * @interface IIncomingCall
         * @property {string|null} [callId] IncomingCall callId
         * @property {server.CallType|null} [callType] IncomingCall callType
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] IncomingCall webrtcOffer
         * @property {Array.<server.IStunServer>|null} [stunServers] IncomingCall stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] IncomingCall turnServers
         * @property {number|Long|null} [timestampMs] IncomingCall timestampMs
         * @property {number|Long|null} [serverSentTsMs] IncomingCall serverSentTsMs
         * @property {server.ICallConfig|null} [callConfig] IncomingCall callConfig
         * @property {server.ICallCapabilities|null} [callCapabilities] IncomingCall callCapabilities
         */

        /**
         * Constructs a new IncomingCall.
         * @memberof server
         * @classdesc Represents an IncomingCall.
         * @implements IIncomingCall
         * @constructor
         * @param {server.IIncomingCall=} [properties] Properties to set
         */
        function IncomingCall(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingCall callId.
         * @member {string} callId
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callId = "";

        /**
         * IncomingCall callType.
         * @member {server.CallType} callType
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callType = 0;

        /**
         * IncomingCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.webrtcOffer = null;

        /**
         * IncomingCall stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.stunServers = $util.emptyArray;

        /**
         * IncomingCall turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.turnServers = $util.emptyArray;

        /**
         * IncomingCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCall serverSentTsMs.
         * @member {number|Long} serverSentTsMs
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.serverSentTsMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCall callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callConfig = null;

        /**
         * IncomingCall callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callCapabilities = null;

        /**
         * Creates a new IncomingCall instance using the specified properties.
         * @function create
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall=} [properties] Properties to set
         * @returns {server.IncomingCall} IncomingCall instance
         */
        IncomingCall.create = function create(properties) {
            return new IncomingCall(properties);
        };

        /**
         * Encodes the specified IncomingCall message. Does not implicitly {@link server.IncomingCall.verify|verify} messages.
         * @function encode
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall} message IncomingCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.callType);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestampMs);
            if (message.serverSentTsMs != null && Object.hasOwnProperty.call(message, "serverSentTsMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.serverSentTsMs);
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IncomingCall message, length delimited. Does not implicitly {@link server.IncomingCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall} message IncomingCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncomingCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.IncomingCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IncomingCall} IncomingCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IncomingCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.callType = reader.int32();
                    break;
                case 3:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timestampMs = reader.int64();
                    break;
                case 7:
                    message.serverSentTsMs = reader.int64();
                    break;
                case 8:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IncomingCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IncomingCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IncomingCall} IncomingCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncomingCall message.
         * @function verify
         * @memberof server.IncomingCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncomingCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.serverSentTsMs != null && message.hasOwnProperty("serverSentTsMs"))
                if (!$util.isInteger(message.serverSentTsMs) && !(message.serverSentTsMs && $util.isInteger(message.serverSentTsMs.low) && $util.isInteger(message.serverSentTsMs.high)))
                    return "serverSentTsMs: integer|Long expected";
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates an IncomingCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IncomingCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IncomingCall} IncomingCall
         */
        IncomingCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IncomingCall)
                return object;
            var message = new $root.server.IncomingCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.IncomingCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.IncomingCall.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.IncomingCall.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.IncomingCall.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.IncomingCall.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.serverSentTsMs != null)
                if ($util.Long)
                    (message.serverSentTsMs = $util.Long.fromValue(object.serverSentTsMs)).unsigned = false;
                else if (typeof object.serverSentTsMs === "string")
                    message.serverSentTsMs = parseInt(object.serverSentTsMs, 10);
                else if (typeof object.serverSentTsMs === "number")
                    message.serverSentTsMs = object.serverSentTsMs;
                else if (typeof object.serverSentTsMs === "object")
                    message.serverSentTsMs = new $util.LongBits(object.serverSentTsMs.low >>> 0, object.serverSentTsMs.high >>> 0).toNumber();
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.IncomingCall.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.IncomingCall.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from an IncomingCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IncomingCall
         * @static
         * @param {server.IncomingCall} message IncomingCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncomingCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.callId = "";
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.webrtcOffer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.serverSentTsMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverSentTsMs = options.longs === String ? "0" : 0;
                object.callConfig = null;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.serverSentTsMs != null && message.hasOwnProperty("serverSentTsMs"))
                if (typeof message.serverSentTsMs === "number")
                    object.serverSentTsMs = options.longs === String ? String(message.serverSentTsMs) : message.serverSentTsMs;
                else
                    object.serverSentTsMs = options.longs === String ? $util.Long.prototype.toString.call(message.serverSentTsMs) : options.longs === Number ? new $util.LongBits(message.serverSentTsMs.low >>> 0, message.serverSentTsMs.high >>> 0).toNumber() : message.serverSentTsMs;
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this IncomingCall to JSON.
         * @function toJSON
         * @memberof server.IncomingCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncomingCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IncomingCall;
    })();

    server.IceCandidate = (function() {

        /**
         * Properties of an IceCandidate.
         * @memberof server
         * @interface IIceCandidate
         * @property {string|null} [callId] IceCandidate callId
         * @property {string|null} [sdpMediaId] IceCandidate sdpMediaId
         * @property {number|null} [sdpMediaLineIndex] IceCandidate sdpMediaLineIndex
         * @property {string|null} [sdp] IceCandidate sdp
         */

        /**
         * Constructs a new IceCandidate.
         * @memberof server
         * @classdesc Represents an IceCandidate.
         * @implements IIceCandidate
         * @constructor
         * @param {server.IIceCandidate=} [properties] Properties to set
         */
        function IceCandidate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceCandidate callId.
         * @member {string} callId
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.callId = "";

        /**
         * IceCandidate sdpMediaId.
         * @member {string} sdpMediaId
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdpMediaId = "";

        /**
         * IceCandidate sdpMediaLineIndex.
         * @member {number} sdpMediaLineIndex
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdpMediaLineIndex = 0;

        /**
         * IceCandidate sdp.
         * @member {string} sdp
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdp = "";

        /**
         * Creates a new IceCandidate instance using the specified properties.
         * @function create
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate=} [properties] Properties to set
         * @returns {server.IceCandidate} IceCandidate instance
         */
        IceCandidate.create = function create(properties) {
            return new IceCandidate(properties);
        };

        /**
         * Encodes the specified IceCandidate message. Does not implicitly {@link server.IceCandidate.verify|verify} messages.
         * @function encode
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.sdpMediaId != null && Object.hasOwnProperty.call(message, "sdpMediaId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdpMediaId);
            if (message.sdpMediaLineIndex != null && Object.hasOwnProperty.call(message, "sdpMediaLineIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sdpMediaLineIndex);
            if (message.sdp != null && Object.hasOwnProperty.call(message, "sdp"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sdp);
            return writer;
        };

        /**
         * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link server.IceCandidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceCandidate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.sdpMediaId = reader.string();
                    break;
                case 3:
                    message.sdpMediaLineIndex = reader.int32();
                    break;
                case 4:
                    message.sdp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceCandidate message.
         * @function verify
         * @memberof server.IceCandidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceCandidate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.sdpMediaId != null && message.hasOwnProperty("sdpMediaId"))
                if (!$util.isString(message.sdpMediaId))
                    return "sdpMediaId: string expected";
            if (message.sdpMediaLineIndex != null && message.hasOwnProperty("sdpMediaLineIndex"))
                if (!$util.isInteger(message.sdpMediaLineIndex))
                    return "sdpMediaLineIndex: integer expected";
            if (message.sdp != null && message.hasOwnProperty("sdp"))
                if (!$util.isString(message.sdp))
                    return "sdp: string expected";
            return null;
        };

        /**
         * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceCandidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceCandidate} IceCandidate
         */
        IceCandidate.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceCandidate)
                return object;
            var message = new $root.server.IceCandidate();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.sdpMediaId != null)
                message.sdpMediaId = String(object.sdpMediaId);
            if (object.sdpMediaLineIndex != null)
                message.sdpMediaLineIndex = object.sdpMediaLineIndex | 0;
            if (object.sdp != null)
                message.sdp = String(object.sdp);
            return message;
        };

        /**
         * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceCandidate
         * @static
         * @param {server.IceCandidate} message IceCandidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceCandidate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.sdpMediaId = "";
                object.sdpMediaLineIndex = 0;
                object.sdp = "";
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.sdpMediaId != null && message.hasOwnProperty("sdpMediaId"))
                object.sdpMediaId = message.sdpMediaId;
            if (message.sdpMediaLineIndex != null && message.hasOwnProperty("sdpMediaLineIndex"))
                object.sdpMediaLineIndex = message.sdpMediaLineIndex;
            if (message.sdp != null && message.hasOwnProperty("sdp"))
                object.sdp = message.sdp;
            return object;
        };

        /**
         * Converts this IceCandidate to JSON.
         * @function toJSON
         * @memberof server.IceCandidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceCandidate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceCandidate;
    })();

    server.CallRinging = (function() {

        /**
         * Properties of a CallRinging.
         * @memberof server
         * @interface ICallRinging
         * @property {string|null} [callId] CallRinging callId
         * @property {number|Long|null} [timestampMs] CallRinging timestampMs
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] CallRinging webrtcAnswer
         */

        /**
         * Constructs a new CallRinging.
         * @memberof server
         * @classdesc Represents a CallRinging.
         * @implements ICallRinging
         * @constructor
         * @param {server.ICallRinging=} [properties] Properties to set
         */
        function CallRinging(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallRinging callId.
         * @member {string} callId
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.callId = "";

        /**
         * CallRinging timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CallRinging webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.webrtcAnswer = null;

        /**
         * Creates a new CallRinging instance using the specified properties.
         * @function create
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging=} [properties] Properties to set
         * @returns {server.CallRinging} CallRinging instance
         */
        CallRinging.create = function create(properties) {
            return new CallRinging(properties);
        };

        /**
         * Encodes the specified CallRinging message. Does not implicitly {@link server.CallRinging.verify|verify} messages.
         * @function encode
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging} message CallRinging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallRinging.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestampMs);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CallRinging message, length delimited. Does not implicitly {@link server.CallRinging.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging} message CallRinging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallRinging.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallRinging message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallRinging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallRinging} CallRinging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallRinging.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallRinging();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.timestampMs = reader.int64();
                    break;
                case 3:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallRinging message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallRinging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallRinging} CallRinging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallRinging.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallRinging message.
         * @function verify
         * @memberof server.CallRinging
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallRinging.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            return null;
        };

        /**
         * Creates a CallRinging message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallRinging
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallRinging} CallRinging
         */
        CallRinging.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallRinging)
                return object;
            var message = new $root.server.CallRinging();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.CallRinging.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallRinging message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallRinging
         * @static
         * @param {server.CallRinging} message CallRinging
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallRinging.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.webrtcAnswer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            return object;
        };

        /**
         * Converts this CallRinging to JSON.
         * @function toJSON
         * @memberof server.CallRinging
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallRinging.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallRinging;
    })();

    server.PreAnswerCall = (function() {

        /**
         * Properties of a PreAnswerCall.
         * @memberof server
         * @interface IPreAnswerCall
         * @property {string|null} [callId] PreAnswerCall callId
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] PreAnswerCall webrtcAnswer
         * @property {number|Long|null} [timestampMs] PreAnswerCall timestampMs
         */

        /**
         * Constructs a new PreAnswerCall.
         * @memberof server
         * @classdesc Represents a PreAnswerCall.
         * @implements IPreAnswerCall
         * @constructor
         * @param {server.IPreAnswerCall=} [properties] Properties to set
         */
        function PreAnswerCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreAnswerCall callId.
         * @member {string} callId
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.callId = "";

        /**
         * PreAnswerCall webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.webrtcAnswer = null;

        /**
         * PreAnswerCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PreAnswerCall instance using the specified properties.
         * @function create
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall=} [properties] Properties to set
         * @returns {server.PreAnswerCall} PreAnswerCall instance
         */
        PreAnswerCall.create = function create(properties) {
            return new PreAnswerCall(properties);
        };

        /**
         * Encodes the specified PreAnswerCall message. Does not implicitly {@link server.PreAnswerCall.verify|verify} messages.
         * @function encode
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall} message PreAnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAnswerCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified PreAnswerCall message, length delimited. Does not implicitly {@link server.PreAnswerCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall} message PreAnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAnswerCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreAnswerCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.PreAnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PreAnswerCall} PreAnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAnswerCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PreAnswerCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreAnswerCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PreAnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PreAnswerCall} PreAnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAnswerCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreAnswerCall message.
         * @function verify
         * @memberof server.PreAnswerCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreAnswerCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a PreAnswerCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PreAnswerCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PreAnswerCall} PreAnswerCall
         */
        PreAnswerCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PreAnswerCall)
                return object;
            var message = new $root.server.PreAnswerCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.PreAnswerCall.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PreAnswerCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.PreAnswerCall} message PreAnswerCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreAnswerCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.webrtcAnswer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this PreAnswerCall to JSON.
         * @function toJSON
         * @memberof server.PreAnswerCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreAnswerCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreAnswerCall;
    })();

    server.AnswerCall = (function() {

        /**
         * Properties of an AnswerCall.
         * @memberof server
         * @interface IAnswerCall
         * @property {string|null} [callId] AnswerCall callId
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] AnswerCall webrtcAnswer
         * @property {number|Long|null} [timestampMs] AnswerCall timestampMs
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] AnswerCall webrtcOffer
         */

        /**
         * Constructs a new AnswerCall.
         * @memberof server
         * @classdesc Represents an AnswerCall.
         * @implements IAnswerCall
         * @constructor
         * @param {server.IAnswerCall=} [properties] Properties to set
         */
        function AnswerCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnswerCall callId.
         * @member {string} callId
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.callId = "";

        /**
         * AnswerCall webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.webrtcAnswer = null;

        /**
         * AnswerCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnswerCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.webrtcOffer = null;

        /**
         * Creates a new AnswerCall instance using the specified properties.
         * @function create
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall=} [properties] Properties to set
         * @returns {server.AnswerCall} AnswerCall instance
         */
        AnswerCall.create = function create(properties) {
            return new AnswerCall(properties);
        };

        /**
         * Encodes the specified AnswerCall message. Does not implicitly {@link server.AnswerCall.verify|verify} messages.
         * @function encode
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall} message AnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnswerCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AnswerCall message, length delimited. Does not implicitly {@link server.AnswerCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall} message AnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnswerCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnswerCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.AnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AnswerCall} AnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnswerCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AnswerCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                case 4:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnswerCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AnswerCall} AnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnswerCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnswerCall message.
         * @function verify
         * @memberof server.AnswerCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnswerCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            return null;
        };

        /**
         * Creates an AnswerCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AnswerCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AnswerCall} AnswerCall
         */
        AnswerCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AnswerCall)
                return object;
            var message = new $root.server.AnswerCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.AnswerCall.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.AnswerCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            return message;
        };

        /**
         * Creates a plain object from an AnswerCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AnswerCall
         * @static
         * @param {server.AnswerCall} message AnswerCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnswerCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.webrtcAnswer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.webrtcOffer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            return object;
        };

        /**
         * Converts this AnswerCall to JSON.
         * @function toJSON
         * @memberof server.AnswerCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnswerCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnswerCall;
    })();

    server.CallSdp = (function() {

        /**
         * Properties of a CallSdp.
         * @memberof server
         * @interface ICallSdp
         * @property {string|null} [callId] CallSdp callId
         * @property {server.CallSdp.SdpType|null} [sdpType] CallSdp sdpType
         * @property {server.IWebRtcSessionDescription|null} [info] CallSdp info
         * @property {number|Long|null} [timestampMs] CallSdp timestampMs
         */

        /**
         * Constructs a new CallSdp.
         * @memberof server
         * @classdesc Represents a CallSdp.
         * @implements ICallSdp
         * @constructor
         * @param {server.ICallSdp=} [properties] Properties to set
         */
        function CallSdp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallSdp callId.
         * @member {string} callId
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.callId = "";

        /**
         * CallSdp sdpType.
         * @member {server.CallSdp.SdpType} sdpType
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.sdpType = 0;

        /**
         * CallSdp info.
         * @member {server.IWebRtcSessionDescription|null|undefined} info
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.info = null;

        /**
         * CallSdp timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CallSdp instance using the specified properties.
         * @function create
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp=} [properties] Properties to set
         * @returns {server.CallSdp} CallSdp instance
         */
        CallSdp.create = function create(properties) {
            return new CallSdp(properties);
        };

        /**
         * Encodes the specified CallSdp message. Does not implicitly {@link server.CallSdp.verify|verify} messages.
         * @function encode
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp} message CallSdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallSdp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.sdpType != null && Object.hasOwnProperty.call(message, "sdpType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sdpType);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.server.WebRtcSessionDescription.encode(message.info, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified CallSdp message, length delimited. Does not implicitly {@link server.CallSdp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp} message CallSdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallSdp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallSdp message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallSdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallSdp} CallSdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallSdp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallSdp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.sdpType = reader.int32();
                    break;
                case 3:
                    message.info = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallSdp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallSdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallSdp} CallSdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallSdp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallSdp message.
         * @function verify
         * @memberof server.CallSdp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallSdp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.sdpType != null && message.hasOwnProperty("sdpType"))
                switch (message.sdpType) {
                default:
                    return "sdpType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a CallSdp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallSdp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallSdp} CallSdp
         */
        CallSdp.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallSdp)
                return object;
            var message = new $root.server.CallSdp();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.sdpType) {
            case "UNKNOWN":
            case 0:
                message.sdpType = 0;
                break;
            case "OFFER":
            case 1:
                message.sdpType = 1;
                break;
            case "ANSWER":
            case 2:
                message.sdpType = 2;
                break;
            }
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".server.CallSdp.info: object expected");
                message.info = $root.server.WebRtcSessionDescription.fromObject(object.info);
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CallSdp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallSdp
         * @static
         * @param {server.CallSdp} message CallSdp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallSdp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.sdpType = options.enums === String ? "UNKNOWN" : 0;
                object.info = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.sdpType != null && message.hasOwnProperty("sdpType"))
                object.sdpType = options.enums === String ? $root.server.CallSdp.SdpType[message.sdpType] : message.sdpType;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.server.WebRtcSessionDescription.toObject(message.info, options);
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this CallSdp to JSON.
         * @function toJSON
         * @memberof server.CallSdp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallSdp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * SdpType enum.
         * @name server.CallSdp.SdpType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OFFER=1 OFFER value
         * @property {number} ANSWER=2 ANSWER value
         */
        CallSdp.SdpType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OFFER"] = 1;
            values[valuesById[2] = "ANSWER"] = 2;
            return values;
        })();

        return CallSdp;
    })();

    server.EndCall = (function() {

        /**
         * Properties of an EndCall.
         * @memberof server
         * @interface IEndCall
         * @property {string|null} [callId] EndCall callId
         * @property {server.EndCall.Reason|null} [reason] EndCall reason
         * @property {number|Long|null} [timestampMs] EndCall timestampMs
         */

        /**
         * Constructs a new EndCall.
         * @memberof server
         * @classdesc Represents an EndCall.
         * @implements IEndCall
         * @constructor
         * @param {server.IEndCall=} [properties] Properties to set
         */
        function EndCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EndCall callId.
         * @member {string} callId
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.callId = "";

        /**
         * EndCall reason.
         * @member {server.EndCall.Reason} reason
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.reason = 0;

        /**
         * EndCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EndCall instance using the specified properties.
         * @function create
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall=} [properties] Properties to set
         * @returns {server.EndCall} EndCall instance
         */
        EndCall.create = function create(properties) {
            return new EndCall(properties);
        };

        /**
         * Encodes the specified EndCall message. Does not implicitly {@link server.EndCall.verify|verify} messages.
         * @function encode
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall} message EndCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified EndCall message, length delimited. Does not implicitly {@link server.EndCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall} message EndCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EndCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.EndCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EndCall} EndCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EndCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EndCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EndCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EndCall} EndCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EndCall message.
         * @function verify
         * @memberof server.EndCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EndCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates an EndCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EndCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EndCall} EndCall
         */
        EndCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EndCall)
                return object;
            var message = new $root.server.EndCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.reason) {
            case "UNKNOWN":
            case 0:
                message.reason = 0;
                break;
            case "REJECT":
            case 1:
                message.reason = 1;
                break;
            case "BUSY":
            case 2:
                message.reason = 2;
                break;
            case "TIMEOUT":
            case 3:
                message.reason = 3;
                break;
            case "CALL_END":
            case 4:
                message.reason = 4;
                break;
            case "CANCEL":
            case 5:
                message.reason = 5;
                break;
            case "DECRYPTION_FAILED":
            case 6:
                message.reason = 6;
                break;
            case "ENCRYPTION_FAILED":
            case 7:
                message.reason = 7;
                break;
            case "SYSTEM_ERROR":
            case 8:
                message.reason = 8;
                break;
            case "VIDEO_UNSUPPORTED":
            case 9:
                message.reason = 9;
                break;
            case "CONNECTION_ERROR":
            case 10:
                message.reason = 10;
                break;
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EndCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EndCall
         * @static
         * @param {server.EndCall} message EndCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EndCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.reason = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.EndCall.Reason[message.reason] : message.reason;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this EndCall to JSON.
         * @function toJSON
         * @memberof server.EndCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EndCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.EndCall.Reason
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REJECT=1 REJECT value
         * @property {number} BUSY=2 BUSY value
         * @property {number} TIMEOUT=3 TIMEOUT value
         * @property {number} CALL_END=4 CALL_END value
         * @property {number} CANCEL=5 CANCEL value
         * @property {number} DECRYPTION_FAILED=6 DECRYPTION_FAILED value
         * @property {number} ENCRYPTION_FAILED=7 ENCRYPTION_FAILED value
         * @property {number} SYSTEM_ERROR=8 SYSTEM_ERROR value
         * @property {number} VIDEO_UNSUPPORTED=9 VIDEO_UNSUPPORTED value
         * @property {number} CONNECTION_ERROR=10 CONNECTION_ERROR value
         */
        EndCall.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REJECT"] = 1;
            values[valuesById[2] = "BUSY"] = 2;
            values[valuesById[3] = "TIMEOUT"] = 3;
            values[valuesById[4] = "CALL_END"] = 4;
            values[valuesById[5] = "CANCEL"] = 5;
            values[valuesById[6] = "DECRYPTION_FAILED"] = 6;
            values[valuesById[7] = "ENCRYPTION_FAILED"] = 7;
            values[valuesById[8] = "SYSTEM_ERROR"] = 8;
            values[valuesById[9] = "VIDEO_UNSUPPORTED"] = 9;
            values[valuesById[10] = "CONNECTION_ERROR"] = 10;
            return values;
        })();

        return EndCall;
    })();

    server.IceRestartOffer = (function() {

        /**
         * Properties of an IceRestartOffer.
         * @memberof server
         * @interface IIceRestartOffer
         * @property {string|null} [callId] IceRestartOffer callId
         * @property {number|null} [idx] IceRestartOffer idx
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] IceRestartOffer webrtcOffer
         */

        /**
         * Constructs a new IceRestartOffer.
         * @memberof server
         * @classdesc Represents an IceRestartOffer.
         * @implements IIceRestartOffer
         * @constructor
         * @param {server.IIceRestartOffer=} [properties] Properties to set
         */
        function IceRestartOffer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceRestartOffer callId.
         * @member {string} callId
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.callId = "";

        /**
         * IceRestartOffer idx.
         * @member {number} idx
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.idx = 0;

        /**
         * IceRestartOffer webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.webrtcOffer = null;

        /**
         * Creates a new IceRestartOffer instance using the specified properties.
         * @function create
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer=} [properties] Properties to set
         * @returns {server.IceRestartOffer} IceRestartOffer instance
         */
        IceRestartOffer.create = function create(properties) {
            return new IceRestartOffer(properties);
        };

        /**
         * Encodes the specified IceRestartOffer message. Does not implicitly {@link server.IceRestartOffer.verify|verify} messages.
         * @function encode
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer} message IceRestartOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.idx);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IceRestartOffer message, length delimited. Does not implicitly {@link server.IceRestartOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer} message IceRestartOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceRestartOffer message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceRestartOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceRestartOffer} IceRestartOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceRestartOffer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.idx = reader.int32();
                    break;
                case 3:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceRestartOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceRestartOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceRestartOffer} IceRestartOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceRestartOffer message.
         * @function verify
         * @memberof server.IceRestartOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceRestartOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            return null;
        };

        /**
         * Creates an IceRestartOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceRestartOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceRestartOffer} IceRestartOffer
         */
        IceRestartOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceRestartOffer)
                return object;
            var message = new $root.server.IceRestartOffer();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.IceRestartOffer.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            return message;
        };

        /**
         * Creates a plain object from an IceRestartOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IceRestartOffer} message IceRestartOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceRestartOffer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.idx = 0;
                object.webrtcOffer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            return object;
        };

        /**
         * Converts this IceRestartOffer to JSON.
         * @function toJSON
         * @memberof server.IceRestartOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceRestartOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceRestartOffer;
    })();

    server.IceRestartAnswer = (function() {

        /**
         * Properties of an IceRestartAnswer.
         * @memberof server
         * @interface IIceRestartAnswer
         * @property {string|null} [callId] IceRestartAnswer callId
         * @property {number|null} [idx] IceRestartAnswer idx
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] IceRestartAnswer webrtcAnswer
         */

        /**
         * Constructs a new IceRestartAnswer.
         * @memberof server
         * @classdesc Represents an IceRestartAnswer.
         * @implements IIceRestartAnswer
         * @constructor
         * @param {server.IIceRestartAnswer=} [properties] Properties to set
         */
        function IceRestartAnswer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceRestartAnswer callId.
         * @member {string} callId
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.callId = "";

        /**
         * IceRestartAnswer idx.
         * @member {number} idx
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.idx = 0;

        /**
         * IceRestartAnswer webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.webrtcAnswer = null;

        /**
         * Creates a new IceRestartAnswer instance using the specified properties.
         * @function create
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer=} [properties] Properties to set
         * @returns {server.IceRestartAnswer} IceRestartAnswer instance
         */
        IceRestartAnswer.create = function create(properties) {
            return new IceRestartAnswer(properties);
        };

        /**
         * Encodes the specified IceRestartAnswer message. Does not implicitly {@link server.IceRestartAnswer.verify|verify} messages.
         * @function encode
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer} message IceRestartAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartAnswer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.idx);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IceRestartAnswer message, length delimited. Does not implicitly {@link server.IceRestartAnswer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer} message IceRestartAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartAnswer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceRestartAnswer message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceRestartAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartAnswer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceRestartAnswer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.idx = reader.int32();
                    break;
                case 3:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceRestartAnswer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceRestartAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartAnswer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceRestartAnswer message.
         * @function verify
         * @memberof server.IceRestartAnswer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceRestartAnswer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            return null;
        };

        /**
         * Creates an IceRestartAnswer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceRestartAnswer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         */
        IceRestartAnswer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceRestartAnswer)
                return object;
            var message = new $root.server.IceRestartAnswer();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.IceRestartAnswer.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            return message;
        };

        /**
         * Creates a plain object from an IceRestartAnswer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IceRestartAnswer} message IceRestartAnswer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceRestartAnswer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.idx = 0;
                object.webrtcAnswer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            return object;
        };

        /**
         * Converts this IceRestartAnswer to JSON.
         * @function toJSON
         * @memberof server.IceRestartAnswer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceRestartAnswer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceRestartAnswer;
    })();

    server.HoldCall = (function() {

        /**
         * Properties of a HoldCall.
         * @memberof server
         * @interface IHoldCall
         * @property {string|null} [callId] HoldCall callId
         * @property {boolean|null} [hold] HoldCall hold
         * @property {number|Long|null} [timestampMs] HoldCall timestampMs
         */

        /**
         * Constructs a new HoldCall.
         * @memberof server
         * @classdesc Represents a HoldCall.
         * @implements IHoldCall
         * @constructor
         * @param {server.IHoldCall=} [properties] Properties to set
         */
        function HoldCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HoldCall callId.
         * @member {string} callId
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.callId = "";

        /**
         * HoldCall hold.
         * @member {boolean} hold
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.hold = false;

        /**
         * HoldCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new HoldCall instance using the specified properties.
         * @function create
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall=} [properties] Properties to set
         * @returns {server.HoldCall} HoldCall instance
         */
        HoldCall.create = function create(properties) {
            return new HoldCall(properties);
        };

        /**
         * Encodes the specified HoldCall message. Does not implicitly {@link server.HoldCall.verify|verify} messages.
         * @function encode
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall} message HoldCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HoldCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.hold != null && Object.hasOwnProperty.call(message, "hold"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hold);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified HoldCall message, length delimited. Does not implicitly {@link server.HoldCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall} message HoldCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HoldCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HoldCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.HoldCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HoldCall} HoldCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HoldCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HoldCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.hold = reader.bool();
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HoldCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HoldCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HoldCall} HoldCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HoldCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HoldCall message.
         * @function verify
         * @memberof server.HoldCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HoldCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.hold != null && message.hasOwnProperty("hold"))
                if (typeof message.hold !== "boolean")
                    return "hold: boolean expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a HoldCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HoldCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HoldCall} HoldCall
         */
        HoldCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HoldCall)
                return object;
            var message = new $root.server.HoldCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.hold != null)
                message.hold = Boolean(object.hold);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a HoldCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HoldCall
         * @static
         * @param {server.HoldCall} message HoldCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HoldCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.hold = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.hold != null && message.hasOwnProperty("hold"))
                object.hold = message.hold;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this HoldCall to JSON.
         * @function toJSON
         * @memberof server.HoldCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HoldCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HoldCall;
    })();

    server.MuteCall = (function() {

        /**
         * Properties of a MuteCall.
         * @memberof server
         * @interface IMuteCall
         * @property {string|null} [callId] MuteCall callId
         * @property {server.MuteCall.MediaType|null} [mediaType] MuteCall mediaType
         * @property {boolean|null} [muted] MuteCall muted
         * @property {number|Long|null} [timestampMs] MuteCall timestampMs
         */

        /**
         * Constructs a new MuteCall.
         * @memberof server
         * @classdesc Represents a MuteCall.
         * @implements IMuteCall
         * @constructor
         * @param {server.IMuteCall=} [properties] Properties to set
         */
        function MuteCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MuteCall callId.
         * @member {string} callId
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.callId = "";

        /**
         * MuteCall mediaType.
         * @member {server.MuteCall.MediaType} mediaType
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.mediaType = 0;

        /**
         * MuteCall muted.
         * @member {boolean} muted
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.muted = false;

        /**
         * MuteCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MuteCall instance using the specified properties.
         * @function create
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall=} [properties] Properties to set
         * @returns {server.MuteCall} MuteCall instance
         */
        MuteCall.create = function create(properties) {
            return new MuteCall(properties);
        };

        /**
         * Encodes the specified MuteCall message. Does not implicitly {@link server.MuteCall.verify|verify} messages.
         * @function encode
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall} message MuteCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MuteCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaType);
            if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.muted);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified MuteCall message, length delimited. Does not implicitly {@link server.MuteCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall} message MuteCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MuteCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MuteCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.MuteCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MuteCall} MuteCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MuteCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MuteCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.mediaType = reader.int32();
                    break;
                case 3:
                    message.muted = reader.bool();
                    break;
                case 4:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MuteCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MuteCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MuteCall} MuteCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MuteCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MuteCall message.
         * @function verify
         * @memberof server.MuteCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MuteCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.muted != null && message.hasOwnProperty("muted"))
                if (typeof message.muted !== "boolean")
                    return "muted: boolean expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a MuteCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MuteCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MuteCall} MuteCall
         */
        MuteCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MuteCall)
                return object;
            var message = new $root.server.MuteCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.mediaType) {
            case "AUDIO":
            case 0:
                message.mediaType = 0;
                break;
            case "VIDEO":
            case 1:
                message.mediaType = 1;
                break;
            }
            if (object.muted != null)
                message.muted = Boolean(object.muted);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MuteCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MuteCall
         * @static
         * @param {server.MuteCall} message MuteCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MuteCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.mediaType = options.enums === String ? "AUDIO" : 0;
                object.muted = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.server.MuteCall.MediaType[message.mediaType] : message.mediaType;
            if (message.muted != null && message.hasOwnProperty("muted"))
                object.muted = message.muted;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this MuteCall to JSON.
         * @function toJSON
         * @memberof server.MuteCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MuteCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * MediaType enum.
         * @name server.MuteCall.MediaType
         * @enum {number}
         * @property {number} AUDIO=0 AUDIO value
         * @property {number} VIDEO=1 VIDEO value
         */
        MuteCall.MediaType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AUDIO"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            return values;
        })();

        return MuteCall;
    })();

    server.CallConfig = (function() {

        /**
         * Properties of a CallConfig.
         * @memberof server
         * @interface ICallConfig
         * @property {number|null} [audioBitrateMax] CallConfig audioBitrateMax
         * @property {number|null} [videoBitrateMax] CallConfig videoBitrateMax
         * @property {number|null} [audioCodec] CallConfig audioCodec
         * @property {number|null} [videoCodec] CallConfig videoCodec
         * @property {number|null} [videoWidth] CallConfig videoWidth
         * @property {number|null} [videoHeight] CallConfig videoHeight
         * @property {number|null} [videoFps] CallConfig videoFps
         * @property {number|null} [audioJitterBufferMaxPackets] CallConfig audioJitterBufferMaxPackets
         * @property {boolean|null} [audioJitterBufferFastAccelerate] CallConfig audioJitterBufferFastAccelerate
         * @property {server.CallConfig.IceTransportPolicy|null} [iceTransportPolicy] CallConfig iceTransportPolicy
         * @property {number|null} [iceRestartDelayMs] CallConfig iceRestartDelayMs
         * @property {boolean|null} [pruneTurnPorts] CallConfig pruneTurnPorts
         * @property {number|null} [iceCandidatePoolSize] CallConfig iceCandidatePoolSize
         * @property {number|null} [iceBackupPingIntervalMs] CallConfig iceBackupPingIntervalMs
         * @property {number|null} [iceConnectionTimeoutMs] CallConfig iceConnectionTimeoutMs
         */

        /**
         * Constructs a new CallConfig.
         * @memberof server
         * @classdesc Represents a CallConfig.
         * @implements ICallConfig
         * @constructor
         * @param {server.ICallConfig=} [properties] Properties to set
         */
        function CallConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallConfig audioBitrateMax.
         * @member {number} audioBitrateMax
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioBitrateMax = 0;

        /**
         * CallConfig videoBitrateMax.
         * @member {number} videoBitrateMax
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoBitrateMax = 0;

        /**
         * CallConfig audioCodec.
         * @member {number} audioCodec
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioCodec = 0;

        /**
         * CallConfig videoCodec.
         * @member {number} videoCodec
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoCodec = 0;

        /**
         * CallConfig videoWidth.
         * @member {number} videoWidth
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoWidth = 0;

        /**
         * CallConfig videoHeight.
         * @member {number} videoHeight
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoHeight = 0;

        /**
         * CallConfig videoFps.
         * @member {number} videoFps
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoFps = 0;

        /**
         * CallConfig audioJitterBufferMaxPackets.
         * @member {number} audioJitterBufferMaxPackets
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioJitterBufferMaxPackets = 0;

        /**
         * CallConfig audioJitterBufferFastAccelerate.
         * @member {boolean} audioJitterBufferFastAccelerate
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioJitterBufferFastAccelerate = false;

        /**
         * CallConfig iceTransportPolicy.
         * @member {server.CallConfig.IceTransportPolicy} iceTransportPolicy
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceTransportPolicy = 0;

        /**
         * CallConfig iceRestartDelayMs.
         * @member {number} iceRestartDelayMs
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceRestartDelayMs = 0;

        /**
         * CallConfig pruneTurnPorts.
         * @member {boolean} pruneTurnPorts
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.pruneTurnPorts = false;

        /**
         * CallConfig iceCandidatePoolSize.
         * @member {number} iceCandidatePoolSize
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceCandidatePoolSize = 0;

        /**
         * CallConfig iceBackupPingIntervalMs.
         * @member {number} iceBackupPingIntervalMs
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceBackupPingIntervalMs = 0;

        /**
         * CallConfig iceConnectionTimeoutMs.
         * @member {number} iceConnectionTimeoutMs
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceConnectionTimeoutMs = 0;

        /**
         * Creates a new CallConfig instance using the specified properties.
         * @function create
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig=} [properties] Properties to set
         * @returns {server.CallConfig} CallConfig instance
         */
        CallConfig.create = function create(properties) {
            return new CallConfig(properties);
        };

        /**
         * Encodes the specified CallConfig message. Does not implicitly {@link server.CallConfig.verify|verify} messages.
         * @function encode
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig} message CallConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioBitrateMax != null && Object.hasOwnProperty.call(message, "audioBitrateMax"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.audioBitrateMax);
            if (message.videoBitrateMax != null && Object.hasOwnProperty.call(message, "videoBitrateMax"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.videoBitrateMax);
            if (message.audioCodec != null && Object.hasOwnProperty.call(message, "audioCodec"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.audioCodec);
            if (message.videoCodec != null && Object.hasOwnProperty.call(message, "videoCodec"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.videoCodec);
            if (message.videoWidth != null && Object.hasOwnProperty.call(message, "videoWidth"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.videoWidth);
            if (message.videoHeight != null && Object.hasOwnProperty.call(message, "videoHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.videoHeight);
            if (message.videoFps != null && Object.hasOwnProperty.call(message, "videoFps"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.videoFps);
            if (message.audioJitterBufferMaxPackets != null && Object.hasOwnProperty.call(message, "audioJitterBufferMaxPackets"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.audioJitterBufferMaxPackets);
            if (message.audioJitterBufferFastAccelerate != null && Object.hasOwnProperty.call(message, "audioJitterBufferFastAccelerate"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.audioJitterBufferFastAccelerate);
            if (message.iceTransportPolicy != null && Object.hasOwnProperty.call(message, "iceTransportPolicy"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.iceTransportPolicy);
            if (message.iceRestartDelayMs != null && Object.hasOwnProperty.call(message, "iceRestartDelayMs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.iceRestartDelayMs);
            if (message.pruneTurnPorts != null && Object.hasOwnProperty.call(message, "pruneTurnPorts"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.pruneTurnPorts);
            if (message.iceCandidatePoolSize != null && Object.hasOwnProperty.call(message, "iceCandidatePoolSize"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.iceCandidatePoolSize);
            if (message.iceBackupPingIntervalMs != null && Object.hasOwnProperty.call(message, "iceBackupPingIntervalMs"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.iceBackupPingIntervalMs);
            if (message.iceConnectionTimeoutMs != null && Object.hasOwnProperty.call(message, "iceConnectionTimeoutMs"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.iceConnectionTimeoutMs);
            return writer;
        };

        /**
         * Encodes the specified CallConfig message, length delimited. Does not implicitly {@link server.CallConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig} message CallConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallConfig message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallConfig} CallConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audioBitrateMax = reader.int32();
                    break;
                case 2:
                    message.videoBitrateMax = reader.int32();
                    break;
                case 3:
                    message.audioCodec = reader.int32();
                    break;
                case 4:
                    message.videoCodec = reader.int32();
                    break;
                case 5:
                    message.videoWidth = reader.int32();
                    break;
                case 6:
                    message.videoHeight = reader.int32();
                    break;
                case 7:
                    message.videoFps = reader.int32();
                    break;
                case 8:
                    message.audioJitterBufferMaxPackets = reader.int32();
                    break;
                case 9:
                    message.audioJitterBufferFastAccelerate = reader.bool();
                    break;
                case 10:
                    message.iceTransportPolicy = reader.int32();
                    break;
                case 11:
                    message.iceRestartDelayMs = reader.int32();
                    break;
                case 12:
                    message.pruneTurnPorts = reader.bool();
                    break;
                case 13:
                    message.iceCandidatePoolSize = reader.int32();
                    break;
                case 14:
                    message.iceBackupPingIntervalMs = reader.int32();
                    break;
                case 15:
                    message.iceConnectionTimeoutMs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallConfig} CallConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallConfig message.
         * @function verify
         * @memberof server.CallConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioBitrateMax != null && message.hasOwnProperty("audioBitrateMax"))
                if (!$util.isInteger(message.audioBitrateMax))
                    return "audioBitrateMax: integer expected";
            if (message.videoBitrateMax != null && message.hasOwnProperty("videoBitrateMax"))
                if (!$util.isInteger(message.videoBitrateMax))
                    return "videoBitrateMax: integer expected";
            if (message.audioCodec != null && message.hasOwnProperty("audioCodec"))
                if (!$util.isInteger(message.audioCodec))
                    return "audioCodec: integer expected";
            if (message.videoCodec != null && message.hasOwnProperty("videoCodec"))
                if (!$util.isInteger(message.videoCodec))
                    return "videoCodec: integer expected";
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                if (!$util.isInteger(message.videoWidth))
                    return "videoWidth: integer expected";
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                if (!$util.isInteger(message.videoHeight))
                    return "videoHeight: integer expected";
            if (message.videoFps != null && message.hasOwnProperty("videoFps"))
                if (!$util.isInteger(message.videoFps))
                    return "videoFps: integer expected";
            if (message.audioJitterBufferMaxPackets != null && message.hasOwnProperty("audioJitterBufferMaxPackets"))
                if (!$util.isInteger(message.audioJitterBufferMaxPackets))
                    return "audioJitterBufferMaxPackets: integer expected";
            if (message.audioJitterBufferFastAccelerate != null && message.hasOwnProperty("audioJitterBufferFastAccelerate"))
                if (typeof message.audioJitterBufferFastAccelerate !== "boolean")
                    return "audioJitterBufferFastAccelerate: boolean expected";
            if (message.iceTransportPolicy != null && message.hasOwnProperty("iceTransportPolicy"))
                switch (message.iceTransportPolicy) {
                default:
                    return "iceTransportPolicy: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.iceRestartDelayMs != null && message.hasOwnProperty("iceRestartDelayMs"))
                if (!$util.isInteger(message.iceRestartDelayMs))
                    return "iceRestartDelayMs: integer expected";
            if (message.pruneTurnPorts != null && message.hasOwnProperty("pruneTurnPorts"))
                if (typeof message.pruneTurnPorts !== "boolean")
                    return "pruneTurnPorts: boolean expected";
            if (message.iceCandidatePoolSize != null && message.hasOwnProperty("iceCandidatePoolSize"))
                if (!$util.isInteger(message.iceCandidatePoolSize))
                    return "iceCandidatePoolSize: integer expected";
            if (message.iceBackupPingIntervalMs != null && message.hasOwnProperty("iceBackupPingIntervalMs"))
                if (!$util.isInteger(message.iceBackupPingIntervalMs))
                    return "iceBackupPingIntervalMs: integer expected";
            if (message.iceConnectionTimeoutMs != null && message.hasOwnProperty("iceConnectionTimeoutMs"))
                if (!$util.isInteger(message.iceConnectionTimeoutMs))
                    return "iceConnectionTimeoutMs: integer expected";
            return null;
        };

        /**
         * Creates a CallConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallConfig} CallConfig
         */
        CallConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallConfig)
                return object;
            var message = new $root.server.CallConfig();
            if (object.audioBitrateMax != null)
                message.audioBitrateMax = object.audioBitrateMax | 0;
            if (object.videoBitrateMax != null)
                message.videoBitrateMax = object.videoBitrateMax | 0;
            if (object.audioCodec != null)
                message.audioCodec = object.audioCodec | 0;
            if (object.videoCodec != null)
                message.videoCodec = object.videoCodec | 0;
            if (object.videoWidth != null)
                message.videoWidth = object.videoWidth | 0;
            if (object.videoHeight != null)
                message.videoHeight = object.videoHeight | 0;
            if (object.videoFps != null)
                message.videoFps = object.videoFps | 0;
            if (object.audioJitterBufferMaxPackets != null)
                message.audioJitterBufferMaxPackets = object.audioJitterBufferMaxPackets | 0;
            if (object.audioJitterBufferFastAccelerate != null)
                message.audioJitterBufferFastAccelerate = Boolean(object.audioJitterBufferFastAccelerate);
            switch (object.iceTransportPolicy) {
            case "ALL":
            case 0:
                message.iceTransportPolicy = 0;
                break;
            case "RELAY":
            case 1:
                message.iceTransportPolicy = 1;
                break;
            }
            if (object.iceRestartDelayMs != null)
                message.iceRestartDelayMs = object.iceRestartDelayMs | 0;
            if (object.pruneTurnPorts != null)
                message.pruneTurnPorts = Boolean(object.pruneTurnPorts);
            if (object.iceCandidatePoolSize != null)
                message.iceCandidatePoolSize = object.iceCandidatePoolSize | 0;
            if (object.iceBackupPingIntervalMs != null)
                message.iceBackupPingIntervalMs = object.iceBackupPingIntervalMs | 0;
            if (object.iceConnectionTimeoutMs != null)
                message.iceConnectionTimeoutMs = object.iceConnectionTimeoutMs | 0;
            return message;
        };

        /**
         * Creates a plain object from a CallConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallConfig
         * @static
         * @param {server.CallConfig} message CallConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audioBitrateMax = 0;
                object.videoBitrateMax = 0;
                object.audioCodec = 0;
                object.videoCodec = 0;
                object.videoWidth = 0;
                object.videoHeight = 0;
                object.videoFps = 0;
                object.audioJitterBufferMaxPackets = 0;
                object.audioJitterBufferFastAccelerate = false;
                object.iceTransportPolicy = options.enums === String ? "ALL" : 0;
                object.iceRestartDelayMs = 0;
                object.pruneTurnPorts = false;
                object.iceCandidatePoolSize = 0;
                object.iceBackupPingIntervalMs = 0;
                object.iceConnectionTimeoutMs = 0;
            }
            if (message.audioBitrateMax != null && message.hasOwnProperty("audioBitrateMax"))
                object.audioBitrateMax = message.audioBitrateMax;
            if (message.videoBitrateMax != null && message.hasOwnProperty("videoBitrateMax"))
                object.videoBitrateMax = message.videoBitrateMax;
            if (message.audioCodec != null && message.hasOwnProperty("audioCodec"))
                object.audioCodec = message.audioCodec;
            if (message.videoCodec != null && message.hasOwnProperty("videoCodec"))
                object.videoCodec = message.videoCodec;
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                object.videoWidth = message.videoWidth;
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                object.videoHeight = message.videoHeight;
            if (message.videoFps != null && message.hasOwnProperty("videoFps"))
                object.videoFps = message.videoFps;
            if (message.audioJitterBufferMaxPackets != null && message.hasOwnProperty("audioJitterBufferMaxPackets"))
                object.audioJitterBufferMaxPackets = message.audioJitterBufferMaxPackets;
            if (message.audioJitterBufferFastAccelerate != null && message.hasOwnProperty("audioJitterBufferFastAccelerate"))
                object.audioJitterBufferFastAccelerate = message.audioJitterBufferFastAccelerate;
            if (message.iceTransportPolicy != null && message.hasOwnProperty("iceTransportPolicy"))
                object.iceTransportPolicy = options.enums === String ? $root.server.CallConfig.IceTransportPolicy[message.iceTransportPolicy] : message.iceTransportPolicy;
            if (message.iceRestartDelayMs != null && message.hasOwnProperty("iceRestartDelayMs"))
                object.iceRestartDelayMs = message.iceRestartDelayMs;
            if (message.pruneTurnPorts != null && message.hasOwnProperty("pruneTurnPorts"))
                object.pruneTurnPorts = message.pruneTurnPorts;
            if (message.iceCandidatePoolSize != null && message.hasOwnProperty("iceCandidatePoolSize"))
                object.iceCandidatePoolSize = message.iceCandidatePoolSize;
            if (message.iceBackupPingIntervalMs != null && message.hasOwnProperty("iceBackupPingIntervalMs"))
                object.iceBackupPingIntervalMs = message.iceBackupPingIntervalMs;
            if (message.iceConnectionTimeoutMs != null && message.hasOwnProperty("iceConnectionTimeoutMs"))
                object.iceConnectionTimeoutMs = message.iceConnectionTimeoutMs;
            return object;
        };

        /**
         * Converts this CallConfig to JSON.
         * @function toJSON
         * @memberof server.CallConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * IceTransportPolicy enum.
         * @name server.CallConfig.IceTransportPolicy
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} RELAY=1 RELAY value
         */
        CallConfig.IceTransportPolicy = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "RELAY"] = 1;
            return values;
        })();

        return CallConfig;
    })();

    server.OgTagInfo = (function() {

        /**
         * Properties of an OgTagInfo.
         * @memberof server
         * @interface IOgTagInfo
         * @property {string|null} [title] OgTagInfo title
         * @property {string|null} [description] OgTagInfo description
         * @property {string|null} [thumbnailUrl] OgTagInfo thumbnailUrl
         * @property {number|null} [thumbnailWidth] OgTagInfo thumbnailWidth
         * @property {number|null} [thumbnailHeight] OgTagInfo thumbnailHeight
         */

        /**
         * Constructs a new OgTagInfo.
         * @memberof server
         * @classdesc Represents an OgTagInfo.
         * @implements IOgTagInfo
         * @constructor
         * @param {server.IOgTagInfo=} [properties] Properties to set
         */
        function OgTagInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OgTagInfo title.
         * @member {string} title
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.title = "";

        /**
         * OgTagInfo description.
         * @member {string} description
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.description = "";

        /**
         * OgTagInfo thumbnailUrl.
         * @member {string} thumbnailUrl
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailUrl = "";

        /**
         * OgTagInfo thumbnailWidth.
         * @member {number} thumbnailWidth
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailWidth = 0;

        /**
         * OgTagInfo thumbnailHeight.
         * @member {number} thumbnailHeight
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailHeight = 0;

        /**
         * Creates a new OgTagInfo instance using the specified properties.
         * @function create
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo=} [properties] Properties to set
         * @returns {server.OgTagInfo} OgTagInfo instance
         */
        OgTagInfo.create = function create(properties) {
            return new OgTagInfo(properties);
        };

        /**
         * Encodes the specified OgTagInfo message. Does not implicitly {@link server.OgTagInfo.verify|verify} messages.
         * @function encode
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo} message OgTagInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OgTagInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
            if (message.thumbnailUrl != null && Object.hasOwnProperty.call(message, "thumbnailUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.thumbnailUrl);
            if (message.thumbnailWidth != null && Object.hasOwnProperty.call(message, "thumbnailWidth"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.thumbnailWidth);
            if (message.thumbnailHeight != null && Object.hasOwnProperty.call(message, "thumbnailHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.thumbnailHeight);
            return writer;
        };

        /**
         * Encodes the specified OgTagInfo message, length delimited. Does not implicitly {@link server.OgTagInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo} message OgTagInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OgTagInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OgTagInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.OgTagInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OgTagInfo} OgTagInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OgTagInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OgTagInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.thumbnailUrl = reader.string();
                    break;
                case 4:
                    message.thumbnailWidth = reader.int32();
                    break;
                case 5:
                    message.thumbnailHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OgTagInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OgTagInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OgTagInfo} OgTagInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OgTagInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OgTagInfo message.
         * @function verify
         * @memberof server.OgTagInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OgTagInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                if (!$util.isString(message.thumbnailUrl))
                    return "thumbnailUrl: string expected";
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                if (!$util.isInteger(message.thumbnailWidth))
                    return "thumbnailWidth: integer expected";
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                if (!$util.isInteger(message.thumbnailHeight))
                    return "thumbnailHeight: integer expected";
            return null;
        };

        /**
         * Creates an OgTagInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OgTagInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OgTagInfo} OgTagInfo
         */
        OgTagInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OgTagInfo)
                return object;
            var message = new $root.server.OgTagInfo();
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.thumbnailUrl != null)
                message.thumbnailUrl = String(object.thumbnailUrl);
            if (object.thumbnailWidth != null)
                message.thumbnailWidth = object.thumbnailWidth | 0;
            if (object.thumbnailHeight != null)
                message.thumbnailHeight = object.thumbnailHeight | 0;
            return message;
        };

        /**
         * Creates a plain object from an OgTagInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OgTagInfo
         * @static
         * @param {server.OgTagInfo} message OgTagInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OgTagInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.title = "";
                object.description = "";
                object.thumbnailUrl = "";
                object.thumbnailWidth = 0;
                object.thumbnailHeight = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                object.thumbnailUrl = message.thumbnailUrl;
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                object.thumbnailWidth = message.thumbnailWidth;
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                object.thumbnailHeight = message.thumbnailHeight;
            return object;
        };

        /**
         * Converts this OgTagInfo to JSON.
         * @function toJSON
         * @memberof server.OgTagInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OgTagInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OgTagInfo;
    })();

    server.ExternalSharePost = (function() {

        /**
         * Properties of an ExternalSharePost.
         * @memberof server
         * @interface IExternalSharePost
         * @property {server.ExternalSharePost.Action|null} [action] ExternalSharePost action
         * @property {string|null} [blobId] ExternalSharePost blobId
         * @property {Uint8Array|null} [blob] ExternalSharePost blob
         * @property {number|Long|null} [expiresInSeconds] ExternalSharePost expiresInSeconds
         * @property {server.IOgTagInfo|null} [ogTagInfo] ExternalSharePost ogTagInfo
         */

        /**
         * Constructs a new ExternalSharePost.
         * @memberof server
         * @classdesc Represents an ExternalSharePost.
         * @implements IExternalSharePost
         * @constructor
         * @param {server.IExternalSharePost=} [properties] Properties to set
         */
        function ExternalSharePost(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalSharePost action.
         * @member {server.ExternalSharePost.Action} action
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.action = 0;

        /**
         * ExternalSharePost blobId.
         * @member {string} blobId
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.blobId = "";

        /**
         * ExternalSharePost blob.
         * @member {Uint8Array} blob
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.blob = $util.newBuffer([]);

        /**
         * ExternalSharePost expiresInSeconds.
         * @member {number|Long} expiresInSeconds
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.expiresInSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExternalSharePost ogTagInfo.
         * @member {server.IOgTagInfo|null|undefined} ogTagInfo
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.ogTagInfo = null;

        /**
         * Creates a new ExternalSharePost instance using the specified properties.
         * @function create
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost=} [properties] Properties to set
         * @returns {server.ExternalSharePost} ExternalSharePost instance
         */
        ExternalSharePost.create = function create(properties) {
            return new ExternalSharePost(properties);
        };

        /**
         * Encodes the specified ExternalSharePost message. Does not implicitly {@link server.ExternalSharePost.verify|verify} messages.
         * @function encode
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost} message ExternalSharePost message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePost.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.blobId != null && Object.hasOwnProperty.call(message, "blobId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blobId);
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.blob);
            if (message.expiresInSeconds != null && Object.hasOwnProperty.call(message, "expiresInSeconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expiresInSeconds);
            if (message.ogTagInfo != null && Object.hasOwnProperty.call(message, "ogTagInfo"))
                $root.server.OgTagInfo.encode(message.ogTagInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExternalSharePost message, length delimited. Does not implicitly {@link server.ExternalSharePost.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost} message ExternalSharePost message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePost.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalSharePost message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExternalSharePost
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExternalSharePost} ExternalSharePost
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePost.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExternalSharePost();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.blobId = reader.string();
                    break;
                case 3:
                    message.blob = reader.bytes();
                    break;
                case 4:
                    message.expiresInSeconds = reader.int64();
                    break;
                case 5:
                    message.ogTagInfo = $root.server.OgTagInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalSharePost message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExternalSharePost
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExternalSharePost} ExternalSharePost
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePost.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalSharePost message.
         * @function verify
         * @memberof server.ExternalSharePost
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalSharePost.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.blobId != null && message.hasOwnProperty("blobId"))
                if (!$util.isString(message.blobId))
                    return "blobId: string expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (!$util.isInteger(message.expiresInSeconds) && !(message.expiresInSeconds && $util.isInteger(message.expiresInSeconds.low) && $util.isInteger(message.expiresInSeconds.high)))
                    return "expiresInSeconds: integer|Long expected";
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo")) {
                var error = $root.server.OgTagInfo.verify(message.ogTagInfo);
                if (error)
                    return "ogTagInfo." + error;
            }
            return null;
        };

        /**
         * Creates an ExternalSharePost message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExternalSharePost
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExternalSharePost} ExternalSharePost
         */
        ExternalSharePost.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExternalSharePost)
                return object;
            var message = new $root.server.ExternalSharePost();
            switch (object.action) {
            case "STORE":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            case "GET":
            case 2:
                message.action = 2;
                break;
            }
            if (object.blobId != null)
                message.blobId = String(object.blobId);
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            if (object.expiresInSeconds != null)
                if ($util.Long)
                    (message.expiresInSeconds = $util.Long.fromValue(object.expiresInSeconds)).unsigned = false;
                else if (typeof object.expiresInSeconds === "string")
                    message.expiresInSeconds = parseInt(object.expiresInSeconds, 10);
                else if (typeof object.expiresInSeconds === "number")
                    message.expiresInSeconds = object.expiresInSeconds;
                else if (typeof object.expiresInSeconds === "object")
                    message.expiresInSeconds = new $util.LongBits(object.expiresInSeconds.low >>> 0, object.expiresInSeconds.high >>> 0).toNumber();
            if (object.ogTagInfo != null) {
                if (typeof object.ogTagInfo !== "object")
                    throw TypeError(".server.ExternalSharePost.ogTagInfo: object expected");
                message.ogTagInfo = $root.server.OgTagInfo.fromObject(object.ogTagInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExternalSharePost message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.ExternalSharePost} message ExternalSharePost
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalSharePost.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "STORE" : 0;
                object.blobId = "";
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiresInSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresInSeconds = options.longs === String ? "0" : 0;
                object.ogTagInfo = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.ExternalSharePost.Action[message.action] : message.action;
            if (message.blobId != null && message.hasOwnProperty("blobId"))
                object.blobId = message.blobId;
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (typeof message.expiresInSeconds === "number")
                    object.expiresInSeconds = options.longs === String ? String(message.expiresInSeconds) : message.expiresInSeconds;
                else
                    object.expiresInSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.expiresInSeconds) : options.longs === Number ? new $util.LongBits(message.expiresInSeconds.low >>> 0, message.expiresInSeconds.high >>> 0).toNumber() : message.expiresInSeconds;
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo"))
                object.ogTagInfo = $root.server.OgTagInfo.toObject(message.ogTagInfo, options);
            return object;
        };

        /**
         * Converts this ExternalSharePost to JSON.
         * @function toJSON
         * @memberof server.ExternalSharePost
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalSharePost.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.ExternalSharePost.Action
         * @enum {number}
         * @property {number} STORE=0 STORE value
         * @property {number} DELETE=1 DELETE value
         * @property {number} GET=2 GET value
         */
        ExternalSharePost.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STORE"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            values[valuesById[2] = "GET"] = 2;
            return values;
        })();

        return ExternalSharePost;
    })();

    server.ExternalSharePostContainer = (function() {

        /**
         * Properties of an ExternalSharePostContainer.
         * @memberof server
         * @interface IExternalSharePostContainer
         * @property {number|Long|null} [uid] ExternalSharePostContainer uid
         * @property {Uint8Array|null} [blob] ExternalSharePostContainer blob
         * @property {server.IOgTagInfo|null} [ogTagInfo] ExternalSharePostContainer ogTagInfo
         * @property {string|null} [name] ExternalSharePostContainer name
         * @property {string|null} [avatarId] ExternalSharePostContainer avatarId
         */

        /**
         * Constructs a new ExternalSharePostContainer.
         * @memberof server
         * @classdesc Represents an ExternalSharePostContainer.
         * @implements IExternalSharePostContainer
         * @constructor
         * @param {server.IExternalSharePostContainer=} [properties] Properties to set
         */
        function ExternalSharePostContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalSharePostContainer uid.
         * @member {number|Long} uid
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExternalSharePostContainer blob.
         * @member {Uint8Array} blob
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.blob = $util.newBuffer([]);

        /**
         * ExternalSharePostContainer ogTagInfo.
         * @member {server.IOgTagInfo|null|undefined} ogTagInfo
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.ogTagInfo = null;

        /**
         * ExternalSharePostContainer name.
         * @member {string} name
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.name = "";

        /**
         * ExternalSharePostContainer avatarId.
         * @member {string} avatarId
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.avatarId = "";

        /**
         * Creates a new ExternalSharePostContainer instance using the specified properties.
         * @function create
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer=} [properties] Properties to set
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer instance
         */
        ExternalSharePostContainer.create = function create(properties) {
            return new ExternalSharePostContainer(properties);
        };

        /**
         * Encodes the specified ExternalSharePostContainer message. Does not implicitly {@link server.ExternalSharePostContainer.verify|verify} messages.
         * @function encode
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer} message ExternalSharePostContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePostContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blob);
            if (message.ogTagInfo != null && Object.hasOwnProperty.call(message, "ogTagInfo"))
                $root.server.OgTagInfo.encode(message.ogTagInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            return writer;
        };

        /**
         * Encodes the specified ExternalSharePostContainer message, length delimited. Does not implicitly {@link server.ExternalSharePostContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer} message ExternalSharePostContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePostContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalSharePostContainer message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePostContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExternalSharePostContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.blob = reader.bytes();
                    break;
                case 3:
                    message.ogTagInfo = $root.server.OgTagInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalSharePostContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePostContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalSharePostContainer message.
         * @function verify
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalSharePostContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo")) {
                var error = $root.server.OgTagInfo.verify(message.ogTagInfo);
                if (error)
                    return "ogTagInfo." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            return null;
        };

        /**
         * Creates an ExternalSharePostContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         */
        ExternalSharePostContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExternalSharePostContainer)
                return object;
            var message = new $root.server.ExternalSharePostContainer();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            if (object.ogTagInfo != null) {
                if (typeof object.ogTagInfo !== "object")
                    throw TypeError(".server.ExternalSharePostContainer.ogTagInfo: object expected");
                message.ogTagInfo = $root.server.OgTagInfo.fromObject(object.ogTagInfo);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            return message;
        };

        /**
         * Creates a plain object from an ExternalSharePostContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.ExternalSharePostContainer} message ExternalSharePostContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalSharePostContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
                object.ogTagInfo = null;
                object.name = "";
                object.avatarId = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo"))
                object.ogTagInfo = $root.server.OgTagInfo.toObject(message.ogTagInfo, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            return object;
        };

        /**
         * Converts this ExternalSharePostContainer to JSON.
         * @function toJSON
         * @memberof server.ExternalSharePostContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalSharePostContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExternalSharePostContainer;
    })();

    server.WebClientInfo = (function() {

        /**
         * Properties of a WebClientInfo.
         * @memberof server
         * @interface IWebClientInfo
         * @property {server.WebClientInfo.Action|null} [action] WebClientInfo action
         * @property {Uint8Array|null} [staticKey] WebClientInfo staticKey
         * @property {server.WebClientInfo.Result|null} [result] WebClientInfo result
         */

        /**
         * Constructs a new WebClientInfo.
         * @memberof server
         * @classdesc Represents a WebClientInfo.
         * @implements IWebClientInfo
         * @constructor
         * @param {server.IWebClientInfo=} [properties] Properties to set
         */
        function WebClientInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebClientInfo action.
         * @member {server.WebClientInfo.Action} action
         * @memberof server.WebClientInfo
         * @instance
         */
        WebClientInfo.prototype.action = 0;

        /**
         * WebClientInfo staticKey.
         * @member {Uint8Array} staticKey
         * @memberof server.WebClientInfo
         * @instance
         */
        WebClientInfo.prototype.staticKey = $util.newBuffer([]);

        /**
         * WebClientInfo result.
         * @member {server.WebClientInfo.Result} result
         * @memberof server.WebClientInfo
         * @instance
         */
        WebClientInfo.prototype.result = 0;

        /**
         * Creates a new WebClientInfo instance using the specified properties.
         * @function create
         * @memberof server.WebClientInfo
         * @static
         * @param {server.IWebClientInfo=} [properties] Properties to set
         * @returns {server.WebClientInfo} WebClientInfo instance
         */
        WebClientInfo.create = function create(properties) {
            return new WebClientInfo(properties);
        };

        /**
         * Encodes the specified WebClientInfo message. Does not implicitly {@link server.WebClientInfo.verify|verify} messages.
         * @function encode
         * @memberof server.WebClientInfo
         * @static
         * @param {server.IWebClientInfo} message WebClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebClientInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.staticKey != null && Object.hasOwnProperty.call(message, "staticKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.staticKey);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified WebClientInfo message, length delimited. Does not implicitly {@link server.WebClientInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WebClientInfo
         * @static
         * @param {server.IWebClientInfo} message WebClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebClientInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebClientInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.WebClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WebClientInfo} WebClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebClientInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WebClientInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.staticKey = reader.bytes();
                    break;
                case 3:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebClientInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WebClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WebClientInfo} WebClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebClientInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebClientInfo message.
         * @function verify
         * @memberof server.WebClientInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebClientInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                if (!(message.staticKey && typeof message.staticKey.length === "number" || $util.isString(message.staticKey)))
                    return "staticKey: buffer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a WebClientInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WebClientInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WebClientInfo} WebClientInfo
         */
        WebClientInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WebClientInfo)
                return object;
            var message = new $root.server.WebClientInfo();
            switch (object.action) {
            case "UNKNOWN_ACTION":
            case 0:
                message.action = 0;
                break;
            case "ADD_KEY":
            case 1:
                message.action = 1;
                break;
            case "IS_KEY_AUTHENTICATED":
            case 2:
                message.action = 2;
                break;
            case "AUTHENTICATE_KEY":
            case 3:
                message.action = 3;
                break;
            case "REMOVE_KEY":
            case 4:
                message.action = 4;
                break;
            }
            if (object.staticKey != null)
                if (typeof object.staticKey === "string")
                    $util.base64.decode(object.staticKey, message.staticKey = $util.newBuffer($util.base64.length(object.staticKey)), 0);
                else if (object.staticKey.length)
                    message.staticKey = object.staticKey;
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "AUTHENTICATED":
            case 2:
                message.result = 2;
                break;
            case "NOT_AUTHENTICATED":
            case 3:
                message.result = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a WebClientInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WebClientInfo
         * @static
         * @param {server.WebClientInfo} message WebClientInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebClientInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "UNKNOWN_ACTION" : 0;
                if (options.bytes === String)
                    object.staticKey = "";
                else {
                    object.staticKey = [];
                    if (options.bytes !== Array)
                        object.staticKey = $util.newBuffer(object.staticKey);
                }
                object.result = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.WebClientInfo.Action[message.action] : message.action;
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                object.staticKey = options.bytes === String ? $util.base64.encode(message.staticKey, 0, message.staticKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.staticKey) : message.staticKey;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.WebClientInfo.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this WebClientInfo to JSON.
         * @function toJSON
         * @memberof server.WebClientInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebClientInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.WebClientInfo.Action
         * @enum {number}
         * @property {number} UNKNOWN_ACTION=0 UNKNOWN_ACTION value
         * @property {number} ADD_KEY=1 ADD_KEY value
         * @property {number} IS_KEY_AUTHENTICATED=2 IS_KEY_AUTHENTICATED value
         * @property {number} AUTHENTICATE_KEY=3 AUTHENTICATE_KEY value
         * @property {number} REMOVE_KEY=4 REMOVE_KEY value
         */
        WebClientInfo.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_ACTION"] = 0;
            values[valuesById[1] = "ADD_KEY"] = 1;
            values[valuesById[2] = "IS_KEY_AUTHENTICATED"] = 2;
            values[valuesById[3] = "AUTHENTICATE_KEY"] = 3;
            values[valuesById[4] = "REMOVE_KEY"] = 4;
            return values;
        })();

        /**
         * Result enum.
         * @name server.WebClientInfo.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OK=1 OK value
         * @property {number} AUTHENTICATED=2 AUTHENTICATED value
         * @property {number} NOT_AUTHENTICATED=3 NOT_AUTHENTICATED value
         */
        WebClientInfo.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "AUTHENTICATED"] = 2;
            values[valuesById[3] = "NOT_AUTHENTICATED"] = 3;
            return values;
        })();

        return WebClientInfo;
    })();

    server.ReportUserContent = (function() {

        /**
         * Properties of a ReportUserContent.
         * @memberof server
         * @interface IReportUserContent
         * @property {server.ReportUserContent.Type|null} [type] ReportUserContent type
         * @property {number|Long|null} [uid] ReportUserContent uid
         * @property {string|null} [contentId] ReportUserContent contentId
         * @property {server.ReportUserContent.Reason|null} [reason] ReportUserContent reason
         */

        /**
         * Constructs a new ReportUserContent.
         * @memberof server
         * @classdesc Represents a ReportUserContent.
         * @implements IReportUserContent
         * @constructor
         * @param {server.IReportUserContent=} [properties] Properties to set
         */
        function ReportUserContent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReportUserContent type.
         * @member {server.ReportUserContent.Type} type
         * @memberof server.ReportUserContent
         * @instance
         */
        ReportUserContent.prototype.type = 0;

        /**
         * ReportUserContent uid.
         * @member {number|Long} uid
         * @memberof server.ReportUserContent
         * @instance
         */
        ReportUserContent.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReportUserContent contentId.
         * @member {string} contentId
         * @memberof server.ReportUserContent
         * @instance
         */
        ReportUserContent.prototype.contentId = "";

        /**
         * ReportUserContent reason.
         * @member {server.ReportUserContent.Reason} reason
         * @memberof server.ReportUserContent
         * @instance
         */
        ReportUserContent.prototype.reason = 0;

        /**
         * Creates a new ReportUserContent instance using the specified properties.
         * @function create
         * @memberof server.ReportUserContent
         * @static
         * @param {server.IReportUserContent=} [properties] Properties to set
         * @returns {server.ReportUserContent} ReportUserContent instance
         */
        ReportUserContent.create = function create(properties) {
            return new ReportUserContent(properties);
        };

        /**
         * Encodes the specified ReportUserContent message. Does not implicitly {@link server.ReportUserContent.verify|verify} messages.
         * @function encode
         * @memberof server.ReportUserContent
         * @static
         * @param {server.IReportUserContent} message ReportUserContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReportUserContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.contentId);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ReportUserContent message, length delimited. Does not implicitly {@link server.ReportUserContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ReportUserContent
         * @static
         * @param {server.IReportUserContent} message ReportUserContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReportUserContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReportUserContent message from the specified reader or buffer.
         * @function decode
         * @memberof server.ReportUserContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ReportUserContent} ReportUserContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReportUserContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ReportUserContent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.contentId = reader.string();
                    break;
                case 4:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReportUserContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ReportUserContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ReportUserContent} ReportUserContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReportUserContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReportUserContent message.
         * @function verify
         * @memberof server.ReportUserContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReportUserContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isString(message.contentId))
                    return "contentId: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a ReportUserContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ReportUserContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ReportUserContent} ReportUserContent
         */
        ReportUserContent.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ReportUserContent)
                return object;
            var message = new $root.server.ReportUserContent();
            switch (object.type) {
            case "UNKNOWN_TYPE":
            case 0:
                message.type = 0;
                break;
            case "USER":
            case 1:
                message.type = 1;
                break;
            case "POST":
            case 2:
                message.type = 2;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.contentId != null)
                message.contentId = String(object.contentId);
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "DONT_LIKE":
            case 1:
                message.reason = 1;
                break;
            case "SPAM":
            case 2:
                message.reason = 2;
                break;
            case "VIOLATES_RULES":
            case 3:
                message.reason = 3;
                break;
            case "OTHER":
            case 4:
                message.reason = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ReportUserContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ReportUserContent
         * @static
         * @param {server.ReportUserContent} message ReportUserContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReportUserContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN_TYPE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.contentId = "";
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ReportUserContent.Type[message.type] : message.type;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.ReportUserContent.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this ReportUserContent to JSON.
         * @function toJSON
         * @memberof server.ReportUserContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReportUserContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ReportUserContent.Type
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} USER=1 USER value
         * @property {number} POST=2 POST value
         */
        ReportUserContent.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "USER"] = 1;
            values[valuesById[2] = "POST"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.ReportUserContent.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} DONT_LIKE=1 DONT_LIKE value
         * @property {number} SPAM=2 SPAM value
         * @property {number} VIOLATES_RULES=3 VIOLATES_RULES value
         * @property {number} OTHER=4 OTHER value
         */
        ReportUserContent.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "DONT_LIKE"] = 1;
            values[valuesById[2] = "SPAM"] = 2;
            values[valuesById[3] = "VIOLATES_RULES"] = 3;
            values[valuesById[4] = "OTHER"] = 4;
            return values;
        })();

        return ReportUserContent;
    })();

    server.WebStanza = (function() {

        /**
         * Properties of a WebStanza.
         * @memberof server
         * @interface IWebStanza
         * @property {Uint8Array|null} [staticKey] WebStanza staticKey
         * @property {Uint8Array|null} [content] WebStanza content
         * @property {server.INoiseMessage|null} [noiseMessage] WebStanza noiseMessage
         */

        /**
         * Constructs a new WebStanza.
         * @memberof server
         * @classdesc Represents a WebStanza.
         * @implements IWebStanza
         * @constructor
         * @param {server.IWebStanza=} [properties] Properties to set
         */
        function WebStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebStanza staticKey.
         * @member {Uint8Array} staticKey
         * @memberof server.WebStanza
         * @instance
         */
        WebStanza.prototype.staticKey = $util.newBuffer([]);

        /**
         * WebStanza content.
         * @member {Uint8Array} content
         * @memberof server.WebStanza
         * @instance
         */
        WebStanza.prototype.content = $util.newBuffer([]);

        /**
         * WebStanza noiseMessage.
         * @member {server.INoiseMessage|null|undefined} noiseMessage
         * @memberof server.WebStanza
         * @instance
         */
        WebStanza.prototype.noiseMessage = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * WebStanza payload.
         * @member {"content"|"noiseMessage"|undefined} payload
         * @memberof server.WebStanza
         * @instance
         */
        Object.defineProperty(WebStanza.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["content", "noiseMessage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new WebStanza instance using the specified properties.
         * @function create
         * @memberof server.WebStanza
         * @static
         * @param {server.IWebStanza=} [properties] Properties to set
         * @returns {server.WebStanza} WebStanza instance
         */
        WebStanza.create = function create(properties) {
            return new WebStanza(properties);
        };

        /**
         * Encodes the specified WebStanza message. Does not implicitly {@link server.WebStanza.verify|verify} messages.
         * @function encode
         * @memberof server.WebStanza
         * @static
         * @param {server.IWebStanza} message WebStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticKey != null && Object.hasOwnProperty.call(message, "staticKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.staticKey);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            if (message.noiseMessage != null && Object.hasOwnProperty.call(message, "noiseMessage"))
                $root.server.NoiseMessage.encode(message.noiseMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WebStanza message, length delimited. Does not implicitly {@link server.WebStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WebStanza
         * @static
         * @param {server.IWebStanza} message WebStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.WebStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WebStanza} WebStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WebStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.staticKey = reader.bytes();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                case 3:
                    message.noiseMessage = $root.server.NoiseMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WebStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WebStanza} WebStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebStanza message.
         * @function verify
         * @memberof server.WebStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                if (!(message.staticKey && typeof message.staticKey.length === "number" || $util.isString(message.staticKey)))
                    return "staticKey: buffer expected";
            if (message.content != null && message.hasOwnProperty("content")) {
                properties.payload = 1;
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            }
            if (message.noiseMessage != null && message.hasOwnProperty("noiseMessage")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.NoiseMessage.verify(message.noiseMessage);
                    if (error)
                        return "noiseMessage." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WebStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WebStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WebStanza} WebStanza
         */
        WebStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WebStanza)
                return object;
            var message = new $root.server.WebStanza();
            if (object.staticKey != null)
                if (typeof object.staticKey === "string")
                    $util.base64.decode(object.staticKey, message.staticKey = $util.newBuffer($util.base64.length(object.staticKey)), 0);
                else if (object.staticKey.length)
                    message.staticKey = object.staticKey;
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            if (object.noiseMessage != null) {
                if (typeof object.noiseMessage !== "object")
                    throw TypeError(".server.WebStanza.noiseMessage: object expected");
                message.noiseMessage = $root.server.NoiseMessage.fromObject(object.noiseMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a WebStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WebStanza
         * @static
         * @param {server.WebStanza} message WebStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.staticKey = "";
                else {
                    object.staticKey = [];
                    if (options.bytes !== Array)
                        object.staticKey = $util.newBuffer(object.staticKey);
                }
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                object.staticKey = options.bytes === String ? $util.base64.encode(message.staticKey, 0, message.staticKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.staticKey) : message.staticKey;
            if (message.content != null && message.hasOwnProperty("content")) {
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (options.oneofs)
                    object.payload = "content";
            }
            if (message.noiseMessage != null && message.hasOwnProperty("noiseMessage")) {
                object.noiseMessage = $root.server.NoiseMessage.toObject(message.noiseMessage, options);
                if (options.oneofs)
                    object.payload = "noiseMessage";
            }
            return object;
        };

        /**
         * Converts this WebStanza to JSON.
         * @function toJSON
         * @memberof server.WebStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebStanza;
    })();

    server.ContentMissing = (function() {

        /**
         * Properties of a ContentMissing.
         * @memberof server
         * @interface IContentMissing
         * @property {string|null} [contentId] ContentMissing contentId
         * @property {server.ContentMissing.ContentType|null} [contentType] ContentMissing contentType
         * @property {string|null} [senderClientVersion] ContentMissing senderClientVersion
         */

        /**
         * Constructs a new ContentMissing.
         * @memberof server
         * @classdesc Represents a ContentMissing.
         * @implements IContentMissing
         * @constructor
         * @param {server.IContentMissing=} [properties] Properties to set
         */
        function ContentMissing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentMissing contentId.
         * @member {string} contentId
         * @memberof server.ContentMissing
         * @instance
         */
        ContentMissing.prototype.contentId = "";

        /**
         * ContentMissing contentType.
         * @member {server.ContentMissing.ContentType} contentType
         * @memberof server.ContentMissing
         * @instance
         */
        ContentMissing.prototype.contentType = 0;

        /**
         * ContentMissing senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.ContentMissing
         * @instance
         */
        ContentMissing.prototype.senderClientVersion = "";

        /**
         * Creates a new ContentMissing instance using the specified properties.
         * @function create
         * @memberof server.ContentMissing
         * @static
         * @param {server.IContentMissing=} [properties] Properties to set
         * @returns {server.ContentMissing} ContentMissing instance
         */
        ContentMissing.create = function create(properties) {
            return new ContentMissing(properties);
        };

        /**
         * Encodes the specified ContentMissing message. Does not implicitly {@link server.ContentMissing.verify|verify} messages.
         * @function encode
         * @memberof server.ContentMissing
         * @static
         * @param {server.IContentMissing} message ContentMissing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentMissing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentId);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contentType);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified ContentMissing message, length delimited. Does not implicitly {@link server.ContentMissing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContentMissing
         * @static
         * @param {server.IContentMissing} message ContentMissing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentMissing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContentMissing message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContentMissing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContentMissing} ContentMissing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentMissing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContentMissing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contentId = reader.string();
                    break;
                case 2:
                    message.contentType = reader.int32();
                    break;
                case 3:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContentMissing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContentMissing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContentMissing} ContentMissing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentMissing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContentMissing message.
         * @function verify
         * @memberof server.ContentMissing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContentMissing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isString(message.contentId))
                    return "contentId: string expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    break;
                }
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a ContentMissing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContentMissing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContentMissing} ContentMissing
         */
        ContentMissing.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContentMissing)
                return object;
            var message = new $root.server.ContentMissing();
            if (object.contentId != null)
                message.contentId = String(object.contentId);
            switch (object.contentType) {
            case "UNKNOWN":
            case 0:
                message.contentType = 0;
                break;
            case "CHAT":
            case 1:
                message.contentType = 1;
                break;
            case "CALL":
            case 2:
                message.contentType = 2;
                break;
            case "GROUP_FEED_POST":
            case 3:
                message.contentType = 3;
                break;
            case "GROUP_FEED_COMMENT":
            case 4:
                message.contentType = 4;
                break;
            case "HOME_FEED_POST":
            case 5:
                message.contentType = 5;
                break;
            case "HOME_FEED_COMMENT":
            case 6:
                message.contentType = 6;
                break;
            case "HISTORY_RESEND":
            case 7:
                message.contentType = 7;
                break;
            case "GROUP_HISTORY":
            case 8:
                message.contentType = 8;
                break;
            case "CHAT_REACTION":
            case 9:
                message.contentType = 9;
                break;
            case "GROUP_COMMENT_REACTION":
            case 10:
                message.contentType = 10;
                break;
            case "GROUP_POST_REACTION":
            case 11:
                message.contentType = 11;
                break;
            case "HOME_COMMENT_REACTION":
            case 12:
                message.contentType = 12;
                break;
            case "HOME_POST_REACTION":
            case 13:
                message.contentType = 13;
                break;
            case "GROUP_CHAT":
            case 14:
                message.contentType = 14;
                break;
            case "GROUP_CHAT_REACTION":
            case 15:
                message.contentType = 15;
                break;
            }
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a ContentMissing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContentMissing
         * @static
         * @param {server.ContentMissing} message ContentMissing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContentMissing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contentId = "";
                object.contentType = options.enums === String ? "UNKNOWN" : 0;
                object.senderClientVersion = "";
            }
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.ContentMissing.ContentType[message.contentType] : message.contentType;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this ContentMissing to JSON.
         * @function toJSON
         * @memberof server.ContentMissing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContentMissing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ContentType enum.
         * @name server.ContentMissing.ContentType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CHAT=1 CHAT value
         * @property {number} CALL=2 CALL value
         * @property {number} GROUP_FEED_POST=3 GROUP_FEED_POST value
         * @property {number} GROUP_FEED_COMMENT=4 GROUP_FEED_COMMENT value
         * @property {number} HOME_FEED_POST=5 HOME_FEED_POST value
         * @property {number} HOME_FEED_COMMENT=6 HOME_FEED_COMMENT value
         * @property {number} HISTORY_RESEND=7 HISTORY_RESEND value
         * @property {number} GROUP_HISTORY=8 GROUP_HISTORY value
         * @property {number} CHAT_REACTION=9 CHAT_REACTION value
         * @property {number} GROUP_COMMENT_REACTION=10 GROUP_COMMENT_REACTION value
         * @property {number} GROUP_POST_REACTION=11 GROUP_POST_REACTION value
         * @property {number} HOME_COMMENT_REACTION=12 HOME_COMMENT_REACTION value
         * @property {number} HOME_POST_REACTION=13 HOME_POST_REACTION value
         * @property {number} GROUP_CHAT=14 GROUP_CHAT value
         * @property {number} GROUP_CHAT_REACTION=15 GROUP_CHAT_REACTION value
         */
        ContentMissing.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CHAT"] = 1;
            values[valuesById[2] = "CALL"] = 2;
            values[valuesById[3] = "GROUP_FEED_POST"] = 3;
            values[valuesById[4] = "GROUP_FEED_COMMENT"] = 4;
            values[valuesById[5] = "HOME_FEED_POST"] = 5;
            values[valuesById[6] = "HOME_FEED_COMMENT"] = 6;
            values[valuesById[7] = "HISTORY_RESEND"] = 7;
            values[valuesById[8] = "GROUP_HISTORY"] = 8;
            values[valuesById[9] = "CHAT_REACTION"] = 9;
            values[valuesById[10] = "GROUP_COMMENT_REACTION"] = 10;
            values[valuesById[11] = "GROUP_POST_REACTION"] = 11;
            values[valuesById[12] = "HOME_COMMENT_REACTION"] = 12;
            values[valuesById[13] = "HOME_POST_REACTION"] = 13;
            values[valuesById[14] = "GROUP_CHAT"] = 14;
            values[valuesById[15] = "GROUP_CHAT_REACTION"] = 15;
            return values;
        })();

        return ContentMissing;
    })();

    server.MomentNotification = (function() {

        /**
         * Properties of a MomentNotification.
         * @memberof server
         * @interface IMomentNotification
         * @property {number|Long|null} [timestamp] MomentNotification timestamp
         * @property {number|Long|null} [notificationId] MomentNotification notificationId
         * @property {server.MomentNotification.Type|null} [type] MomentNotification type
         * @property {string|null} [prompt] MomentNotification prompt
         * @property {boolean|null} [hideBanner] MomentNotification hideBanner
         * @property {Uint8Array|null} [promptImage] MomentNotification promptImage
         */

        /**
         * Constructs a new MomentNotification.
         * @memberof server
         * @classdesc Represents a MomentNotification.
         * @implements IMomentNotification
         * @constructor
         * @param {server.IMomentNotification=} [properties] Properties to set
         */
        function MomentNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MomentNotification timestamp.
         * @member {number|Long} timestamp
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentNotification notificationId.
         * @member {number|Long} notificationId
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.notificationId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MomentNotification type.
         * @member {server.MomentNotification.Type} type
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.type = 0;

        /**
         * MomentNotification prompt.
         * @member {string} prompt
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.prompt = "";

        /**
         * MomentNotification hideBanner.
         * @member {boolean} hideBanner
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.hideBanner = false;

        /**
         * MomentNotification promptImage.
         * @member {Uint8Array} promptImage
         * @memberof server.MomentNotification
         * @instance
         */
        MomentNotification.prototype.promptImage = $util.newBuffer([]);

        /**
         * Creates a new MomentNotification instance using the specified properties.
         * @function create
         * @memberof server.MomentNotification
         * @static
         * @param {server.IMomentNotification=} [properties] Properties to set
         * @returns {server.MomentNotification} MomentNotification instance
         */
        MomentNotification.create = function create(properties) {
            return new MomentNotification(properties);
        };

        /**
         * Encodes the specified MomentNotification message. Does not implicitly {@link server.MomentNotification.verify|verify} messages.
         * @function encode
         * @memberof server.MomentNotification
         * @static
         * @param {server.IMomentNotification} message MomentNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MomentNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.notificationId != null && Object.hasOwnProperty.call(message, "notificationId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.notificationId);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.prompt != null && Object.hasOwnProperty.call(message, "prompt"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.prompt);
            if (message.hideBanner != null && Object.hasOwnProperty.call(message, "hideBanner"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hideBanner);
            if (message.promptImage != null && Object.hasOwnProperty.call(message, "promptImage"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.promptImage);
            return writer;
        };

        /**
         * Encodes the specified MomentNotification message, length delimited. Does not implicitly {@link server.MomentNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MomentNotification
         * @static
         * @param {server.IMomentNotification} message MomentNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MomentNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MomentNotification message from the specified reader or buffer.
         * @function decode
         * @memberof server.MomentNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MomentNotification} MomentNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MomentNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.notificationId = reader.int64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.prompt = reader.string();
                    break;
                case 5:
                    message.hideBanner = reader.bool();
                    break;
                case 6:
                    message.promptImage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MomentNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MomentNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MomentNotification} MomentNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MomentNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MomentNotification message.
         * @function verify
         * @memberof server.MomentNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MomentNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.notificationId != null && message.hasOwnProperty("notificationId"))
                if (!$util.isInteger(message.notificationId) && !(message.notificationId && $util.isInteger(message.notificationId.low) && $util.isInteger(message.notificationId.high)))
                    return "notificationId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.prompt != null && message.hasOwnProperty("prompt"))
                if (!$util.isString(message.prompt))
                    return "prompt: string expected";
            if (message.hideBanner != null && message.hasOwnProperty("hideBanner"))
                if (typeof message.hideBanner !== "boolean")
                    return "hideBanner: boolean expected";
            if (message.promptImage != null && message.hasOwnProperty("promptImage"))
                if (!(message.promptImage && typeof message.promptImage.length === "number" || $util.isString(message.promptImage)))
                    return "promptImage: buffer expected";
            return null;
        };

        /**
         * Creates a MomentNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MomentNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MomentNotification} MomentNotification
         */
        MomentNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MomentNotification)
                return object;
            var message = new $root.server.MomentNotification();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.notificationId != null)
                if ($util.Long)
                    (message.notificationId = $util.Long.fromValue(object.notificationId)).unsigned = false;
                else if (typeof object.notificationId === "string")
                    message.notificationId = parseInt(object.notificationId, 10);
                else if (typeof object.notificationId === "number")
                    message.notificationId = object.notificationId;
                else if (typeof object.notificationId === "object")
                    message.notificationId = new $util.LongBits(object.notificationId.low >>> 0, object.notificationId.high >>> 0).toNumber();
            switch (object.type) {
            case "LIVE_CAMERA":
            case 0:
                message.type = 0;
                break;
            case "TEXT_POST":
            case 1:
                message.type = 1;
                break;
            case "PROMPT_POST":
            case 2:
                message.type = 2;
                break;
            case "ALBUM_POST":
            case 3:
                message.type = 3;
                break;
            }
            if (object.prompt != null)
                message.prompt = String(object.prompt);
            if (object.hideBanner != null)
                message.hideBanner = Boolean(object.hideBanner);
            if (object.promptImage != null)
                if (typeof object.promptImage === "string")
                    $util.base64.decode(object.promptImage, message.promptImage = $util.newBuffer($util.base64.length(object.promptImage)), 0);
                else if (object.promptImage.length)
                    message.promptImage = object.promptImage;
            return message;
        };

        /**
         * Creates a plain object from a MomentNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MomentNotification
         * @static
         * @param {server.MomentNotification} message MomentNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MomentNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.notificationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.notificationId = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "LIVE_CAMERA" : 0;
                object.prompt = "";
                object.hideBanner = false;
                if (options.bytes === String)
                    object.promptImage = "";
                else {
                    object.promptImage = [];
                    if (options.bytes !== Array)
                        object.promptImage = $util.newBuffer(object.promptImage);
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.notificationId != null && message.hasOwnProperty("notificationId"))
                if (typeof message.notificationId === "number")
                    object.notificationId = options.longs === String ? String(message.notificationId) : message.notificationId;
                else
                    object.notificationId = options.longs === String ? $util.Long.prototype.toString.call(message.notificationId) : options.longs === Number ? new $util.LongBits(message.notificationId.low >>> 0, message.notificationId.high >>> 0).toNumber() : message.notificationId;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MomentNotification.Type[message.type] : message.type;
            if (message.prompt != null && message.hasOwnProperty("prompt"))
                object.prompt = message.prompt;
            if (message.hideBanner != null && message.hasOwnProperty("hideBanner"))
                object.hideBanner = message.hideBanner;
            if (message.promptImage != null && message.hasOwnProperty("promptImage"))
                object.promptImage = options.bytes === String ? $util.base64.encode(message.promptImage, 0, message.promptImage.length) : options.bytes === Array ? Array.prototype.slice.call(message.promptImage) : message.promptImage;
            return object;
        };

        /**
         * Converts this MomentNotification to JSON.
         * @function toJSON
         * @memberof server.MomentNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MomentNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MomentNotification.Type
         * @enum {number}
         * @property {number} LIVE_CAMERA=0 LIVE_CAMERA value
         * @property {number} TEXT_POST=1 TEXT_POST value
         * @property {number} PROMPT_POST=2 PROMPT_POST value
         * @property {number} ALBUM_POST=3 ALBUM_POST value
         */
        MomentNotification.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LIVE_CAMERA"] = 0;
            values[valuesById[1] = "TEXT_POST"] = 1;
            values[valuesById[2] = "PROMPT_POST"] = 2;
            values[valuesById[3] = "ALBUM_POST"] = 3;
            return values;
        })();

        return MomentNotification;
    })();

    server.ArchiveRequest = (function() {

        /**
         * Properties of an ArchiveRequest.
         * @memberof server
         * @interface IArchiveRequest
         * @property {number|Long|null} [uid] ArchiveRequest uid
         */

        /**
         * Constructs a new ArchiveRequest.
         * @memberof server
         * @classdesc Represents an ArchiveRequest.
         * @implements IArchiveRequest
         * @constructor
         * @param {server.IArchiveRequest=} [properties] Properties to set
         */
        function ArchiveRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArchiveRequest uid.
         * @member {number|Long} uid
         * @memberof server.ArchiveRequest
         * @instance
         */
        ArchiveRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ArchiveRequest instance using the specified properties.
         * @function create
         * @memberof server.ArchiveRequest
         * @static
         * @param {server.IArchiveRequest=} [properties] Properties to set
         * @returns {server.ArchiveRequest} ArchiveRequest instance
         */
        ArchiveRequest.create = function create(properties) {
            return new ArchiveRequest(properties);
        };

        /**
         * Encodes the specified ArchiveRequest message. Does not implicitly {@link server.ArchiveRequest.verify|verify} messages.
         * @function encode
         * @memberof server.ArchiveRequest
         * @static
         * @param {server.IArchiveRequest} message ArchiveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArchiveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified ArchiveRequest message, length delimited. Does not implicitly {@link server.ArchiveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ArchiveRequest
         * @static
         * @param {server.IArchiveRequest} message ArchiveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArchiveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArchiveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.ArchiveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ArchiveRequest} ArchiveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArchiveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ArchiveRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArchiveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ArchiveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ArchiveRequest} ArchiveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArchiveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArchiveRequest message.
         * @function verify
         * @memberof server.ArchiveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArchiveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates an ArchiveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ArchiveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ArchiveRequest} ArchiveRequest
         */
        ArchiveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ArchiveRequest)
                return object;
            var message = new $root.server.ArchiveRequest();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ArchiveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ArchiveRequest
         * @static
         * @param {server.ArchiveRequest} message ArchiveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArchiveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this ArchiveRequest to JSON.
         * @function toJSON
         * @memberof server.ArchiveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArchiveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ArchiveRequest;
    })();

    server.ArchiveResult = (function() {

        /**
         * Properties of an ArchiveResult.
         * @memberof server
         * @interface IArchiveResult
         * @property {server.ArchiveResult.Result|null} [result] ArchiveResult result
         * @property {server.ArchiveResult.Reason|null} [reason] ArchiveResult reason
         * @property {number|Long|null} [uid] ArchiveResult uid
         * @property {Array.<server.IPost>|null} [posts] ArchiveResult posts
         */

        /**
         * Constructs a new ArchiveResult.
         * @memberof server
         * @classdesc Represents an ArchiveResult.
         * @implements IArchiveResult
         * @constructor
         * @param {server.IArchiveResult=} [properties] Properties to set
         */
        function ArchiveResult(properties) {
            this.posts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArchiveResult result.
         * @member {server.ArchiveResult.Result} result
         * @memberof server.ArchiveResult
         * @instance
         */
        ArchiveResult.prototype.result = 0;

        /**
         * ArchiveResult reason.
         * @member {server.ArchiveResult.Reason} reason
         * @memberof server.ArchiveResult
         * @instance
         */
        ArchiveResult.prototype.reason = 0;

        /**
         * ArchiveResult uid.
         * @member {number|Long} uid
         * @memberof server.ArchiveResult
         * @instance
         */
        ArchiveResult.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ArchiveResult posts.
         * @member {Array.<server.IPost>} posts
         * @memberof server.ArchiveResult
         * @instance
         */
        ArchiveResult.prototype.posts = $util.emptyArray;

        /**
         * Creates a new ArchiveResult instance using the specified properties.
         * @function create
         * @memberof server.ArchiveResult
         * @static
         * @param {server.IArchiveResult=} [properties] Properties to set
         * @returns {server.ArchiveResult} ArchiveResult instance
         */
        ArchiveResult.create = function create(properties) {
            return new ArchiveResult(properties);
        };

        /**
         * Encodes the specified ArchiveResult message. Does not implicitly {@link server.ArchiveResult.verify|verify} messages.
         * @function encode
         * @memberof server.ArchiveResult
         * @static
         * @param {server.IArchiveResult} message ArchiveResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArchiveResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            if (message.posts != null && message.posts.length)
                for (var i = 0; i < message.posts.length; ++i)
                    $root.server.Post.encode(message.posts[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArchiveResult message, length delimited. Does not implicitly {@link server.ArchiveResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ArchiveResult
         * @static
         * @param {server.IArchiveResult} message ArchiveResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArchiveResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArchiveResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.ArchiveResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ArchiveResult} ArchiveResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArchiveResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ArchiveResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.uid = reader.int64();
                    break;
                case 4:
                    if (!(message.posts && message.posts.length))
                        message.posts = [];
                    message.posts.push($root.server.Post.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArchiveResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ArchiveResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ArchiveResult} ArchiveResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArchiveResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArchiveResult message.
         * @function verify
         * @memberof server.ArchiveResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArchiveResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.posts != null && message.hasOwnProperty("posts")) {
                if (!Array.isArray(message.posts))
                    return "posts: array expected";
                for (var i = 0; i < message.posts.length; ++i) {
                    var error = $root.server.Post.verify(message.posts[i]);
                    if (error)
                        return "posts." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArchiveResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ArchiveResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ArchiveResult} ArchiveResult
         */
        ArchiveResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ArchiveResult)
                return object;
            var message = new $root.server.ArchiveResult();
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_USER":
            case 1:
                message.reason = 1;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.posts) {
                if (!Array.isArray(object.posts))
                    throw TypeError(".server.ArchiveResult.posts: array expected");
                message.posts = [];
                for (var i = 0; i < object.posts.length; ++i) {
                    if (typeof object.posts[i] !== "object")
                        throw TypeError(".server.ArchiveResult.posts: object expected");
                    message.posts[i] = $root.server.Post.fromObject(object.posts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ArchiveResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ArchiveResult
         * @static
         * @param {server.ArchiveResult} message ArchiveResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArchiveResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.posts = [];
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.ArchiveResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.ArchiveResult.Reason[message.reason] : message.reason;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.posts && message.posts.length) {
                object.posts = [];
                for (var j = 0; j < message.posts.length; ++j)
                    object.posts[j] = $root.server.Post.toObject(message.posts[j], options);
            }
            return object;
        };

        /**
         * Converts this ArchiveResult to JSON.
         * @function toJSON
         * @memberof server.ArchiveResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArchiveResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.ArchiveResult.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        ArchiveResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.ArchiveResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_USER=1 INVALID_USER value
         */
        ArchiveResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_USER"] = 1;
            return values;
        })();

        return ArchiveResult;
    })();

    server.Iq = (function() {

        /**
         * Properties of an Iq.
         * @memberof server
         * @interface IIq
         * @property {string|null} [id] Iq id
         * @property {server.Iq.Type|null} [type] Iq type
         * @property {server.IUploadMedia|null} [uploadMedia] Iq uploadMedia
         * @property {server.IContactList|null} [contactList] Iq contactList
         * @property {server.IUploadAvatar|null} [uploadAvatar] Iq uploadAvatar
         * @property {server.IAvatar|null} [avatar] Iq avatar
         * @property {server.IAvatars|null} [avatars] Iq avatars
         * @property {server.IClientMode|null} [clientMode] Iq clientMode
         * @property {server.IClientVersion|null} [clientVersion] Iq clientVersion
         * @property {server.IPushRegister|null} [pushRegister] Iq pushRegister
         * @property {server.IWhisperKeys|null} [whisperKeys] Iq whisperKeys
         * @property {server.IPing|null} [ping] Iq ping
         * @property {server.IFeedItem|null} [feedItem] Iq feedItem
         * @property {server.IPrivacyList|null} [privacyList] Iq privacyList
         * @property {server.IPrivacyLists|null} [privacyLists] Iq privacyLists
         * @property {server.IGroupStanza|null} [groupStanza] Iq groupStanza
         * @property {server.IGroupsStanza|null} [groupsStanza] Iq groupsStanza
         * @property {server.IClientLog|null} [clientLog] Iq clientLog
         * @property {server.IName|null} [name] Iq name
         * @property {server.IErrorStanza|null} [errorStanza] Iq errorStanza
         * @property {server.IProps|null} [props] Iq props
         * @property {server.IInvitesRequest|null} [invitesRequest] Iq invitesRequest
         * @property {server.IInvitesResponse|null} [invitesResponse] Iq invitesResponse
         * @property {server.INotificationPrefs|null} [notificationPrefs] Iq notificationPrefs
         * @property {server.IGroupFeedItem|null} [groupFeedItem] Iq groupFeedItem
         * @property {server.IUploadGroupAvatar|null} [groupAvatar] Iq groupAvatar
         * @property {server.IDeleteAccount|null} [deleteAccount] Iq deleteAccount
         * @property {server.IGroupInviteLink|null} [groupInviteLink] Iq groupInviteLink
         * @property {server.IHistoryResend|null} [historyResend] Iq historyResend
         * @property {server.IExportData|null} [exportData] Iq exportData
         * @property {server.IContactSyncError|null} [contactSyncError] Iq contactSyncError
         * @property {server.IClientOtpRequest|null} [clientOtpRequest] Iq clientOtpRequest
         * @property {server.IClientOtpResponse|null} [clientOtpResponse] Iq clientOtpResponse
         * @property {server.IWhisperKeysCollection|null} [whisperKeysCollection] Iq whisperKeysCollection
         * @property {server.IGetCallServers|null} [getCallServers] Iq getCallServers
         * @property {server.IGetCallServersResult|null} [getCallServersResult] Iq getCallServersResult
         * @property {server.IStartCall|null} [startCall] Iq startCall
         * @property {server.IStartCallResult|null} [startCallResult] Iq startCallResult
         * @property {server.ITruncWhisperKeysCollection|null} [truncWhisperKeysCollection] Iq truncWhisperKeysCollection
         * @property {server.IExternalSharePost|null} [externalSharePost] Iq externalSharePost
         * @property {server.IExternalSharePostContainer|null} [externalSharePostContainer] Iq externalSharePostContainer
         * @property {server.IWebClientInfo|null} [webClientInfo] Iq webClientInfo
         * @property {server.IReportUserContent|null} [reportUserContent] Iq reportUserContent
         * @property {server.IPublicFeedRequest|null} [publicFeedRequest] Iq publicFeedRequest
         * @property {server.IPublicFeedResponse|null} [publicFeedResponse] Iq publicFeedResponse
         * @property {server.IRelationshipRequest|null} [relationshipRequest] Iq relationshipRequest
         * @property {server.IRelationshipResponse|null} [relationshipResponse] Iq relationshipResponse
         * @property {server.IRelationshipList|null} [relationshipList] Iq relationshipList
         * @property {server.IUsernameRequest|null} [usernameRequest] Iq usernameRequest
         * @property {server.IUsernameResponse|null} [usernameResponse] Iq usernameResponse
         * @property {server.ISearchRequest|null} [searchRequest] Iq searchRequest
         * @property {server.ISearchResponse|null} [searchResponse] Iq searchResponse
         * @property {server.IFollowSuggestionsRequest|null} [followSuggestionsRequest] Iq followSuggestionsRequest
         * @property {server.IFollowSuggestionsResponse|null} [followSuggestionsResponse] Iq followSuggestionsResponse
         * @property {server.ISetLinkRequest|null} [setLinkRequest] Iq setLinkRequest
         * @property {server.ISetLinkResult|null} [setLinkResult] Iq setLinkResult
         * @property {server.ISetBioRequest|null} [setBioRequest] Iq setBioRequest
         * @property {server.ISetBioResult|null} [setBioResult] Iq setBioResult
         * @property {server.IUserProfileRequest|null} [userProfileRequest] Iq userProfileRequest
         * @property {server.IUserProfileResult|null} [userProfileResult] Iq userProfileResult
         * @property {server.IPostMetricsRequest|null} [postMetricsRequest] Iq postMetricsRequest
         * @property {server.IPostMetricsResult|null} [postMetricsResult] Iq postMetricsResult
         * @property {server.IAiImageRequest|null} [aiImageRequest] Iq aiImageRequest
         * @property {server.IAiImageResult|null} [aiImageResult] Iq aiImageResult
         * @property {server.IArchiveRequest|null} [archiveRequest] Iq archiveRequest
         * @property {server.IArchiveResult|null} [archiveResult] Iq archiveResult
         * @property {server.IPostSubscriptionRequest|null} [postSubscriptionRequest] Iq postSubscriptionRequest
         * @property {server.IPostSubscriptionResponse|null} [postSubscriptionResponse] Iq postSubscriptionResponse
         */

        /**
         * Constructs a new Iq.
         * @memberof server
         * @classdesc Represents an Iq.
         * @implements IIq
         * @constructor
         * @param {server.IIq=} [properties] Properties to set
         */
        function Iq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Iq id.
         * @member {string} id
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.id = "";

        /**
         * Iq type.
         * @member {server.Iq.Type} type
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.type = 0;

        /**
         * Iq uploadMedia.
         * @member {server.IUploadMedia|null|undefined} uploadMedia
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.uploadMedia = null;

        /**
         * Iq contactList.
         * @member {server.IContactList|null|undefined} contactList
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.contactList = null;

        /**
         * Iq uploadAvatar.
         * @member {server.IUploadAvatar|null|undefined} uploadAvatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.uploadAvatar = null;

        /**
         * Iq avatar.
         * @member {server.IAvatar|null|undefined} avatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.avatar = null;

        /**
         * Iq avatars.
         * @member {server.IAvatars|null|undefined} avatars
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.avatars = null;

        /**
         * Iq clientMode.
         * @member {server.IClientMode|null|undefined} clientMode
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientMode = null;

        /**
         * Iq clientVersion.
         * @member {server.IClientVersion|null|undefined} clientVersion
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientVersion = null;

        /**
         * Iq pushRegister.
         * @member {server.IPushRegister|null|undefined} pushRegister
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.pushRegister = null;

        /**
         * Iq whisperKeys.
         * @member {server.IWhisperKeys|null|undefined} whisperKeys
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.whisperKeys = null;

        /**
         * Iq ping.
         * @member {server.IPing|null|undefined} ping
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.ping = null;

        /**
         * Iq feedItem.
         * @member {server.IFeedItem|null|undefined} feedItem
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.feedItem = null;

        /**
         * Iq privacyList.
         * @member {server.IPrivacyList|null|undefined} privacyList
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.privacyList = null;

        /**
         * Iq privacyLists.
         * @member {server.IPrivacyLists|null|undefined} privacyLists
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.privacyLists = null;

        /**
         * Iq groupStanza.
         * @member {server.IGroupStanza|null|undefined} groupStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupStanza = null;

        /**
         * Iq groupsStanza.
         * @member {server.IGroupsStanza|null|undefined} groupsStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupsStanza = null;

        /**
         * Iq clientLog.
         * @member {server.IClientLog|null|undefined} clientLog
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientLog = null;

        /**
         * Iq name.
         * @member {server.IName|null|undefined} name
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.name = null;

        /**
         * Iq errorStanza.
         * @member {server.IErrorStanza|null|undefined} errorStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.errorStanza = null;

        /**
         * Iq props.
         * @member {server.IProps|null|undefined} props
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.props = null;

        /**
         * Iq invitesRequest.
         * @member {server.IInvitesRequest|null|undefined} invitesRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.invitesRequest = null;

        /**
         * Iq invitesResponse.
         * @member {server.IInvitesResponse|null|undefined} invitesResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.invitesResponse = null;

        /**
         * Iq notificationPrefs.
         * @member {server.INotificationPrefs|null|undefined} notificationPrefs
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.notificationPrefs = null;

        /**
         * Iq groupFeedItem.
         * @member {server.IGroupFeedItem|null|undefined} groupFeedItem
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupFeedItem = null;

        /**
         * Iq groupAvatar.
         * @member {server.IUploadGroupAvatar|null|undefined} groupAvatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupAvatar = null;

        /**
         * Iq deleteAccount.
         * @member {server.IDeleteAccount|null|undefined} deleteAccount
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.deleteAccount = null;

        /**
         * Iq groupInviteLink.
         * @member {server.IGroupInviteLink|null|undefined} groupInviteLink
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupInviteLink = null;

        /**
         * Iq historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.historyResend = null;

        /**
         * Iq exportData.
         * @member {server.IExportData|null|undefined} exportData
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.exportData = null;

        /**
         * Iq contactSyncError.
         * @member {server.IContactSyncError|null|undefined} contactSyncError
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.contactSyncError = null;

        /**
         * Iq clientOtpRequest.
         * @member {server.IClientOtpRequest|null|undefined} clientOtpRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientOtpRequest = null;

        /**
         * Iq clientOtpResponse.
         * @member {server.IClientOtpResponse|null|undefined} clientOtpResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientOtpResponse = null;

        /**
         * Iq whisperKeysCollection.
         * @member {server.IWhisperKeysCollection|null|undefined} whisperKeysCollection
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.whisperKeysCollection = null;

        /**
         * Iq getCallServers.
         * @member {server.IGetCallServers|null|undefined} getCallServers
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.getCallServers = null;

        /**
         * Iq getCallServersResult.
         * @member {server.IGetCallServersResult|null|undefined} getCallServersResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.getCallServersResult = null;

        /**
         * Iq startCall.
         * @member {server.IStartCall|null|undefined} startCall
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.startCall = null;

        /**
         * Iq startCallResult.
         * @member {server.IStartCallResult|null|undefined} startCallResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.startCallResult = null;

        /**
         * Iq truncWhisperKeysCollection.
         * @member {server.ITruncWhisperKeysCollection|null|undefined} truncWhisperKeysCollection
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.truncWhisperKeysCollection = null;

        /**
         * Iq externalSharePost.
         * @member {server.IExternalSharePost|null|undefined} externalSharePost
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.externalSharePost = null;

        /**
         * Iq externalSharePostContainer.
         * @member {server.IExternalSharePostContainer|null|undefined} externalSharePostContainer
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.externalSharePostContainer = null;

        /**
         * Iq webClientInfo.
         * @member {server.IWebClientInfo|null|undefined} webClientInfo
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.webClientInfo = null;

        /**
         * Iq reportUserContent.
         * @member {server.IReportUserContent|null|undefined} reportUserContent
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.reportUserContent = null;

        /**
         * Iq publicFeedRequest.
         * @member {server.IPublicFeedRequest|null|undefined} publicFeedRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.publicFeedRequest = null;

        /**
         * Iq publicFeedResponse.
         * @member {server.IPublicFeedResponse|null|undefined} publicFeedResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.publicFeedResponse = null;

        /**
         * Iq relationshipRequest.
         * @member {server.IRelationshipRequest|null|undefined} relationshipRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.relationshipRequest = null;

        /**
         * Iq relationshipResponse.
         * @member {server.IRelationshipResponse|null|undefined} relationshipResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.relationshipResponse = null;

        /**
         * Iq relationshipList.
         * @member {server.IRelationshipList|null|undefined} relationshipList
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.relationshipList = null;

        /**
         * Iq usernameRequest.
         * @member {server.IUsernameRequest|null|undefined} usernameRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.usernameRequest = null;

        /**
         * Iq usernameResponse.
         * @member {server.IUsernameResponse|null|undefined} usernameResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.usernameResponse = null;

        /**
         * Iq searchRequest.
         * @member {server.ISearchRequest|null|undefined} searchRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.searchRequest = null;

        /**
         * Iq searchResponse.
         * @member {server.ISearchResponse|null|undefined} searchResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.searchResponse = null;

        /**
         * Iq followSuggestionsRequest.
         * @member {server.IFollowSuggestionsRequest|null|undefined} followSuggestionsRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.followSuggestionsRequest = null;

        /**
         * Iq followSuggestionsResponse.
         * @member {server.IFollowSuggestionsResponse|null|undefined} followSuggestionsResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.followSuggestionsResponse = null;

        /**
         * Iq setLinkRequest.
         * @member {server.ISetLinkRequest|null|undefined} setLinkRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.setLinkRequest = null;

        /**
         * Iq setLinkResult.
         * @member {server.ISetLinkResult|null|undefined} setLinkResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.setLinkResult = null;

        /**
         * Iq setBioRequest.
         * @member {server.ISetBioRequest|null|undefined} setBioRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.setBioRequest = null;

        /**
         * Iq setBioResult.
         * @member {server.ISetBioResult|null|undefined} setBioResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.setBioResult = null;

        /**
         * Iq userProfileRequest.
         * @member {server.IUserProfileRequest|null|undefined} userProfileRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.userProfileRequest = null;

        /**
         * Iq userProfileResult.
         * @member {server.IUserProfileResult|null|undefined} userProfileResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.userProfileResult = null;

        /**
         * Iq postMetricsRequest.
         * @member {server.IPostMetricsRequest|null|undefined} postMetricsRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.postMetricsRequest = null;

        /**
         * Iq postMetricsResult.
         * @member {server.IPostMetricsResult|null|undefined} postMetricsResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.postMetricsResult = null;

        /**
         * Iq aiImageRequest.
         * @member {server.IAiImageRequest|null|undefined} aiImageRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.aiImageRequest = null;

        /**
         * Iq aiImageResult.
         * @member {server.IAiImageResult|null|undefined} aiImageResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.aiImageResult = null;

        /**
         * Iq archiveRequest.
         * @member {server.IArchiveRequest|null|undefined} archiveRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.archiveRequest = null;

        /**
         * Iq archiveResult.
         * @member {server.IArchiveResult|null|undefined} archiveResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.archiveResult = null;

        /**
         * Iq postSubscriptionRequest.
         * @member {server.IPostSubscriptionRequest|null|undefined} postSubscriptionRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.postSubscriptionRequest = null;

        /**
         * Iq postSubscriptionResponse.
         * @member {server.IPostSubscriptionResponse|null|undefined} postSubscriptionResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.postSubscriptionResponse = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Iq payload.
         * @member {"uploadMedia"|"contactList"|"uploadAvatar"|"avatar"|"avatars"|"clientMode"|"clientVersion"|"pushRegister"|"whisperKeys"|"ping"|"feedItem"|"privacyList"|"privacyLists"|"groupStanza"|"groupsStanza"|"clientLog"|"name"|"errorStanza"|"props"|"invitesRequest"|"invitesResponse"|"notificationPrefs"|"groupFeedItem"|"groupAvatar"|"deleteAccount"|"groupInviteLink"|"historyResend"|"exportData"|"contactSyncError"|"clientOtpRequest"|"clientOtpResponse"|"whisperKeysCollection"|"getCallServers"|"getCallServersResult"|"startCall"|"startCallResult"|"truncWhisperKeysCollection"|"externalSharePost"|"externalSharePostContainer"|"webClientInfo"|"reportUserContent"|"publicFeedRequest"|"publicFeedResponse"|"relationshipRequest"|"relationshipResponse"|"relationshipList"|"usernameRequest"|"usernameResponse"|"searchRequest"|"searchResponse"|"followSuggestionsRequest"|"followSuggestionsResponse"|"setLinkRequest"|"setLinkResult"|"setBioRequest"|"setBioResult"|"userProfileRequest"|"userProfileResult"|"postMetricsRequest"|"postMetricsResult"|"aiImageRequest"|"aiImageResult"|"archiveRequest"|"archiveResult"|"postSubscriptionRequest"|"postSubscriptionResponse"|undefined} payload
         * @memberof server.Iq
         * @instance
         */
        Object.defineProperty(Iq.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["uploadMedia", "contactList", "uploadAvatar", "avatar", "avatars", "clientMode", "clientVersion", "pushRegister", "whisperKeys", "ping", "feedItem", "privacyList", "privacyLists", "groupStanza", "groupsStanza", "clientLog", "name", "errorStanza", "props", "invitesRequest", "invitesResponse", "notificationPrefs", "groupFeedItem", "groupAvatar", "deleteAccount", "groupInviteLink", "historyResend", "exportData", "contactSyncError", "clientOtpRequest", "clientOtpResponse", "whisperKeysCollection", "getCallServers", "getCallServersResult", "startCall", "startCallResult", "truncWhisperKeysCollection", "externalSharePost", "externalSharePostContainer", "webClientInfo", "reportUserContent", "publicFeedRequest", "publicFeedResponse", "relationshipRequest", "relationshipResponse", "relationshipList", "usernameRequest", "usernameResponse", "searchRequest", "searchResponse", "followSuggestionsRequest", "followSuggestionsResponse", "setLinkRequest", "setLinkResult", "setBioRequest", "setBioResult", "userProfileRequest", "userProfileResult", "postMetricsRequest", "postMetricsResult", "aiImageRequest", "aiImageResult", "archiveRequest", "archiveResult", "postSubscriptionRequest", "postSubscriptionResponse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Iq instance using the specified properties.
         * @function create
         * @memberof server.Iq
         * @static
         * @param {server.IIq=} [properties] Properties to set
         * @returns {server.Iq} Iq instance
         */
        Iq.create = function create(properties) {
            return new Iq(properties);
        };

        /**
         * Encodes the specified Iq message. Does not implicitly {@link server.Iq.verify|verify} messages.
         * @function encode
         * @memberof server.Iq
         * @static
         * @param {server.IIq} message Iq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Iq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.uploadMedia != null && Object.hasOwnProperty.call(message, "uploadMedia"))
                $root.server.UploadMedia.encode(message.uploadMedia, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.contactList != null && Object.hasOwnProperty.call(message, "contactList"))
                $root.server.ContactList.encode(message.contactList, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.uploadAvatar != null && Object.hasOwnProperty.call(message, "uploadAvatar"))
                $root.server.UploadAvatar.encode(message.uploadAvatar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.server.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.avatars != null && Object.hasOwnProperty.call(message, "avatars"))
                $root.server.Avatars.encode(message.avatars, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.clientMode != null && Object.hasOwnProperty.call(message, "clientMode"))
                $root.server.ClientMode.encode(message.clientMode, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
                $root.server.ClientVersion.encode(message.clientVersion, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.pushRegister != null && Object.hasOwnProperty.call(message, "pushRegister"))
                $root.server.PushRegister.encode(message.pushRegister, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.whisperKeys != null && Object.hasOwnProperty.call(message, "whisperKeys"))
                $root.server.WhisperKeys.encode(message.whisperKeys, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.server.Ping.encode(message.ping, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.feedItem != null && Object.hasOwnProperty.call(message, "feedItem"))
                $root.server.FeedItem.encode(message.feedItem, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.privacyList != null && Object.hasOwnProperty.call(message, "privacyList"))
                $root.server.PrivacyList.encode(message.privacyList, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.privacyLists != null && Object.hasOwnProperty.call(message, "privacyLists"))
                $root.server.PrivacyLists.encode(message.privacyLists, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.groupStanza != null && Object.hasOwnProperty.call(message, "groupStanza"))
                $root.server.GroupStanza.encode(message.groupStanza, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.groupsStanza != null && Object.hasOwnProperty.call(message, "groupsStanza"))
                $root.server.GroupsStanza.encode(message.groupsStanza, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.clientLog != null && Object.hasOwnProperty.call(message, "clientLog"))
                $root.server.ClientLog.encode(message.clientLog, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.server.Name.encode(message.name, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.errorStanza != null && Object.hasOwnProperty.call(message, "errorStanza"))
                $root.server.ErrorStanza.encode(message.errorStanza, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.props != null && Object.hasOwnProperty.call(message, "props"))
                $root.server.Props.encode(message.props, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.invitesRequest != null && Object.hasOwnProperty.call(message, "invitesRequest"))
                $root.server.InvitesRequest.encode(message.invitesRequest, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.invitesResponse != null && Object.hasOwnProperty.call(message, "invitesResponse"))
                $root.server.InvitesResponse.encode(message.invitesResponse, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.notificationPrefs != null && Object.hasOwnProperty.call(message, "notificationPrefs"))
                $root.server.NotificationPrefs.encode(message.notificationPrefs, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.groupFeedItem != null && Object.hasOwnProperty.call(message, "groupFeedItem"))
                $root.server.GroupFeedItem.encode(message.groupFeedItem, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.groupAvatar != null && Object.hasOwnProperty.call(message, "groupAvatar"))
                $root.server.UploadGroupAvatar.encode(message.groupAvatar, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.deleteAccount != null && Object.hasOwnProperty.call(message, "deleteAccount"))
                $root.server.DeleteAccount.encode(message.deleteAccount, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.groupInviteLink != null && Object.hasOwnProperty.call(message, "groupInviteLink"))
                $root.server.GroupInviteLink.encode(message.groupInviteLink, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.exportData != null && Object.hasOwnProperty.call(message, "exportData"))
                $root.server.ExportData.encode(message.exportData, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.contactSyncError != null && Object.hasOwnProperty.call(message, "contactSyncError"))
                $root.server.ContactSyncError.encode(message.contactSyncError, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.clientOtpRequest != null && Object.hasOwnProperty.call(message, "clientOtpRequest"))
                $root.server.ClientOtpRequest.encode(message.clientOtpRequest, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.clientOtpResponse != null && Object.hasOwnProperty.call(message, "clientOtpResponse"))
                $root.server.ClientOtpResponse.encode(message.clientOtpResponse, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.whisperKeysCollection != null && Object.hasOwnProperty.call(message, "whisperKeysCollection"))
                $root.server.WhisperKeysCollection.encode(message.whisperKeysCollection, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.getCallServers != null && Object.hasOwnProperty.call(message, "getCallServers"))
                $root.server.GetCallServers.encode(message.getCallServers, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.getCallServersResult != null && Object.hasOwnProperty.call(message, "getCallServersResult"))
                $root.server.GetCallServersResult.encode(message.getCallServersResult, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.startCall != null && Object.hasOwnProperty.call(message, "startCall"))
                $root.server.StartCall.encode(message.startCall, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.startCallResult != null && Object.hasOwnProperty.call(message, "startCallResult"))
                $root.server.StartCallResult.encode(message.startCallResult, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.truncWhisperKeysCollection != null && Object.hasOwnProperty.call(message, "truncWhisperKeysCollection"))
                $root.server.TruncWhisperKeysCollection.encode(message.truncWhisperKeysCollection, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.externalSharePost != null && Object.hasOwnProperty.call(message, "externalSharePost"))
                $root.server.ExternalSharePost.encode(message.externalSharePost, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.externalSharePostContainer != null && Object.hasOwnProperty.call(message, "externalSharePostContainer"))
                $root.server.ExternalSharePostContainer.encode(message.externalSharePostContainer, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.webClientInfo != null && Object.hasOwnProperty.call(message, "webClientInfo"))
                $root.server.WebClientInfo.encode(message.webClientInfo, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.reportUserContent != null && Object.hasOwnProperty.call(message, "reportUserContent"))
                $root.server.ReportUserContent.encode(message.reportUserContent, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.publicFeedRequest != null && Object.hasOwnProperty.call(message, "publicFeedRequest"))
                $root.server.PublicFeedRequest.encode(message.publicFeedRequest, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            if (message.publicFeedResponse != null && Object.hasOwnProperty.call(message, "publicFeedResponse"))
                $root.server.PublicFeedResponse.encode(message.publicFeedResponse, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
            if (message.relationshipRequest != null && Object.hasOwnProperty.call(message, "relationshipRequest"))
                $root.server.RelationshipRequest.encode(message.relationshipRequest, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            if (message.relationshipResponse != null && Object.hasOwnProperty.call(message, "relationshipResponse"))
                $root.server.RelationshipResponse.encode(message.relationshipResponse, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.relationshipList != null && Object.hasOwnProperty.call(message, "relationshipList"))
                $root.server.RelationshipList.encode(message.relationshipList, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.usernameRequest != null && Object.hasOwnProperty.call(message, "usernameRequest"))
                $root.server.UsernameRequest.encode(message.usernameRequest, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
            if (message.usernameResponse != null && Object.hasOwnProperty.call(message, "usernameResponse"))
                $root.server.UsernameResponse.encode(message.usernameResponse, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.searchRequest != null && Object.hasOwnProperty.call(message, "searchRequest"))
                $root.server.SearchRequest.encode(message.searchRequest, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.searchResponse != null && Object.hasOwnProperty.call(message, "searchResponse"))
                $root.server.SearchResponse.encode(message.searchResponse, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.followSuggestionsRequest != null && Object.hasOwnProperty.call(message, "followSuggestionsRequest"))
                $root.server.FollowSuggestionsRequest.encode(message.followSuggestionsRequest, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            if (message.followSuggestionsResponse != null && Object.hasOwnProperty.call(message, "followSuggestionsResponse"))
                $root.server.FollowSuggestionsResponse.encode(message.followSuggestionsResponse, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
            if (message.setLinkRequest != null && Object.hasOwnProperty.call(message, "setLinkRequest"))
                $root.server.SetLinkRequest.encode(message.setLinkRequest, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
            if (message.setLinkResult != null && Object.hasOwnProperty.call(message, "setLinkResult"))
                $root.server.SetLinkResult.encode(message.setLinkResult, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
            if (message.setBioRequest != null && Object.hasOwnProperty.call(message, "setBioRequest"))
                $root.server.SetBioRequest.encode(message.setBioRequest, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
            if (message.setBioResult != null && Object.hasOwnProperty.call(message, "setBioResult"))
                $root.server.SetBioResult.encode(message.setBioResult, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
            if (message.userProfileRequest != null && Object.hasOwnProperty.call(message, "userProfileRequest"))
                $root.server.UserProfileRequest.encode(message.userProfileRequest, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
            if (message.userProfileResult != null && Object.hasOwnProperty.call(message, "userProfileResult"))
                $root.server.UserProfileResult.encode(message.userProfileResult, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
            if (message.postMetricsRequest != null && Object.hasOwnProperty.call(message, "postMetricsRequest"))
                $root.server.PostMetricsRequest.encode(message.postMetricsRequest, writer.uint32(/* id 64, wireType 2 =*/514).fork()).ldelim();
            if (message.postMetricsResult != null && Object.hasOwnProperty.call(message, "postMetricsResult"))
                $root.server.PostMetricsResult.encode(message.postMetricsResult, writer.uint32(/* id 65, wireType 2 =*/522).fork()).ldelim();
            if (message.aiImageRequest != null && Object.hasOwnProperty.call(message, "aiImageRequest"))
                $root.server.AiImageRequest.encode(message.aiImageRequest, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
            if (message.aiImageResult != null && Object.hasOwnProperty.call(message, "aiImageResult"))
                $root.server.AiImageResult.encode(message.aiImageResult, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
            if (message.archiveRequest != null && Object.hasOwnProperty.call(message, "archiveRequest"))
                $root.server.ArchiveRequest.encode(message.archiveRequest, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
            if (message.archiveResult != null && Object.hasOwnProperty.call(message, "archiveResult"))
                $root.server.ArchiveResult.encode(message.archiveResult, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
            if (message.postSubscriptionRequest != null && Object.hasOwnProperty.call(message, "postSubscriptionRequest"))
                $root.server.PostSubscriptionRequest.encode(message.postSubscriptionRequest, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
            if (message.postSubscriptionResponse != null && Object.hasOwnProperty.call(message, "postSubscriptionResponse"))
                $root.server.PostSubscriptionResponse.encode(message.postSubscriptionResponse, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Iq message, length delimited. Does not implicitly {@link server.Iq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Iq
         * @static
         * @param {server.IIq} message Iq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Iq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Iq message from the specified reader or buffer.
         * @function decode
         * @memberof server.Iq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Iq} Iq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Iq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Iq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.uploadMedia = $root.server.UploadMedia.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.contactList = $root.server.ContactList.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.uploadAvatar = $root.server.UploadAvatar.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.avatar = $root.server.Avatar.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.avatars = $root.server.Avatars.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.clientMode = $root.server.ClientMode.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.clientVersion = $root.server.ClientVersion.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.pushRegister = $root.server.PushRegister.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.whisperKeys = $root.server.WhisperKeys.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.ping = $root.server.Ping.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.feedItem = $root.server.FeedItem.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.privacyList = $root.server.PrivacyList.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.privacyLists = $root.server.PrivacyLists.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.groupStanza = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.groupsStanza = $root.server.GroupsStanza.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.clientLog = $root.server.ClientLog.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.name = $root.server.Name.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.errorStanza = $root.server.ErrorStanza.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.props = $root.server.Props.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.invitesRequest = $root.server.InvitesRequest.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.invitesResponse = $root.server.InvitesResponse.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.notificationPrefs = $root.server.NotificationPrefs.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.groupFeedItem = $root.server.GroupFeedItem.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.groupAvatar = $root.server.UploadGroupAvatar.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.deleteAccount = $root.server.DeleteAccount.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.groupInviteLink = $root.server.GroupInviteLink.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.exportData = $root.server.ExportData.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.contactSyncError = $root.server.ContactSyncError.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.clientOtpRequest = $root.server.ClientOtpRequest.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.clientOtpResponse = $root.server.ClientOtpResponse.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.whisperKeysCollection = $root.server.WhisperKeysCollection.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.getCallServers = $root.server.GetCallServers.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.getCallServersResult = $root.server.GetCallServersResult.decode(reader, reader.uint32());
                    break;
                case 40:
                    message.startCall = $root.server.StartCall.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.startCallResult = $root.server.StartCallResult.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.externalSharePost = $root.server.ExternalSharePost.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.externalSharePostContainer = $root.server.ExternalSharePostContainer.decode(reader, reader.uint32());
                    break;
                case 45:
                    message.webClientInfo = $root.server.WebClientInfo.decode(reader, reader.uint32());
                    break;
                case 46:
                    message.reportUserContent = $root.server.ReportUserContent.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.publicFeedRequest = $root.server.PublicFeedRequest.decode(reader, reader.uint32());
                    break;
                case 48:
                    message.publicFeedResponse = $root.server.PublicFeedResponse.decode(reader, reader.uint32());
                    break;
                case 49:
                    message.relationshipRequest = $root.server.RelationshipRequest.decode(reader, reader.uint32());
                    break;
                case 50:
                    message.relationshipResponse = $root.server.RelationshipResponse.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.relationshipList = $root.server.RelationshipList.decode(reader, reader.uint32());
                    break;
                case 52:
                    message.usernameRequest = $root.server.UsernameRequest.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.usernameResponse = $root.server.UsernameResponse.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.searchRequest = $root.server.SearchRequest.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.searchResponse = $root.server.SearchResponse.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.followSuggestionsRequest = $root.server.FollowSuggestionsRequest.decode(reader, reader.uint32());
                    break;
                case 57:
                    message.followSuggestionsResponse = $root.server.FollowSuggestionsResponse.decode(reader, reader.uint32());
                    break;
                case 58:
                    message.setLinkRequest = $root.server.SetLinkRequest.decode(reader, reader.uint32());
                    break;
                case 59:
                    message.setLinkResult = $root.server.SetLinkResult.decode(reader, reader.uint32());
                    break;
                case 60:
                    message.setBioRequest = $root.server.SetBioRequest.decode(reader, reader.uint32());
                    break;
                case 61:
                    message.setBioResult = $root.server.SetBioResult.decode(reader, reader.uint32());
                    break;
                case 62:
                    message.userProfileRequest = $root.server.UserProfileRequest.decode(reader, reader.uint32());
                    break;
                case 63:
                    message.userProfileResult = $root.server.UserProfileResult.decode(reader, reader.uint32());
                    break;
                case 64:
                    message.postMetricsRequest = $root.server.PostMetricsRequest.decode(reader, reader.uint32());
                    break;
                case 65:
                    message.postMetricsResult = $root.server.PostMetricsResult.decode(reader, reader.uint32());
                    break;
                case 66:
                    message.aiImageRequest = $root.server.AiImageRequest.decode(reader, reader.uint32());
                    break;
                case 67:
                    message.aiImageResult = $root.server.AiImageResult.decode(reader, reader.uint32());
                    break;
                case 68:
                    message.archiveRequest = $root.server.ArchiveRequest.decode(reader, reader.uint32());
                    break;
                case 69:
                    message.archiveResult = $root.server.ArchiveResult.decode(reader, reader.uint32());
                    break;
                case 70:
                    message.postSubscriptionRequest = $root.server.PostSubscriptionRequest.decode(reader, reader.uint32());
                    break;
                case 71:
                    message.postSubscriptionResponse = $root.server.PostSubscriptionResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Iq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Iq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Iq} Iq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Iq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Iq message.
         * @function verify
         * @memberof server.Iq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Iq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.uploadMedia != null && message.hasOwnProperty("uploadMedia")) {
                properties.payload = 1;
                {
                    var error = $root.server.UploadMedia.verify(message.uploadMedia);
                    if (error)
                        return "uploadMedia." + error;
                }
            }
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactList.verify(message.contactList);
                    if (error)
                        return "contactList." + error;
                }
            }
            if (message.uploadAvatar != null && message.hasOwnProperty("uploadAvatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UploadAvatar.verify(message.uploadAvatar);
                    if (error)
                        return "uploadAvatar." + error;
                }
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
            }
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatars.verify(message.avatars);
                    if (error)
                        return "avatars." + error;
                }
            }
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientMode.verify(message.clientMode);
                    if (error)
                        return "clientMode." + error;
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientVersion.verify(message.clientVersion);
                    if (error)
                        return "clientVersion." + error;
                }
            }
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PushRegister.verify(message.pushRegister);
                    if (error)
                        return "pushRegister." + error;
                }
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeys.verify(message.whisperKeys);
                    if (error)
                        return "whisperKeys." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Ping.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItem.verify(message.feedItem);
                    if (error)
                        return "feedItem." + error;
                }
            }
            if (message.privacyList != null && message.hasOwnProperty("privacyList")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PrivacyList.verify(message.privacyList);
                    if (error)
                        return "privacyList." + error;
                }
            }
            if (message.privacyLists != null && message.hasOwnProperty("privacyLists")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PrivacyLists.verify(message.privacyLists);
                    if (error)
                        return "privacyLists." + error;
                }
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupStanza.verify(message.groupStanza);
                    if (error)
                        return "groupStanza." + error;
                }
            }
            if (message.groupsStanza != null && message.hasOwnProperty("groupsStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupsStanza.verify(message.groupsStanza);
                    if (error)
                        return "groupsStanza." + error;
                }
            }
            if (message.clientLog != null && message.hasOwnProperty("clientLog")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientLog.verify(message.clientLog);
                    if (error)
                        return "clientLog." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Name.verify(message.name);
                    if (error)
                        return "name." + error;
                }
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ErrorStanza.verify(message.errorStanza);
                    if (error)
                        return "errorStanza." + error;
                }
            }
            if (message.props != null && message.hasOwnProperty("props")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Props.verify(message.props);
                    if (error)
                        return "props." + error;
                }
            }
            if (message.invitesRequest != null && message.hasOwnProperty("invitesRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InvitesRequest.verify(message.invitesRequest);
                    if (error)
                        return "invitesRequest." + error;
                }
            }
            if (message.invitesResponse != null && message.hasOwnProperty("invitesResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InvitesResponse.verify(message.invitesResponse);
                    if (error)
                        return "invitesResponse." + error;
                }
            }
            if (message.notificationPrefs != null && message.hasOwnProperty("notificationPrefs")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.NotificationPrefs.verify(message.notificationPrefs);
                    if (error)
                        return "notificationPrefs." + error;
                }
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItem.verify(message.groupFeedItem);
                    if (error)
                        return "groupFeedItem." + error;
                }
            }
            if (message.groupAvatar != null && message.hasOwnProperty("groupAvatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UploadGroupAvatar.verify(message.groupAvatar);
                    if (error)
                        return "groupAvatar." + error;
                }
            }
            if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.DeleteAccount.verify(message.deleteAccount);
                    if (error)
                        return "deleteAccount." + error;
                }
            }
            if (message.groupInviteLink != null && message.hasOwnProperty("groupInviteLink")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupInviteLink.verify(message.groupInviteLink);
                    if (error)
                        return "groupInviteLink." + error;
                }
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HistoryResend.verify(message.historyResend);
                    if (error)
                        return "historyResend." + error;
                }
            }
            if (message.exportData != null && message.hasOwnProperty("exportData")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExportData.verify(message.exportData);
                    if (error)
                        return "exportData." + error;
                }
            }
            if (message.contactSyncError != null && message.hasOwnProperty("contactSyncError")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactSyncError.verify(message.contactSyncError);
                    if (error)
                        return "contactSyncError." + error;
                }
            }
            if (message.clientOtpRequest != null && message.hasOwnProperty("clientOtpRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientOtpRequest.verify(message.clientOtpRequest);
                    if (error)
                        return "clientOtpRequest." + error;
                }
            }
            if (message.clientOtpResponse != null && message.hasOwnProperty("clientOtpResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientOtpResponse.verify(message.clientOtpResponse);
                    if (error)
                        return "clientOtpResponse." + error;
                }
            }
            if (message.whisperKeysCollection != null && message.hasOwnProperty("whisperKeysCollection")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeysCollection.verify(message.whisperKeysCollection);
                    if (error)
                        return "whisperKeysCollection." + error;
                }
            }
            if (message.getCallServers != null && message.hasOwnProperty("getCallServers")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GetCallServers.verify(message.getCallServers);
                    if (error)
                        return "getCallServers." + error;
                }
            }
            if (message.getCallServersResult != null && message.hasOwnProperty("getCallServersResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GetCallServersResult.verify(message.getCallServersResult);
                    if (error)
                        return "getCallServersResult." + error;
                }
            }
            if (message.startCall != null && message.hasOwnProperty("startCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.StartCall.verify(message.startCall);
                    if (error)
                        return "startCall." + error;
                }
            }
            if (message.startCallResult != null && message.hasOwnProperty("startCallResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.StartCallResult.verify(message.startCallResult);
                    if (error)
                        return "startCallResult." + error;
                }
            }
            if (message.truncWhisperKeysCollection != null && message.hasOwnProperty("truncWhisperKeysCollection")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.TruncWhisperKeysCollection.verify(message.truncWhisperKeysCollection);
                    if (error)
                        return "truncWhisperKeysCollection." + error;
                }
            }
            if (message.externalSharePost != null && message.hasOwnProperty("externalSharePost")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExternalSharePost.verify(message.externalSharePost);
                    if (error)
                        return "externalSharePost." + error;
                }
            }
            if (message.externalSharePostContainer != null && message.hasOwnProperty("externalSharePostContainer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExternalSharePostContainer.verify(message.externalSharePostContainer);
                    if (error)
                        return "externalSharePostContainer." + error;
                }
            }
            if (message.webClientInfo != null && message.hasOwnProperty("webClientInfo")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WebClientInfo.verify(message.webClientInfo);
                    if (error)
                        return "webClientInfo." + error;
                }
            }
            if (message.reportUserContent != null && message.hasOwnProperty("reportUserContent")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ReportUserContent.verify(message.reportUserContent);
                    if (error)
                        return "reportUserContent." + error;
                }
            }
            if (message.publicFeedRequest != null && message.hasOwnProperty("publicFeedRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PublicFeedRequest.verify(message.publicFeedRequest);
                    if (error)
                        return "publicFeedRequest." + error;
                }
            }
            if (message.publicFeedResponse != null && message.hasOwnProperty("publicFeedResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PublicFeedResponse.verify(message.publicFeedResponse);
                    if (error)
                        return "publicFeedResponse." + error;
                }
            }
            if (message.relationshipRequest != null && message.hasOwnProperty("relationshipRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.RelationshipRequest.verify(message.relationshipRequest);
                    if (error)
                        return "relationshipRequest." + error;
                }
            }
            if (message.relationshipResponse != null && message.hasOwnProperty("relationshipResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.RelationshipResponse.verify(message.relationshipResponse);
                    if (error)
                        return "relationshipResponse." + error;
                }
            }
            if (message.relationshipList != null && message.hasOwnProperty("relationshipList")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.RelationshipList.verify(message.relationshipList);
                    if (error)
                        return "relationshipList." + error;
                }
            }
            if (message.usernameRequest != null && message.hasOwnProperty("usernameRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UsernameRequest.verify(message.usernameRequest);
                    if (error)
                        return "usernameRequest." + error;
                }
            }
            if (message.usernameResponse != null && message.hasOwnProperty("usernameResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UsernameResponse.verify(message.usernameResponse);
                    if (error)
                        return "usernameResponse." + error;
                }
            }
            if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SearchRequest.verify(message.searchRequest);
                    if (error)
                        return "searchRequest." + error;
                }
            }
            if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SearchResponse.verify(message.searchResponse);
                    if (error)
                        return "searchResponse." + error;
                }
            }
            if (message.followSuggestionsRequest != null && message.hasOwnProperty("followSuggestionsRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FollowSuggestionsRequest.verify(message.followSuggestionsRequest);
                    if (error)
                        return "followSuggestionsRequest." + error;
                }
            }
            if (message.followSuggestionsResponse != null && message.hasOwnProperty("followSuggestionsResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FollowSuggestionsResponse.verify(message.followSuggestionsResponse);
                    if (error)
                        return "followSuggestionsResponse." + error;
                }
            }
            if (message.setLinkRequest != null && message.hasOwnProperty("setLinkRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SetLinkRequest.verify(message.setLinkRequest);
                    if (error)
                        return "setLinkRequest." + error;
                }
            }
            if (message.setLinkResult != null && message.hasOwnProperty("setLinkResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SetLinkResult.verify(message.setLinkResult);
                    if (error)
                        return "setLinkResult." + error;
                }
            }
            if (message.setBioRequest != null && message.hasOwnProperty("setBioRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SetBioRequest.verify(message.setBioRequest);
                    if (error)
                        return "setBioRequest." + error;
                }
            }
            if (message.setBioResult != null && message.hasOwnProperty("setBioResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SetBioResult.verify(message.setBioResult);
                    if (error)
                        return "setBioResult." + error;
                }
            }
            if (message.userProfileRequest != null && message.hasOwnProperty("userProfileRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UserProfileRequest.verify(message.userProfileRequest);
                    if (error)
                        return "userProfileRequest." + error;
                }
            }
            if (message.userProfileResult != null && message.hasOwnProperty("userProfileResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UserProfileResult.verify(message.userProfileResult);
                    if (error)
                        return "userProfileResult." + error;
                }
            }
            if (message.postMetricsRequest != null && message.hasOwnProperty("postMetricsRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PostMetricsRequest.verify(message.postMetricsRequest);
                    if (error)
                        return "postMetricsRequest." + error;
                }
            }
            if (message.postMetricsResult != null && message.hasOwnProperty("postMetricsResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PostMetricsResult.verify(message.postMetricsResult);
                    if (error)
                        return "postMetricsResult." + error;
                }
            }
            if (message.aiImageRequest != null && message.hasOwnProperty("aiImageRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.AiImageRequest.verify(message.aiImageRequest);
                    if (error)
                        return "aiImageRequest." + error;
                }
            }
            if (message.aiImageResult != null && message.hasOwnProperty("aiImageResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.AiImageResult.verify(message.aiImageResult);
                    if (error)
                        return "aiImageResult." + error;
                }
            }
            if (message.archiveRequest != null && message.hasOwnProperty("archiveRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ArchiveRequest.verify(message.archiveRequest);
                    if (error)
                        return "archiveRequest." + error;
                }
            }
            if (message.archiveResult != null && message.hasOwnProperty("archiveResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ArchiveResult.verify(message.archiveResult);
                    if (error)
                        return "archiveResult." + error;
                }
            }
            if (message.postSubscriptionRequest != null && message.hasOwnProperty("postSubscriptionRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PostSubscriptionRequest.verify(message.postSubscriptionRequest);
                    if (error)
                        return "postSubscriptionRequest." + error;
                }
            }
            if (message.postSubscriptionResponse != null && message.hasOwnProperty("postSubscriptionResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PostSubscriptionResponse.verify(message.postSubscriptionResponse);
                    if (error)
                        return "postSubscriptionResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Iq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Iq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Iq} Iq
         */
        Iq.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Iq)
                return object;
            var message = new $root.server.Iq();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "GET":
            case 0:
                message.type = 0;
                break;
            case "SET":
            case 1:
                message.type = 1;
                break;
            case "RESULT":
            case 2:
                message.type = 2;
                break;
            case "ERROR":
            case 3:
                message.type = 3;
                break;
            }
            if (object.uploadMedia != null) {
                if (typeof object.uploadMedia !== "object")
                    throw TypeError(".server.Iq.uploadMedia: object expected");
                message.uploadMedia = $root.server.UploadMedia.fromObject(object.uploadMedia);
            }
            if (object.contactList != null) {
                if (typeof object.contactList !== "object")
                    throw TypeError(".server.Iq.contactList: object expected");
                message.contactList = $root.server.ContactList.fromObject(object.contactList);
            }
            if (object.uploadAvatar != null) {
                if (typeof object.uploadAvatar !== "object")
                    throw TypeError(".server.Iq.uploadAvatar: object expected");
                message.uploadAvatar = $root.server.UploadAvatar.fromObject(object.uploadAvatar);
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".server.Iq.avatar: object expected");
                message.avatar = $root.server.Avatar.fromObject(object.avatar);
            }
            if (object.avatars != null) {
                if (typeof object.avatars !== "object")
                    throw TypeError(".server.Iq.avatars: object expected");
                message.avatars = $root.server.Avatars.fromObject(object.avatars);
            }
            if (object.clientMode != null) {
                if (typeof object.clientMode !== "object")
                    throw TypeError(".server.Iq.clientMode: object expected");
                message.clientMode = $root.server.ClientMode.fromObject(object.clientMode);
            }
            if (object.clientVersion != null) {
                if (typeof object.clientVersion !== "object")
                    throw TypeError(".server.Iq.clientVersion: object expected");
                message.clientVersion = $root.server.ClientVersion.fromObject(object.clientVersion);
            }
            if (object.pushRegister != null) {
                if (typeof object.pushRegister !== "object")
                    throw TypeError(".server.Iq.pushRegister: object expected");
                message.pushRegister = $root.server.PushRegister.fromObject(object.pushRegister);
            }
            if (object.whisperKeys != null) {
                if (typeof object.whisperKeys !== "object")
                    throw TypeError(".server.Iq.whisperKeys: object expected");
                message.whisperKeys = $root.server.WhisperKeys.fromObject(object.whisperKeys);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".server.Iq.ping: object expected");
                message.ping = $root.server.Ping.fromObject(object.ping);
            }
            if (object.feedItem != null) {
                if (typeof object.feedItem !== "object")
                    throw TypeError(".server.Iq.feedItem: object expected");
                message.feedItem = $root.server.FeedItem.fromObject(object.feedItem);
            }
            if (object.privacyList != null) {
                if (typeof object.privacyList !== "object")
                    throw TypeError(".server.Iq.privacyList: object expected");
                message.privacyList = $root.server.PrivacyList.fromObject(object.privacyList);
            }
            if (object.privacyLists != null) {
                if (typeof object.privacyLists !== "object")
                    throw TypeError(".server.Iq.privacyLists: object expected");
                message.privacyLists = $root.server.PrivacyLists.fromObject(object.privacyLists);
            }
            if (object.groupStanza != null) {
                if (typeof object.groupStanza !== "object")
                    throw TypeError(".server.Iq.groupStanza: object expected");
                message.groupStanza = $root.server.GroupStanza.fromObject(object.groupStanza);
            }
            if (object.groupsStanza != null) {
                if (typeof object.groupsStanza !== "object")
                    throw TypeError(".server.Iq.groupsStanza: object expected");
                message.groupsStanza = $root.server.GroupsStanza.fromObject(object.groupsStanza);
            }
            if (object.clientLog != null) {
                if (typeof object.clientLog !== "object")
                    throw TypeError(".server.Iq.clientLog: object expected");
                message.clientLog = $root.server.ClientLog.fromObject(object.clientLog);
            }
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".server.Iq.name: object expected");
                message.name = $root.server.Name.fromObject(object.name);
            }
            if (object.errorStanza != null) {
                if (typeof object.errorStanza !== "object")
                    throw TypeError(".server.Iq.errorStanza: object expected");
                message.errorStanza = $root.server.ErrorStanza.fromObject(object.errorStanza);
            }
            if (object.props != null) {
                if (typeof object.props !== "object")
                    throw TypeError(".server.Iq.props: object expected");
                message.props = $root.server.Props.fromObject(object.props);
            }
            if (object.invitesRequest != null) {
                if (typeof object.invitesRequest !== "object")
                    throw TypeError(".server.Iq.invitesRequest: object expected");
                message.invitesRequest = $root.server.InvitesRequest.fromObject(object.invitesRequest);
            }
            if (object.invitesResponse != null) {
                if (typeof object.invitesResponse !== "object")
                    throw TypeError(".server.Iq.invitesResponse: object expected");
                message.invitesResponse = $root.server.InvitesResponse.fromObject(object.invitesResponse);
            }
            if (object.notificationPrefs != null) {
                if (typeof object.notificationPrefs !== "object")
                    throw TypeError(".server.Iq.notificationPrefs: object expected");
                message.notificationPrefs = $root.server.NotificationPrefs.fromObject(object.notificationPrefs);
            }
            if (object.groupFeedItem != null) {
                if (typeof object.groupFeedItem !== "object")
                    throw TypeError(".server.Iq.groupFeedItem: object expected");
                message.groupFeedItem = $root.server.GroupFeedItem.fromObject(object.groupFeedItem);
            }
            if (object.groupAvatar != null) {
                if (typeof object.groupAvatar !== "object")
                    throw TypeError(".server.Iq.groupAvatar: object expected");
                message.groupAvatar = $root.server.UploadGroupAvatar.fromObject(object.groupAvatar);
            }
            if (object.deleteAccount != null) {
                if (typeof object.deleteAccount !== "object")
                    throw TypeError(".server.Iq.deleteAccount: object expected");
                message.deleteAccount = $root.server.DeleteAccount.fromObject(object.deleteAccount);
            }
            if (object.groupInviteLink != null) {
                if (typeof object.groupInviteLink !== "object")
                    throw TypeError(".server.Iq.groupInviteLink: object expected");
                message.groupInviteLink = $root.server.GroupInviteLink.fromObject(object.groupInviteLink);
            }
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.Iq.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            if (object.exportData != null) {
                if (typeof object.exportData !== "object")
                    throw TypeError(".server.Iq.exportData: object expected");
                message.exportData = $root.server.ExportData.fromObject(object.exportData);
            }
            if (object.contactSyncError != null) {
                if (typeof object.contactSyncError !== "object")
                    throw TypeError(".server.Iq.contactSyncError: object expected");
                message.contactSyncError = $root.server.ContactSyncError.fromObject(object.contactSyncError);
            }
            if (object.clientOtpRequest != null) {
                if (typeof object.clientOtpRequest !== "object")
                    throw TypeError(".server.Iq.clientOtpRequest: object expected");
                message.clientOtpRequest = $root.server.ClientOtpRequest.fromObject(object.clientOtpRequest);
            }
            if (object.clientOtpResponse != null) {
                if (typeof object.clientOtpResponse !== "object")
                    throw TypeError(".server.Iq.clientOtpResponse: object expected");
                message.clientOtpResponse = $root.server.ClientOtpResponse.fromObject(object.clientOtpResponse);
            }
            if (object.whisperKeysCollection != null) {
                if (typeof object.whisperKeysCollection !== "object")
                    throw TypeError(".server.Iq.whisperKeysCollection: object expected");
                message.whisperKeysCollection = $root.server.WhisperKeysCollection.fromObject(object.whisperKeysCollection);
            }
            if (object.getCallServers != null) {
                if (typeof object.getCallServers !== "object")
                    throw TypeError(".server.Iq.getCallServers: object expected");
                message.getCallServers = $root.server.GetCallServers.fromObject(object.getCallServers);
            }
            if (object.getCallServersResult != null) {
                if (typeof object.getCallServersResult !== "object")
                    throw TypeError(".server.Iq.getCallServersResult: object expected");
                message.getCallServersResult = $root.server.GetCallServersResult.fromObject(object.getCallServersResult);
            }
            if (object.startCall != null) {
                if (typeof object.startCall !== "object")
                    throw TypeError(".server.Iq.startCall: object expected");
                message.startCall = $root.server.StartCall.fromObject(object.startCall);
            }
            if (object.startCallResult != null) {
                if (typeof object.startCallResult !== "object")
                    throw TypeError(".server.Iq.startCallResult: object expected");
                message.startCallResult = $root.server.StartCallResult.fromObject(object.startCallResult);
            }
            if (object.truncWhisperKeysCollection != null) {
                if (typeof object.truncWhisperKeysCollection !== "object")
                    throw TypeError(".server.Iq.truncWhisperKeysCollection: object expected");
                message.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.fromObject(object.truncWhisperKeysCollection);
            }
            if (object.externalSharePost != null) {
                if (typeof object.externalSharePost !== "object")
                    throw TypeError(".server.Iq.externalSharePost: object expected");
                message.externalSharePost = $root.server.ExternalSharePost.fromObject(object.externalSharePost);
            }
            if (object.externalSharePostContainer != null) {
                if (typeof object.externalSharePostContainer !== "object")
                    throw TypeError(".server.Iq.externalSharePostContainer: object expected");
                message.externalSharePostContainer = $root.server.ExternalSharePostContainer.fromObject(object.externalSharePostContainer);
            }
            if (object.webClientInfo != null) {
                if (typeof object.webClientInfo !== "object")
                    throw TypeError(".server.Iq.webClientInfo: object expected");
                message.webClientInfo = $root.server.WebClientInfo.fromObject(object.webClientInfo);
            }
            if (object.reportUserContent != null) {
                if (typeof object.reportUserContent !== "object")
                    throw TypeError(".server.Iq.reportUserContent: object expected");
                message.reportUserContent = $root.server.ReportUserContent.fromObject(object.reportUserContent);
            }
            if (object.publicFeedRequest != null) {
                if (typeof object.publicFeedRequest !== "object")
                    throw TypeError(".server.Iq.publicFeedRequest: object expected");
                message.publicFeedRequest = $root.server.PublicFeedRequest.fromObject(object.publicFeedRequest);
            }
            if (object.publicFeedResponse != null) {
                if (typeof object.publicFeedResponse !== "object")
                    throw TypeError(".server.Iq.publicFeedResponse: object expected");
                message.publicFeedResponse = $root.server.PublicFeedResponse.fromObject(object.publicFeedResponse);
            }
            if (object.relationshipRequest != null) {
                if (typeof object.relationshipRequest !== "object")
                    throw TypeError(".server.Iq.relationshipRequest: object expected");
                message.relationshipRequest = $root.server.RelationshipRequest.fromObject(object.relationshipRequest);
            }
            if (object.relationshipResponse != null) {
                if (typeof object.relationshipResponse !== "object")
                    throw TypeError(".server.Iq.relationshipResponse: object expected");
                message.relationshipResponse = $root.server.RelationshipResponse.fromObject(object.relationshipResponse);
            }
            if (object.relationshipList != null) {
                if (typeof object.relationshipList !== "object")
                    throw TypeError(".server.Iq.relationshipList: object expected");
                message.relationshipList = $root.server.RelationshipList.fromObject(object.relationshipList);
            }
            if (object.usernameRequest != null) {
                if (typeof object.usernameRequest !== "object")
                    throw TypeError(".server.Iq.usernameRequest: object expected");
                message.usernameRequest = $root.server.UsernameRequest.fromObject(object.usernameRequest);
            }
            if (object.usernameResponse != null) {
                if (typeof object.usernameResponse !== "object")
                    throw TypeError(".server.Iq.usernameResponse: object expected");
                message.usernameResponse = $root.server.UsernameResponse.fromObject(object.usernameResponse);
            }
            if (object.searchRequest != null) {
                if (typeof object.searchRequest !== "object")
                    throw TypeError(".server.Iq.searchRequest: object expected");
                message.searchRequest = $root.server.SearchRequest.fromObject(object.searchRequest);
            }
            if (object.searchResponse != null) {
                if (typeof object.searchResponse !== "object")
                    throw TypeError(".server.Iq.searchResponse: object expected");
                message.searchResponse = $root.server.SearchResponse.fromObject(object.searchResponse);
            }
            if (object.followSuggestionsRequest != null) {
                if (typeof object.followSuggestionsRequest !== "object")
                    throw TypeError(".server.Iq.followSuggestionsRequest: object expected");
                message.followSuggestionsRequest = $root.server.FollowSuggestionsRequest.fromObject(object.followSuggestionsRequest);
            }
            if (object.followSuggestionsResponse != null) {
                if (typeof object.followSuggestionsResponse !== "object")
                    throw TypeError(".server.Iq.followSuggestionsResponse: object expected");
                message.followSuggestionsResponse = $root.server.FollowSuggestionsResponse.fromObject(object.followSuggestionsResponse);
            }
            if (object.setLinkRequest != null) {
                if (typeof object.setLinkRequest !== "object")
                    throw TypeError(".server.Iq.setLinkRequest: object expected");
                message.setLinkRequest = $root.server.SetLinkRequest.fromObject(object.setLinkRequest);
            }
            if (object.setLinkResult != null) {
                if (typeof object.setLinkResult !== "object")
                    throw TypeError(".server.Iq.setLinkResult: object expected");
                message.setLinkResult = $root.server.SetLinkResult.fromObject(object.setLinkResult);
            }
            if (object.setBioRequest != null) {
                if (typeof object.setBioRequest !== "object")
                    throw TypeError(".server.Iq.setBioRequest: object expected");
                message.setBioRequest = $root.server.SetBioRequest.fromObject(object.setBioRequest);
            }
            if (object.setBioResult != null) {
                if (typeof object.setBioResult !== "object")
                    throw TypeError(".server.Iq.setBioResult: object expected");
                message.setBioResult = $root.server.SetBioResult.fromObject(object.setBioResult);
            }
            if (object.userProfileRequest != null) {
                if (typeof object.userProfileRequest !== "object")
                    throw TypeError(".server.Iq.userProfileRequest: object expected");
                message.userProfileRequest = $root.server.UserProfileRequest.fromObject(object.userProfileRequest);
            }
            if (object.userProfileResult != null) {
                if (typeof object.userProfileResult !== "object")
                    throw TypeError(".server.Iq.userProfileResult: object expected");
                message.userProfileResult = $root.server.UserProfileResult.fromObject(object.userProfileResult);
            }
            if (object.postMetricsRequest != null) {
                if (typeof object.postMetricsRequest !== "object")
                    throw TypeError(".server.Iq.postMetricsRequest: object expected");
                message.postMetricsRequest = $root.server.PostMetricsRequest.fromObject(object.postMetricsRequest);
            }
            if (object.postMetricsResult != null) {
                if (typeof object.postMetricsResult !== "object")
                    throw TypeError(".server.Iq.postMetricsResult: object expected");
                message.postMetricsResult = $root.server.PostMetricsResult.fromObject(object.postMetricsResult);
            }
            if (object.aiImageRequest != null) {
                if (typeof object.aiImageRequest !== "object")
                    throw TypeError(".server.Iq.aiImageRequest: object expected");
                message.aiImageRequest = $root.server.AiImageRequest.fromObject(object.aiImageRequest);
            }
            if (object.aiImageResult != null) {
                if (typeof object.aiImageResult !== "object")
                    throw TypeError(".server.Iq.aiImageResult: object expected");
                message.aiImageResult = $root.server.AiImageResult.fromObject(object.aiImageResult);
            }
            if (object.archiveRequest != null) {
                if (typeof object.archiveRequest !== "object")
                    throw TypeError(".server.Iq.archiveRequest: object expected");
                message.archiveRequest = $root.server.ArchiveRequest.fromObject(object.archiveRequest);
            }
            if (object.archiveResult != null) {
                if (typeof object.archiveResult !== "object")
                    throw TypeError(".server.Iq.archiveResult: object expected");
                message.archiveResult = $root.server.ArchiveResult.fromObject(object.archiveResult);
            }
            if (object.postSubscriptionRequest != null) {
                if (typeof object.postSubscriptionRequest !== "object")
                    throw TypeError(".server.Iq.postSubscriptionRequest: object expected");
                message.postSubscriptionRequest = $root.server.PostSubscriptionRequest.fromObject(object.postSubscriptionRequest);
            }
            if (object.postSubscriptionResponse != null) {
                if (typeof object.postSubscriptionResponse !== "object")
                    throw TypeError(".server.Iq.postSubscriptionResponse: object expected");
                message.postSubscriptionResponse = $root.server.PostSubscriptionResponse.fromObject(object.postSubscriptionResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from an Iq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Iq
         * @static
         * @param {server.Iq} message Iq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Iq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "GET" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Iq.Type[message.type] : message.type;
            if (message.uploadMedia != null && message.hasOwnProperty("uploadMedia")) {
                object.uploadMedia = $root.server.UploadMedia.toObject(message.uploadMedia, options);
                if (options.oneofs)
                    object.payload = "uploadMedia";
            }
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                object.contactList = $root.server.ContactList.toObject(message.contactList, options);
                if (options.oneofs)
                    object.payload = "contactList";
            }
            if (message.uploadAvatar != null && message.hasOwnProperty("uploadAvatar")) {
                object.uploadAvatar = $root.server.UploadAvatar.toObject(message.uploadAvatar, options);
                if (options.oneofs)
                    object.payload = "uploadAvatar";
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                object.avatar = $root.server.Avatar.toObject(message.avatar, options);
                if (options.oneofs)
                    object.payload = "avatar";
            }
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                object.avatars = $root.server.Avatars.toObject(message.avatars, options);
                if (options.oneofs)
                    object.payload = "avatars";
            }
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                object.clientMode = $root.server.ClientMode.toObject(message.clientMode, options);
                if (options.oneofs)
                    object.payload = "clientMode";
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                object.clientVersion = $root.server.ClientVersion.toObject(message.clientVersion, options);
                if (options.oneofs)
                    object.payload = "clientVersion";
            }
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                object.pushRegister = $root.server.PushRegister.toObject(message.pushRegister, options);
                if (options.oneofs)
                    object.payload = "pushRegister";
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                object.whisperKeys = $root.server.WhisperKeys.toObject(message.whisperKeys, options);
                if (options.oneofs)
                    object.payload = "whisperKeys";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.server.Ping.toObject(message.ping, options);
                if (options.oneofs)
                    object.payload = "ping";
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                object.feedItem = $root.server.FeedItem.toObject(message.feedItem, options);
                if (options.oneofs)
                    object.payload = "feedItem";
            }
            if (message.privacyList != null && message.hasOwnProperty("privacyList")) {
                object.privacyList = $root.server.PrivacyList.toObject(message.privacyList, options);
                if (options.oneofs)
                    object.payload = "privacyList";
            }
            if (message.privacyLists != null && message.hasOwnProperty("privacyLists")) {
                object.privacyLists = $root.server.PrivacyLists.toObject(message.privacyLists, options);
                if (options.oneofs)
                    object.payload = "privacyLists";
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                object.groupStanza = $root.server.GroupStanza.toObject(message.groupStanza, options);
                if (options.oneofs)
                    object.payload = "groupStanza";
            }
            if (message.groupsStanza != null && message.hasOwnProperty("groupsStanza")) {
                object.groupsStanza = $root.server.GroupsStanza.toObject(message.groupsStanza, options);
                if (options.oneofs)
                    object.payload = "groupsStanza";
            }
            if (message.clientLog != null && message.hasOwnProperty("clientLog")) {
                object.clientLog = $root.server.ClientLog.toObject(message.clientLog, options);
                if (options.oneofs)
                    object.payload = "clientLog";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = $root.server.Name.toObject(message.name, options);
                if (options.oneofs)
                    object.payload = "name";
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                object.errorStanza = $root.server.ErrorStanza.toObject(message.errorStanza, options);
                if (options.oneofs)
                    object.payload = "errorStanza";
            }
            if (message.props != null && message.hasOwnProperty("props")) {
                object.props = $root.server.Props.toObject(message.props, options);
                if (options.oneofs)
                    object.payload = "props";
            }
            if (message.invitesRequest != null && message.hasOwnProperty("invitesRequest")) {
                object.invitesRequest = $root.server.InvitesRequest.toObject(message.invitesRequest, options);
                if (options.oneofs)
                    object.payload = "invitesRequest";
            }
            if (message.invitesResponse != null && message.hasOwnProperty("invitesResponse")) {
                object.invitesResponse = $root.server.InvitesResponse.toObject(message.invitesResponse, options);
                if (options.oneofs)
                    object.payload = "invitesResponse";
            }
            if (message.notificationPrefs != null && message.hasOwnProperty("notificationPrefs")) {
                object.notificationPrefs = $root.server.NotificationPrefs.toObject(message.notificationPrefs, options);
                if (options.oneofs)
                    object.payload = "notificationPrefs";
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                object.groupFeedItem = $root.server.GroupFeedItem.toObject(message.groupFeedItem, options);
                if (options.oneofs)
                    object.payload = "groupFeedItem";
            }
            if (message.groupAvatar != null && message.hasOwnProperty("groupAvatar")) {
                object.groupAvatar = $root.server.UploadGroupAvatar.toObject(message.groupAvatar, options);
                if (options.oneofs)
                    object.payload = "groupAvatar";
            }
            if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                object.deleteAccount = $root.server.DeleteAccount.toObject(message.deleteAccount, options);
                if (options.oneofs)
                    object.payload = "deleteAccount";
            }
            if (message.groupInviteLink != null && message.hasOwnProperty("groupInviteLink")) {
                object.groupInviteLink = $root.server.GroupInviteLink.toObject(message.groupInviteLink, options);
                if (options.oneofs)
                    object.payload = "groupInviteLink";
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
                if (options.oneofs)
                    object.payload = "historyResend";
            }
            if (message.exportData != null && message.hasOwnProperty("exportData")) {
                object.exportData = $root.server.ExportData.toObject(message.exportData, options);
                if (options.oneofs)
                    object.payload = "exportData";
            }
            if (message.contactSyncError != null && message.hasOwnProperty("contactSyncError")) {
                object.contactSyncError = $root.server.ContactSyncError.toObject(message.contactSyncError, options);
                if (options.oneofs)
                    object.payload = "contactSyncError";
            }
            if (message.clientOtpRequest != null && message.hasOwnProperty("clientOtpRequest")) {
                object.clientOtpRequest = $root.server.ClientOtpRequest.toObject(message.clientOtpRequest, options);
                if (options.oneofs)
                    object.payload = "clientOtpRequest";
            }
            if (message.clientOtpResponse != null && message.hasOwnProperty("clientOtpResponse")) {
                object.clientOtpResponse = $root.server.ClientOtpResponse.toObject(message.clientOtpResponse, options);
                if (options.oneofs)
                    object.payload = "clientOtpResponse";
            }
            if (message.whisperKeysCollection != null && message.hasOwnProperty("whisperKeysCollection")) {
                object.whisperKeysCollection = $root.server.WhisperKeysCollection.toObject(message.whisperKeysCollection, options);
                if (options.oneofs)
                    object.payload = "whisperKeysCollection";
            }
            if (message.getCallServers != null && message.hasOwnProperty("getCallServers")) {
                object.getCallServers = $root.server.GetCallServers.toObject(message.getCallServers, options);
                if (options.oneofs)
                    object.payload = "getCallServers";
            }
            if (message.getCallServersResult != null && message.hasOwnProperty("getCallServersResult")) {
                object.getCallServersResult = $root.server.GetCallServersResult.toObject(message.getCallServersResult, options);
                if (options.oneofs)
                    object.payload = "getCallServersResult";
            }
            if (message.startCall != null && message.hasOwnProperty("startCall")) {
                object.startCall = $root.server.StartCall.toObject(message.startCall, options);
                if (options.oneofs)
                    object.payload = "startCall";
            }
            if (message.startCallResult != null && message.hasOwnProperty("startCallResult")) {
                object.startCallResult = $root.server.StartCallResult.toObject(message.startCallResult, options);
                if (options.oneofs)
                    object.payload = "startCallResult";
            }
            if (message.truncWhisperKeysCollection != null && message.hasOwnProperty("truncWhisperKeysCollection")) {
                object.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.toObject(message.truncWhisperKeysCollection, options);
                if (options.oneofs)
                    object.payload = "truncWhisperKeysCollection";
            }
            if (message.externalSharePost != null && message.hasOwnProperty("externalSharePost")) {
                object.externalSharePost = $root.server.ExternalSharePost.toObject(message.externalSharePost, options);
                if (options.oneofs)
                    object.payload = "externalSharePost";
            }
            if (message.externalSharePostContainer != null && message.hasOwnProperty("externalSharePostContainer")) {
                object.externalSharePostContainer = $root.server.ExternalSharePostContainer.toObject(message.externalSharePostContainer, options);
                if (options.oneofs)
                    object.payload = "externalSharePostContainer";
            }
            if (message.webClientInfo != null && message.hasOwnProperty("webClientInfo")) {
                object.webClientInfo = $root.server.WebClientInfo.toObject(message.webClientInfo, options);
                if (options.oneofs)
                    object.payload = "webClientInfo";
            }
            if (message.reportUserContent != null && message.hasOwnProperty("reportUserContent")) {
                object.reportUserContent = $root.server.ReportUserContent.toObject(message.reportUserContent, options);
                if (options.oneofs)
                    object.payload = "reportUserContent";
            }
            if (message.publicFeedRequest != null && message.hasOwnProperty("publicFeedRequest")) {
                object.publicFeedRequest = $root.server.PublicFeedRequest.toObject(message.publicFeedRequest, options);
                if (options.oneofs)
                    object.payload = "publicFeedRequest";
            }
            if (message.publicFeedResponse != null && message.hasOwnProperty("publicFeedResponse")) {
                object.publicFeedResponse = $root.server.PublicFeedResponse.toObject(message.publicFeedResponse, options);
                if (options.oneofs)
                    object.payload = "publicFeedResponse";
            }
            if (message.relationshipRequest != null && message.hasOwnProperty("relationshipRequest")) {
                object.relationshipRequest = $root.server.RelationshipRequest.toObject(message.relationshipRequest, options);
                if (options.oneofs)
                    object.payload = "relationshipRequest";
            }
            if (message.relationshipResponse != null && message.hasOwnProperty("relationshipResponse")) {
                object.relationshipResponse = $root.server.RelationshipResponse.toObject(message.relationshipResponse, options);
                if (options.oneofs)
                    object.payload = "relationshipResponse";
            }
            if (message.relationshipList != null && message.hasOwnProperty("relationshipList")) {
                object.relationshipList = $root.server.RelationshipList.toObject(message.relationshipList, options);
                if (options.oneofs)
                    object.payload = "relationshipList";
            }
            if (message.usernameRequest != null && message.hasOwnProperty("usernameRequest")) {
                object.usernameRequest = $root.server.UsernameRequest.toObject(message.usernameRequest, options);
                if (options.oneofs)
                    object.payload = "usernameRequest";
            }
            if (message.usernameResponse != null && message.hasOwnProperty("usernameResponse")) {
                object.usernameResponse = $root.server.UsernameResponse.toObject(message.usernameResponse, options);
                if (options.oneofs)
                    object.payload = "usernameResponse";
            }
            if (message.searchRequest != null && message.hasOwnProperty("searchRequest")) {
                object.searchRequest = $root.server.SearchRequest.toObject(message.searchRequest, options);
                if (options.oneofs)
                    object.payload = "searchRequest";
            }
            if (message.searchResponse != null && message.hasOwnProperty("searchResponse")) {
                object.searchResponse = $root.server.SearchResponse.toObject(message.searchResponse, options);
                if (options.oneofs)
                    object.payload = "searchResponse";
            }
            if (message.followSuggestionsRequest != null && message.hasOwnProperty("followSuggestionsRequest")) {
                object.followSuggestionsRequest = $root.server.FollowSuggestionsRequest.toObject(message.followSuggestionsRequest, options);
                if (options.oneofs)
                    object.payload = "followSuggestionsRequest";
            }
            if (message.followSuggestionsResponse != null && message.hasOwnProperty("followSuggestionsResponse")) {
                object.followSuggestionsResponse = $root.server.FollowSuggestionsResponse.toObject(message.followSuggestionsResponse, options);
                if (options.oneofs)
                    object.payload = "followSuggestionsResponse";
            }
            if (message.setLinkRequest != null && message.hasOwnProperty("setLinkRequest")) {
                object.setLinkRequest = $root.server.SetLinkRequest.toObject(message.setLinkRequest, options);
                if (options.oneofs)
                    object.payload = "setLinkRequest";
            }
            if (message.setLinkResult != null && message.hasOwnProperty("setLinkResult")) {
                object.setLinkResult = $root.server.SetLinkResult.toObject(message.setLinkResult, options);
                if (options.oneofs)
                    object.payload = "setLinkResult";
            }
            if (message.setBioRequest != null && message.hasOwnProperty("setBioRequest")) {
                object.setBioRequest = $root.server.SetBioRequest.toObject(message.setBioRequest, options);
                if (options.oneofs)
                    object.payload = "setBioRequest";
            }
            if (message.setBioResult != null && message.hasOwnProperty("setBioResult")) {
                object.setBioResult = $root.server.SetBioResult.toObject(message.setBioResult, options);
                if (options.oneofs)
                    object.payload = "setBioResult";
            }
            if (message.userProfileRequest != null && message.hasOwnProperty("userProfileRequest")) {
                object.userProfileRequest = $root.server.UserProfileRequest.toObject(message.userProfileRequest, options);
                if (options.oneofs)
                    object.payload = "userProfileRequest";
            }
            if (message.userProfileResult != null && message.hasOwnProperty("userProfileResult")) {
                object.userProfileResult = $root.server.UserProfileResult.toObject(message.userProfileResult, options);
                if (options.oneofs)
                    object.payload = "userProfileResult";
            }
            if (message.postMetricsRequest != null && message.hasOwnProperty("postMetricsRequest")) {
                object.postMetricsRequest = $root.server.PostMetricsRequest.toObject(message.postMetricsRequest, options);
                if (options.oneofs)
                    object.payload = "postMetricsRequest";
            }
            if (message.postMetricsResult != null && message.hasOwnProperty("postMetricsResult")) {
                object.postMetricsResult = $root.server.PostMetricsResult.toObject(message.postMetricsResult, options);
                if (options.oneofs)
                    object.payload = "postMetricsResult";
            }
            if (message.aiImageRequest != null && message.hasOwnProperty("aiImageRequest")) {
                object.aiImageRequest = $root.server.AiImageRequest.toObject(message.aiImageRequest, options);
                if (options.oneofs)
                    object.payload = "aiImageRequest";
            }
            if (message.aiImageResult != null && message.hasOwnProperty("aiImageResult")) {
                object.aiImageResult = $root.server.AiImageResult.toObject(message.aiImageResult, options);
                if (options.oneofs)
                    object.payload = "aiImageResult";
            }
            if (message.archiveRequest != null && message.hasOwnProperty("archiveRequest")) {
                object.archiveRequest = $root.server.ArchiveRequest.toObject(message.archiveRequest, options);
                if (options.oneofs)
                    object.payload = "archiveRequest";
            }
            if (message.archiveResult != null && message.hasOwnProperty("archiveResult")) {
                object.archiveResult = $root.server.ArchiveResult.toObject(message.archiveResult, options);
                if (options.oneofs)
                    object.payload = "archiveResult";
            }
            if (message.postSubscriptionRequest != null && message.hasOwnProperty("postSubscriptionRequest")) {
                object.postSubscriptionRequest = $root.server.PostSubscriptionRequest.toObject(message.postSubscriptionRequest, options);
                if (options.oneofs)
                    object.payload = "postSubscriptionRequest";
            }
            if (message.postSubscriptionResponse != null && message.hasOwnProperty("postSubscriptionResponse")) {
                object.postSubscriptionResponse = $root.server.PostSubscriptionResponse.toObject(message.postSubscriptionResponse, options);
                if (options.oneofs)
                    object.payload = "postSubscriptionResponse";
            }
            return object;
        };

        /**
         * Converts this Iq to JSON.
         * @function toJSON
         * @memberof server.Iq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Iq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Iq.Type
         * @enum {number}
         * @property {number} GET=0 GET value
         * @property {number} SET=1 SET value
         * @property {number} RESULT=2 RESULT value
         * @property {number} ERROR=3 ERROR value
         */
        Iq.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            values[valuesById[1] = "SET"] = 1;
            values[valuesById[2] = "RESULT"] = 2;
            values[valuesById[3] = "ERROR"] = 3;
            return values;
        })();

        return Iq;
    })();

    server.Msg = (function() {

        /**
         * Properties of a Msg.
         * @memberof server
         * @interface IMsg
         * @property {string|null} [id] Msg id
         * @property {server.Msg.Type|null} [type] Msg type
         * @property {number|Long|null} [toUid] Msg toUid
         * @property {number|Long|null} [fromUid] Msg fromUid
         * @property {server.IContactList|null} [contactList] Msg contactList
         * @property {server.IAvatar|null} [avatar] Msg avatar
         * @property {server.IWhisperKeys|null} [whisperKeys] Msg whisperKeys
         * @property {server.ISeenReceipt|null} [seenReceipt] Msg seenReceipt
         * @property {server.IDeliveryReceipt|null} [deliveryReceipt] Msg deliveryReceipt
         * @property {server.IChatStanza|null} [chatStanza] Msg chatStanza
         * @property {server.IFeedItem|null} [feedItem] Msg feedItem
         * @property {server.IFeedItems|null} [feedItems] Msg feedItems
         * @property {server.IContactHash|null} [contactHash] Msg contactHash
         * @property {server.IGroupStanza|null} [groupStanza] Msg groupStanza
         * @property {server.IGroupChat|null} [groupChat] Msg groupChat
         * @property {server.IName|null} [name] Msg name
         * @property {server.IErrorStanza|null} [errorStanza] Msg errorStanza
         * @property {server.IGroupChatRetract|null} [groupchatRetract] Msg groupchatRetract
         * @property {server.IChatRetract|null} [chatRetract] Msg chatRetract
         * @property {server.IGroupFeedItem|null} [groupFeedItem] Msg groupFeedItem
         * @property {server.IRerequest|null} [rerequest] Msg rerequest
         * @property {server.ISilentChatStanza|null} [silentChatStanza] Msg silentChatStanza
         * @property {server.IGroupFeedItems|null} [groupFeedItems] Msg groupFeedItems
         * @property {server.IEndOfQueue|null} [endOfQueue] Msg endOfQueue
         * @property {server.IInviteeNotice|null} [inviteeNotice] Msg inviteeNotice
         * @property {server.IGroupFeedRerequest|null} [groupFeedRerequest] Msg groupFeedRerequest
         * @property {server.IHistoryResend|null} [historyResend] Msg historyResend
         * @property {server.IPlayedReceipt|null} [playedReceipt] Msg playedReceipt
         * @property {server.IRequestLogs|null} [requestLogs] Msg requestLogs
         * @property {server.IWakeUp|null} [wakeup] Msg wakeup
         * @property {server.IHomeFeedRerequest|null} [homeFeedRerequest] Msg homeFeedRerequest
         * @property {server.IIncomingCall|null} [incomingCall] Msg incomingCall
         * @property {server.ICallRinging|null} [callRinging] Msg callRinging
         * @property {server.IAnswerCall|null} [answerCall] Msg answerCall
         * @property {server.IEndCall|null} [endCall] Msg endCall
         * @property {server.IIceCandidate|null} [iceCandidate] Msg iceCandidate
         * @property {server.IMarketingAlert|null} [marketingAlert] Msg marketingAlert
         * @property {server.IIceRestartOffer|null} [iceRestartOffer] Msg iceRestartOffer
         * @property {server.IIceRestartAnswer|null} [iceRestartAnswer] Msg iceRestartAnswer
         * @property {server.IGroupFeedHistory|null} [groupFeedHistory] Msg groupFeedHistory
         * @property {server.IPreAnswerCall|null} [preAnswerCall] Msg preAnswerCall
         * @property {server.IHoldCall|null} [holdCall] Msg holdCall
         * @property {server.IMuteCall|null} [muteCall] Msg muteCall
         * @property {server.IIncomingCallPush|null} [incomingCallPush] Msg incomingCallPush
         * @property {server.ICallSdp|null} [callSdp] Msg callSdp
         * @property {server.IWebStanza|null} [webStanza] Msg webStanza
         * @property {server.IContentMissing|null} [contentMissing] Msg contentMissing
         * @property {server.IScreenshotReceipt|null} [screenshotReceipt] Msg screenshotReceipt
         * @property {server.ISavedReceipt|null} [savedReceipt] Msg savedReceipt
         * @property {server.IGroupChatStanza|null} [groupChatStanza] Msg groupChatStanza
         * @property {server.IMomentNotification|null} [momentNotification] Msg momentNotification
         * @property {server.IProfileUpdate|null} [profileUpdate] Msg profileUpdate
         * @property {server.IPublicFeedUpdate|null} [publicFeedUpdate] Msg publicFeedUpdate
         * @property {server.IAiImage|null} [aiImage] Msg aiImage
         * @property {number|null} [retryCount] Msg retryCount
         * @property {number|null} [rerequestCount] Msg rerequestCount
         */

        /**
         * Constructs a new Msg.
         * @memberof server
         * @classdesc Represents a Msg.
         * @implements IMsg
         * @constructor
         * @param {server.IMsg=} [properties] Properties to set
         */
        function Msg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Msg id.
         * @member {string} id
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.id = "";

        /**
         * Msg type.
         * @member {server.Msg.Type} type
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.type = 0;

        /**
         * Msg toUid.
         * @member {number|Long} toUid
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.toUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Msg fromUid.
         * @member {number|Long} fromUid
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Msg contactList.
         * @member {server.IContactList|null|undefined} contactList
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.contactList = null;

        /**
         * Msg avatar.
         * @member {server.IAvatar|null|undefined} avatar
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.avatar = null;

        /**
         * Msg whisperKeys.
         * @member {server.IWhisperKeys|null|undefined} whisperKeys
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.whisperKeys = null;

        /**
         * Msg seenReceipt.
         * @member {server.ISeenReceipt|null|undefined} seenReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.seenReceipt = null;

        /**
         * Msg deliveryReceipt.
         * @member {server.IDeliveryReceipt|null|undefined} deliveryReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.deliveryReceipt = null;

        /**
         * Msg chatStanza.
         * @member {server.IChatStanza|null|undefined} chatStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.chatStanza = null;

        /**
         * Msg feedItem.
         * @member {server.IFeedItem|null|undefined} feedItem
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.feedItem = null;

        /**
         * Msg feedItems.
         * @member {server.IFeedItems|null|undefined} feedItems
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.feedItems = null;

        /**
         * Msg contactHash.
         * @member {server.IContactHash|null|undefined} contactHash
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.contactHash = null;

        /**
         * Msg groupStanza.
         * @member {server.IGroupStanza|null|undefined} groupStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupStanza = null;

        /**
         * Msg groupChat.
         * @member {server.IGroupChat|null|undefined} groupChat
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupChat = null;

        /**
         * Msg name.
         * @member {server.IName|null|undefined} name
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.name = null;

        /**
         * Msg errorStanza.
         * @member {server.IErrorStanza|null|undefined} errorStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.errorStanza = null;

        /**
         * Msg groupchatRetract.
         * @member {server.IGroupChatRetract|null|undefined} groupchatRetract
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupchatRetract = null;

        /**
         * Msg chatRetract.
         * @member {server.IChatRetract|null|undefined} chatRetract
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.chatRetract = null;

        /**
         * Msg groupFeedItem.
         * @member {server.IGroupFeedItem|null|undefined} groupFeedItem
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedItem = null;

        /**
         * Msg rerequest.
         * @member {server.IRerequest|null|undefined} rerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.rerequest = null;

        /**
         * Msg silentChatStanza.
         * @member {server.ISilentChatStanza|null|undefined} silentChatStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.silentChatStanza = null;

        /**
         * Msg groupFeedItems.
         * @member {server.IGroupFeedItems|null|undefined} groupFeedItems
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedItems = null;

        /**
         * Msg endOfQueue.
         * @member {server.IEndOfQueue|null|undefined} endOfQueue
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.endOfQueue = null;

        /**
         * Msg inviteeNotice.
         * @member {server.IInviteeNotice|null|undefined} inviteeNotice
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.inviteeNotice = null;

        /**
         * Msg groupFeedRerequest.
         * @member {server.IGroupFeedRerequest|null|undefined} groupFeedRerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedRerequest = null;

        /**
         * Msg historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.historyResend = null;

        /**
         * Msg playedReceipt.
         * @member {server.IPlayedReceipt|null|undefined} playedReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.playedReceipt = null;

        /**
         * Msg requestLogs.
         * @member {server.IRequestLogs|null|undefined} requestLogs
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.requestLogs = null;

        /**
         * Msg wakeup.
         * @member {server.IWakeUp|null|undefined} wakeup
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.wakeup = null;

        /**
         * Msg homeFeedRerequest.
         * @member {server.IHomeFeedRerequest|null|undefined} homeFeedRerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.homeFeedRerequest = null;

        /**
         * Msg incomingCall.
         * @member {server.IIncomingCall|null|undefined} incomingCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.incomingCall = null;

        /**
         * Msg callRinging.
         * @member {server.ICallRinging|null|undefined} callRinging
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.callRinging = null;

        /**
         * Msg answerCall.
         * @member {server.IAnswerCall|null|undefined} answerCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.answerCall = null;

        /**
         * Msg endCall.
         * @member {server.IEndCall|null|undefined} endCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.endCall = null;

        /**
         * Msg iceCandidate.
         * @member {server.IIceCandidate|null|undefined} iceCandidate
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceCandidate = null;

        /**
         * Msg marketingAlert.
         * @member {server.IMarketingAlert|null|undefined} marketingAlert
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.marketingAlert = null;

        /**
         * Msg iceRestartOffer.
         * @member {server.IIceRestartOffer|null|undefined} iceRestartOffer
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceRestartOffer = null;

        /**
         * Msg iceRestartAnswer.
         * @member {server.IIceRestartAnswer|null|undefined} iceRestartAnswer
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceRestartAnswer = null;

        /**
         * Msg groupFeedHistory.
         * @member {server.IGroupFeedHistory|null|undefined} groupFeedHistory
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedHistory = null;

        /**
         * Msg preAnswerCall.
         * @member {server.IPreAnswerCall|null|undefined} preAnswerCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.preAnswerCall = null;

        /**
         * Msg holdCall.
         * @member {server.IHoldCall|null|undefined} holdCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.holdCall = null;

        /**
         * Msg muteCall.
         * @member {server.IMuteCall|null|undefined} muteCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.muteCall = null;

        /**
         * Msg incomingCallPush.
         * @member {server.IIncomingCallPush|null|undefined} incomingCallPush
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.incomingCallPush = null;

        /**
         * Msg callSdp.
         * @member {server.ICallSdp|null|undefined} callSdp
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.callSdp = null;

        /**
         * Msg webStanza.
         * @member {server.IWebStanza|null|undefined} webStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.webStanza = null;

        /**
         * Msg contentMissing.
         * @member {server.IContentMissing|null|undefined} contentMissing
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.contentMissing = null;

        /**
         * Msg screenshotReceipt.
         * @member {server.IScreenshotReceipt|null|undefined} screenshotReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.screenshotReceipt = null;

        /**
         * Msg savedReceipt.
         * @member {server.ISavedReceipt|null|undefined} savedReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.savedReceipt = null;

        /**
         * Msg groupChatStanza.
         * @member {server.IGroupChatStanza|null|undefined} groupChatStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupChatStanza = null;

        /**
         * Msg momentNotification.
         * @member {server.IMomentNotification|null|undefined} momentNotification
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.momentNotification = null;

        /**
         * Msg profileUpdate.
         * @member {server.IProfileUpdate|null|undefined} profileUpdate
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.profileUpdate = null;

        /**
         * Msg publicFeedUpdate.
         * @member {server.IPublicFeedUpdate|null|undefined} publicFeedUpdate
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.publicFeedUpdate = null;

        /**
         * Msg aiImage.
         * @member {server.IAiImage|null|undefined} aiImage
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.aiImage = null;

        /**
         * Msg retryCount.
         * @member {number} retryCount
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.retryCount = 0;

        /**
         * Msg rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.rerequestCount = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Msg payload.
         * @member {"contactList"|"avatar"|"whisperKeys"|"seenReceipt"|"deliveryReceipt"|"chatStanza"|"feedItem"|"feedItems"|"contactHash"|"groupStanza"|"groupChat"|"name"|"errorStanza"|"groupchatRetract"|"chatRetract"|"groupFeedItem"|"rerequest"|"silentChatStanza"|"groupFeedItems"|"endOfQueue"|"inviteeNotice"|"groupFeedRerequest"|"historyResend"|"playedReceipt"|"requestLogs"|"wakeup"|"homeFeedRerequest"|"incomingCall"|"callRinging"|"answerCall"|"endCall"|"iceCandidate"|"marketingAlert"|"iceRestartOffer"|"iceRestartAnswer"|"groupFeedHistory"|"preAnswerCall"|"holdCall"|"muteCall"|"incomingCallPush"|"callSdp"|"webStanza"|"contentMissing"|"screenshotReceipt"|"savedReceipt"|"groupChatStanza"|"momentNotification"|"profileUpdate"|"publicFeedUpdate"|"aiImage"|undefined} payload
         * @memberof server.Msg
         * @instance
         */
        Object.defineProperty(Msg.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["contactList", "avatar", "whisperKeys", "seenReceipt", "deliveryReceipt", "chatStanza", "feedItem", "feedItems", "contactHash", "groupStanza", "groupChat", "name", "errorStanza", "groupchatRetract", "chatRetract", "groupFeedItem", "rerequest", "silentChatStanza", "groupFeedItems", "endOfQueue", "inviteeNotice", "groupFeedRerequest", "historyResend", "playedReceipt", "requestLogs", "wakeup", "homeFeedRerequest", "incomingCall", "callRinging", "answerCall", "endCall", "iceCandidate", "marketingAlert", "iceRestartOffer", "iceRestartAnswer", "groupFeedHistory", "preAnswerCall", "holdCall", "muteCall", "incomingCallPush", "callSdp", "webStanza", "contentMissing", "screenshotReceipt", "savedReceipt", "groupChatStanza", "momentNotification", "profileUpdate", "publicFeedUpdate", "aiImage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Msg instance using the specified properties.
         * @function create
         * @memberof server.Msg
         * @static
         * @param {server.IMsg=} [properties] Properties to set
         * @returns {server.Msg} Msg instance
         */
        Msg.create = function create(properties) {
            return new Msg(properties);
        };

        /**
         * Encodes the specified Msg message. Does not implicitly {@link server.Msg.verify|verify} messages.
         * @function encode
         * @memberof server.Msg
         * @static
         * @param {server.IMsg} message Msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Msg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.toUid);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromUid);
            if (message.contactList != null && Object.hasOwnProperty.call(message, "contactList"))
                $root.server.ContactList.encode(message.contactList, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.server.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.whisperKeys != null && Object.hasOwnProperty.call(message, "whisperKeys"))
                $root.server.WhisperKeys.encode(message.whisperKeys, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.seenReceipt != null && Object.hasOwnProperty.call(message, "seenReceipt"))
                $root.server.SeenReceipt.encode(message.seenReceipt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.deliveryReceipt != null && Object.hasOwnProperty.call(message, "deliveryReceipt"))
                $root.server.DeliveryReceipt.encode(message.deliveryReceipt, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.chatStanza != null && Object.hasOwnProperty.call(message, "chatStanza"))
                $root.server.ChatStanza.encode(message.chatStanza, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.feedItem != null && Object.hasOwnProperty.call(message, "feedItem"))
                $root.server.FeedItem.encode(message.feedItem, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.feedItems != null && Object.hasOwnProperty.call(message, "feedItems"))
                $root.server.FeedItems.encode(message.feedItems, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.contactHash != null && Object.hasOwnProperty.call(message, "contactHash"))
                $root.server.ContactHash.encode(message.contactHash, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.groupStanza != null && Object.hasOwnProperty.call(message, "groupStanza"))
                $root.server.GroupStanza.encode(message.groupStanza, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.groupChat != null && Object.hasOwnProperty.call(message, "groupChat"))
                $root.server.GroupChat.encode(message.groupChat, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.server.Name.encode(message.name, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.errorStanza != null && Object.hasOwnProperty.call(message, "errorStanza"))
                $root.server.ErrorStanza.encode(message.errorStanza, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.groupchatRetract != null && Object.hasOwnProperty.call(message, "groupchatRetract"))
                $root.server.GroupChatRetract.encode(message.groupchatRetract, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.chatRetract != null && Object.hasOwnProperty.call(message, "chatRetract"))
                $root.server.ChatRetract.encode(message.chatRetract, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.groupFeedItem != null && Object.hasOwnProperty.call(message, "groupFeedItem"))
                $root.server.GroupFeedItem.encode(message.groupFeedItem, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.retryCount);
            if (message.rerequest != null && Object.hasOwnProperty.call(message, "rerequest"))
                $root.server.Rerequest.encode(message.rerequest, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.silentChatStanza != null && Object.hasOwnProperty.call(message, "silentChatStanza"))
                $root.server.SilentChatStanza.encode(message.silentChatStanza, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.groupFeedItems != null && Object.hasOwnProperty.call(message, "groupFeedItems"))
                $root.server.GroupFeedItems.encode(message.groupFeedItems, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.rerequestCount);
            if (message.endOfQueue != null && Object.hasOwnProperty.call(message, "endOfQueue"))
                $root.server.EndOfQueue.encode(message.endOfQueue, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.inviteeNotice != null && Object.hasOwnProperty.call(message, "inviteeNotice"))
                $root.server.InviteeNotice.encode(message.inviteeNotice, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.groupFeedRerequest != null && Object.hasOwnProperty.call(message, "groupFeedRerequest"))
                $root.server.GroupFeedRerequest.encode(message.groupFeedRerequest, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.playedReceipt != null && Object.hasOwnProperty.call(message, "playedReceipt"))
                $root.server.PlayedReceipt.encode(message.playedReceipt, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.requestLogs != null && Object.hasOwnProperty.call(message, "requestLogs"))
                $root.server.RequestLogs.encode(message.requestLogs, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.wakeup != null && Object.hasOwnProperty.call(message, "wakeup"))
                $root.server.WakeUp.encode(message.wakeup, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.homeFeedRerequest != null && Object.hasOwnProperty.call(message, "homeFeedRerequest"))
                $root.server.HomeFeedRerequest.encode(message.homeFeedRerequest, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.incomingCall != null && Object.hasOwnProperty.call(message, "incomingCall"))
                $root.server.IncomingCall.encode(message.incomingCall, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.callRinging != null && Object.hasOwnProperty.call(message, "callRinging"))
                $root.server.CallRinging.encode(message.callRinging, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.answerCall != null && Object.hasOwnProperty.call(message, "answerCall"))
                $root.server.AnswerCall.encode(message.answerCall, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.endCall != null && Object.hasOwnProperty.call(message, "endCall"))
                $root.server.EndCall.encode(message.endCall, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.iceCandidate != null && Object.hasOwnProperty.call(message, "iceCandidate"))
                $root.server.IceCandidate.encode(message.iceCandidate, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.marketingAlert != null && Object.hasOwnProperty.call(message, "marketingAlert"))
                $root.server.MarketingAlert.encode(message.marketingAlert, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.iceRestartOffer != null && Object.hasOwnProperty.call(message, "iceRestartOffer"))
                $root.server.IceRestartOffer.encode(message.iceRestartOffer, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.iceRestartAnswer != null && Object.hasOwnProperty.call(message, "iceRestartAnswer"))
                $root.server.IceRestartAnswer.encode(message.iceRestartAnswer, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.groupFeedHistory != null && Object.hasOwnProperty.call(message, "groupFeedHistory"))
                $root.server.GroupFeedHistory.encode(message.groupFeedHistory, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.preAnswerCall != null && Object.hasOwnProperty.call(message, "preAnswerCall"))
                $root.server.PreAnswerCall.encode(message.preAnswerCall, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.holdCall != null && Object.hasOwnProperty.call(message, "holdCall"))
                $root.server.HoldCall.encode(message.holdCall, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.muteCall != null && Object.hasOwnProperty.call(message, "muteCall"))
                $root.server.MuteCall.encode(message.muteCall, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.incomingCallPush != null && Object.hasOwnProperty.call(message, "incomingCallPush"))
                $root.server.IncomingCallPush.encode(message.incomingCallPush, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.callSdp != null && Object.hasOwnProperty.call(message, "callSdp"))
                $root.server.CallSdp.encode(message.callSdp, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            if (message.webStanza != null && Object.hasOwnProperty.call(message, "webStanza"))
                $root.server.WebStanza.encode(message.webStanza, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
            if (message.contentMissing != null && Object.hasOwnProperty.call(message, "contentMissing"))
                $root.server.ContentMissing.encode(message.contentMissing, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            if (message.screenshotReceipt != null && Object.hasOwnProperty.call(message, "screenshotReceipt"))
                $root.server.ScreenshotReceipt.encode(message.screenshotReceipt, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.savedReceipt != null && Object.hasOwnProperty.call(message, "savedReceipt"))
                $root.server.SavedReceipt.encode(message.savedReceipt, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.groupChatStanza != null && Object.hasOwnProperty.call(message, "groupChatStanza"))
                $root.server.GroupChatStanza.encode(message.groupChatStanza, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
            if (message.momentNotification != null && Object.hasOwnProperty.call(message, "momentNotification"))
                $root.server.MomentNotification.encode(message.momentNotification, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.profileUpdate != null && Object.hasOwnProperty.call(message, "profileUpdate"))
                $root.server.ProfileUpdate.encode(message.profileUpdate, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.publicFeedUpdate != null && Object.hasOwnProperty.call(message, "publicFeedUpdate"))
                $root.server.PublicFeedUpdate.encode(message.publicFeedUpdate, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.aiImage != null && Object.hasOwnProperty.call(message, "aiImage"))
                $root.server.AiImage.encode(message.aiImage, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Msg message, length delimited. Does not implicitly {@link server.Msg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Msg
         * @static
         * @param {server.IMsg} message Msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Msg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Msg message from the specified reader or buffer.
         * @function decode
         * @memberof server.Msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Msg} Msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Msg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Msg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.toUid = reader.int64();
                    break;
                case 4:
                    message.fromUid = reader.int64();
                    break;
                case 5:
                    message.contactList = $root.server.ContactList.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.avatar = $root.server.Avatar.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.whisperKeys = $root.server.WhisperKeys.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.seenReceipt = $root.server.SeenReceipt.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.deliveryReceipt = $root.server.DeliveryReceipt.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.chatStanza = $root.server.ChatStanza.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.feedItem = $root.server.FeedItem.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.feedItems = $root.server.FeedItems.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.contactHash = $root.server.ContactHash.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.groupStanza = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.groupChat = $root.server.GroupChat.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.name = $root.server.Name.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.errorStanza = $root.server.ErrorStanza.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.groupchatRetract = $root.server.GroupChatRetract.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.chatRetract = $root.server.ChatRetract.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.groupFeedItem = $root.server.GroupFeedItem.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.rerequest = $root.server.Rerequest.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.silentChatStanza = $root.server.SilentChatStanza.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.groupFeedItems = $root.server.GroupFeedItems.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.endOfQueue = $root.server.EndOfQueue.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.inviteeNotice = $root.server.InviteeNotice.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.groupFeedRerequest = $root.server.GroupFeedRerequest.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.playedReceipt = $root.server.PlayedReceipt.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.requestLogs = $root.server.RequestLogs.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.wakeup = $root.server.WakeUp.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.homeFeedRerequest = $root.server.HomeFeedRerequest.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.incomingCall = $root.server.IncomingCall.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.callRinging = $root.server.CallRinging.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.answerCall = $root.server.AnswerCall.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.endCall = $root.server.EndCall.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.iceCandidate = $root.server.IceCandidate.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.marketingAlert = $root.server.MarketingAlert.decode(reader, reader.uint32());
                    break;
                case 40:
                    message.iceRestartOffer = $root.server.IceRestartOffer.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.iceRestartAnswer = $root.server.IceRestartAnswer.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.groupFeedHistory = $root.server.GroupFeedHistory.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.preAnswerCall = $root.server.PreAnswerCall.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.holdCall = $root.server.HoldCall.decode(reader, reader.uint32());
                    break;
                case 45:
                    message.muteCall = $root.server.MuteCall.decode(reader, reader.uint32());
                    break;
                case 46:
                    message.incomingCallPush = $root.server.IncomingCallPush.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.callSdp = $root.server.CallSdp.decode(reader, reader.uint32());
                    break;
                case 48:
                    message.webStanza = $root.server.WebStanza.decode(reader, reader.uint32());
                    break;
                case 49:
                    message.contentMissing = $root.server.ContentMissing.decode(reader, reader.uint32());
                    break;
                case 50:
                    message.screenshotReceipt = $root.server.ScreenshotReceipt.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.savedReceipt = $root.server.SavedReceipt.decode(reader, reader.uint32());
                    break;
                case 52:
                    message.groupChatStanza = $root.server.GroupChatStanza.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.momentNotification = $root.server.MomentNotification.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.profileUpdate = $root.server.ProfileUpdate.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.publicFeedUpdate = $root.server.PublicFeedUpdate.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.aiImage = $root.server.AiImage.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.retryCount = reader.int32();
                    break;
                case 25:
                    message.rerequestCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Msg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Msg} Msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Msg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Msg message.
         * @function verify
         * @memberof server.Msg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Msg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (!$util.isInteger(message.toUid) && !(message.toUid && $util.isInteger(message.toUid.low) && $util.isInteger(message.toUid.high)))
                    return "toUid: integer|Long expected";
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                properties.payload = 1;
                {
                    var error = $root.server.ContactList.verify(message.contactList);
                    if (error)
                        return "contactList." + error;
                }
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeys.verify(message.whisperKeys);
                    if (error)
                        return "whisperKeys." + error;
                }
            }
            if (message.seenReceipt != null && message.hasOwnProperty("seenReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SeenReceipt.verify(message.seenReceipt);
                    if (error)
                        return "seenReceipt." + error;
                }
            }
            if (message.deliveryReceipt != null && message.hasOwnProperty("deliveryReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.DeliveryReceipt.verify(message.deliveryReceipt);
                    if (error)
                        return "deliveryReceipt." + error;
                }
            }
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ChatStanza.verify(message.chatStanza);
                    if (error)
                        return "chatStanza." + error;
                }
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItem.verify(message.feedItem);
                    if (error)
                        return "feedItem." + error;
                }
            }
            if (message.feedItems != null && message.hasOwnProperty("feedItems")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItems.verify(message.feedItems);
                    if (error)
                        return "feedItems." + error;
                }
            }
            if (message.contactHash != null && message.hasOwnProperty("contactHash")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactHash.verify(message.contactHash);
                    if (error)
                        return "contactHash." + error;
                }
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupStanza.verify(message.groupStanza);
                    if (error)
                        return "groupStanza." + error;
                }
            }
            if (message.groupChat != null && message.hasOwnProperty("groupChat")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupChat.verify(message.groupChat);
                    if (error)
                        return "groupChat." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Name.verify(message.name);
                    if (error)
                        return "name." + error;
                }
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ErrorStanza.verify(message.errorStanza);
                    if (error)
                        return "errorStanza." + error;
                }
            }
            if (message.groupchatRetract != null && message.hasOwnProperty("groupchatRetract")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupChatRetract.verify(message.groupchatRetract);
                    if (error)
                        return "groupchatRetract." + error;
                }
            }
            if (message.chatRetract != null && message.hasOwnProperty("chatRetract")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ChatRetract.verify(message.chatRetract);
                    if (error)
                        return "chatRetract." + error;
                }
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItem.verify(message.groupFeedItem);
                    if (error)
                        return "groupFeedItem." + error;
                }
            }
            if (message.rerequest != null && message.hasOwnProperty("rerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Rerequest.verify(message.rerequest);
                    if (error)
                        return "rerequest." + error;
                }
            }
            if (message.silentChatStanza != null && message.hasOwnProperty("silentChatStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SilentChatStanza.verify(message.silentChatStanza);
                    if (error)
                        return "silentChatStanza." + error;
                }
            }
            if (message.groupFeedItems != null && message.hasOwnProperty("groupFeedItems")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItems.verify(message.groupFeedItems);
                    if (error)
                        return "groupFeedItems." + error;
                }
            }
            if (message.endOfQueue != null && message.hasOwnProperty("endOfQueue")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.EndOfQueue.verify(message.endOfQueue);
                    if (error)
                        return "endOfQueue." + error;
                }
            }
            if (message.inviteeNotice != null && message.hasOwnProperty("inviteeNotice")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InviteeNotice.verify(message.inviteeNotice);
                    if (error)
                        return "inviteeNotice." + error;
                }
            }
            if (message.groupFeedRerequest != null && message.hasOwnProperty("groupFeedRerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedRerequest.verify(message.groupFeedRerequest);
                    if (error)
                        return "groupFeedRerequest." + error;
                }
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HistoryResend.verify(message.historyResend);
                    if (error)
                        return "historyResend." + error;
                }
            }
            if (message.playedReceipt != null && message.hasOwnProperty("playedReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PlayedReceipt.verify(message.playedReceipt);
                    if (error)
                        return "playedReceipt." + error;
                }
            }
            if (message.requestLogs != null && message.hasOwnProperty("requestLogs")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.RequestLogs.verify(message.requestLogs);
                    if (error)
                        return "requestLogs." + error;
                }
            }
            if (message.wakeup != null && message.hasOwnProperty("wakeup")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WakeUp.verify(message.wakeup);
                    if (error)
                        return "wakeup." + error;
                }
            }
            if (message.homeFeedRerequest != null && message.hasOwnProperty("homeFeedRerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HomeFeedRerequest.verify(message.homeFeedRerequest);
                    if (error)
                        return "homeFeedRerequest." + error;
                }
            }
            if (message.incomingCall != null && message.hasOwnProperty("incomingCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IncomingCall.verify(message.incomingCall);
                    if (error)
                        return "incomingCall." + error;
                }
            }
            if (message.callRinging != null && message.hasOwnProperty("callRinging")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.CallRinging.verify(message.callRinging);
                    if (error)
                        return "callRinging." + error;
                }
            }
            if (message.answerCall != null && message.hasOwnProperty("answerCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.AnswerCall.verify(message.answerCall);
                    if (error)
                        return "answerCall." + error;
                }
            }
            if (message.endCall != null && message.hasOwnProperty("endCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.EndCall.verify(message.endCall);
                    if (error)
                        return "endCall." + error;
                }
            }
            if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceCandidate.verify(message.iceCandidate);
                    if (error)
                        return "iceCandidate." + error;
                }
            }
            if (message.marketingAlert != null && message.hasOwnProperty("marketingAlert")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.MarketingAlert.verify(message.marketingAlert);
                    if (error)
                        return "marketingAlert." + error;
                }
            }
            if (message.iceRestartOffer != null && message.hasOwnProperty("iceRestartOffer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceRestartOffer.verify(message.iceRestartOffer);
                    if (error)
                        return "iceRestartOffer." + error;
                }
            }
            if (message.iceRestartAnswer != null && message.hasOwnProperty("iceRestartAnswer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceRestartAnswer.verify(message.iceRestartAnswer);
                    if (error)
                        return "iceRestartAnswer." + error;
                }
            }
            if (message.groupFeedHistory != null && message.hasOwnProperty("groupFeedHistory")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedHistory.verify(message.groupFeedHistory);
                    if (error)
                        return "groupFeedHistory." + error;
                }
            }
            if (message.preAnswerCall != null && message.hasOwnProperty("preAnswerCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PreAnswerCall.verify(message.preAnswerCall);
                    if (error)
                        return "preAnswerCall." + error;
                }
            }
            if (message.holdCall != null && message.hasOwnProperty("holdCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HoldCall.verify(message.holdCall);
                    if (error)
                        return "holdCall." + error;
                }
            }
            if (message.muteCall != null && message.hasOwnProperty("muteCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.MuteCall.verify(message.muteCall);
                    if (error)
                        return "muteCall." + error;
                }
            }
            if (message.incomingCallPush != null && message.hasOwnProperty("incomingCallPush")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IncomingCallPush.verify(message.incomingCallPush);
                    if (error)
                        return "incomingCallPush." + error;
                }
            }
            if (message.callSdp != null && message.hasOwnProperty("callSdp")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.CallSdp.verify(message.callSdp);
                    if (error)
                        return "callSdp." + error;
                }
            }
            if (message.webStanza != null && message.hasOwnProperty("webStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WebStanza.verify(message.webStanza);
                    if (error)
                        return "webStanza." + error;
                }
            }
            if (message.contentMissing != null && message.hasOwnProperty("contentMissing")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContentMissing.verify(message.contentMissing);
                    if (error)
                        return "contentMissing." + error;
                }
            }
            if (message.screenshotReceipt != null && message.hasOwnProperty("screenshotReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ScreenshotReceipt.verify(message.screenshotReceipt);
                    if (error)
                        return "screenshotReceipt." + error;
                }
            }
            if (message.savedReceipt != null && message.hasOwnProperty("savedReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SavedReceipt.verify(message.savedReceipt);
                    if (error)
                        return "savedReceipt." + error;
                }
            }
            if (message.groupChatStanza != null && message.hasOwnProperty("groupChatStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupChatStanza.verify(message.groupChatStanza);
                    if (error)
                        return "groupChatStanza." + error;
                }
            }
            if (message.momentNotification != null && message.hasOwnProperty("momentNotification")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.MomentNotification.verify(message.momentNotification);
                    if (error)
                        return "momentNotification." + error;
                }
            }
            if (message.profileUpdate != null && message.hasOwnProperty("profileUpdate")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ProfileUpdate.verify(message.profileUpdate);
                    if (error)
                        return "profileUpdate." + error;
                }
            }
            if (message.publicFeedUpdate != null && message.hasOwnProperty("publicFeedUpdate")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PublicFeedUpdate.verify(message.publicFeedUpdate);
                    if (error)
                        return "publicFeedUpdate." + error;
                }
            }
            if (message.aiImage != null && message.hasOwnProperty("aiImage")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.AiImage.verify(message.aiImage);
                    if (error)
                        return "aiImage." + error;
                }
            }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            return null;
        };

        /**
         * Creates a Msg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Msg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Msg} Msg
         */
        Msg.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Msg)
                return object;
            var message = new $root.server.Msg();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "NORMAL":
            case 0:
                message.type = 0;
                break;
            case "ERROR":
            case 1:
                message.type = 1;
                break;
            case "GROUPCHAT":
            case 2:
                message.type = 2;
                break;
            case "HEADLINE":
            case 3:
                message.type = 3;
                break;
            case "CHAT":
            case 4:
                message.type = 4;
                break;
            case "CALL":
            case 5:
                message.type = 5;
                break;
            }
            if (object.toUid != null)
                if ($util.Long)
                    (message.toUid = $util.Long.fromValue(object.toUid)).unsigned = false;
                else if (typeof object.toUid === "string")
                    message.toUid = parseInt(object.toUid, 10);
                else if (typeof object.toUid === "number")
                    message.toUid = object.toUid;
                else if (typeof object.toUid === "object")
                    message.toUid = new $util.LongBits(object.toUid.low >>> 0, object.toUid.high >>> 0).toNumber();
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            if (object.contactList != null) {
                if (typeof object.contactList !== "object")
                    throw TypeError(".server.Msg.contactList: object expected");
                message.contactList = $root.server.ContactList.fromObject(object.contactList);
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".server.Msg.avatar: object expected");
                message.avatar = $root.server.Avatar.fromObject(object.avatar);
            }
            if (object.whisperKeys != null) {
                if (typeof object.whisperKeys !== "object")
                    throw TypeError(".server.Msg.whisperKeys: object expected");
                message.whisperKeys = $root.server.WhisperKeys.fromObject(object.whisperKeys);
            }
            if (object.seenReceipt != null) {
                if (typeof object.seenReceipt !== "object")
                    throw TypeError(".server.Msg.seenReceipt: object expected");
                message.seenReceipt = $root.server.SeenReceipt.fromObject(object.seenReceipt);
            }
            if (object.deliveryReceipt != null) {
                if (typeof object.deliveryReceipt !== "object")
                    throw TypeError(".server.Msg.deliveryReceipt: object expected");
                message.deliveryReceipt = $root.server.DeliveryReceipt.fromObject(object.deliveryReceipt);
            }
            if (object.chatStanza != null) {
                if (typeof object.chatStanza !== "object")
                    throw TypeError(".server.Msg.chatStanza: object expected");
                message.chatStanza = $root.server.ChatStanza.fromObject(object.chatStanza);
            }
            if (object.feedItem != null) {
                if (typeof object.feedItem !== "object")
                    throw TypeError(".server.Msg.feedItem: object expected");
                message.feedItem = $root.server.FeedItem.fromObject(object.feedItem);
            }
            if (object.feedItems != null) {
                if (typeof object.feedItems !== "object")
                    throw TypeError(".server.Msg.feedItems: object expected");
                message.feedItems = $root.server.FeedItems.fromObject(object.feedItems);
            }
            if (object.contactHash != null) {
                if (typeof object.contactHash !== "object")
                    throw TypeError(".server.Msg.contactHash: object expected");
                message.contactHash = $root.server.ContactHash.fromObject(object.contactHash);
            }
            if (object.groupStanza != null) {
                if (typeof object.groupStanza !== "object")
                    throw TypeError(".server.Msg.groupStanza: object expected");
                message.groupStanza = $root.server.GroupStanza.fromObject(object.groupStanza);
            }
            if (object.groupChat != null) {
                if (typeof object.groupChat !== "object")
                    throw TypeError(".server.Msg.groupChat: object expected");
                message.groupChat = $root.server.GroupChat.fromObject(object.groupChat);
            }
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".server.Msg.name: object expected");
                message.name = $root.server.Name.fromObject(object.name);
            }
            if (object.errorStanza != null) {
                if (typeof object.errorStanza !== "object")
                    throw TypeError(".server.Msg.errorStanza: object expected");
                message.errorStanza = $root.server.ErrorStanza.fromObject(object.errorStanza);
            }
            if (object.groupchatRetract != null) {
                if (typeof object.groupchatRetract !== "object")
                    throw TypeError(".server.Msg.groupchatRetract: object expected");
                message.groupchatRetract = $root.server.GroupChatRetract.fromObject(object.groupchatRetract);
            }
            if (object.chatRetract != null) {
                if (typeof object.chatRetract !== "object")
                    throw TypeError(".server.Msg.chatRetract: object expected");
                message.chatRetract = $root.server.ChatRetract.fromObject(object.chatRetract);
            }
            if (object.groupFeedItem != null) {
                if (typeof object.groupFeedItem !== "object")
                    throw TypeError(".server.Msg.groupFeedItem: object expected");
                message.groupFeedItem = $root.server.GroupFeedItem.fromObject(object.groupFeedItem);
            }
            if (object.rerequest != null) {
                if (typeof object.rerequest !== "object")
                    throw TypeError(".server.Msg.rerequest: object expected");
                message.rerequest = $root.server.Rerequest.fromObject(object.rerequest);
            }
            if (object.silentChatStanza != null) {
                if (typeof object.silentChatStanza !== "object")
                    throw TypeError(".server.Msg.silentChatStanza: object expected");
                message.silentChatStanza = $root.server.SilentChatStanza.fromObject(object.silentChatStanza);
            }
            if (object.groupFeedItems != null) {
                if (typeof object.groupFeedItems !== "object")
                    throw TypeError(".server.Msg.groupFeedItems: object expected");
                message.groupFeedItems = $root.server.GroupFeedItems.fromObject(object.groupFeedItems);
            }
            if (object.endOfQueue != null) {
                if (typeof object.endOfQueue !== "object")
                    throw TypeError(".server.Msg.endOfQueue: object expected");
                message.endOfQueue = $root.server.EndOfQueue.fromObject(object.endOfQueue);
            }
            if (object.inviteeNotice != null) {
                if (typeof object.inviteeNotice !== "object")
                    throw TypeError(".server.Msg.inviteeNotice: object expected");
                message.inviteeNotice = $root.server.InviteeNotice.fromObject(object.inviteeNotice);
            }
            if (object.groupFeedRerequest != null) {
                if (typeof object.groupFeedRerequest !== "object")
                    throw TypeError(".server.Msg.groupFeedRerequest: object expected");
                message.groupFeedRerequest = $root.server.GroupFeedRerequest.fromObject(object.groupFeedRerequest);
            }
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.Msg.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            if (object.playedReceipt != null) {
                if (typeof object.playedReceipt !== "object")
                    throw TypeError(".server.Msg.playedReceipt: object expected");
                message.playedReceipt = $root.server.PlayedReceipt.fromObject(object.playedReceipt);
            }
            if (object.requestLogs != null) {
                if (typeof object.requestLogs !== "object")
                    throw TypeError(".server.Msg.requestLogs: object expected");
                message.requestLogs = $root.server.RequestLogs.fromObject(object.requestLogs);
            }
            if (object.wakeup != null) {
                if (typeof object.wakeup !== "object")
                    throw TypeError(".server.Msg.wakeup: object expected");
                message.wakeup = $root.server.WakeUp.fromObject(object.wakeup);
            }
            if (object.homeFeedRerequest != null) {
                if (typeof object.homeFeedRerequest !== "object")
                    throw TypeError(".server.Msg.homeFeedRerequest: object expected");
                message.homeFeedRerequest = $root.server.HomeFeedRerequest.fromObject(object.homeFeedRerequest);
            }
            if (object.incomingCall != null) {
                if (typeof object.incomingCall !== "object")
                    throw TypeError(".server.Msg.incomingCall: object expected");
                message.incomingCall = $root.server.IncomingCall.fromObject(object.incomingCall);
            }
            if (object.callRinging != null) {
                if (typeof object.callRinging !== "object")
                    throw TypeError(".server.Msg.callRinging: object expected");
                message.callRinging = $root.server.CallRinging.fromObject(object.callRinging);
            }
            if (object.answerCall != null) {
                if (typeof object.answerCall !== "object")
                    throw TypeError(".server.Msg.answerCall: object expected");
                message.answerCall = $root.server.AnswerCall.fromObject(object.answerCall);
            }
            if (object.endCall != null) {
                if (typeof object.endCall !== "object")
                    throw TypeError(".server.Msg.endCall: object expected");
                message.endCall = $root.server.EndCall.fromObject(object.endCall);
            }
            if (object.iceCandidate != null) {
                if (typeof object.iceCandidate !== "object")
                    throw TypeError(".server.Msg.iceCandidate: object expected");
                message.iceCandidate = $root.server.IceCandidate.fromObject(object.iceCandidate);
            }
            if (object.marketingAlert != null) {
                if (typeof object.marketingAlert !== "object")
                    throw TypeError(".server.Msg.marketingAlert: object expected");
                message.marketingAlert = $root.server.MarketingAlert.fromObject(object.marketingAlert);
            }
            if (object.iceRestartOffer != null) {
                if (typeof object.iceRestartOffer !== "object")
                    throw TypeError(".server.Msg.iceRestartOffer: object expected");
                message.iceRestartOffer = $root.server.IceRestartOffer.fromObject(object.iceRestartOffer);
            }
            if (object.iceRestartAnswer != null) {
                if (typeof object.iceRestartAnswer !== "object")
                    throw TypeError(".server.Msg.iceRestartAnswer: object expected");
                message.iceRestartAnswer = $root.server.IceRestartAnswer.fromObject(object.iceRestartAnswer);
            }
            if (object.groupFeedHistory != null) {
                if (typeof object.groupFeedHistory !== "object")
                    throw TypeError(".server.Msg.groupFeedHistory: object expected");
                message.groupFeedHistory = $root.server.GroupFeedHistory.fromObject(object.groupFeedHistory);
            }
            if (object.preAnswerCall != null) {
                if (typeof object.preAnswerCall !== "object")
                    throw TypeError(".server.Msg.preAnswerCall: object expected");
                message.preAnswerCall = $root.server.PreAnswerCall.fromObject(object.preAnswerCall);
            }
            if (object.holdCall != null) {
                if (typeof object.holdCall !== "object")
                    throw TypeError(".server.Msg.holdCall: object expected");
                message.holdCall = $root.server.HoldCall.fromObject(object.holdCall);
            }
            if (object.muteCall != null) {
                if (typeof object.muteCall !== "object")
                    throw TypeError(".server.Msg.muteCall: object expected");
                message.muteCall = $root.server.MuteCall.fromObject(object.muteCall);
            }
            if (object.incomingCallPush != null) {
                if (typeof object.incomingCallPush !== "object")
                    throw TypeError(".server.Msg.incomingCallPush: object expected");
                message.incomingCallPush = $root.server.IncomingCallPush.fromObject(object.incomingCallPush);
            }
            if (object.callSdp != null) {
                if (typeof object.callSdp !== "object")
                    throw TypeError(".server.Msg.callSdp: object expected");
                message.callSdp = $root.server.CallSdp.fromObject(object.callSdp);
            }
            if (object.webStanza != null) {
                if (typeof object.webStanza !== "object")
                    throw TypeError(".server.Msg.webStanza: object expected");
                message.webStanza = $root.server.WebStanza.fromObject(object.webStanza);
            }
            if (object.contentMissing != null) {
                if (typeof object.contentMissing !== "object")
                    throw TypeError(".server.Msg.contentMissing: object expected");
                message.contentMissing = $root.server.ContentMissing.fromObject(object.contentMissing);
            }
            if (object.screenshotReceipt != null) {
                if (typeof object.screenshotReceipt !== "object")
                    throw TypeError(".server.Msg.screenshotReceipt: object expected");
                message.screenshotReceipt = $root.server.ScreenshotReceipt.fromObject(object.screenshotReceipt);
            }
            if (object.savedReceipt != null) {
                if (typeof object.savedReceipt !== "object")
                    throw TypeError(".server.Msg.savedReceipt: object expected");
                message.savedReceipt = $root.server.SavedReceipt.fromObject(object.savedReceipt);
            }
            if (object.groupChatStanza != null) {
                if (typeof object.groupChatStanza !== "object")
                    throw TypeError(".server.Msg.groupChatStanza: object expected");
                message.groupChatStanza = $root.server.GroupChatStanza.fromObject(object.groupChatStanza);
            }
            if (object.momentNotification != null) {
                if (typeof object.momentNotification !== "object")
                    throw TypeError(".server.Msg.momentNotification: object expected");
                message.momentNotification = $root.server.MomentNotification.fromObject(object.momentNotification);
            }
            if (object.profileUpdate != null) {
                if (typeof object.profileUpdate !== "object")
                    throw TypeError(".server.Msg.profileUpdate: object expected");
                message.profileUpdate = $root.server.ProfileUpdate.fromObject(object.profileUpdate);
            }
            if (object.publicFeedUpdate != null) {
                if (typeof object.publicFeedUpdate !== "object")
                    throw TypeError(".server.Msg.publicFeedUpdate: object expected");
                message.publicFeedUpdate = $root.server.PublicFeedUpdate.fromObject(object.publicFeedUpdate);
            }
            if (object.aiImage != null) {
                if (typeof object.aiImage !== "object")
                    throw TypeError(".server.Msg.aiImage: object expected");
                message.aiImage = $root.server.AiImage.fromObject(object.aiImage);
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount | 0;
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Msg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Msg
         * @static
         * @param {server.Msg} message Msg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Msg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "NORMAL" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.toUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toUid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
                object.retryCount = 0;
                object.rerequestCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Msg.Type[message.type] : message.type;
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (typeof message.toUid === "number")
                    object.toUid = options.longs === String ? String(message.toUid) : message.toUid;
                else
                    object.toUid = options.longs === String ? $util.Long.prototype.toString.call(message.toUid) : options.longs === Number ? new $util.LongBits(message.toUid.low >>> 0, message.toUid.high >>> 0).toNumber() : message.toUid;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                object.contactList = $root.server.ContactList.toObject(message.contactList, options);
                if (options.oneofs)
                    object.payload = "contactList";
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                object.avatar = $root.server.Avatar.toObject(message.avatar, options);
                if (options.oneofs)
                    object.payload = "avatar";
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                object.whisperKeys = $root.server.WhisperKeys.toObject(message.whisperKeys, options);
                if (options.oneofs)
                    object.payload = "whisperKeys";
            }
            if (message.seenReceipt != null && message.hasOwnProperty("seenReceipt")) {
                object.seenReceipt = $root.server.SeenReceipt.toObject(message.seenReceipt, options);
                if (options.oneofs)
                    object.payload = "seenReceipt";
            }
            if (message.deliveryReceipt != null && message.hasOwnProperty("deliveryReceipt")) {
                object.deliveryReceipt = $root.server.DeliveryReceipt.toObject(message.deliveryReceipt, options);
                if (options.oneofs)
                    object.payload = "deliveryReceipt";
            }
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                object.chatStanza = $root.server.ChatStanza.toObject(message.chatStanza, options);
                if (options.oneofs)
                    object.payload = "chatStanza";
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                object.feedItem = $root.server.FeedItem.toObject(message.feedItem, options);
                if (options.oneofs)
                    object.payload = "feedItem";
            }
            if (message.feedItems != null && message.hasOwnProperty("feedItems")) {
                object.feedItems = $root.server.FeedItems.toObject(message.feedItems, options);
                if (options.oneofs)
                    object.payload = "feedItems";
            }
            if (message.contactHash != null && message.hasOwnProperty("contactHash")) {
                object.contactHash = $root.server.ContactHash.toObject(message.contactHash, options);
                if (options.oneofs)
                    object.payload = "contactHash";
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                object.groupStanza = $root.server.GroupStanza.toObject(message.groupStanza, options);
                if (options.oneofs)
                    object.payload = "groupStanza";
            }
            if (message.groupChat != null && message.hasOwnProperty("groupChat")) {
                object.groupChat = $root.server.GroupChat.toObject(message.groupChat, options);
                if (options.oneofs)
                    object.payload = "groupChat";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = $root.server.Name.toObject(message.name, options);
                if (options.oneofs)
                    object.payload = "name";
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                object.errorStanza = $root.server.ErrorStanza.toObject(message.errorStanza, options);
                if (options.oneofs)
                    object.payload = "errorStanza";
            }
            if (message.groupchatRetract != null && message.hasOwnProperty("groupchatRetract")) {
                object.groupchatRetract = $root.server.GroupChatRetract.toObject(message.groupchatRetract, options);
                if (options.oneofs)
                    object.payload = "groupchatRetract";
            }
            if (message.chatRetract != null && message.hasOwnProperty("chatRetract")) {
                object.chatRetract = $root.server.ChatRetract.toObject(message.chatRetract, options);
                if (options.oneofs)
                    object.payload = "chatRetract";
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                object.groupFeedItem = $root.server.GroupFeedItem.toObject(message.groupFeedItem, options);
                if (options.oneofs)
                    object.payload = "groupFeedItem";
            }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            if (message.rerequest != null && message.hasOwnProperty("rerequest")) {
                object.rerequest = $root.server.Rerequest.toObject(message.rerequest, options);
                if (options.oneofs)
                    object.payload = "rerequest";
            }
            if (message.silentChatStanza != null && message.hasOwnProperty("silentChatStanza")) {
                object.silentChatStanza = $root.server.SilentChatStanza.toObject(message.silentChatStanza, options);
                if (options.oneofs)
                    object.payload = "silentChatStanza";
            }
            if (message.groupFeedItems != null && message.hasOwnProperty("groupFeedItems")) {
                object.groupFeedItems = $root.server.GroupFeedItems.toObject(message.groupFeedItems, options);
                if (options.oneofs)
                    object.payload = "groupFeedItems";
            }
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.endOfQueue != null && message.hasOwnProperty("endOfQueue")) {
                object.endOfQueue = $root.server.EndOfQueue.toObject(message.endOfQueue, options);
                if (options.oneofs)
                    object.payload = "endOfQueue";
            }
            if (message.inviteeNotice != null && message.hasOwnProperty("inviteeNotice")) {
                object.inviteeNotice = $root.server.InviteeNotice.toObject(message.inviteeNotice, options);
                if (options.oneofs)
                    object.payload = "inviteeNotice";
            }
            if (message.groupFeedRerequest != null && message.hasOwnProperty("groupFeedRerequest")) {
                object.groupFeedRerequest = $root.server.GroupFeedRerequest.toObject(message.groupFeedRerequest, options);
                if (options.oneofs)
                    object.payload = "groupFeedRerequest";
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
                if (options.oneofs)
                    object.payload = "historyResend";
            }
            if (message.playedReceipt != null && message.hasOwnProperty("playedReceipt")) {
                object.playedReceipt = $root.server.PlayedReceipt.toObject(message.playedReceipt, options);
                if (options.oneofs)
                    object.payload = "playedReceipt";
            }
            if (message.requestLogs != null && message.hasOwnProperty("requestLogs")) {
                object.requestLogs = $root.server.RequestLogs.toObject(message.requestLogs, options);
                if (options.oneofs)
                    object.payload = "requestLogs";
            }
            if (message.wakeup != null && message.hasOwnProperty("wakeup")) {
                object.wakeup = $root.server.WakeUp.toObject(message.wakeup, options);
                if (options.oneofs)
                    object.payload = "wakeup";
            }
            if (message.homeFeedRerequest != null && message.hasOwnProperty("homeFeedRerequest")) {
                object.homeFeedRerequest = $root.server.HomeFeedRerequest.toObject(message.homeFeedRerequest, options);
                if (options.oneofs)
                    object.payload = "homeFeedRerequest";
            }
            if (message.incomingCall != null && message.hasOwnProperty("incomingCall")) {
                object.incomingCall = $root.server.IncomingCall.toObject(message.incomingCall, options);
                if (options.oneofs)
                    object.payload = "incomingCall";
            }
            if (message.callRinging != null && message.hasOwnProperty("callRinging")) {
                object.callRinging = $root.server.CallRinging.toObject(message.callRinging, options);
                if (options.oneofs)
                    object.payload = "callRinging";
            }
            if (message.answerCall != null && message.hasOwnProperty("answerCall")) {
                object.answerCall = $root.server.AnswerCall.toObject(message.answerCall, options);
                if (options.oneofs)
                    object.payload = "answerCall";
            }
            if (message.endCall != null && message.hasOwnProperty("endCall")) {
                object.endCall = $root.server.EndCall.toObject(message.endCall, options);
                if (options.oneofs)
                    object.payload = "endCall";
            }
            if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
                object.iceCandidate = $root.server.IceCandidate.toObject(message.iceCandidate, options);
                if (options.oneofs)
                    object.payload = "iceCandidate";
            }
            if (message.marketingAlert != null && message.hasOwnProperty("marketingAlert")) {
                object.marketingAlert = $root.server.MarketingAlert.toObject(message.marketingAlert, options);
                if (options.oneofs)
                    object.payload = "marketingAlert";
            }
            if (message.iceRestartOffer != null && message.hasOwnProperty("iceRestartOffer")) {
                object.iceRestartOffer = $root.server.IceRestartOffer.toObject(message.iceRestartOffer, options);
                if (options.oneofs)
                    object.payload = "iceRestartOffer";
            }
            if (message.iceRestartAnswer != null && message.hasOwnProperty("iceRestartAnswer")) {
                object.iceRestartAnswer = $root.server.IceRestartAnswer.toObject(message.iceRestartAnswer, options);
                if (options.oneofs)
                    object.payload = "iceRestartAnswer";
            }
            if (message.groupFeedHistory != null && message.hasOwnProperty("groupFeedHistory")) {
                object.groupFeedHistory = $root.server.GroupFeedHistory.toObject(message.groupFeedHistory, options);
                if (options.oneofs)
                    object.payload = "groupFeedHistory";
            }
            if (message.preAnswerCall != null && message.hasOwnProperty("preAnswerCall")) {
                object.preAnswerCall = $root.server.PreAnswerCall.toObject(message.preAnswerCall, options);
                if (options.oneofs)
                    object.payload = "preAnswerCall";
            }
            if (message.holdCall != null && message.hasOwnProperty("holdCall")) {
                object.holdCall = $root.server.HoldCall.toObject(message.holdCall, options);
                if (options.oneofs)
                    object.payload = "holdCall";
            }
            if (message.muteCall != null && message.hasOwnProperty("muteCall")) {
                object.muteCall = $root.server.MuteCall.toObject(message.muteCall, options);
                if (options.oneofs)
                    object.payload = "muteCall";
            }
            if (message.incomingCallPush != null && message.hasOwnProperty("incomingCallPush")) {
                object.incomingCallPush = $root.server.IncomingCallPush.toObject(message.incomingCallPush, options);
                if (options.oneofs)
                    object.payload = "incomingCallPush";
            }
            if (message.callSdp != null && message.hasOwnProperty("callSdp")) {
                object.callSdp = $root.server.CallSdp.toObject(message.callSdp, options);
                if (options.oneofs)
                    object.payload = "callSdp";
            }
            if (message.webStanza != null && message.hasOwnProperty("webStanza")) {
                object.webStanza = $root.server.WebStanza.toObject(message.webStanza, options);
                if (options.oneofs)
                    object.payload = "webStanza";
            }
            if (message.contentMissing != null && message.hasOwnProperty("contentMissing")) {
                object.contentMissing = $root.server.ContentMissing.toObject(message.contentMissing, options);
                if (options.oneofs)
                    object.payload = "contentMissing";
            }
            if (message.screenshotReceipt != null && message.hasOwnProperty("screenshotReceipt")) {
                object.screenshotReceipt = $root.server.ScreenshotReceipt.toObject(message.screenshotReceipt, options);
                if (options.oneofs)
                    object.payload = "screenshotReceipt";
            }
            if (message.savedReceipt != null && message.hasOwnProperty("savedReceipt")) {
                object.savedReceipt = $root.server.SavedReceipt.toObject(message.savedReceipt, options);
                if (options.oneofs)
                    object.payload = "savedReceipt";
            }
            if (message.groupChatStanza != null && message.hasOwnProperty("groupChatStanza")) {
                object.groupChatStanza = $root.server.GroupChatStanza.toObject(message.groupChatStanza, options);
                if (options.oneofs)
                    object.payload = "groupChatStanza";
            }
            if (message.momentNotification != null && message.hasOwnProperty("momentNotification")) {
                object.momentNotification = $root.server.MomentNotification.toObject(message.momentNotification, options);
                if (options.oneofs)
                    object.payload = "momentNotification";
            }
            if (message.profileUpdate != null && message.hasOwnProperty("profileUpdate")) {
                object.profileUpdate = $root.server.ProfileUpdate.toObject(message.profileUpdate, options);
                if (options.oneofs)
                    object.payload = "profileUpdate";
            }
            if (message.publicFeedUpdate != null && message.hasOwnProperty("publicFeedUpdate")) {
                object.publicFeedUpdate = $root.server.PublicFeedUpdate.toObject(message.publicFeedUpdate, options);
                if (options.oneofs)
                    object.payload = "publicFeedUpdate";
            }
            if (message.aiImage != null && message.hasOwnProperty("aiImage")) {
                object.aiImage = $root.server.AiImage.toObject(message.aiImage, options);
                if (options.oneofs)
                    object.payload = "aiImage";
            }
            return object;
        };

        /**
         * Converts this Msg to JSON.
         * @function toJSON
         * @memberof server.Msg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Msg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Msg.Type
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} ERROR=1 ERROR value
         * @property {number} GROUPCHAT=2 GROUPCHAT value
         * @property {number} HEADLINE=3 HEADLINE value
         * @property {number} CHAT=4 CHAT value
         * @property {number} CALL=5 CALL value
         */
        Msg.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "ERROR"] = 1;
            values[valuesById[2] = "GROUPCHAT"] = 2;
            values[valuesById[3] = "HEADLINE"] = 3;
            values[valuesById[4] = "CHAT"] = 4;
            values[valuesById[5] = "CALL"] = 5;
            return values;
        })();

        return Msg;
    })();

    server.Presence = (function() {

        /**
         * Properties of a Presence.
         * @memberof server
         * @interface IPresence
         * @property {string|null} [id] Presence id
         * @property {server.Presence.Type|null} [type] Presence type
         * @property {number|Long|null} [uid] Presence uid
         * @property {number|Long|null} [lastSeen] Presence lastSeen
         * @property {number|Long|null} [toUid] Presence toUid
         * @property {number|Long|null} [fromUid] Presence fromUid
         */

        /**
         * Constructs a new Presence.
         * @memberof server
         * @classdesc Represents a Presence.
         * @implements IPresence
         * @constructor
         * @param {server.IPresence=} [properties] Properties to set
         */
        function Presence(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Presence id.
         * @member {string} id
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.id = "";

        /**
         * Presence type.
         * @member {server.Presence.Type} type
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.type = 0;

        /**
         * Presence uid.
         * @member {number|Long} uid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence lastSeen.
         * @member {number|Long} lastSeen
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.lastSeen = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence toUid.
         * @member {number|Long} toUid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.toUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence fromUid.
         * @member {number|Long} fromUid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Presence instance using the specified properties.
         * @function create
         * @memberof server.Presence
         * @static
         * @param {server.IPresence=} [properties] Properties to set
         * @returns {server.Presence} Presence instance
         */
        Presence.create = function create(properties) {
            return new Presence(properties);
        };

        /**
         * Encodes the specified Presence message. Does not implicitly {@link server.Presence.verify|verify} messages.
         * @function encode
         * @memberof server.Presence
         * @static
         * @param {server.IPresence} message Presence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presence.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            if (message.lastSeen != null && Object.hasOwnProperty.call(message, "lastSeen"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastSeen);
            if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.toUid);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fromUid);
            return writer;
        };

        /**
         * Encodes the specified Presence message, length delimited. Does not implicitly {@link server.Presence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Presence
         * @static
         * @param {server.IPresence} message Presence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presence.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Presence message from the specified reader or buffer.
         * @function decode
         * @memberof server.Presence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Presence} Presence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presence.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Presence();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.uid = reader.int64();
                    break;
                case 4:
                    message.lastSeen = reader.int64();
                    break;
                case 5:
                    message.toUid = reader.int64();
                    break;
                case 6:
                    message.fromUid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Presence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Presence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Presence} Presence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presence.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Presence message.
         * @function verify
         * @memberof server.Presence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Presence.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
                if (!$util.isInteger(message.lastSeen) && !(message.lastSeen && $util.isInteger(message.lastSeen.low) && $util.isInteger(message.lastSeen.high)))
                    return "lastSeen: integer|Long expected";
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (!$util.isInteger(message.toUid) && !(message.toUid && $util.isInteger(message.toUid.low) && $util.isInteger(message.toUid.high)))
                    return "toUid: integer|Long expected";
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            return null;
        };

        /**
         * Creates a Presence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Presence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Presence} Presence
         */
        Presence.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Presence)
                return object;
            var message = new $root.server.Presence();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "AVAILABLE":
            case 0:
                message.type = 0;
                break;
            case "AWAY":
            case 1:
                message.type = 1;
                break;
            case "SUBSCRIBE":
            case 2:
                message.type = 2;
                break;
            case "UNSUBSCRIBE":
            case 3:
                message.type = 3;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lastSeen != null)
                if ($util.Long)
                    (message.lastSeen = $util.Long.fromValue(object.lastSeen)).unsigned = false;
                else if (typeof object.lastSeen === "string")
                    message.lastSeen = parseInt(object.lastSeen, 10);
                else if (typeof object.lastSeen === "number")
                    message.lastSeen = object.lastSeen;
                else if (typeof object.lastSeen === "object")
                    message.lastSeen = new $util.LongBits(object.lastSeen.low >>> 0, object.lastSeen.high >>> 0).toNumber();
            if (object.toUid != null)
                if ($util.Long)
                    (message.toUid = $util.Long.fromValue(object.toUid)).unsigned = false;
                else if (typeof object.toUid === "string")
                    message.toUid = parseInt(object.toUid, 10);
                else if (typeof object.toUid === "number")
                    message.toUid = object.toUid;
                else if (typeof object.toUid === "object")
                    message.toUid = new $util.LongBits(object.toUid.low >>> 0, object.toUid.high >>> 0).toNumber();
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Presence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Presence
         * @static
         * @param {server.Presence} message Presence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Presence.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "AVAILABLE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSeen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastSeen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.toUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toUid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Presence.Type[message.type] : message.type;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
                if (typeof message.lastSeen === "number")
                    object.lastSeen = options.longs === String ? String(message.lastSeen) : message.lastSeen;
                else
                    object.lastSeen = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeen) : options.longs === Number ? new $util.LongBits(message.lastSeen.low >>> 0, message.lastSeen.high >>> 0).toNumber() : message.lastSeen;
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (typeof message.toUid === "number")
                    object.toUid = options.longs === String ? String(message.toUid) : message.toUid;
                else
                    object.toUid = options.longs === String ? $util.Long.prototype.toString.call(message.toUid) : options.longs === Number ? new $util.LongBits(message.toUid.low >>> 0, message.toUid.high >>> 0).toNumber() : message.toUid;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            return object;
        };

        /**
         * Converts this Presence to JSON.
         * @function toJSON
         * @memberof server.Presence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Presence.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Presence.Type
         * @enum {number}
         * @property {number} AVAILABLE=0 AVAILABLE value
         * @property {number} AWAY=1 AWAY value
         * @property {number} SUBSCRIBE=2 SUBSCRIBE value
         * @property {number} UNSUBSCRIBE=3 UNSUBSCRIBE value
         */
        Presence.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AVAILABLE"] = 0;
            values[valuesById[1] = "AWAY"] = 1;
            values[valuesById[2] = "SUBSCRIBE"] = 2;
            values[valuesById[3] = "UNSUBSCRIBE"] = 3;
            return values;
        })();

        return Presence;
    })();

    server.ChatState = (function() {

        /**
         * Properties of a ChatState.
         * @memberof server
         * @interface IChatState
         * @property {server.ChatState.Type|null} [type] ChatState type
         * @property {string|null} [threadId] ChatState threadId
         * @property {server.ChatState.ThreadType|null} [threadType] ChatState threadType
         * @property {number|Long|null} [fromUid] ChatState fromUid
         */

        /**
         * Constructs a new ChatState.
         * @memberof server
         * @classdesc Represents a ChatState.
         * @implements IChatState
         * @constructor
         * @param {server.IChatState=} [properties] Properties to set
         */
        function ChatState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatState type.
         * @member {server.ChatState.Type} type
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.type = 0;

        /**
         * ChatState threadId.
         * @member {string} threadId
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.threadId = "";

        /**
         * ChatState threadType.
         * @member {server.ChatState.ThreadType} threadType
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.threadType = 0;

        /**
         * ChatState fromUid.
         * @member {number|Long} fromUid
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChatState instance using the specified properties.
         * @function create
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState=} [properties] Properties to set
         * @returns {server.ChatState} ChatState instance
         */
        ChatState.create = function create(properties) {
            return new ChatState(properties);
        };

        /**
         * Encodes the specified ChatState message. Does not implicitly {@link server.ChatState.verify|verify} messages.
         * @function encode
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState} message ChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.threadType != null && Object.hasOwnProperty.call(message, "threadType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.threadType);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromUid);
            return writer;
        };

        /**
         * Encodes the specified ChatState message, length delimited. Does not implicitly {@link server.ChatState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState} message ChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatState message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatState} ChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.threadType = reader.int32();
                    break;
                case 4:
                    message.fromUid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatState} ChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatState message.
         * @function verify
         * @memberof server.ChatState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                switch (message.threadType) {
                default:
                    return "threadType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChatState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatState} ChatState
         */
        ChatState.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatState)
                return object;
            var message = new $root.server.ChatState();
            switch (object.type) {
            case "AVAILABLE":
            case 0:
                message.type = 0;
                break;
            case "TYPING":
            case 1:
                message.type = 1;
                break;
            }
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            switch (object.threadType) {
            case "CHAT":
            case 0:
                message.threadType = 0;
                break;
            case "GROUP_CHAT":
            case 1:
                message.threadType = 1;
                break;
            }
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChatState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatState
         * @static
         * @param {server.ChatState} message ChatState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "AVAILABLE" : 0;
                object.threadId = "";
                object.threadType = options.enums === String ? "CHAT" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ChatState.Type[message.type] : message.type;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                object.threadType = options.enums === String ? $root.server.ChatState.ThreadType[message.threadType] : message.threadType;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            return object;
        };

        /**
         * Converts this ChatState to JSON.
         * @function toJSON
         * @memberof server.ChatState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ChatState.Type
         * @enum {number}
         * @property {number} AVAILABLE=0 AVAILABLE value
         * @property {number} TYPING=1 TYPING value
         */
        ChatState.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AVAILABLE"] = 0;
            values[valuesById[1] = "TYPING"] = 1;
            return values;
        })();

        /**
         * ThreadType enum.
         * @name server.ChatState.ThreadType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} GROUP_CHAT=1 GROUP_CHAT value
         */
        ChatState.ThreadType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "GROUP_CHAT"] = 1;
            return values;
        })();

        return ChatState;
    })();

    server.Ack = (function() {

        /**
         * Properties of an Ack.
         * @memberof server
         * @interface IAck
         * @property {string|null} [id] Ack id
         * @property {number|Long|null} [timestamp] Ack timestamp
         */

        /**
         * Constructs a new Ack.
         * @memberof server
         * @classdesc Represents an Ack.
         * @implements IAck
         * @constructor
         * @param {server.IAck=} [properties] Properties to set
         */
        function Ack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ack id.
         * @member {string} id
         * @memberof server.Ack
         * @instance
         */
        Ack.prototype.id = "";

        /**
         * Ack timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Ack
         * @instance
         */
        Ack.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Ack instance using the specified properties.
         * @function create
         * @memberof server.Ack
         * @static
         * @param {server.IAck=} [properties] Properties to set
         * @returns {server.Ack} Ack instance
         */
        Ack.create = function create(properties) {
            return new Ack(properties);
        };

        /**
         * Encodes the specified Ack message. Does not implicitly {@link server.Ack.verify|verify} messages.
         * @function encode
         * @memberof server.Ack
         * @static
         * @param {server.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Ack message, length delimited. Does not implicitly {@link server.Ack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Ack
         * @static
         * @param {server.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Ack message from the specified reader or buffer.
         * @function decode
         * @memberof server.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Ack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Ack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Ack message.
         * @function verify
         * @memberof server.Ack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an Ack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Ack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Ack} Ack
         */
        Ack.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Ack)
                return object;
            var message = new $root.server.Ack();
            if (object.id != null)
                message.id = String(object.id);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Ack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Ack
         * @static
         * @param {server.Ack} message Ack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Ack to JSON.
         * @function toJSON
         * @memberof server.Ack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ack;
    })();

    server.HaError = (function() {

        /**
         * Properties of a HaError.
         * @memberof server
         * @interface IHaError
         * @property {string|null} [reason] HaError reason
         */

        /**
         * Constructs a new HaError.
         * @memberof server
         * @classdesc Represents a HaError.
         * @implements IHaError
         * @constructor
         * @param {server.IHaError=} [properties] Properties to set
         */
        function HaError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HaError reason.
         * @member {string} reason
         * @memberof server.HaError
         * @instance
         */
        HaError.prototype.reason = "";

        /**
         * Creates a new HaError instance using the specified properties.
         * @function create
         * @memberof server.HaError
         * @static
         * @param {server.IHaError=} [properties] Properties to set
         * @returns {server.HaError} HaError instance
         */
        HaError.create = function create(properties) {
            return new HaError(properties);
        };

        /**
         * Encodes the specified HaError message. Does not implicitly {@link server.HaError.verify|verify} messages.
         * @function encode
         * @memberof server.HaError
         * @static
         * @param {server.IHaError} message HaError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HaError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified HaError message, length delimited. Does not implicitly {@link server.HaError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HaError
         * @static
         * @param {server.IHaError} message HaError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HaError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HaError message from the specified reader or buffer.
         * @function decode
         * @memberof server.HaError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HaError} HaError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HaError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HaError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HaError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HaError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HaError} HaError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HaError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HaError message.
         * @function verify
         * @memberof server.HaError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HaError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a HaError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HaError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HaError} HaError
         */
        HaError.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HaError)
                return object;
            var message = new $root.server.HaError();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a HaError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HaError
         * @static
         * @param {server.HaError} message HaError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HaError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this HaError to JSON.
         * @function toJSON
         * @memberof server.HaError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HaError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HaError;
    })();

    server.Packet = (function() {

        /**
         * Properties of a Packet.
         * @memberof server
         * @interface IPacket
         * @property {server.IMsg|null} [msg] Packet msg
         * @property {server.IIq|null} [iq] Packet iq
         * @property {server.IAck|null} [ack] Packet ack
         * @property {server.IPresence|null} [presence] Packet presence
         * @property {server.IHaError|null} [haError] Packet haError
         * @property {server.IChatState|null} [chatState] Packet chatState
         */

        /**
         * Constructs a new Packet.
         * @memberof server
         * @classdesc Represents a Packet.
         * @implements IPacket
         * @constructor
         * @param {server.IPacket=} [properties] Properties to set
         */
        function Packet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Packet msg.
         * @member {server.IMsg|null|undefined} msg
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.msg = null;

        /**
         * Packet iq.
         * @member {server.IIq|null|undefined} iq
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.iq = null;

        /**
         * Packet ack.
         * @member {server.IAck|null|undefined} ack
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.ack = null;

        /**
         * Packet presence.
         * @member {server.IPresence|null|undefined} presence
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.presence = null;

        /**
         * Packet haError.
         * @member {server.IHaError|null|undefined} haError
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.haError = null;

        /**
         * Packet chatState.
         * @member {server.IChatState|null|undefined} chatState
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.chatState = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Packet stanza.
         * @member {"msg"|"iq"|"ack"|"presence"|"haError"|"chatState"|undefined} stanza
         * @memberof server.Packet
         * @instance
         */
        Object.defineProperty(Packet.prototype, "stanza", {
            get: $util.oneOfGetter($oneOfFields = ["msg", "iq", "ack", "presence", "haError", "chatState"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Packet instance using the specified properties.
         * @function create
         * @memberof server.Packet
         * @static
         * @param {server.IPacket=} [properties] Properties to set
         * @returns {server.Packet} Packet instance
         */
        Packet.create = function create(properties) {
            return new Packet(properties);
        };

        /**
         * Encodes the specified Packet message. Does not implicitly {@link server.Packet.verify|verify} messages.
         * @function encode
         * @memberof server.Packet
         * @static
         * @param {server.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.server.Msg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.iq != null && Object.hasOwnProperty.call(message, "iq"))
                $root.server.Iq.encode(message.iq, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                $root.server.Ack.encode(message.ack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.presence != null && Object.hasOwnProperty.call(message, "presence"))
                $root.server.Presence.encode(message.presence, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.haError != null && Object.hasOwnProperty.call(message, "haError"))
                $root.server.HaError.encode(message.haError, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.chatState != null && Object.hasOwnProperty.call(message, "chatState"))
                $root.server.ChatState.encode(message.chatState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Packet message, length delimited. Does not implicitly {@link server.Packet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Packet
         * @static
         * @param {server.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Packet message from the specified reader or buffer.
         * @function decode
         * @memberof server.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Packet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = $root.server.Msg.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.iq = $root.server.Iq.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.ack = $root.server.Ack.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.presence = $root.server.Presence.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.haError = $root.server.HaError.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.chatState = $root.server.ChatState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Packet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Packet message.
         * @function verify
         * @memberof server.Packet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Packet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.msg != null && message.hasOwnProperty("msg")) {
                properties.stanza = 1;
                {
                    var error = $root.server.Msg.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
            }
            if (message.iq != null && message.hasOwnProperty("iq")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Iq.verify(message.iq);
                    if (error)
                        return "iq." + error;
                }
            }
            if (message.ack != null && message.hasOwnProperty("ack")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Ack.verify(message.ack);
                    if (error)
                        return "ack." + error;
                }
            }
            if (message.presence != null && message.hasOwnProperty("presence")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Presence.verify(message.presence);
                    if (error)
                        return "presence." + error;
                }
            }
            if (message.haError != null && message.hasOwnProperty("haError")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.HaError.verify(message.haError);
                    if (error)
                        return "haError." + error;
                }
            }
            if (message.chatState != null && message.hasOwnProperty("chatState")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.ChatState.verify(message.chatState);
                    if (error)
                        return "chatState." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Packet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Packet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Packet} Packet
         */
        Packet.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Packet)
                return object;
            var message = new $root.server.Packet();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".server.Packet.msg: object expected");
                message.msg = $root.server.Msg.fromObject(object.msg);
            }
            if (object.iq != null) {
                if (typeof object.iq !== "object")
                    throw TypeError(".server.Packet.iq: object expected");
                message.iq = $root.server.Iq.fromObject(object.iq);
            }
            if (object.ack != null) {
                if (typeof object.ack !== "object")
                    throw TypeError(".server.Packet.ack: object expected");
                message.ack = $root.server.Ack.fromObject(object.ack);
            }
            if (object.presence != null) {
                if (typeof object.presence !== "object")
                    throw TypeError(".server.Packet.presence: object expected");
                message.presence = $root.server.Presence.fromObject(object.presence);
            }
            if (object.haError != null) {
                if (typeof object.haError !== "object")
                    throw TypeError(".server.Packet.haError: object expected");
                message.haError = $root.server.HaError.fromObject(object.haError);
            }
            if (object.chatState != null) {
                if (typeof object.chatState !== "object")
                    throw TypeError(".server.Packet.chatState: object expected");
                message.chatState = $root.server.ChatState.fromObject(object.chatState);
            }
            return message;
        };

        /**
         * Creates a plain object from a Packet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Packet
         * @static
         * @param {server.Packet} message Packet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Packet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.msg != null && message.hasOwnProperty("msg")) {
                object.msg = $root.server.Msg.toObject(message.msg, options);
                if (options.oneofs)
                    object.stanza = "msg";
            }
            if (message.iq != null && message.hasOwnProperty("iq")) {
                object.iq = $root.server.Iq.toObject(message.iq, options);
                if (options.oneofs)
                    object.stanza = "iq";
            }
            if (message.ack != null && message.hasOwnProperty("ack")) {
                object.ack = $root.server.Ack.toObject(message.ack, options);
                if (options.oneofs)
                    object.stanza = "ack";
            }
            if (message.presence != null && message.hasOwnProperty("presence")) {
                object.presence = $root.server.Presence.toObject(message.presence, options);
                if (options.oneofs)
                    object.stanza = "presence";
            }
            if (message.haError != null && message.hasOwnProperty("haError")) {
                object.haError = $root.server.HaError.toObject(message.haError, options);
                if (options.oneofs)
                    object.stanza = "haError";
            }
            if (message.chatState != null && message.hasOwnProperty("chatState")) {
                object.chatState = $root.server.ChatState.toObject(message.chatState, options);
                if (options.oneofs)
                    object.stanza = "chatState";
            }
            return object;
        };

        /**
         * Converts this Packet to JSON.
         * @function toJSON
         * @memberof server.Packet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Packet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Packet;
    })();

    server.UidElement = (function() {

        /**
         * Properties of an UidElement.
         * @memberof server
         * @interface IUidElement
         * @property {server.UidElement.Action|null} [action] UidElement action
         * @property {number|Long|null} [uid] UidElement uid
         */

        /**
         * Constructs a new UidElement.
         * @memberof server
         * @classdesc Represents an UidElement.
         * @implements IUidElement
         * @constructor
         * @param {server.IUidElement=} [properties] Properties to set
         */
        function UidElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UidElement action.
         * @member {server.UidElement.Action} action
         * @memberof server.UidElement
         * @instance
         */
        UidElement.prototype.action = 0;

        /**
         * UidElement uid.
         * @member {number|Long} uid
         * @memberof server.UidElement
         * @instance
         */
        UidElement.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UidElement instance using the specified properties.
         * @function create
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement=} [properties] Properties to set
         * @returns {server.UidElement} UidElement instance
         */
        UidElement.create = function create(properties) {
            return new UidElement(properties);
        };

        /**
         * Encodes the specified UidElement message. Does not implicitly {@link server.UidElement.verify|verify} messages.
         * @function encode
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement} message UidElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified UidElement message, length delimited. Does not implicitly {@link server.UidElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement} message UidElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UidElement message from the specified reader or buffer.
         * @function decode
         * @memberof server.UidElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UidElement} UidElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UidElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UidElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UidElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UidElement} UidElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UidElement message.
         * @function verify
         * @memberof server.UidElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UidElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates an UidElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UidElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UidElement} UidElement
         */
        UidElement.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UidElement)
                return object;
            var message = new $root.server.UidElement();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UidElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UidElement
         * @static
         * @param {server.UidElement} message UidElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UidElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.UidElement.Action[message.action] : message.action;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this UidElement to JSON.
         * @function toJSON
         * @memberof server.UidElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UidElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.UidElement.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        UidElement.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return UidElement;
    })();

    server.PhoneElement = (function() {

        /**
         * Properties of a PhoneElement.
         * @memberof server
         * @interface IPhoneElement
         * @property {server.PhoneElement.Action|null} [action] PhoneElement action
         * @property {string|null} [phone] PhoneElement phone
         */

        /**
         * Constructs a new PhoneElement.
         * @memberof server
         * @classdesc Represents a PhoneElement.
         * @implements IPhoneElement
         * @constructor
         * @param {server.IPhoneElement=} [properties] Properties to set
         */
        function PhoneElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PhoneElement action.
         * @member {server.PhoneElement.Action} action
         * @memberof server.PhoneElement
         * @instance
         */
        PhoneElement.prototype.action = 0;

        /**
         * PhoneElement phone.
         * @member {string} phone
         * @memberof server.PhoneElement
         * @instance
         */
        PhoneElement.prototype.phone = "";

        /**
         * Creates a new PhoneElement instance using the specified properties.
         * @function create
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement=} [properties] Properties to set
         * @returns {server.PhoneElement} PhoneElement instance
         */
        PhoneElement.create = function create(properties) {
            return new PhoneElement(properties);
        };

        /**
         * Encodes the specified PhoneElement message. Does not implicitly {@link server.PhoneElement.verify|verify} messages.
         * @function encode
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement} message PhoneElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhoneElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);
            return writer;
        };

        /**
         * Encodes the specified PhoneElement message, length delimited. Does not implicitly {@link server.PhoneElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement} message PhoneElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhoneElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PhoneElement message from the specified reader or buffer.
         * @function decode
         * @memberof server.PhoneElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PhoneElement} PhoneElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhoneElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PhoneElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PhoneElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PhoneElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PhoneElement} PhoneElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhoneElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PhoneElement message.
         * @function verify
         * @memberof server.PhoneElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PhoneElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            return null;
        };

        /**
         * Creates a PhoneElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PhoneElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PhoneElement} PhoneElement
         */
        PhoneElement.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PhoneElement)
                return object;
            var message = new $root.server.PhoneElement();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.phone != null)
                message.phone = String(object.phone);
            return message;
        };

        /**
         * Creates a plain object from a PhoneElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PhoneElement
         * @static
         * @param {server.PhoneElement} message PhoneElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PhoneElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                object.phone = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.PhoneElement.Action[message.action] : message.action;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            return object;
        };

        /**
         * Converts this PhoneElement to JSON.
         * @function toJSON
         * @memberof server.PhoneElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PhoneElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.PhoneElement.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        PhoneElement.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return PhoneElement;
    })();

    server.PrivacyList = (function() {

        /**
         * Properties of a PrivacyList.
         * @memberof server
         * @interface IPrivacyList
         * @property {server.PrivacyList.Type|null} [type] PrivacyList type
         * @property {Array.<server.IUidElement>|null} [uidElements] PrivacyList uidElements
         * @property {Uint8Array|null} [hash] PrivacyList hash
         * @property {Array.<server.IPhoneElement>|null} [phoneElements] PrivacyList phoneElements
         * @property {boolean|null} [usingPhones] PrivacyList usingPhones
         */

        /**
         * Constructs a new PrivacyList.
         * @memberof server
         * @classdesc Represents a PrivacyList.
         * @implements IPrivacyList
         * @constructor
         * @param {server.IPrivacyList=} [properties] Properties to set
         */
        function PrivacyList(properties) {
            this.uidElements = [];
            this.phoneElements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivacyList type.
         * @member {server.PrivacyList.Type} type
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.type = 0;

        /**
         * PrivacyList uidElements.
         * @member {Array.<server.IUidElement>} uidElements
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.uidElements = $util.emptyArray;

        /**
         * PrivacyList hash.
         * @member {Uint8Array} hash
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.hash = $util.newBuffer([]);

        /**
         * PrivacyList phoneElements.
         * @member {Array.<server.IPhoneElement>} phoneElements
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.phoneElements = $util.emptyArray;

        /**
         * PrivacyList usingPhones.
         * @member {boolean} usingPhones
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.usingPhones = false;

        /**
         * Creates a new PrivacyList instance using the specified properties.
         * @function create
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList=} [properties] Properties to set
         * @returns {server.PrivacyList} PrivacyList instance
         */
        PrivacyList.create = function create(properties) {
            return new PrivacyList(properties);
        };

        /**
         * Encodes the specified PrivacyList message. Does not implicitly {@link server.PrivacyList.verify|verify} messages.
         * @function encode
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList} message PrivacyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.uidElements != null && message.uidElements.length)
                for (var i = 0; i < message.uidElements.length; ++i)
                    $root.server.UidElement.encode(message.uidElements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hash);
            if (message.phoneElements != null && message.phoneElements.length)
                for (var i = 0; i < message.phoneElements.length; ++i)
                    $root.server.PhoneElement.encode(message.phoneElements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.usingPhones != null && Object.hasOwnProperty.call(message, "usingPhones"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.usingPhones);
            return writer;
        };

        /**
         * Encodes the specified PrivacyList message, length delimited. Does not implicitly {@link server.PrivacyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList} message PrivacyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivacyList message from the specified reader or buffer.
         * @function decode
         * @memberof server.PrivacyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PrivacyList} PrivacyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PrivacyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.uidElements && message.uidElements.length))
                        message.uidElements = [];
                    message.uidElements.push($root.server.UidElement.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.hash = reader.bytes();
                    break;
                case 4:
                    if (!(message.phoneElements && message.phoneElements.length))
                        message.phoneElements = [];
                    message.phoneElements.push($root.server.PhoneElement.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.usingPhones = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivacyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PrivacyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PrivacyList} PrivacyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivacyList message.
         * @function verify
         * @memberof server.PrivacyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivacyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.uidElements != null && message.hasOwnProperty("uidElements")) {
                if (!Array.isArray(message.uidElements))
                    return "uidElements: array expected";
                for (var i = 0; i < message.uidElements.length; ++i) {
                    var error = $root.server.UidElement.verify(message.uidElements[i]);
                    if (error)
                        return "uidElements." + error;
                }
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.phoneElements != null && message.hasOwnProperty("phoneElements")) {
                if (!Array.isArray(message.phoneElements))
                    return "phoneElements: array expected";
                for (var i = 0; i < message.phoneElements.length; ++i) {
                    var error = $root.server.PhoneElement.verify(message.phoneElements[i]);
                    if (error)
                        return "phoneElements." + error;
                }
            }
            if (message.usingPhones != null && message.hasOwnProperty("usingPhones"))
                if (typeof message.usingPhones !== "boolean")
                    return "usingPhones: boolean expected";
            return null;
        };

        /**
         * Creates a PrivacyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PrivacyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PrivacyList} PrivacyList
         */
        PrivacyList.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PrivacyList)
                return object;
            var message = new $root.server.PrivacyList();
            switch (object.type) {
            case "ALL":
            case 0:
                message.type = 0;
                break;
            case "BLOCK":
            case 1:
                message.type = 1;
                break;
            case "EXCEPT":
            case 2:
                message.type = 2;
                break;
            case "MUTE":
            case 3:
                message.type = 3;
                break;
            case "ONLY":
            case 4:
                message.type = 4;
                break;
            }
            if (object.uidElements) {
                if (!Array.isArray(object.uidElements))
                    throw TypeError(".server.PrivacyList.uidElements: array expected");
                message.uidElements = [];
                for (var i = 0; i < object.uidElements.length; ++i) {
                    if (typeof object.uidElements[i] !== "object")
                        throw TypeError(".server.PrivacyList.uidElements: object expected");
                    message.uidElements[i] = $root.server.UidElement.fromObject(object.uidElements[i]);
                }
            }
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.phoneElements) {
                if (!Array.isArray(object.phoneElements))
                    throw TypeError(".server.PrivacyList.phoneElements: array expected");
                message.phoneElements = [];
                for (var i = 0; i < object.phoneElements.length; ++i) {
                    if (typeof object.phoneElements[i] !== "object")
                        throw TypeError(".server.PrivacyList.phoneElements: object expected");
                    message.phoneElements[i] = $root.server.PhoneElement.fromObject(object.phoneElements[i]);
                }
            }
            if (object.usingPhones != null)
                message.usingPhones = Boolean(object.usingPhones);
            return message;
        };

        /**
         * Creates a plain object from a PrivacyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PrivacyList
         * @static
         * @param {server.PrivacyList} message PrivacyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivacyList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.uidElements = [];
                object.phoneElements = [];
            }
            if (options.defaults) {
                object.type = options.enums === String ? "ALL" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                object.usingPhones = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.PrivacyList.Type[message.type] : message.type;
            if (message.uidElements && message.uidElements.length) {
                object.uidElements = [];
                for (var j = 0; j < message.uidElements.length; ++j)
                    object.uidElements[j] = $root.server.UidElement.toObject(message.uidElements[j], options);
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.phoneElements && message.phoneElements.length) {
                object.phoneElements = [];
                for (var j = 0; j < message.phoneElements.length; ++j)
                    object.phoneElements[j] = $root.server.PhoneElement.toObject(message.phoneElements[j], options);
            }
            if (message.usingPhones != null && message.hasOwnProperty("usingPhones"))
                object.usingPhones = message.usingPhones;
            return object;
        };

        /**
         * Converts this PrivacyList to JSON.
         * @function toJSON
         * @memberof server.PrivacyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivacyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.PrivacyList.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} BLOCK=1 BLOCK value
         * @property {number} EXCEPT=2 EXCEPT value
         * @property {number} MUTE=3 MUTE value
         * @property {number} ONLY=4 ONLY value
         */
        PrivacyList.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            values[valuesById[2] = "EXCEPT"] = 2;
            values[valuesById[3] = "MUTE"] = 3;
            values[valuesById[4] = "ONLY"] = 4;
            return values;
        })();

        return PrivacyList;
    })();

    server.PrivacyLists = (function() {

        /**
         * Properties of a PrivacyLists.
         * @memberof server
         * @interface IPrivacyLists
         * @property {server.PrivacyLists.Type|null} [activeType] PrivacyLists activeType
         * @property {Array.<server.IPrivacyList>|null} [lists] PrivacyLists lists
         */

        /**
         * Constructs a new PrivacyLists.
         * @memberof server
         * @classdesc Represents a PrivacyLists.
         * @implements IPrivacyLists
         * @constructor
         * @param {server.IPrivacyLists=} [properties] Properties to set
         */
        function PrivacyLists(properties) {
            this.lists = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivacyLists activeType.
         * @member {server.PrivacyLists.Type} activeType
         * @memberof server.PrivacyLists
         * @instance
         */
        PrivacyLists.prototype.activeType = 0;

        /**
         * PrivacyLists lists.
         * @member {Array.<server.IPrivacyList>} lists
         * @memberof server.PrivacyLists
         * @instance
         */
        PrivacyLists.prototype.lists = $util.emptyArray;

        /**
         * Creates a new PrivacyLists instance using the specified properties.
         * @function create
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists=} [properties] Properties to set
         * @returns {server.PrivacyLists} PrivacyLists instance
         */
        PrivacyLists.create = function create(properties) {
            return new PrivacyLists(properties);
        };

        /**
         * Encodes the specified PrivacyLists message. Does not implicitly {@link server.PrivacyLists.verify|verify} messages.
         * @function encode
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists} message PrivacyLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyLists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeType != null && Object.hasOwnProperty.call(message, "activeType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activeType);
            if (message.lists != null && message.lists.length)
                for (var i = 0; i < message.lists.length; ++i)
                    $root.server.PrivacyList.encode(message.lists[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PrivacyLists message, length delimited. Does not implicitly {@link server.PrivacyLists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists} message PrivacyLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyLists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivacyLists message from the specified reader or buffer.
         * @function decode
         * @memberof server.PrivacyLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PrivacyLists} PrivacyLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyLists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PrivacyLists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeType = reader.int32();
                    break;
                case 2:
                    if (!(message.lists && message.lists.length))
                        message.lists = [];
                    message.lists.push($root.server.PrivacyList.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivacyLists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PrivacyLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PrivacyLists} PrivacyLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyLists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivacyLists message.
         * @function verify
         * @memberof server.PrivacyLists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivacyLists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeType != null && message.hasOwnProperty("activeType"))
                switch (message.activeType) {
                default:
                    return "activeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.lists != null && message.hasOwnProperty("lists")) {
                if (!Array.isArray(message.lists))
                    return "lists: array expected";
                for (var i = 0; i < message.lists.length; ++i) {
                    var error = $root.server.PrivacyList.verify(message.lists[i]);
                    if (error)
                        return "lists." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PrivacyLists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PrivacyLists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PrivacyLists} PrivacyLists
         */
        PrivacyLists.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PrivacyLists)
                return object;
            var message = new $root.server.PrivacyLists();
            switch (object.activeType) {
            case "ALL":
            case 0:
                message.activeType = 0;
                break;
            case "BLOCK":
            case 1:
                message.activeType = 1;
                break;
            case "EXCEPT":
            case 2:
                message.activeType = 2;
                break;
            case "ONLY":
            case 3:
                message.activeType = 3;
                break;
            }
            if (object.lists) {
                if (!Array.isArray(object.lists))
                    throw TypeError(".server.PrivacyLists.lists: array expected");
                message.lists = [];
                for (var i = 0; i < object.lists.length; ++i) {
                    if (typeof object.lists[i] !== "object")
                        throw TypeError(".server.PrivacyLists.lists: object expected");
                    message.lists[i] = $root.server.PrivacyList.fromObject(object.lists[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PrivacyLists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PrivacyLists
         * @static
         * @param {server.PrivacyLists} message PrivacyLists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivacyLists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lists = [];
            if (options.defaults)
                object.activeType = options.enums === String ? "ALL" : 0;
            if (message.activeType != null && message.hasOwnProperty("activeType"))
                object.activeType = options.enums === String ? $root.server.PrivacyLists.Type[message.activeType] : message.activeType;
            if (message.lists && message.lists.length) {
                object.lists = [];
                for (var j = 0; j < message.lists.length; ++j)
                    object.lists[j] = $root.server.PrivacyList.toObject(message.lists[j], options);
            }
            return object;
        };

        /**
         * Converts this PrivacyLists to JSON.
         * @function toJSON
         * @memberof server.PrivacyLists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivacyLists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.PrivacyLists.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} BLOCK=1 BLOCK value
         * @property {number} EXCEPT=2 EXCEPT value
         * @property {number} ONLY=3 ONLY value
         */
        PrivacyLists.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            values[valuesById[2] = "EXCEPT"] = 2;
            values[valuesById[3] = "ONLY"] = 3;
            return values;
        })();

        return PrivacyLists;
    })();

    server.PushToken = (function() {

        /**
         * Properties of a PushToken.
         * @memberof server
         * @interface IPushToken
         * @property {server.PushToken.TokenType|null} [tokenType] PushToken tokenType
         * @property {string|null} [token] PushToken token
         */

        /**
         * Constructs a new PushToken.
         * @memberof server
         * @classdesc Represents a PushToken.
         * @implements IPushToken
         * @constructor
         * @param {server.IPushToken=} [properties] Properties to set
         */
        function PushToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushToken tokenType.
         * @member {server.PushToken.TokenType} tokenType
         * @memberof server.PushToken
         * @instance
         */
        PushToken.prototype.tokenType = 0;

        /**
         * PushToken token.
         * @member {string} token
         * @memberof server.PushToken
         * @instance
         */
        PushToken.prototype.token = "";

        /**
         * Creates a new PushToken instance using the specified properties.
         * @function create
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken=} [properties] Properties to set
         * @returns {server.PushToken} PushToken instance
         */
        PushToken.create = function create(properties) {
            return new PushToken(properties);
        };

        /**
         * Encodes the specified PushToken message. Does not implicitly {@link server.PushToken.verify|verify} messages.
         * @function encode
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken} message PushToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenType != null && Object.hasOwnProperty.call(message, "tokenType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tokenType);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            return writer;
        };

        /**
         * Encodes the specified PushToken message, length delimited. Does not implicitly {@link server.PushToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken} message PushToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushToken message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushToken} PushToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tokenType = reader.int32();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushToken} PushToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushToken message.
         * @function verify
         * @memberof server.PushToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                switch (message.tokenType) {
                default:
                    return "tokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            return null;
        };

        /**
         * Creates a PushToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushToken} PushToken
         */
        PushToken.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushToken)
                return object;
            var message = new $root.server.PushToken();
            switch (object.tokenType) {
            case "ANDROID":
            case 0:
                message.tokenType = 0;
                break;
            case "IOS":
            case 1:
                message.tokenType = 1;
                break;
            case "IOS_DEV":
            case 2:
                message.tokenType = 2;
                break;
            case "IOS_APPCLIP":
            case 3:
                message.tokenType = 3;
                break;
            case "IOS_VOIP":
            case 4:
                message.tokenType = 4;
                break;
            case "ANDROID_HUAWEI":
            case 5:
                message.tokenType = 5;
                break;
            }
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };

        /**
         * Creates a plain object from a PushToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushToken
         * @static
         * @param {server.PushToken} message PushToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tokenType = options.enums === String ? "ANDROID" : 0;
                object.token = "";
            }
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                object.tokenType = options.enums === String ? $root.server.PushToken.TokenType[message.tokenType] : message.tokenType;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };

        /**
         * Converts this PushToken to JSON.
         * @function toJSON
         * @memberof server.PushToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * TokenType enum.
         * @name server.PushToken.TokenType
         * @enum {number}
         * @property {number} ANDROID=0 ANDROID value
         * @property {number} IOS=1 IOS value
         * @property {number} IOS_DEV=2 IOS_DEV value
         * @property {number} IOS_APPCLIP=3 IOS_APPCLIP value
         * @property {number} IOS_VOIP=4 IOS_VOIP value
         * @property {number} ANDROID_HUAWEI=5 ANDROID_HUAWEI value
         */
        PushToken.TokenType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ANDROID"] = 0;
            values[valuesById[1] = "IOS"] = 1;
            values[valuesById[2] = "IOS_DEV"] = 2;
            values[valuesById[3] = "IOS_APPCLIP"] = 3;
            values[valuesById[4] = "IOS_VOIP"] = 4;
            values[valuesById[5] = "ANDROID_HUAWEI"] = 5;
            return values;
        })();

        return PushToken;
    })();

    server.PushRegister = (function() {

        /**
         * Properties of a PushRegister.
         * @memberof server
         * @interface IPushRegister
         * @property {server.IPushToken|null} [pushToken] PushRegister pushToken
         * @property {string|null} [langId] PushRegister langId
         * @property {number|Long|null} [zoneOffset] PushRegister zoneOffset
         */

        /**
         * Constructs a new PushRegister.
         * @memberof server
         * @classdesc Represents a PushRegister.
         * @implements IPushRegister
         * @constructor
         * @param {server.IPushRegister=} [properties] Properties to set
         */
        function PushRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRegister pushToken.
         * @member {server.IPushToken|null|undefined} pushToken
         * @memberof server.PushRegister
         * @instance
         */
        PushRegister.prototype.pushToken = null;

        /**
         * PushRegister langId.
         * @member {string} langId
         * @memberof server.PushRegister
         * @instance
         */
        PushRegister.prototype.langId = "";

        /**
         * PushRegister zoneOffset.
         * @member {number|Long} zoneOffset
         * @memberof server.PushRegister
         * @instance
         */
        PushRegister.prototype.zoneOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PushRegister instance using the specified properties.
         * @function create
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister=} [properties] Properties to set
         * @returns {server.PushRegister} PushRegister instance
         */
        PushRegister.create = function create(properties) {
            return new PushRegister(properties);
        };

        /**
         * Encodes the specified PushRegister message. Does not implicitly {@link server.PushRegister.verify|verify} messages.
         * @function encode
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister} message PushRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pushToken != null && Object.hasOwnProperty.call(message, "pushToken"))
                $root.server.PushToken.encode(message.pushToken, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.langId != null && Object.hasOwnProperty.call(message, "langId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.langId);
            if (message.zoneOffset != null && Object.hasOwnProperty.call(message, "zoneOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.zoneOffset);
            return writer;
        };

        /**
         * Encodes the specified PushRegister message, length delimited. Does not implicitly {@link server.PushRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister} message PushRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRegister.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushRegister message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushRegister} PushRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pushToken = $root.server.PushToken.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.langId = reader.string();
                    break;
                case 3:
                    message.zoneOffset = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushRegister} PushRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRegister.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushRegister message.
         * @function verify
         * @memberof server.PushRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushRegister.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pushToken != null && message.hasOwnProperty("pushToken")) {
                var error = $root.server.PushToken.verify(message.pushToken);
                if (error)
                    return "pushToken." + error;
            }
            if (message.langId != null && message.hasOwnProperty("langId"))
                if (!$util.isString(message.langId))
                    return "langId: string expected";
            if (message.zoneOffset != null && message.hasOwnProperty("zoneOffset"))
                if (!$util.isInteger(message.zoneOffset) && !(message.zoneOffset && $util.isInteger(message.zoneOffset.low) && $util.isInteger(message.zoneOffset.high)))
                    return "zoneOffset: integer|Long expected";
            return null;
        };

        /**
         * Creates a PushRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushRegister} PushRegister
         */
        PushRegister.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushRegister)
                return object;
            var message = new $root.server.PushRegister();
            if (object.pushToken != null) {
                if (typeof object.pushToken !== "object")
                    throw TypeError(".server.PushRegister.pushToken: object expected");
                message.pushToken = $root.server.PushToken.fromObject(object.pushToken);
            }
            if (object.langId != null)
                message.langId = String(object.langId);
            if (object.zoneOffset != null)
                if ($util.Long)
                    (message.zoneOffset = $util.Long.fromValue(object.zoneOffset)).unsigned = false;
                else if (typeof object.zoneOffset === "string")
                    message.zoneOffset = parseInt(object.zoneOffset, 10);
                else if (typeof object.zoneOffset === "number")
                    message.zoneOffset = object.zoneOffset;
                else if (typeof object.zoneOffset === "object")
                    message.zoneOffset = new $util.LongBits(object.zoneOffset.low >>> 0, object.zoneOffset.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PushRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushRegister
         * @static
         * @param {server.PushRegister} message PushRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushRegister.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pushToken = null;
                object.langId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.zoneOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.zoneOffset = options.longs === String ? "0" : 0;
            }
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                object.pushToken = $root.server.PushToken.toObject(message.pushToken, options);
            if (message.langId != null && message.hasOwnProperty("langId"))
                object.langId = message.langId;
            if (message.zoneOffset != null && message.hasOwnProperty("zoneOffset"))
                if (typeof message.zoneOffset === "number")
                    object.zoneOffset = options.longs === String ? String(message.zoneOffset) : message.zoneOffset;
                else
                    object.zoneOffset = options.longs === String ? $util.Long.prototype.toString.call(message.zoneOffset) : options.longs === Number ? new $util.LongBits(message.zoneOffset.low >>> 0, message.zoneOffset.high >>> 0).toNumber() : message.zoneOffset;
            return object;
        };

        /**
         * Converts this PushRegister to JSON.
         * @function toJSON
         * @memberof server.PushRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushRegister.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushRegister;
    })();

    server.PushPref = (function() {

        /**
         * Properties of a PushPref.
         * @memberof server
         * @interface IPushPref
         * @property {server.PushPref.Name|null} [name] PushPref name
         * @property {boolean|null} [value] PushPref value
         */

        /**
         * Constructs a new PushPref.
         * @memberof server
         * @classdesc Represents a PushPref.
         * @implements IPushPref
         * @constructor
         * @param {server.IPushPref=} [properties] Properties to set
         */
        function PushPref(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushPref name.
         * @member {server.PushPref.Name} name
         * @memberof server.PushPref
         * @instance
         */
        PushPref.prototype.name = 0;

        /**
         * PushPref value.
         * @member {boolean} value
         * @memberof server.PushPref
         * @instance
         */
        PushPref.prototype.value = false;

        /**
         * Creates a new PushPref instance using the specified properties.
         * @function create
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref=} [properties] Properties to set
         * @returns {server.PushPref} PushPref instance
         */
        PushPref.create = function create(properties) {
            return new PushPref(properties);
        };

        /**
         * Encodes the specified PushPref message. Does not implicitly {@link server.PushPref.verify|verify} messages.
         * @function encode
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref} message PushPref message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushPref.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
            return writer;
        };

        /**
         * Encodes the specified PushPref message, length delimited. Does not implicitly {@link server.PushPref.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref} message PushPref message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushPref.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushPref message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushPref
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushPref} PushPref
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushPref.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushPref();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.int32();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushPref message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushPref
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushPref} PushPref
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushPref.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushPref message.
         * @function verify
         * @memberof server.PushPref
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushPref.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                switch (message.name) {
                default:
                    return "name: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "boolean")
                    return "value: boolean expected";
            return null;
        };

        /**
         * Creates a PushPref message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushPref
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushPref} PushPref
         */
        PushPref.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushPref)
                return object;
            var message = new $root.server.PushPref();
            switch (object.name) {
            case "POST":
            case 0:
                message.name = 0;
                break;
            case "COMMENT":
            case 1:
                message.name = 1;
                break;
            case "MENTIONS":
            case 2:
                message.name = 2;
                break;
            case "ON_FIRE":
            case 3:
                message.name = 3;
                break;
            case "NEW_USERS":
            case 4:
                message.name = 4;
                break;
            case "FOLLOWERS":
            case 5:
                message.name = 5;
                break;
            }
            if (object.value != null)
                message.value = Boolean(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PushPref message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushPref
         * @static
         * @param {server.PushPref} message PushPref
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushPref.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = options.enums === String ? "POST" : 0;
                object.value = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.enums === String ? $root.server.PushPref.Name[message.name] : message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PushPref to JSON.
         * @function toJSON
         * @memberof server.PushPref
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushPref.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Name enum.
         * @name server.PushPref.Name
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} COMMENT=1 COMMENT value
         * @property {number} MENTIONS=2 MENTIONS value
         * @property {number} ON_FIRE=3 ON_FIRE value
         * @property {number} NEW_USERS=4 NEW_USERS value
         * @property {number} FOLLOWERS=5 FOLLOWERS value
         */
        PushPref.Name = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "COMMENT"] = 1;
            values[valuesById[2] = "MENTIONS"] = 2;
            values[valuesById[3] = "ON_FIRE"] = 3;
            values[valuesById[4] = "NEW_USERS"] = 4;
            values[valuesById[5] = "FOLLOWERS"] = 5;
            return values;
        })();

        return PushPref;
    })();

    server.NotificationPrefs = (function() {

        /**
         * Properties of a NotificationPrefs.
         * @memberof server
         * @interface INotificationPrefs
         * @property {Array.<server.IPushPref>|null} [pushPrefs] NotificationPrefs pushPrefs
         */

        /**
         * Constructs a new NotificationPrefs.
         * @memberof server
         * @classdesc Represents a NotificationPrefs.
         * @implements INotificationPrefs
         * @constructor
         * @param {server.INotificationPrefs=} [properties] Properties to set
         */
        function NotificationPrefs(properties) {
            this.pushPrefs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationPrefs pushPrefs.
         * @member {Array.<server.IPushPref>} pushPrefs
         * @memberof server.NotificationPrefs
         * @instance
         */
        NotificationPrefs.prototype.pushPrefs = $util.emptyArray;

        /**
         * Creates a new NotificationPrefs instance using the specified properties.
         * @function create
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs=} [properties] Properties to set
         * @returns {server.NotificationPrefs} NotificationPrefs instance
         */
        NotificationPrefs.create = function create(properties) {
            return new NotificationPrefs(properties);
        };

        /**
         * Encodes the specified NotificationPrefs message. Does not implicitly {@link server.NotificationPrefs.verify|verify} messages.
         * @function encode
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs} message NotificationPrefs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationPrefs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pushPrefs != null && message.pushPrefs.length)
                for (var i = 0; i < message.pushPrefs.length; ++i)
                    $root.server.PushPref.encode(message.pushPrefs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NotificationPrefs message, length delimited. Does not implicitly {@link server.NotificationPrefs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs} message NotificationPrefs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationPrefs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotificationPrefs message from the specified reader or buffer.
         * @function decode
         * @memberof server.NotificationPrefs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.NotificationPrefs} NotificationPrefs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationPrefs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.NotificationPrefs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.pushPrefs && message.pushPrefs.length))
                        message.pushPrefs = [];
                    message.pushPrefs.push($root.server.PushPref.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotificationPrefs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.NotificationPrefs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.NotificationPrefs} NotificationPrefs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationPrefs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotificationPrefs message.
         * @function verify
         * @memberof server.NotificationPrefs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotificationPrefs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pushPrefs != null && message.hasOwnProperty("pushPrefs")) {
                if (!Array.isArray(message.pushPrefs))
                    return "pushPrefs: array expected";
                for (var i = 0; i < message.pushPrefs.length; ++i) {
                    var error = $root.server.PushPref.verify(message.pushPrefs[i]);
                    if (error)
                        return "pushPrefs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NotificationPrefs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.NotificationPrefs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.NotificationPrefs} NotificationPrefs
         */
        NotificationPrefs.fromObject = function fromObject(object) {
            if (object instanceof $root.server.NotificationPrefs)
                return object;
            var message = new $root.server.NotificationPrefs();
            if (object.pushPrefs) {
                if (!Array.isArray(object.pushPrefs))
                    throw TypeError(".server.NotificationPrefs.pushPrefs: array expected");
                message.pushPrefs = [];
                for (var i = 0; i < object.pushPrefs.length; ++i) {
                    if (typeof object.pushPrefs[i] !== "object")
                        throw TypeError(".server.NotificationPrefs.pushPrefs: object expected");
                    message.pushPrefs[i] = $root.server.PushPref.fromObject(object.pushPrefs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NotificationPrefs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.NotificationPrefs} message NotificationPrefs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotificationPrefs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pushPrefs = [];
            if (message.pushPrefs && message.pushPrefs.length) {
                object.pushPrefs = [];
                for (var j = 0; j < message.pushPrefs.length; ++j)
                    object.pushPrefs[j] = $root.server.PushPref.toObject(message.pushPrefs[j], options);
            }
            return object;
        };

        /**
         * Converts this NotificationPrefs to JSON.
         * @function toJSON
         * @memberof server.NotificationPrefs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotificationPrefs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NotificationPrefs;
    })();

    server.Rerequest = (function() {

        /**
         * Properties of a Rerequest.
         * @memberof server
         * @interface IRerequest
         * @property {string|null} [id] Rerequest id
         * @property {Uint8Array|null} [identityKey] Rerequest identityKey
         * @property {number|Long|null} [signedPreKeyId] Rerequest signedPreKeyId
         * @property {number|Long|null} [oneTimePreKeyId] Rerequest oneTimePreKeyId
         * @property {Uint8Array|null} [sessionSetupEphemeralKey] Rerequest sessionSetupEphemeralKey
         * @property {Uint8Array|null} [messageEphemeralKey] Rerequest messageEphemeralKey
         * @property {server.Rerequest.ContentType|null} [contentType] Rerequest contentType
         */

        /**
         * Constructs a new Rerequest.
         * @memberof server
         * @classdesc Represents a Rerequest.
         * @implements IRerequest
         * @constructor
         * @param {server.IRerequest=} [properties] Properties to set
         */
        function Rerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rerequest id.
         * @member {string} id
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.id = "";

        /**
         * Rerequest identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.identityKey = $util.newBuffer([]);

        /**
         * Rerequest signedPreKeyId.
         * @member {number|Long} signedPreKeyId
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.signedPreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rerequest oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rerequest sessionSetupEphemeralKey.
         * @member {Uint8Array} sessionSetupEphemeralKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.sessionSetupEphemeralKey = $util.newBuffer([]);

        /**
         * Rerequest messageEphemeralKey.
         * @member {Uint8Array} messageEphemeralKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.messageEphemeralKey = $util.newBuffer([]);

        /**
         * Rerequest contentType.
         * @member {server.Rerequest.ContentType} contentType
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.contentType = 0;

        /**
         * Creates a new Rerequest instance using the specified properties.
         * @function create
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest=} [properties] Properties to set
         * @returns {server.Rerequest} Rerequest instance
         */
        Rerequest.create = function create(properties) {
            return new Rerequest(properties);
        };

        /**
         * Encodes the specified Rerequest message. Does not implicitly {@link server.Rerequest.verify|verify} messages.
         * @function encode
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest} message Rerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identityKey);
            if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.signedPreKeyId);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.oneTimePreKeyId);
            if (message.sessionSetupEphemeralKey != null && Object.hasOwnProperty.call(message, "sessionSetupEphemeralKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sessionSetupEphemeralKey);
            if (message.messageEphemeralKey != null && Object.hasOwnProperty.call(message, "messageEphemeralKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.messageEphemeralKey);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified Rerequest message, length delimited. Does not implicitly {@link server.Rerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest} message Rerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.Rerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Rerequest} Rerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Rerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.identityKey = reader.bytes();
                    break;
                case 3:
                    message.signedPreKeyId = reader.int64();
                    break;
                case 4:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 5:
                    message.sessionSetupEphemeralKey = reader.bytes();
                    break;
                case 6:
                    message.messageEphemeralKey = reader.bytes();
                    break;
                case 7:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Rerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Rerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Rerequest} Rerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rerequest message.
         * @function verify
         * @memberof server.Rerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (!$util.isInteger(message.signedPreKeyId) && !(message.signedPreKeyId && $util.isInteger(message.signedPreKeyId.low) && $util.isInteger(message.signedPreKeyId.high)))
                    return "signedPreKeyId: integer|Long expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.sessionSetupEphemeralKey != null && message.hasOwnProperty("sessionSetupEphemeralKey"))
                if (!(message.sessionSetupEphemeralKey && typeof message.sessionSetupEphemeralKey.length === "number" || $util.isString(message.sessionSetupEphemeralKey)))
                    return "sessionSetupEphemeralKey: buffer expected";
            if (message.messageEphemeralKey != null && message.hasOwnProperty("messageEphemeralKey"))
                if (!(message.messageEphemeralKey && typeof message.messageEphemeralKey.length === "number" || $util.isString(message.messageEphemeralKey)))
                    return "messageEphemeralKey: buffer expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Rerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Rerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Rerequest} Rerequest
         */
        Rerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Rerequest)
                return object;
            var message = new $root.server.Rerequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedPreKeyId != null)
                if ($util.Long)
                    (message.signedPreKeyId = $util.Long.fromValue(object.signedPreKeyId)).unsigned = false;
                else if (typeof object.signedPreKeyId === "string")
                    message.signedPreKeyId = parseInt(object.signedPreKeyId, 10);
                else if (typeof object.signedPreKeyId === "number")
                    message.signedPreKeyId = object.signedPreKeyId;
                else if (typeof object.signedPreKeyId === "object")
                    message.signedPreKeyId = new $util.LongBits(object.signedPreKeyId.low >>> 0, object.signedPreKeyId.high >>> 0).toNumber();
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.sessionSetupEphemeralKey != null)
                if (typeof object.sessionSetupEphemeralKey === "string")
                    $util.base64.decode(object.sessionSetupEphemeralKey, message.sessionSetupEphemeralKey = $util.newBuffer($util.base64.length(object.sessionSetupEphemeralKey)), 0);
                else if (object.sessionSetupEphemeralKey.length)
                    message.sessionSetupEphemeralKey = object.sessionSetupEphemeralKey;
            if (object.messageEphemeralKey != null)
                if (typeof object.messageEphemeralKey === "string")
                    $util.base64.decode(object.messageEphemeralKey, message.messageEphemeralKey = $util.newBuffer($util.base64.length(object.messageEphemeralKey)), 0);
                else if (object.messageEphemeralKey.length)
                    message.messageEphemeralKey = object.messageEphemeralKey;
            switch (object.contentType) {
            case "CHAT":
            case 0:
                message.contentType = 0;
                break;
            case "CALL":
            case 1:
                message.contentType = 1;
                break;
            case "GROUP_HISTORY":
            case 2:
                message.contentType = 2;
                break;
            case "CHAT_REACTION":
            case 3:
                message.contentType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Rerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Rerequest
         * @static
         * @param {server.Rerequest} message Rerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.signedPreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.signedPreKeyId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.sessionSetupEphemeralKey = "";
                else {
                    object.sessionSetupEphemeralKey = [];
                    if (options.bytes !== Array)
                        object.sessionSetupEphemeralKey = $util.newBuffer(object.sessionSetupEphemeralKey);
                }
                if (options.bytes === String)
                    object.messageEphemeralKey = "";
                else {
                    object.messageEphemeralKey = [];
                    if (options.bytes !== Array)
                        object.messageEphemeralKey = $util.newBuffer(object.messageEphemeralKey);
                }
                object.contentType = options.enums === String ? "CHAT" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (typeof message.signedPreKeyId === "number")
                    object.signedPreKeyId = options.longs === String ? String(message.signedPreKeyId) : message.signedPreKeyId;
                else
                    object.signedPreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.signedPreKeyId) : options.longs === Number ? new $util.LongBits(message.signedPreKeyId.low >>> 0, message.signedPreKeyId.high >>> 0).toNumber() : message.signedPreKeyId;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.sessionSetupEphemeralKey != null && message.hasOwnProperty("sessionSetupEphemeralKey"))
                object.sessionSetupEphemeralKey = options.bytes === String ? $util.base64.encode(message.sessionSetupEphemeralKey, 0, message.sessionSetupEphemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionSetupEphemeralKey) : message.sessionSetupEphemeralKey;
            if (message.messageEphemeralKey != null && message.hasOwnProperty("messageEphemeralKey"))
                object.messageEphemeralKey = options.bytes === String ? $util.base64.encode(message.messageEphemeralKey, 0, message.messageEphemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageEphemeralKey) : message.messageEphemeralKey;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.Rerequest.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this Rerequest to JSON.
         * @function toJSON
         * @memberof server.Rerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ContentType enum.
         * @name server.Rerequest.ContentType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} CALL=1 CALL value
         * @property {number} GROUP_HISTORY=2 GROUP_HISTORY value
         * @property {number} CHAT_REACTION=3 CHAT_REACTION value
         */
        Rerequest.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "CALL"] = 1;
            values[valuesById[2] = "GROUP_HISTORY"] = 2;
            values[valuesById[3] = "CHAT_REACTION"] = 3;
            return values;
        })();

        return Rerequest;
    })();

    server.GroupFeedRerequest = (function() {

        /**
         * Properties of a GroupFeedRerequest.
         * @memberof server
         * @interface IGroupFeedRerequest
         * @property {string|null} [gid] GroupFeedRerequest gid
         * @property {string|null} [id] GroupFeedRerequest id
         * @property {server.GroupFeedRerequest.RerequestType|null} [rerequestType] GroupFeedRerequest rerequestType
         * @property {server.GroupFeedRerequest.ContentType|null} [contentType] GroupFeedRerequest contentType
         */

        /**
         * Constructs a new GroupFeedRerequest.
         * @memberof server
         * @classdesc Represents a GroupFeedRerequest.
         * @implements IGroupFeedRerequest
         * @constructor
         * @param {server.IGroupFeedRerequest=} [properties] Properties to set
         */
        function GroupFeedRerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedRerequest gid.
         * @member {string} gid
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.gid = "";

        /**
         * GroupFeedRerequest id.
         * @member {string} id
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.id = "";

        /**
         * GroupFeedRerequest rerequestType.
         * @member {server.GroupFeedRerequest.RerequestType} rerequestType
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.rerequestType = 0;

        /**
         * GroupFeedRerequest contentType.
         * @member {server.GroupFeedRerequest.ContentType} contentType
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.contentType = 0;

        /**
         * Creates a new GroupFeedRerequest instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest=} [properties] Properties to set
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest instance
         */
        GroupFeedRerequest.create = function create(properties) {
            return new GroupFeedRerequest(properties);
        };

        /**
         * Encodes the specified GroupFeedRerequest message. Does not implicitly {@link server.GroupFeedRerequest.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest} message GroupFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedRerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.rerequestType != null && Object.hasOwnProperty.call(message, "rerequestType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rerequestType);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedRerequest message, length delimited. Does not implicitly {@link server.GroupFeedRerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest} message GroupFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedRerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedRerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedRerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedRerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.rerequestType = reader.int32();
                    break;
                case 4:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedRerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedRerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedRerequest message.
         * @function verify
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedRerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                switch (message.rerequestType) {
                default:
                    return "rerequestType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupFeedRerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         */
        GroupFeedRerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedRerequest)
                return object;
            var message = new $root.server.GroupFeedRerequest();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            switch (object.rerequestType) {
            case "PAYLOAD":
            case 0:
                message.rerequestType = 0;
                break;
            case "SENDER_STATE":
            case 1:
                message.rerequestType = 1;
                break;
            }
            switch (object.contentType) {
            case "UNKNOWN":
            case 0:
                message.contentType = 0;
                break;
            case "POST":
            case 1:
                message.contentType = 1;
                break;
            case "COMMENT":
            case 2:
                message.contentType = 2;
                break;
            case "HISTORY_RESEND":
            case 3:
                message.contentType = 3;
                break;
            case "POST_REACTION":
            case 4:
                message.contentType = 4;
                break;
            case "COMMENT_REACTION":
            case 5:
                message.contentType = 5;
                break;
            case "MESSAGE":
            case 6:
                message.contentType = 6;
                break;
            case "MESSAGE_REACTION":
            case 7:
                message.contentType = 7;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedRerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.GroupFeedRerequest} message GroupFeedRerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedRerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                object.rerequestType = options.enums === String ? "PAYLOAD" : 0;
                object.contentType = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                object.rerequestType = options.enums === String ? $root.server.GroupFeedRerequest.RerequestType[message.rerequestType] : message.rerequestType;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.GroupFeedRerequest.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this GroupFeedRerequest to JSON.
         * @function toJSON
         * @memberof server.GroupFeedRerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedRerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * RerequestType enum.
         * @name server.GroupFeedRerequest.RerequestType
         * @enum {number}
         * @property {number} PAYLOAD=0 PAYLOAD value
         * @property {number} SENDER_STATE=1 SENDER_STATE value
         */
        GroupFeedRerequest.RerequestType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PAYLOAD"] = 0;
            values[valuesById[1] = "SENDER_STATE"] = 1;
            return values;
        })();

        /**
         * ContentType enum.
         * @name server.GroupFeedRerequest.ContentType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} HISTORY_RESEND=3 HISTORY_RESEND value
         * @property {number} POST_REACTION=4 POST_REACTION value
         * @property {number} COMMENT_REACTION=5 COMMENT_REACTION value
         * @property {number} MESSAGE=6 MESSAGE value
         * @property {number} MESSAGE_REACTION=7 MESSAGE_REACTION value
         */
        GroupFeedRerequest.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[3] = "HISTORY_RESEND"] = 3;
            values[valuesById[4] = "POST_REACTION"] = 4;
            values[valuesById[5] = "COMMENT_REACTION"] = 5;
            values[valuesById[6] = "MESSAGE"] = 6;
            values[valuesById[7] = "MESSAGE_REACTION"] = 7;
            return values;
        })();

        return GroupFeedRerequest;
    })();

    server.HomeFeedRerequest = (function() {

        /**
         * Properties of a HomeFeedRerequest.
         * @memberof server
         * @interface IHomeFeedRerequest
         * @property {string|null} [id] HomeFeedRerequest id
         * @property {server.HomeFeedRerequest.RerequestType|null} [rerequestType] HomeFeedRerequest rerequestType
         * @property {server.HomeFeedRerequest.ContentType|null} [contentType] HomeFeedRerequest contentType
         */

        /**
         * Constructs a new HomeFeedRerequest.
         * @memberof server
         * @classdesc Represents a HomeFeedRerequest.
         * @implements IHomeFeedRerequest
         * @constructor
         * @param {server.IHomeFeedRerequest=} [properties] Properties to set
         */
        function HomeFeedRerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HomeFeedRerequest id.
         * @member {string} id
         * @memberof server.HomeFeedRerequest
         * @instance
         */
        HomeFeedRerequest.prototype.id = "";

        /**
         * HomeFeedRerequest rerequestType.
         * @member {server.HomeFeedRerequest.RerequestType} rerequestType
         * @memberof server.HomeFeedRerequest
         * @instance
         */
        HomeFeedRerequest.prototype.rerequestType = 0;

        /**
         * HomeFeedRerequest contentType.
         * @member {server.HomeFeedRerequest.ContentType} contentType
         * @memberof server.HomeFeedRerequest
         * @instance
         */
        HomeFeedRerequest.prototype.contentType = 0;

        /**
         * Creates a new HomeFeedRerequest instance using the specified properties.
         * @function create
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest=} [properties] Properties to set
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest instance
         */
        HomeFeedRerequest.create = function create(properties) {
            return new HomeFeedRerequest(properties);
        };

        /**
         * Encodes the specified HomeFeedRerequest message. Does not implicitly {@link server.HomeFeedRerequest.verify|verify} messages.
         * @function encode
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest} message HomeFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeFeedRerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.rerequestType != null && Object.hasOwnProperty.call(message, "rerequestType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rerequestType);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified HomeFeedRerequest message, length delimited. Does not implicitly {@link server.HomeFeedRerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest} message HomeFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeFeedRerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HomeFeedRerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeFeedRerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HomeFeedRerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.rerequestType = reader.int32();
                    break;
                case 4:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HomeFeedRerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeFeedRerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HomeFeedRerequest message.
         * @function verify
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HomeFeedRerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                switch (message.rerequestType) {
                default:
                    return "rerequestType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a HomeFeedRerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         */
        HomeFeedRerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HomeFeedRerequest)
                return object;
            var message = new $root.server.HomeFeedRerequest();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.rerequestType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.rerequestType = 0;
                break;
            case "PAYLOAD":
            case 1:
                message.rerequestType = 1;
                break;
            case "SENDER_STATE":
            case 2:
                message.rerequestType = 2;
                break;
            }
            switch (object.contentType) {
            case "UNKNOWN":
            case 0:
                message.contentType = 0;
                break;
            case "POST":
            case 1:
                message.contentType = 1;
                break;
            case "COMMENT":
            case 2:
                message.contentType = 2;
                break;
            case "POST_REACTION":
            case 3:
                message.contentType = 3;
                break;
            case "COMMENT_REACTION":
            case 4:
                message.contentType = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a HomeFeedRerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.HomeFeedRerequest} message HomeFeedRerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HomeFeedRerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.rerequestType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.contentType = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                object.rerequestType = options.enums === String ? $root.server.HomeFeedRerequest.RerequestType[message.rerequestType] : message.rerequestType;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.HomeFeedRerequest.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this HomeFeedRerequest to JSON.
         * @function toJSON
         * @memberof server.HomeFeedRerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HomeFeedRerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * RerequestType enum.
         * @name server.HomeFeedRerequest.RerequestType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} PAYLOAD=1 PAYLOAD value
         * @property {number} SENDER_STATE=2 SENDER_STATE value
         */
        HomeFeedRerequest.RerequestType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "PAYLOAD"] = 1;
            values[valuesById[2] = "SENDER_STATE"] = 2;
            return values;
        })();

        /**
         * ContentType enum.
         * @name server.HomeFeedRerequest.ContentType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} POST_REACTION=3 POST_REACTION value
         * @property {number} COMMENT_REACTION=4 COMMENT_REACTION value
         */
        HomeFeedRerequest.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[3] = "POST_REACTION"] = 3;
            values[valuesById[4] = "COMMENT_REACTION"] = 4;
            return values;
        })();

        return HomeFeedRerequest;
    })();

    server.SeenReceipt = (function() {

        /**
         * Properties of a SeenReceipt.
         * @memberof server
         * @interface ISeenReceipt
         * @property {string|null} [id] SeenReceipt id
         * @property {string|null} [threadId] SeenReceipt threadId
         * @property {number|Long|null} [timestamp] SeenReceipt timestamp
         */

        /**
         * Constructs a new SeenReceipt.
         * @memberof server
         * @classdesc Represents a SeenReceipt.
         * @implements ISeenReceipt
         * @constructor
         * @param {server.ISeenReceipt=} [properties] Properties to set
         */
        function SeenReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeenReceipt id.
         * @member {string} id
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.id = "";

        /**
         * SeenReceipt threadId.
         * @member {string} threadId
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.threadId = "";

        /**
         * SeenReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SeenReceipt instance using the specified properties.
         * @function create
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt=} [properties] Properties to set
         * @returns {server.SeenReceipt} SeenReceipt instance
         */
        SeenReceipt.create = function create(properties) {
            return new SeenReceipt(properties);
        };

        /**
         * Encodes the specified SeenReceipt message. Does not implicitly {@link server.SeenReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt} message SeenReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeenReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified SeenReceipt message, length delimited. Does not implicitly {@link server.SeenReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt} message SeenReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeenReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeenReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.SeenReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SeenReceipt} SeenReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeenReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SeenReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeenReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SeenReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SeenReceipt} SeenReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeenReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeenReceipt message.
         * @function verify
         * @memberof server.SeenReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeenReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a SeenReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SeenReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SeenReceipt} SeenReceipt
         */
        SeenReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SeenReceipt)
                return object;
            var message = new $root.server.SeenReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SeenReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SeenReceipt
         * @static
         * @param {server.SeenReceipt} message SeenReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SeenReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this SeenReceipt to JSON.
         * @function toJSON
         * @memberof server.SeenReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SeenReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SeenReceipt;
    })();

    server.DeliveryReceipt = (function() {

        /**
         * Properties of a DeliveryReceipt.
         * @memberof server
         * @interface IDeliveryReceipt
         * @property {string|null} [id] DeliveryReceipt id
         * @property {string|null} [threadId] DeliveryReceipt threadId
         * @property {number|Long|null} [timestamp] DeliveryReceipt timestamp
         */

        /**
         * Constructs a new DeliveryReceipt.
         * @memberof server
         * @classdesc Represents a DeliveryReceipt.
         * @implements IDeliveryReceipt
         * @constructor
         * @param {server.IDeliveryReceipt=} [properties] Properties to set
         */
        function DeliveryReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeliveryReceipt id.
         * @member {string} id
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.id = "";

        /**
         * DeliveryReceipt threadId.
         * @member {string} threadId
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.threadId = "";

        /**
         * DeliveryReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeliveryReceipt instance using the specified properties.
         * @function create
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt=} [properties] Properties to set
         * @returns {server.DeliveryReceipt} DeliveryReceipt instance
         */
        DeliveryReceipt.create = function create(properties) {
            return new DeliveryReceipt(properties);
        };

        /**
         * Encodes the specified DeliveryReceipt message. Does not implicitly {@link server.DeliveryReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt} message DeliveryReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeliveryReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified DeliveryReceipt message, length delimited. Does not implicitly {@link server.DeliveryReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt} message DeliveryReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeliveryReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeliveryReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeliveryReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeliveryReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeliveryReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeliveryReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeliveryReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeliveryReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeliveryReceipt message.
         * @function verify
         * @memberof server.DeliveryReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeliveryReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a DeliveryReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeliveryReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         */
        DeliveryReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeliveryReceipt)
                return object;
            var message = new $root.server.DeliveryReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DeliveryReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.DeliveryReceipt} message DeliveryReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeliveryReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this DeliveryReceipt to JSON.
         * @function toJSON
         * @memberof server.DeliveryReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeliveryReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeliveryReceipt;
    })();

    server.PlayedReceipt = (function() {

        /**
         * Properties of a PlayedReceipt.
         * @memberof server
         * @interface IPlayedReceipt
         * @property {string|null} [id] PlayedReceipt id
         * @property {string|null} [threadId] PlayedReceipt threadId
         * @property {number|Long|null} [timestamp] PlayedReceipt timestamp
         */

        /**
         * Constructs a new PlayedReceipt.
         * @memberof server
         * @classdesc Represents a PlayedReceipt.
         * @implements IPlayedReceipt
         * @constructor
         * @param {server.IPlayedReceipt=} [properties] Properties to set
         */
        function PlayedReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayedReceipt id.
         * @member {string} id
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.id = "";

        /**
         * PlayedReceipt threadId.
         * @member {string} threadId
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.threadId = "";

        /**
         * PlayedReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PlayedReceipt instance using the specified properties.
         * @function create
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt=} [properties] Properties to set
         * @returns {server.PlayedReceipt} PlayedReceipt instance
         */
        PlayedReceipt.create = function create(properties) {
            return new PlayedReceipt(properties);
        };

        /**
         * Encodes the specified PlayedReceipt message. Does not implicitly {@link server.PlayedReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt} message PlayedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayedReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PlayedReceipt message, length delimited. Does not implicitly {@link server.PlayedReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt} message PlayedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayedReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayedReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.PlayedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PlayedReceipt} PlayedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayedReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PlayedReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayedReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PlayedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PlayedReceipt} PlayedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayedReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayedReceipt message.
         * @function verify
         * @memberof server.PlayedReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayedReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PlayedReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PlayedReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PlayedReceipt} PlayedReceipt
         */
        PlayedReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PlayedReceipt)
                return object;
            var message = new $root.server.PlayedReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PlayedReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.PlayedReceipt} message PlayedReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayedReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PlayedReceipt to JSON.
         * @function toJSON
         * @memberof server.PlayedReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayedReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayedReceipt;
    })();

    server.ScreenshotReceipt = (function() {

        /**
         * Properties of a ScreenshotReceipt.
         * @memberof server
         * @interface IScreenshotReceipt
         * @property {string|null} [id] ScreenshotReceipt id
         * @property {string|null} [threadId] ScreenshotReceipt threadId
         * @property {number|Long|null} [timestamp] ScreenshotReceipt timestamp
         */

        /**
         * Constructs a new ScreenshotReceipt.
         * @memberof server
         * @classdesc Represents a ScreenshotReceipt.
         * @implements IScreenshotReceipt
         * @constructor
         * @param {server.IScreenshotReceipt=} [properties] Properties to set
         */
        function ScreenshotReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScreenshotReceipt id.
         * @member {string} id
         * @memberof server.ScreenshotReceipt
         * @instance
         */
        ScreenshotReceipt.prototype.id = "";

        /**
         * ScreenshotReceipt threadId.
         * @member {string} threadId
         * @memberof server.ScreenshotReceipt
         * @instance
         */
        ScreenshotReceipt.prototype.threadId = "";

        /**
         * ScreenshotReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.ScreenshotReceipt
         * @instance
         */
        ScreenshotReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ScreenshotReceipt instance using the specified properties.
         * @function create
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {server.IScreenshotReceipt=} [properties] Properties to set
         * @returns {server.ScreenshotReceipt} ScreenshotReceipt instance
         */
        ScreenshotReceipt.create = function create(properties) {
            return new ScreenshotReceipt(properties);
        };

        /**
         * Encodes the specified ScreenshotReceipt message. Does not implicitly {@link server.ScreenshotReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {server.IScreenshotReceipt} message ScreenshotReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenshotReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified ScreenshotReceipt message, length delimited. Does not implicitly {@link server.ScreenshotReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {server.IScreenshotReceipt} message ScreenshotReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScreenshotReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScreenshotReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ScreenshotReceipt} ScreenshotReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenshotReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ScreenshotReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScreenshotReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ScreenshotReceipt} ScreenshotReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScreenshotReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScreenshotReceipt message.
         * @function verify
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScreenshotReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a ScreenshotReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ScreenshotReceipt} ScreenshotReceipt
         */
        ScreenshotReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ScreenshotReceipt)
                return object;
            var message = new $root.server.ScreenshotReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ScreenshotReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ScreenshotReceipt
         * @static
         * @param {server.ScreenshotReceipt} message ScreenshotReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScreenshotReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this ScreenshotReceipt to JSON.
         * @function toJSON
         * @memberof server.ScreenshotReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScreenshotReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScreenshotReceipt;
    })();

    server.SavedReceipt = (function() {

        /**
         * Properties of a SavedReceipt.
         * @memberof server
         * @interface ISavedReceipt
         * @property {string|null} [id] SavedReceipt id
         * @property {string|null} [threadId] SavedReceipt threadId
         * @property {number|Long|null} [timestamp] SavedReceipt timestamp
         */

        /**
         * Constructs a new SavedReceipt.
         * @memberof server
         * @classdesc Represents a SavedReceipt.
         * @implements ISavedReceipt
         * @constructor
         * @param {server.ISavedReceipt=} [properties] Properties to set
         */
        function SavedReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SavedReceipt id.
         * @member {string} id
         * @memberof server.SavedReceipt
         * @instance
         */
        SavedReceipt.prototype.id = "";

        /**
         * SavedReceipt threadId.
         * @member {string} threadId
         * @memberof server.SavedReceipt
         * @instance
         */
        SavedReceipt.prototype.threadId = "";

        /**
         * SavedReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.SavedReceipt
         * @instance
         */
        SavedReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SavedReceipt instance using the specified properties.
         * @function create
         * @memberof server.SavedReceipt
         * @static
         * @param {server.ISavedReceipt=} [properties] Properties to set
         * @returns {server.SavedReceipt} SavedReceipt instance
         */
        SavedReceipt.create = function create(properties) {
            return new SavedReceipt(properties);
        };

        /**
         * Encodes the specified SavedReceipt message. Does not implicitly {@link server.SavedReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.SavedReceipt
         * @static
         * @param {server.ISavedReceipt} message SavedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SavedReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified SavedReceipt message, length delimited. Does not implicitly {@link server.SavedReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SavedReceipt
         * @static
         * @param {server.ISavedReceipt} message SavedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SavedReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SavedReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.SavedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SavedReceipt} SavedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SavedReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SavedReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SavedReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SavedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SavedReceipt} SavedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SavedReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SavedReceipt message.
         * @function verify
         * @memberof server.SavedReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SavedReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a SavedReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SavedReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SavedReceipt} SavedReceipt
         */
        SavedReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SavedReceipt)
                return object;
            var message = new $root.server.SavedReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SavedReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SavedReceipt
         * @static
         * @param {server.SavedReceipt} message SavedReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SavedReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this SavedReceipt to JSON.
         * @function toJSON
         * @memberof server.SavedReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SavedReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SavedReceipt;
    })();

    server.GroupChatRetract = (function() {

        /**
         * Properties of a GroupChatRetract.
         * @memberof server
         * @interface IGroupChatRetract
         * @property {string|null} [id] GroupChatRetract id
         * @property {string|null} [gid] GroupChatRetract gid
         */

        /**
         * Constructs a new GroupChatRetract.
         * @memberof server
         * @classdesc Represents a GroupChatRetract.
         * @implements IGroupChatRetract
         * @constructor
         * @param {server.IGroupChatRetract=} [properties] Properties to set
         */
        function GroupChatRetract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChatRetract id.
         * @member {string} id
         * @memberof server.GroupChatRetract
         * @instance
         */
        GroupChatRetract.prototype.id = "";

        /**
         * GroupChatRetract gid.
         * @member {string} gid
         * @memberof server.GroupChatRetract
         * @instance
         */
        GroupChatRetract.prototype.gid = "";

        /**
         * Creates a new GroupChatRetract instance using the specified properties.
         * @function create
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract=} [properties] Properties to set
         * @returns {server.GroupChatRetract} GroupChatRetract instance
         */
        GroupChatRetract.create = function create(properties) {
            return new GroupChatRetract(properties);
        };

        /**
         * Encodes the specified GroupChatRetract message. Does not implicitly {@link server.GroupChatRetract.verify|verify} messages.
         * @function encode
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract} message GroupChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatRetract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            return writer;
        };

        /**
         * Encodes the specified GroupChatRetract message, length delimited. Does not implicitly {@link server.GroupChatRetract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract} message GroupChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatRetract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChatRetract message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupChatRetract} GroupChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatRetract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupChatRetract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChatRetract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupChatRetract} GroupChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatRetract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupChatRetract message.
         * @function verify
         * @memberof server.GroupChatRetract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupChatRetract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            return null;
        };

        /**
         * Creates a GroupChatRetract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupChatRetract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupChatRetract} GroupChatRetract
         */
        GroupChatRetract.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupChatRetract)
                return object;
            var message = new $root.server.GroupChatRetract();
            if (object.id != null)
                message.id = String(object.id);
            if (object.gid != null)
                message.gid = String(object.gid);
            return message;
        };

        /**
         * Creates a plain object from a GroupChatRetract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.GroupChatRetract} message GroupChatRetract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChatRetract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.gid = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            return object;
        };

        /**
         * Converts this GroupChatRetract to JSON.
         * @function toJSON
         * @memberof server.GroupChatRetract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChatRetract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupChatRetract;
    })();

    server.ChatRetract = (function() {

        /**
         * Properties of a ChatRetract.
         * @memberof server
         * @interface IChatRetract
         * @property {string|null} [id] ChatRetract id
         */

        /**
         * Constructs a new ChatRetract.
         * @memberof server
         * @classdesc Represents a ChatRetract.
         * @implements IChatRetract
         * @constructor
         * @param {server.IChatRetract=} [properties] Properties to set
         */
        function ChatRetract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatRetract id.
         * @member {string} id
         * @memberof server.ChatRetract
         * @instance
         */
        ChatRetract.prototype.id = "";

        /**
         * Creates a new ChatRetract instance using the specified properties.
         * @function create
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract=} [properties] Properties to set
         * @returns {server.ChatRetract} ChatRetract instance
         */
        ChatRetract.create = function create(properties) {
            return new ChatRetract(properties);
        };

        /**
         * Encodes the specified ChatRetract message. Does not implicitly {@link server.ChatRetract.verify|verify} messages.
         * @function encode
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract} message ChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRetract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ChatRetract message, length delimited. Does not implicitly {@link server.ChatRetract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract} message ChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRetract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatRetract message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatRetract} ChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRetract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatRetract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatRetract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatRetract} ChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRetract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatRetract message.
         * @function verify
         * @memberof server.ChatRetract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatRetract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ChatRetract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatRetract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatRetract} ChatRetract
         */
        ChatRetract.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatRetract)
                return object;
            var message = new $root.server.ChatRetract();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ChatRetract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatRetract
         * @static
         * @param {server.ChatRetract} message ChatRetract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatRetract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ChatRetract to JSON.
         * @function toJSON
         * @memberof server.ChatRetract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatRetract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatRetract;
    })();

    server.Prop = (function() {

        /**
         * Properties of a Prop.
         * @memberof server
         * @interface IProp
         * @property {string|null} [name] Prop name
         * @property {string|null} [value] Prop value
         */

        /**
         * Constructs a new Prop.
         * @memberof server
         * @classdesc Represents a Prop.
         * @implements IProp
         * @constructor
         * @param {server.IProp=} [properties] Properties to set
         */
        function Prop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Prop name.
         * @member {string} name
         * @memberof server.Prop
         * @instance
         */
        Prop.prototype.name = "";

        /**
         * Prop value.
         * @member {string} value
         * @memberof server.Prop
         * @instance
         */
        Prop.prototype.value = "";

        /**
         * Creates a new Prop instance using the specified properties.
         * @function create
         * @memberof server.Prop
         * @static
         * @param {server.IProp=} [properties] Properties to set
         * @returns {server.Prop} Prop instance
         */
        Prop.create = function create(properties) {
            return new Prop(properties);
        };

        /**
         * Encodes the specified Prop message. Does not implicitly {@link server.Prop.verify|verify} messages.
         * @function encode
         * @memberof server.Prop
         * @static
         * @param {server.IProp} message Prop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Prop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Prop message, length delimited. Does not implicitly {@link server.Prop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Prop
         * @static
         * @param {server.IProp} message Prop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Prop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Prop message from the specified reader or buffer.
         * @function decode
         * @memberof server.Prop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Prop} Prop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Prop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Prop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Prop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Prop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Prop} Prop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Prop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Prop message.
         * @function verify
         * @memberof server.Prop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Prop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Prop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Prop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Prop} Prop
         */
        Prop.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Prop)
                return object;
            var message = new $root.server.Prop();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Prop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Prop
         * @static
         * @param {server.Prop} message Prop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Prop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Prop to JSON.
         * @function toJSON
         * @memberof server.Prop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Prop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Prop;
    })();

    server.Props = (function() {

        /**
         * Properties of a Props.
         * @memberof server
         * @interface IProps
         * @property {Uint8Array|null} [hash] Props hash
         * @property {Array.<server.IProp>|null} [props] Props props
         */

        /**
         * Constructs a new Props.
         * @memberof server
         * @classdesc Represents a Props.
         * @implements IProps
         * @constructor
         * @param {server.IProps=} [properties] Properties to set
         */
        function Props(properties) {
            this.props = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Props hash.
         * @member {Uint8Array} hash
         * @memberof server.Props
         * @instance
         */
        Props.prototype.hash = $util.newBuffer([]);

        /**
         * Props props.
         * @member {Array.<server.IProp>} props
         * @memberof server.Props
         * @instance
         */
        Props.prototype.props = $util.emptyArray;

        /**
         * Creates a new Props instance using the specified properties.
         * @function create
         * @memberof server.Props
         * @static
         * @param {server.IProps=} [properties] Properties to set
         * @returns {server.Props} Props instance
         */
        Props.create = function create(properties) {
            return new Props(properties);
        };

        /**
         * Encodes the specified Props message. Does not implicitly {@link server.Props.verify|verify} messages.
         * @function encode
         * @memberof server.Props
         * @static
         * @param {server.IProps} message Props message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Props.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.props != null && message.props.length)
                for (var i = 0; i < message.props.length; ++i)
                    $root.server.Prop.encode(message.props[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Props message, length delimited. Does not implicitly {@link server.Props.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Props
         * @static
         * @param {server.IProps} message Props message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Props.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Props message from the specified reader or buffer.
         * @function decode
         * @memberof server.Props
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Props} Props
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Props.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Props();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.server.Prop.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Props message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Props
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Props} Props
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Props.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Props message.
         * @function verify
         * @memberof server.Props
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Props.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.props != null && message.hasOwnProperty("props")) {
                if (!Array.isArray(message.props))
                    return "props: array expected";
                for (var i = 0; i < message.props.length; ++i) {
                    var error = $root.server.Prop.verify(message.props[i]);
                    if (error)
                        return "props." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Props message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Props
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Props} Props
         */
        Props.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Props)
                return object;
            var message = new $root.server.Props();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.props) {
                if (!Array.isArray(object.props))
                    throw TypeError(".server.Props.props: array expected");
                message.props = [];
                for (var i = 0; i < object.props.length; ++i) {
                    if (typeof object.props[i] !== "object")
                        throw TypeError(".server.Props.props: object expected");
                    message.props[i] = $root.server.Prop.fromObject(object.props[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Props message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Props
         * @static
         * @param {server.Props} message Props
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Props.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.props = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.props && message.props.length) {
                object.props = [];
                for (var j = 0; j < message.props.length; ++j)
                    object.props[j] = $root.server.Prop.toObject(message.props[j], options);
            }
            return object;
        };

        /**
         * Converts this Props to JSON.
         * @function toJSON
         * @memberof server.Props
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Props.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Props;
    })();

    server.WhisperKeys = (function() {

        /**
         * Properties of a WhisperKeys.
         * @memberof server
         * @interface IWhisperKeys
         * @property {number|Long|null} [uid] WhisperKeys uid
         * @property {server.WhisperKeys.Action|null} [action] WhisperKeys action
         * @property {Uint8Array|null} [identityKey] WhisperKeys identityKey
         * @property {Uint8Array|null} [signedKey] WhisperKeys signedKey
         * @property {number|null} [otpKeyCount] WhisperKeys otpKeyCount
         * @property {Array.<Uint8Array>|null} [oneTimeKeys] WhisperKeys oneTimeKeys
         */

        /**
         * Constructs a new WhisperKeys.
         * @memberof server
         * @classdesc Represents a WhisperKeys.
         * @implements IWhisperKeys
         * @constructor
         * @param {server.IWhisperKeys=} [properties] Properties to set
         */
        function WhisperKeys(properties) {
            this.oneTimeKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperKeys uid.
         * @member {number|Long} uid
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WhisperKeys action.
         * @member {server.WhisperKeys.Action} action
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.action = 0;

        /**
         * WhisperKeys identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.identityKey = $util.newBuffer([]);

        /**
         * WhisperKeys signedKey.
         * @member {Uint8Array} signedKey
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.signedKey = $util.newBuffer([]);

        /**
         * WhisperKeys otpKeyCount.
         * @member {number} otpKeyCount
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.otpKeyCount = 0;

        /**
         * WhisperKeys oneTimeKeys.
         * @member {Array.<Uint8Array>} oneTimeKeys
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.oneTimeKeys = $util.emptyArray;

        /**
         * Creates a new WhisperKeys instance using the specified properties.
         * @function create
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys=} [properties] Properties to set
         * @returns {server.WhisperKeys} WhisperKeys instance
         */
        WhisperKeys.create = function create(properties) {
            return new WhisperKeys(properties);
        };

        /**
         * Encodes the specified WhisperKeys message. Does not implicitly {@link server.WhisperKeys.verify|verify} messages.
         * @function encode
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys} message WhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identityKey);
            if (message.signedKey != null && Object.hasOwnProperty.call(message, "signedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signedKey);
            if (message.otpKeyCount != null && Object.hasOwnProperty.call(message, "otpKeyCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.otpKeyCount);
            if (message.oneTimeKeys != null && message.oneTimeKeys.length)
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.oneTimeKeys[i]);
            return writer;
        };

        /**
         * Encodes the specified WhisperKeys message, length delimited. Does not implicitly {@link server.WhisperKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys} message WhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperKeys message from the specified reader or buffer.
         * @function decode
         * @memberof server.WhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WhisperKeys} WhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WhisperKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.action = reader.int32();
                    break;
                case 3:
                    message.identityKey = reader.bytes();
                    break;
                case 4:
                    message.signedKey = reader.bytes();
                    break;
                case 5:
                    message.otpKeyCount = reader.int32();
                    break;
                case 6:
                    if (!(message.oneTimeKeys && message.oneTimeKeys.length))
                        message.oneTimeKeys = [];
                    message.oneTimeKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WhisperKeys} WhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperKeys message.
         * @function verify
         * @memberof server.WhisperKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                if (!(message.signedKey && typeof message.signedKey.length === "number" || $util.isString(message.signedKey)))
                    return "signedKey: buffer expected";
            if (message.otpKeyCount != null && message.hasOwnProperty("otpKeyCount"))
                if (!$util.isInteger(message.otpKeyCount))
                    return "otpKeyCount: integer expected";
            if (message.oneTimeKeys != null && message.hasOwnProperty("oneTimeKeys")) {
                if (!Array.isArray(message.oneTimeKeys))
                    return "oneTimeKeys: array expected";
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    if (!(message.oneTimeKeys[i] && typeof message.oneTimeKeys[i].length === "number" || $util.isString(message.oneTimeKeys[i])))
                        return "oneTimeKeys: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a WhisperKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WhisperKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WhisperKeys} WhisperKeys
         */
        WhisperKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WhisperKeys)
                return object;
            var message = new $root.server.WhisperKeys();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            switch (object.action) {
            case "NORMAL":
            case 0:
                message.action = 0;
                break;
            case "ADD":
            case 1:
                message.action = 1;
                break;
            case "COUNT":
            case 2:
                message.action = 2;
                break;
            case "GET":
            case 3:
                message.action = 3;
                break;
            case "SET":
            case 4:
                message.action = 4;
                break;
            case "UPDATE":
            case 5:
                message.action = 5;
                break;
            }
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedKey != null)
                if (typeof object.signedKey === "string")
                    $util.base64.decode(object.signedKey, message.signedKey = $util.newBuffer($util.base64.length(object.signedKey)), 0);
                else if (object.signedKey.length)
                    message.signedKey = object.signedKey;
            if (object.otpKeyCount != null)
                message.otpKeyCount = object.otpKeyCount | 0;
            if (object.oneTimeKeys) {
                if (!Array.isArray(object.oneTimeKeys))
                    throw TypeError(".server.WhisperKeys.oneTimeKeys: array expected");
                message.oneTimeKeys = [];
                for (var i = 0; i < object.oneTimeKeys.length; ++i)
                    if (typeof object.oneTimeKeys[i] === "string")
                        $util.base64.decode(object.oneTimeKeys[i], message.oneTimeKeys[i] = $util.newBuffer($util.base64.length(object.oneTimeKeys[i])), 0);
                    else if (object.oneTimeKeys[i].length)
                        message.oneTimeKeys[i] = object.oneTimeKeys[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a WhisperKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WhisperKeys
         * @static
         * @param {server.WhisperKeys} message WhisperKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.oneTimeKeys = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.action = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.signedKey = "";
                else {
                    object.signedKey = [];
                    if (options.bytes !== Array)
                        object.signedKey = $util.newBuffer(object.signedKey);
                }
                object.otpKeyCount = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.WhisperKeys.Action[message.action] : message.action;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                object.signedKey = options.bytes === String ? $util.base64.encode(message.signedKey, 0, message.signedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedKey) : message.signedKey;
            if (message.otpKeyCount != null && message.hasOwnProperty("otpKeyCount"))
                object.otpKeyCount = message.otpKeyCount;
            if (message.oneTimeKeys && message.oneTimeKeys.length) {
                object.oneTimeKeys = [];
                for (var j = 0; j < message.oneTimeKeys.length; ++j)
                    object.oneTimeKeys[j] = options.bytes === String ? $util.base64.encode(message.oneTimeKeys[j], 0, message.oneTimeKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.oneTimeKeys[j]) : message.oneTimeKeys[j];
            }
            return object;
        };

        /**
         * Converts this WhisperKeys to JSON.
         * @function toJSON
         * @memberof server.WhisperKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.WhisperKeys.Action
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} ADD=1 ADD value
         * @property {number} COUNT=2 COUNT value
         * @property {number} GET=3 GET value
         * @property {number} SET=4 SET value
         * @property {number} UPDATE=5 UPDATE value
         */
        WhisperKeys.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "ADD"] = 1;
            values[valuesById[2] = "COUNT"] = 2;
            values[valuesById[3] = "GET"] = 3;
            values[valuesById[4] = "SET"] = 4;
            values[valuesById[5] = "UPDATE"] = 5;
            return values;
        })();

        return WhisperKeys;
    })();

    server.TruncWhisperKeys = (function() {

        /**
         * Properties of a TruncWhisperKeys.
         * @memberof server
         * @interface ITruncWhisperKeys
         * @property {number|Long|null} [uid] TruncWhisperKeys uid
         * @property {Uint8Array|null} [truncPublicIdentityKey] TruncWhisperKeys truncPublicIdentityKey
         */

        /**
         * Constructs a new TruncWhisperKeys.
         * @memberof server
         * @classdesc Represents a TruncWhisperKeys.
         * @implements ITruncWhisperKeys
         * @constructor
         * @param {server.ITruncWhisperKeys=} [properties] Properties to set
         */
        function TruncWhisperKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TruncWhisperKeys uid.
         * @member {number|Long} uid
         * @memberof server.TruncWhisperKeys
         * @instance
         */
        TruncWhisperKeys.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TruncWhisperKeys truncPublicIdentityKey.
         * @member {Uint8Array} truncPublicIdentityKey
         * @memberof server.TruncWhisperKeys
         * @instance
         */
        TruncWhisperKeys.prototype.truncPublicIdentityKey = $util.newBuffer([]);

        /**
         * Creates a new TruncWhisperKeys instance using the specified properties.
         * @function create
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys=} [properties] Properties to set
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys instance
         */
        TruncWhisperKeys.create = function create(properties) {
            return new TruncWhisperKeys(properties);
        };

        /**
         * Encodes the specified TruncWhisperKeys message. Does not implicitly {@link server.TruncWhisperKeys.verify|verify} messages.
         * @function encode
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys} message TruncWhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.truncPublicIdentityKey != null && Object.hasOwnProperty.call(message, "truncPublicIdentityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.truncPublicIdentityKey);
            return writer;
        };

        /**
         * Encodes the specified TruncWhisperKeys message, length delimited. Does not implicitly {@link server.TruncWhisperKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys} message TruncWhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TruncWhisperKeys message from the specified reader or buffer.
         * @function decode
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TruncWhisperKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.truncPublicIdentityKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TruncWhisperKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TruncWhisperKeys message.
         * @function verify
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TruncWhisperKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.truncPublicIdentityKey != null && message.hasOwnProperty("truncPublicIdentityKey"))
                if (!(message.truncPublicIdentityKey && typeof message.truncPublicIdentityKey.length === "number" || $util.isString(message.truncPublicIdentityKey)))
                    return "truncPublicIdentityKey: buffer expected";
            return null;
        };

        /**
         * Creates a TruncWhisperKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         */
        TruncWhisperKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TruncWhisperKeys)
                return object;
            var message = new $root.server.TruncWhisperKeys();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.truncPublicIdentityKey != null)
                if (typeof object.truncPublicIdentityKey === "string")
                    $util.base64.decode(object.truncPublicIdentityKey, message.truncPublicIdentityKey = $util.newBuffer($util.base64.length(object.truncPublicIdentityKey)), 0);
                else if (object.truncPublicIdentityKey.length)
                    message.truncPublicIdentityKey = object.truncPublicIdentityKey;
            return message;
        };

        /**
         * Creates a plain object from a TruncWhisperKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.TruncWhisperKeys} message TruncWhisperKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TruncWhisperKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.truncPublicIdentityKey = "";
                else {
                    object.truncPublicIdentityKey = [];
                    if (options.bytes !== Array)
                        object.truncPublicIdentityKey = $util.newBuffer(object.truncPublicIdentityKey);
                }
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.truncPublicIdentityKey != null && message.hasOwnProperty("truncPublicIdentityKey"))
                object.truncPublicIdentityKey = options.bytes === String ? $util.base64.encode(message.truncPublicIdentityKey, 0, message.truncPublicIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.truncPublicIdentityKey) : message.truncPublicIdentityKey;
            return object;
        };

        /**
         * Converts this TruncWhisperKeys to JSON.
         * @function toJSON
         * @memberof server.TruncWhisperKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TruncWhisperKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TruncWhisperKeys;
    })();

    server.WhisperKeysCollection = (function() {

        /**
         * Properties of a WhisperKeysCollection.
         * @memberof server
         * @interface IWhisperKeysCollection
         * @property {Array.<server.IWhisperKeys>|null} [collection] WhisperKeysCollection collection
         */

        /**
         * Constructs a new WhisperKeysCollection.
         * @memberof server
         * @classdesc Represents a WhisperKeysCollection.
         * @implements IWhisperKeysCollection
         * @constructor
         * @param {server.IWhisperKeysCollection=} [properties] Properties to set
         */
        function WhisperKeysCollection(properties) {
            this.collection = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperKeysCollection collection.
         * @member {Array.<server.IWhisperKeys>} collection
         * @memberof server.WhisperKeysCollection
         * @instance
         */
        WhisperKeysCollection.prototype.collection = $util.emptyArray;

        /**
         * Creates a new WhisperKeysCollection instance using the specified properties.
         * @function create
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection=} [properties] Properties to set
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection instance
         */
        WhisperKeysCollection.create = function create(properties) {
            return new WhisperKeysCollection(properties);
        };

        /**
         * Encodes the specified WhisperKeysCollection message. Does not implicitly {@link server.WhisperKeysCollection.verify|verify} messages.
         * @function encode
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection} message WhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeysCollection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.collection != null && message.collection.length)
                for (var i = 0; i < message.collection.length; ++i)
                    $root.server.WhisperKeys.encode(message.collection[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WhisperKeysCollection message, length delimited. Does not implicitly {@link server.WhisperKeysCollection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection} message WhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeysCollection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperKeysCollection message from the specified reader or buffer.
         * @function decode
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeysCollection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WhisperKeysCollection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.collection && message.collection.length))
                        message.collection = [];
                    message.collection.push($root.server.WhisperKeys.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperKeysCollection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeysCollection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperKeysCollection message.
         * @function verify
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperKeysCollection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.collection != null && message.hasOwnProperty("collection")) {
                if (!Array.isArray(message.collection))
                    return "collection: array expected";
                for (var i = 0; i < message.collection.length; ++i) {
                    var error = $root.server.WhisperKeys.verify(message.collection[i]);
                    if (error)
                        return "collection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WhisperKeysCollection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         */
        WhisperKeysCollection.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WhisperKeysCollection)
                return object;
            var message = new $root.server.WhisperKeysCollection();
            if (object.collection) {
                if (!Array.isArray(object.collection))
                    throw TypeError(".server.WhisperKeysCollection.collection: array expected");
                message.collection = [];
                for (var i = 0; i < object.collection.length; ++i) {
                    if (typeof object.collection[i] !== "object")
                        throw TypeError(".server.WhisperKeysCollection.collection: object expected");
                    message.collection[i] = $root.server.WhisperKeys.fromObject(object.collection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WhisperKeysCollection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.WhisperKeysCollection} message WhisperKeysCollection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperKeysCollection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.collection = [];
            if (message.collection && message.collection.length) {
                object.collection = [];
                for (var j = 0; j < message.collection.length; ++j)
                    object.collection[j] = $root.server.WhisperKeys.toObject(message.collection[j], options);
            }
            return object;
        };

        /**
         * Converts this WhisperKeysCollection to JSON.
         * @function toJSON
         * @memberof server.WhisperKeysCollection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperKeysCollection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WhisperKeysCollection;
    })();

    server.TruncWhisperKeysCollection = (function() {

        /**
         * Properties of a TruncWhisperKeysCollection.
         * @memberof server
         * @interface ITruncWhisperKeysCollection
         * @property {Array.<server.ITruncWhisperKeys>|null} [collection] TruncWhisperKeysCollection collection
         */

        /**
         * Constructs a new TruncWhisperKeysCollection.
         * @memberof server
         * @classdesc Represents a TruncWhisperKeysCollection.
         * @implements ITruncWhisperKeysCollection
         * @constructor
         * @param {server.ITruncWhisperKeysCollection=} [properties] Properties to set
         */
        function TruncWhisperKeysCollection(properties) {
            this.collection = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TruncWhisperKeysCollection collection.
         * @member {Array.<server.ITruncWhisperKeys>} collection
         * @memberof server.TruncWhisperKeysCollection
         * @instance
         */
        TruncWhisperKeysCollection.prototype.collection = $util.emptyArray;

        /**
         * Creates a new TruncWhisperKeysCollection instance using the specified properties.
         * @function create
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection=} [properties] Properties to set
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection instance
         */
        TruncWhisperKeysCollection.create = function create(properties) {
            return new TruncWhisperKeysCollection(properties);
        };

        /**
         * Encodes the specified TruncWhisperKeysCollection message. Does not implicitly {@link server.TruncWhisperKeysCollection.verify|verify} messages.
         * @function encode
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection} message TruncWhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeysCollection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.collection != null && message.collection.length)
                for (var i = 0; i < message.collection.length; ++i)
                    $root.server.TruncWhisperKeys.encode(message.collection[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TruncWhisperKeysCollection message, length delimited. Does not implicitly {@link server.TruncWhisperKeysCollection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection} message TruncWhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeysCollection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TruncWhisperKeysCollection message from the specified reader or buffer.
         * @function decode
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeysCollection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TruncWhisperKeysCollection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.collection && message.collection.length))
                        message.collection = [];
                    message.collection.push($root.server.TruncWhisperKeys.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TruncWhisperKeysCollection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeysCollection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TruncWhisperKeysCollection message.
         * @function verify
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TruncWhisperKeysCollection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.collection != null && message.hasOwnProperty("collection")) {
                if (!Array.isArray(message.collection))
                    return "collection: array expected";
                for (var i = 0; i < message.collection.length; ++i) {
                    var error = $root.server.TruncWhisperKeys.verify(message.collection[i]);
                    if (error)
                        return "collection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TruncWhisperKeysCollection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         */
        TruncWhisperKeysCollection.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TruncWhisperKeysCollection)
                return object;
            var message = new $root.server.TruncWhisperKeysCollection();
            if (object.collection) {
                if (!Array.isArray(object.collection))
                    throw TypeError(".server.TruncWhisperKeysCollection.collection: array expected");
                message.collection = [];
                for (var i = 0; i < object.collection.length; ++i) {
                    if (typeof object.collection[i] !== "object")
                        throw TypeError(".server.TruncWhisperKeysCollection.collection: object expected");
                    message.collection[i] = $root.server.TruncWhisperKeys.fromObject(object.collection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TruncWhisperKeysCollection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.TruncWhisperKeysCollection} message TruncWhisperKeysCollection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TruncWhisperKeysCollection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.collection = [];
            if (message.collection && message.collection.length) {
                object.collection = [];
                for (var j = 0; j < message.collection.length; ++j)
                    object.collection[j] = $root.server.TruncWhisperKeys.toObject(message.collection[j], options);
            }
            return object;
        };

        /**
         * Converts this TruncWhisperKeysCollection to JSON.
         * @function toJSON
         * @memberof server.TruncWhisperKeysCollection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TruncWhisperKeysCollection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TruncWhisperKeysCollection;
    })();

    server.NoiseMessage = (function() {

        /**
         * Properties of a NoiseMessage.
         * @memberof server
         * @interface INoiseMessage
         * @property {server.NoiseMessage.MessageType|null} [messageType] NoiseMessage messageType
         * @property {Uint8Array|null} [content] NoiseMessage content
         */

        /**
         * Constructs a new NoiseMessage.
         * @memberof server
         * @classdesc Represents a NoiseMessage.
         * @implements INoiseMessage
         * @constructor
         * @param {server.INoiseMessage=} [properties] Properties to set
         */
        function NoiseMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoiseMessage messageType.
         * @member {server.NoiseMessage.MessageType} messageType
         * @memberof server.NoiseMessage
         * @instance
         */
        NoiseMessage.prototype.messageType = 0;

        /**
         * NoiseMessage content.
         * @member {Uint8Array} content
         * @memberof server.NoiseMessage
         * @instance
         */
        NoiseMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new NoiseMessage instance using the specified properties.
         * @function create
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage=} [properties] Properties to set
         * @returns {server.NoiseMessage} NoiseMessage instance
         */
        NoiseMessage.create = function create(properties) {
            return new NoiseMessage(properties);
        };

        /**
         * Encodes the specified NoiseMessage message. Does not implicitly {@link server.NoiseMessage.verify|verify} messages.
         * @function encode
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage} message NoiseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && Object.hasOwnProperty.call(message, "messageType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified NoiseMessage message, length delimited. Does not implicitly {@link server.NoiseMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage} message NoiseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoiseMessage message from the specified reader or buffer.
         * @function decode
         * @memberof server.NoiseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.NoiseMessage} NoiseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.NoiseMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.int32();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoiseMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.NoiseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.NoiseMessage} NoiseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoiseMessage message.
         * @function verify
         * @memberof server.NoiseMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoiseMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                switch (message.messageType) {
                default:
                    return "messageType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a NoiseMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.NoiseMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.NoiseMessage} NoiseMessage
         */
        NoiseMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.server.NoiseMessage)
                return object;
            var message = new $root.server.NoiseMessage();
            switch (object.messageType) {
            case "XX_A":
            case 0:
                message.messageType = 0;
                break;
            case "XX_B":
            case 1:
                message.messageType = 1;
                break;
            case "XX_C":
            case 2:
                message.messageType = 2;
                break;
            case "IK_A":
            case 3:
                message.messageType = 3;
                break;
            case "IK_B":
            case 4:
                message.messageType = 4;
                break;
            case "XX_FALLBACK_A":
            case 5:
                message.messageType = 5;
                break;
            case "XX_FALLBACK_B":
            case 6:
                message.messageType = 6;
                break;
            case "KK_A":
            case 7:
                message.messageType = 7;
                break;
            case "KK_B":
            case 8:
                message.messageType = 8;
                break;
            }
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a NoiseMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.NoiseMessage
         * @static
         * @param {server.NoiseMessage} message NoiseMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoiseMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.messageType = options.enums === String ? "XX_A" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = options.enums === String ? $root.server.NoiseMessage.MessageType[message.messageType] : message.messageType;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this NoiseMessage to JSON.
         * @function toJSON
         * @memberof server.NoiseMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoiseMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * MessageType enum.
         * @name server.NoiseMessage.MessageType
         * @enum {number}
         * @property {number} XX_A=0 XX_A value
         * @property {number} XX_B=1 XX_B value
         * @property {number} XX_C=2 XX_C value
         * @property {number} IK_A=3 IK_A value
         * @property {number} IK_B=4 IK_B value
         * @property {number} XX_FALLBACK_A=5 XX_FALLBACK_A value
         * @property {number} XX_FALLBACK_B=6 XX_FALLBACK_B value
         * @property {number} KK_A=7 KK_A value
         * @property {number} KK_B=8 KK_B value
         */
        NoiseMessage.MessageType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "XX_A"] = 0;
            values[valuesById[1] = "XX_B"] = 1;
            values[valuesById[2] = "XX_C"] = 2;
            values[valuesById[3] = "IK_A"] = 3;
            values[valuesById[4] = "IK_B"] = 4;
            values[valuesById[5] = "XX_FALLBACK_A"] = 5;
            values[valuesById[6] = "XX_FALLBACK_B"] = 6;
            values[valuesById[7] = "KK_A"] = 7;
            values[valuesById[8] = "KK_B"] = 8;
            return values;
        })();

        return NoiseMessage;
    })();

    server.DeleteAccount = (function() {

        /**
         * Properties of a DeleteAccount.
         * @memberof server
         * @interface IDeleteAccount
         * @property {string|null} [phone] DeleteAccount phone
         * @property {server.DeleteAccount.Reason|null} [reason] DeleteAccount reason
         * @property {string|null} [feedback] DeleteAccount feedback
         */

        /**
         * Constructs a new DeleteAccount.
         * @memberof server
         * @classdesc Represents a DeleteAccount.
         * @implements IDeleteAccount
         * @constructor
         * @param {server.IDeleteAccount=} [properties] Properties to set
         */
        function DeleteAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteAccount phone.
         * @member {string} phone
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.phone = "";

        /**
         * DeleteAccount reason.
         * @member {server.DeleteAccount.Reason} reason
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.reason = 0;

        /**
         * DeleteAccount feedback.
         * @member {string} feedback
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.feedback = "";

        /**
         * Creates a new DeleteAccount instance using the specified properties.
         * @function create
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount=} [properties] Properties to set
         * @returns {server.DeleteAccount} DeleteAccount instance
         */
        DeleteAccount.create = function create(properties) {
            return new DeleteAccount(properties);
        };

        /**
         * Encodes the specified DeleteAccount message. Does not implicitly {@link server.DeleteAccount.verify|verify} messages.
         * @function encode
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount} message DeleteAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.feedback != null && Object.hasOwnProperty.call(message, "feedback"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.feedback);
            return writer;
        };

        /**
         * Encodes the specified DeleteAccount message, length delimited. Does not implicitly {@link server.DeleteAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount} message DeleteAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAccount message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeleteAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeleteAccount} DeleteAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeleteAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.feedback = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeleteAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeleteAccount} DeleteAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAccount message.
         * @function verify
         * @memberof server.DeleteAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                    break;
                }
            if (message.feedback != null && message.hasOwnProperty("feedback"))
                if (!$util.isString(message.feedback))
                    return "feedback: string expected";
            return null;
        };

        /**
         * Creates a DeleteAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeleteAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeleteAccount} DeleteAccount
         */
        DeleteAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeleteAccount)
                return object;
            var message = new $root.server.DeleteAccount();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.reason) {
            case "UNKNOWN_DELETE_REASON":
            case 0:
                message.reason = 0;
                break;
            }
            if (object.feedback != null)
                message.feedback = String(object.feedback);
            return message;
        };

        /**
         * Creates a plain object from a DeleteAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeleteAccount
         * @static
         * @param {server.DeleteAccount} message DeleteAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.reason = options.enums === String ? "UNKNOWN_DELETE_REASON" : 0;
                object.feedback = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.DeleteAccount.Reason[message.reason] : message.reason;
            if (message.feedback != null && message.hasOwnProperty("feedback"))
                object.feedback = message.feedback;
            return object;
        };

        /**
         * Converts this DeleteAccount to JSON.
         * @function toJSON
         * @memberof server.DeleteAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.DeleteAccount.Reason
         * @enum {number}
         * @property {number} UNKNOWN_DELETE_REASON=0 UNKNOWN_DELETE_REASON value
         */
        DeleteAccount.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DELETE_REASON"] = 0;
            return values;
        })();

        return DeleteAccount;
    })();

    server.ExportData = (function() {

        /**
         * Properties of an ExportData.
         * @memberof server
         * @interface IExportData
         * @property {number|Long|null} [dataReadyTs] ExportData dataReadyTs
         * @property {server.ExportData.Status|null} [status] ExportData status
         * @property {string|null} [dataUrl] ExportData dataUrl
         * @property {number|Long|null} [availableUntilTs] ExportData availableUntilTs
         */

        /**
         * Constructs a new ExportData.
         * @memberof server
         * @classdesc Represents an ExportData.
         * @implements IExportData
         * @constructor
         * @param {server.IExportData=} [properties] Properties to set
         */
        function ExportData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportData dataReadyTs.
         * @member {number|Long} dataReadyTs
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.dataReadyTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExportData status.
         * @member {server.ExportData.Status} status
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.status = 0;

        /**
         * ExportData dataUrl.
         * @member {string} dataUrl
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.dataUrl = "";

        /**
         * ExportData availableUntilTs.
         * @member {number|Long} availableUntilTs
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.availableUntilTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExportData instance using the specified properties.
         * @function create
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData=} [properties] Properties to set
         * @returns {server.ExportData} ExportData instance
         */
        ExportData.create = function create(properties) {
            return new ExportData(properties);
        };

        /**
         * Encodes the specified ExportData message. Does not implicitly {@link server.ExportData.verify|verify} messages.
         * @function encode
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData} message ExportData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dataReadyTs != null && Object.hasOwnProperty.call(message, "dataReadyTs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dataReadyTs);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.dataUrl != null && Object.hasOwnProperty.call(message, "dataUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.dataUrl);
            if (message.availableUntilTs != null && Object.hasOwnProperty.call(message, "availableUntilTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.availableUntilTs);
            return writer;
        };

        /**
         * Encodes the specified ExportData message, length delimited. Does not implicitly {@link server.ExportData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData} message ExportData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportData message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExportData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExportData} ExportData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExportData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dataReadyTs = reader.int64();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.dataUrl = reader.string();
                    break;
                case 4:
                    message.availableUntilTs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExportData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExportData} ExportData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportData message.
         * @function verify
         * @memberof server.ExportData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dataReadyTs != null && message.hasOwnProperty("dataReadyTs"))
                if (!$util.isInteger(message.dataReadyTs) && !(message.dataReadyTs && $util.isInteger(message.dataReadyTs.low) && $util.isInteger(message.dataReadyTs.high)))
                    return "dataReadyTs: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
                if (!$util.isString(message.dataUrl))
                    return "dataUrl: string expected";
            if (message.availableUntilTs != null && message.hasOwnProperty("availableUntilTs"))
                if (!$util.isInteger(message.availableUntilTs) && !(message.availableUntilTs && $util.isInteger(message.availableUntilTs.low) && $util.isInteger(message.availableUntilTs.high)))
                    return "availableUntilTs: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExportData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExportData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExportData} ExportData
         */
        ExportData.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExportData)
                return object;
            var message = new $root.server.ExportData();
            if (object.dataReadyTs != null)
                if ($util.Long)
                    (message.dataReadyTs = $util.Long.fromValue(object.dataReadyTs)).unsigned = false;
                else if (typeof object.dataReadyTs === "string")
                    message.dataReadyTs = parseInt(object.dataReadyTs, 10);
                else if (typeof object.dataReadyTs === "number")
                    message.dataReadyTs = object.dataReadyTs;
                else if (typeof object.dataReadyTs === "object")
                    message.dataReadyTs = new $util.LongBits(object.dataReadyTs.low >>> 0, object.dataReadyTs.high >>> 0).toNumber();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "PENDING":
            case 1:
                message.status = 1;
                break;
            case "READY":
            case 2:
                message.status = 2;
                break;
            case "NOT_STARTED":
            case 3:
                message.status = 3;
                break;
            }
            if (object.dataUrl != null)
                message.dataUrl = String(object.dataUrl);
            if (object.availableUntilTs != null)
                if ($util.Long)
                    (message.availableUntilTs = $util.Long.fromValue(object.availableUntilTs)).unsigned = false;
                else if (typeof object.availableUntilTs === "string")
                    message.availableUntilTs = parseInt(object.availableUntilTs, 10);
                else if (typeof object.availableUntilTs === "number")
                    message.availableUntilTs = object.availableUntilTs;
                else if (typeof object.availableUntilTs === "object")
                    message.availableUntilTs = new $util.LongBits(object.availableUntilTs.low >>> 0, object.availableUntilTs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExportData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExportData
         * @static
         * @param {server.ExportData} message ExportData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.dataReadyTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dataReadyTs = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.dataUrl = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.availableUntilTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.availableUntilTs = options.longs === String ? "0" : 0;
            }
            if (message.dataReadyTs != null && message.hasOwnProperty("dataReadyTs"))
                if (typeof message.dataReadyTs === "number")
                    object.dataReadyTs = options.longs === String ? String(message.dataReadyTs) : message.dataReadyTs;
                else
                    object.dataReadyTs = options.longs === String ? $util.Long.prototype.toString.call(message.dataReadyTs) : options.longs === Number ? new $util.LongBits(message.dataReadyTs.low >>> 0, message.dataReadyTs.high >>> 0).toNumber() : message.dataReadyTs;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.ExportData.Status[message.status] : message.status;
            if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
                object.dataUrl = message.dataUrl;
            if (message.availableUntilTs != null && message.hasOwnProperty("availableUntilTs"))
                if (typeof message.availableUntilTs === "number")
                    object.availableUntilTs = options.longs === String ? String(message.availableUntilTs) : message.availableUntilTs;
                else
                    object.availableUntilTs = options.longs === String ? $util.Long.prototype.toString.call(message.availableUntilTs) : options.longs === Number ? new $util.LongBits(message.availableUntilTs.low >>> 0, message.availableUntilTs.high >>> 0).toNumber() : message.availableUntilTs;
            return object;
        };

        /**
         * Converts this ExportData to JSON.
         * @function toJSON
         * @memberof server.ExportData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.ExportData.Status
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PENDING=1 PENDING value
         * @property {number} READY=2 READY value
         * @property {number} NOT_STARTED=3 NOT_STARTED value
         */
        ExportData.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "READY"] = 2;
            values[valuesById[3] = "NOT_STARTED"] = 3;
            return values;
        })();

        return ExportData;
    })();

    server.PushContent = (function() {

        /**
         * Properties of a PushContent.
         * @memberof server
         * @interface IPushContent
         * @property {Uint8Array|null} [certificate] PushContent certificate
         * @property {Uint8Array|null} [content] PushContent content
         */

        /**
         * Constructs a new PushContent.
         * @memberof server
         * @classdesc Represents a PushContent.
         * @implements IPushContent
         * @constructor
         * @param {server.IPushContent=} [properties] Properties to set
         */
        function PushContent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushContent certificate.
         * @member {Uint8Array} certificate
         * @memberof server.PushContent
         * @instance
         */
        PushContent.prototype.certificate = $util.newBuffer([]);

        /**
         * PushContent content.
         * @member {Uint8Array} content
         * @memberof server.PushContent
         * @instance
         */
        PushContent.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new PushContent instance using the specified properties.
         * @function create
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent=} [properties] Properties to set
         * @returns {server.PushContent} PushContent instance
         */
        PushContent.create = function create(properties) {
            return new PushContent(properties);
        };

        /**
         * Encodes the specified PushContent message. Does not implicitly {@link server.PushContent.verify|verify} messages.
         * @function encode
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent} message PushContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified PushContent message, length delimited. Does not implicitly {@link server.PushContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent} message PushContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushContent message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushContent} PushContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushContent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.bytes();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushContent} PushContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushContent message.
         * @function verify
         * @memberof server.PushContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                    return "certificate: buffer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a PushContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushContent} PushContent
         */
        PushContent.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushContent)
                return object;
            var message = new $root.server.PushContent();
            if (object.certificate != null)
                if (typeof object.certificate === "string")
                    $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                else if (object.certificate.length)
                    message.certificate = object.certificate;
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a PushContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushContent
         * @static
         * @param {server.PushContent} message PushContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.certificate = "";
                else {
                    object.certificate = [];
                    if (options.bytes !== Array)
                        object.certificate = $util.newBuffer(object.certificate);
                }
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this PushContent to JSON.
         * @function toJSON
         * @memberof server.PushContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushContent;
    })();

    server.InviteeNotice = (function() {

        /**
         * Properties of an InviteeNotice.
         * @memberof server
         * @interface IInviteeNotice
         * @property {Array.<server.IInviter>|null} [inviters] InviteeNotice inviters
         */

        /**
         * Constructs a new InviteeNotice.
         * @memberof server
         * @classdesc Represents an InviteeNotice.
         * @implements IInviteeNotice
         * @constructor
         * @param {server.IInviteeNotice=} [properties] Properties to set
         */
        function InviteeNotice(properties) {
            this.inviters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteeNotice inviters.
         * @member {Array.<server.IInviter>} inviters
         * @memberof server.InviteeNotice
         * @instance
         */
        InviteeNotice.prototype.inviters = $util.emptyArray;

        /**
         * Creates a new InviteeNotice instance using the specified properties.
         * @function create
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice=} [properties] Properties to set
         * @returns {server.InviteeNotice} InviteeNotice instance
         */
        InviteeNotice.create = function create(properties) {
            return new InviteeNotice(properties);
        };

        /**
         * Encodes the specified InviteeNotice message. Does not implicitly {@link server.InviteeNotice.verify|verify} messages.
         * @function encode
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice} message InviteeNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteeNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inviters != null && message.inviters.length)
                for (var i = 0; i < message.inviters.length; ++i)
                    $root.server.Inviter.encode(message.inviters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InviteeNotice message, length delimited. Does not implicitly {@link server.InviteeNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice} message InviteeNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteeNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteeNotice message from the specified reader or buffer.
         * @function decode
         * @memberof server.InviteeNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InviteeNotice} InviteeNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteeNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InviteeNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.inviters && message.inviters.length))
                        message.inviters = [];
                    message.inviters.push($root.server.Inviter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteeNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InviteeNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InviteeNotice} InviteeNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteeNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteeNotice message.
         * @function verify
         * @memberof server.InviteeNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteeNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inviters != null && message.hasOwnProperty("inviters")) {
                if (!Array.isArray(message.inviters))
                    return "inviters: array expected";
                for (var i = 0; i < message.inviters.length; ++i) {
                    var error = $root.server.Inviter.verify(message.inviters[i]);
                    if (error)
                        return "inviters." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InviteeNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InviteeNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InviteeNotice} InviteeNotice
         */
        InviteeNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InviteeNotice)
                return object;
            var message = new $root.server.InviteeNotice();
            if (object.inviters) {
                if (!Array.isArray(object.inviters))
                    throw TypeError(".server.InviteeNotice.inviters: array expected");
                message.inviters = [];
                for (var i = 0; i < object.inviters.length; ++i) {
                    if (typeof object.inviters[i] !== "object")
                        throw TypeError(".server.InviteeNotice.inviters: object expected");
                    message.inviters[i] = $root.server.Inviter.fromObject(object.inviters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InviteeNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InviteeNotice
         * @static
         * @param {server.InviteeNotice} message InviteeNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InviteeNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.inviters = [];
            if (message.inviters && message.inviters.length) {
                object.inviters = [];
                for (var j = 0; j < message.inviters.length; ++j)
                    object.inviters[j] = $root.server.Inviter.toObject(message.inviters[j], options);
            }
            return object;
        };

        /**
         * Converts this InviteeNotice to JSON.
         * @function toJSON
         * @memberof server.InviteeNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InviteeNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InviteeNotice;
    })();

    server.Inviter = (function() {

        /**
         * Properties of an Inviter.
         * @memberof server
         * @interface IInviter
         * @property {number|Long|null} [uid] Inviter uid
         * @property {string|null} [name] Inviter name
         * @property {string|null} [phone] Inviter phone
         * @property {number|Long|null} [timestamp] Inviter timestamp
         */

        /**
         * Constructs a new Inviter.
         * @memberof server
         * @classdesc Represents an Inviter.
         * @implements IInviter
         * @constructor
         * @param {server.IInviter=} [properties] Properties to set
         */
        function Inviter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Inviter uid.
         * @member {number|Long} uid
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Inviter name.
         * @member {string} name
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.name = "";

        /**
         * Inviter phone.
         * @member {string} phone
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.phone = "";

        /**
         * Inviter timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Inviter instance using the specified properties.
         * @function create
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter=} [properties] Properties to set
         * @returns {server.Inviter} Inviter instance
         */
        Inviter.create = function create(properties) {
            return new Inviter(properties);
        };

        /**
         * Encodes the specified Inviter message. Does not implicitly {@link server.Inviter.verify|verify} messages.
         * @function encode
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter} message Inviter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inviter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.phone);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Inviter message, length delimited. Does not implicitly {@link server.Inviter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter} message Inviter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inviter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Inviter message from the specified reader or buffer.
         * @function decode
         * @memberof server.Inviter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Inviter} Inviter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inviter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Inviter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.phone = reader.string();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Inviter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Inviter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Inviter} Inviter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inviter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Inviter message.
         * @function verify
         * @memberof server.Inviter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Inviter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an Inviter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Inviter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Inviter} Inviter
         */
        Inviter.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Inviter)
                return object;
            var message = new $root.server.Inviter();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Inviter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Inviter
         * @static
         * @param {server.Inviter} message Inviter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Inviter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.phone = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Inviter to JSON.
         * @function toJSON
         * @memberof server.Inviter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Inviter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Inviter;
    })();

    server.IdentityKey = (function() {

        /**
         * Properties of an IdentityKey.
         * @memberof server
         * @interface IIdentityKey
         * @property {Uint8Array|null} [publicKey] IdentityKey publicKey
         */

        /**
         * Constructs a new IdentityKey.
         * @memberof server
         * @classdesc Represents an IdentityKey.
         * @implements IIdentityKey
         * @constructor
         * @param {server.IIdentityKey=} [properties] Properties to set
         */
        function IdentityKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.IdentityKey
         * @instance
         */
        IdentityKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityKey instance using the specified properties.
         * @function create
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey=} [properties] Properties to set
         * @returns {server.IdentityKey} IdentityKey instance
         */
        IdentityKey.create = function create(properties) {
            return new IdentityKey(properties);
        };

        /**
         * Encodes the specified IdentityKey message. Does not implicitly {@link server.IdentityKey.verify|verify} messages.
         * @function encode
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey} message IdentityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityKey message, length delimited. Does not implicitly {@link server.IdentityKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey} message IdentityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKey message from the specified reader or buffer.
         * @function decode
         * @memberof server.IdentityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IdentityKey} IdentityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IdentityKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IdentityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IdentityKey} IdentityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKey message.
         * @function verify
         * @memberof server.IdentityKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IdentityKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IdentityKey} IdentityKey
         */
        IdentityKey.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IdentityKey)
                return object;
            var message = new $root.server.IdentityKey();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IdentityKey
         * @static
         * @param {server.IdentityKey} message IdentityKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };

        /**
         * Converts this IdentityKey to JSON.
         * @function toJSON
         * @memberof server.IdentityKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKey;
    })();

    server.RequestLogs = (function() {

        /**
         * Properties of a RequestLogs.
         * @memberof server
         * @interface IRequestLogs
         * @property {number|Long|null} [timestamp] RequestLogs timestamp
         */

        /**
         * Constructs a new RequestLogs.
         * @memberof server
         * @classdesc Represents a RequestLogs.
         * @implements IRequestLogs
         * @constructor
         * @param {server.IRequestLogs=} [properties] Properties to set
         */
        function RequestLogs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestLogs timestamp.
         * @member {number|Long} timestamp
         * @memberof server.RequestLogs
         * @instance
         */
        RequestLogs.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RequestLogs instance using the specified properties.
         * @function create
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs=} [properties] Properties to set
         * @returns {server.RequestLogs} RequestLogs instance
         */
        RequestLogs.create = function create(properties) {
            return new RequestLogs(properties);
        };

        /**
         * Encodes the specified RequestLogs message. Does not implicitly {@link server.RequestLogs.verify|verify} messages.
         * @function encode
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs} message RequestLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLogs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified RequestLogs message, length delimited. Does not implicitly {@link server.RequestLogs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs} message RequestLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLogs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestLogs message from the specified reader or buffer.
         * @function decode
         * @memberof server.RequestLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RequestLogs} RequestLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLogs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RequestLogs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestLogs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RequestLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RequestLogs} RequestLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLogs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestLogs message.
         * @function verify
         * @memberof server.RequestLogs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestLogs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a RequestLogs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RequestLogs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RequestLogs} RequestLogs
         */
        RequestLogs.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RequestLogs)
                return object;
            var message = new $root.server.RequestLogs();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RequestLogs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RequestLogs
         * @static
         * @param {server.RequestLogs} message RequestLogs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestLogs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this RequestLogs to JSON.
         * @function toJSON
         * @memberof server.RequestLogs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestLogs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestLogs;
    })();

    server.RegisterRequest = (function() {

        /**
         * Properties of a RegisterRequest.
         * @memberof server
         * @interface IRegisterRequest
         * @property {server.IOtpRequest|null} [otpRequest] RegisterRequest otpRequest
         * @property {server.IVerifyOtpRequest|null} [verifyRequest] RegisterRequest verifyRequest
         * @property {server.IHashcashRequest|null} [hashcashRequest] RegisterRequest hashcashRequest
         */

        /**
         * Constructs a new RegisterRequest.
         * @memberof server
         * @classdesc Represents a RegisterRequest.
         * @implements IRegisterRequest
         * @constructor
         * @param {server.IRegisterRequest=} [properties] Properties to set
         */
        function RegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterRequest otpRequest.
         * @member {server.IOtpRequest|null|undefined} otpRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.otpRequest = null;

        /**
         * RegisterRequest verifyRequest.
         * @member {server.IVerifyOtpRequest|null|undefined} verifyRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.verifyRequest = null;

        /**
         * RegisterRequest hashcashRequest.
         * @member {server.IHashcashRequest|null|undefined} hashcashRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.hashcashRequest = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * RegisterRequest request.
         * @member {"otpRequest"|"verifyRequest"|"hashcashRequest"|undefined} request
         * @memberof server.RegisterRequest
         * @instance
         */
        Object.defineProperty(RegisterRequest.prototype, "request", {
            get: $util.oneOfGetter($oneOfFields = ["otpRequest", "verifyRequest", "hashcashRequest"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RegisterRequest instance using the specified properties.
         * @function create
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest=} [properties] Properties to set
         * @returns {server.RegisterRequest} RegisterRequest instance
         */
        RegisterRequest.create = function create(properties) {
            return new RegisterRequest(properties);
        };

        /**
         * Encodes the specified RegisterRequest message. Does not implicitly {@link server.RegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.otpRequest != null && Object.hasOwnProperty.call(message, "otpRequest"))
                $root.server.OtpRequest.encode(message.otpRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.verifyRequest != null && Object.hasOwnProperty.call(message, "verifyRequest"))
                $root.server.VerifyOtpRequest.encode(message.verifyRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hashcashRequest != null && Object.hasOwnProperty.call(message, "hashcashRequest"))
                $root.server.HashcashRequest.encode(message.hashcashRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterRequest message, length delimited. Does not implicitly {@link server.RegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.otpRequest = $root.server.OtpRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.verifyRequest = $root.server.VerifyOtpRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hashcashRequest = $root.server.HashcashRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterRequest message.
         * @function verify
         * @memberof server.RegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.otpRequest != null && message.hasOwnProperty("otpRequest")) {
                properties.request = 1;
                {
                    var error = $root.server.OtpRequest.verify(message.otpRequest);
                    if (error)
                        return "otpRequest." + error;
                }
            }
            if (message.verifyRequest != null && message.hasOwnProperty("verifyRequest")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                {
                    var error = $root.server.VerifyOtpRequest.verify(message.verifyRequest);
                    if (error)
                        return "verifyRequest." + error;
                }
            }
            if (message.hashcashRequest != null && message.hasOwnProperty("hashcashRequest")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                {
                    var error = $root.server.HashcashRequest.verify(message.hashcashRequest);
                    if (error)
                        return "hashcashRequest." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RegisterRequest} RegisterRequest
         */
        RegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RegisterRequest)
                return object;
            var message = new $root.server.RegisterRequest();
            if (object.otpRequest != null) {
                if (typeof object.otpRequest !== "object")
                    throw TypeError(".server.RegisterRequest.otpRequest: object expected");
                message.otpRequest = $root.server.OtpRequest.fromObject(object.otpRequest);
            }
            if (object.verifyRequest != null) {
                if (typeof object.verifyRequest !== "object")
                    throw TypeError(".server.RegisterRequest.verifyRequest: object expected");
                message.verifyRequest = $root.server.VerifyOtpRequest.fromObject(object.verifyRequest);
            }
            if (object.hashcashRequest != null) {
                if (typeof object.hashcashRequest !== "object")
                    throw TypeError(".server.RegisterRequest.hashcashRequest: object expected");
                message.hashcashRequest = $root.server.HashcashRequest.fromObject(object.hashcashRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RegisterRequest
         * @static
         * @param {server.RegisterRequest} message RegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.otpRequest != null && message.hasOwnProperty("otpRequest")) {
                object.otpRequest = $root.server.OtpRequest.toObject(message.otpRequest, options);
                if (options.oneofs)
                    object.request = "otpRequest";
            }
            if (message.verifyRequest != null && message.hasOwnProperty("verifyRequest")) {
                object.verifyRequest = $root.server.VerifyOtpRequest.toObject(message.verifyRequest, options);
                if (options.oneofs)
                    object.request = "verifyRequest";
            }
            if (message.hashcashRequest != null && message.hasOwnProperty("hashcashRequest")) {
                object.hashcashRequest = $root.server.HashcashRequest.toObject(message.hashcashRequest, options);
                if (options.oneofs)
                    object.request = "hashcashRequest";
            }
            return object;
        };

        /**
         * Converts this RegisterRequest to JSON.
         * @function toJSON
         * @memberof server.RegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterRequest;
    })();

    server.RegisterResponse = (function() {

        /**
         * Properties of a RegisterResponse.
         * @memberof server
         * @interface IRegisterResponse
         * @property {server.IOtpResponse|null} [otpResponse] RegisterResponse otpResponse
         * @property {server.IVerifyOtpResponse|null} [verifyResponse] RegisterResponse verifyResponse
         * @property {server.IHashcashResponse|null} [hashcashResponse] RegisterResponse hashcashResponse
         */

        /**
         * Constructs a new RegisterResponse.
         * @memberof server
         * @classdesc Represents a RegisterResponse.
         * @implements IRegisterResponse
         * @constructor
         * @param {server.IRegisterResponse=} [properties] Properties to set
         */
        function RegisterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterResponse otpResponse.
         * @member {server.IOtpResponse|null|undefined} otpResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.otpResponse = null;

        /**
         * RegisterResponse verifyResponse.
         * @member {server.IVerifyOtpResponse|null|undefined} verifyResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.verifyResponse = null;

        /**
         * RegisterResponse hashcashResponse.
         * @member {server.IHashcashResponse|null|undefined} hashcashResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.hashcashResponse = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * RegisterResponse response.
         * @member {"otpResponse"|"verifyResponse"|"hashcashResponse"|undefined} response
         * @memberof server.RegisterResponse
         * @instance
         */
        Object.defineProperty(RegisterResponse.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["otpResponse", "verifyResponse", "hashcashResponse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RegisterResponse instance using the specified properties.
         * @function create
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse=} [properties] Properties to set
         * @returns {server.RegisterResponse} RegisterResponse instance
         */
        RegisterResponse.create = function create(properties) {
            return new RegisterResponse(properties);
        };

        /**
         * Encodes the specified RegisterResponse message. Does not implicitly {@link server.RegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.otpResponse != null && Object.hasOwnProperty.call(message, "otpResponse"))
                $root.server.OtpResponse.encode(message.otpResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.verifyResponse != null && Object.hasOwnProperty.call(message, "verifyResponse"))
                $root.server.VerifyOtpResponse.encode(message.verifyResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hashcashResponse != null && Object.hasOwnProperty.call(message, "hashcashResponse"))
                $root.server.HashcashResponse.encode(message.hashcashResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterResponse message, length delimited. Does not implicitly {@link server.RegisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RegisterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.otpResponse = $root.server.OtpResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.verifyResponse = $root.server.VerifyOtpResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hashcashResponse = $root.server.HashcashResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterResponse message.
         * @function verify
         * @memberof server.RegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.otpResponse != null && message.hasOwnProperty("otpResponse")) {
                properties.response = 1;
                {
                    var error = $root.server.OtpResponse.verify(message.otpResponse);
                    if (error)
                        return "otpResponse." + error;
                }
            }
            if (message.verifyResponse != null && message.hasOwnProperty("verifyResponse")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                {
                    var error = $root.server.VerifyOtpResponse.verify(message.verifyResponse);
                    if (error)
                        return "verifyResponse." + error;
                }
            }
            if (message.hashcashResponse != null && message.hasOwnProperty("hashcashResponse")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                {
                    var error = $root.server.HashcashResponse.verify(message.hashcashResponse);
                    if (error)
                        return "hashcashResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RegisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RegisterResponse} RegisterResponse
         */
        RegisterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RegisterResponse)
                return object;
            var message = new $root.server.RegisterResponse();
            if (object.otpResponse != null) {
                if (typeof object.otpResponse !== "object")
                    throw TypeError(".server.RegisterResponse.otpResponse: object expected");
                message.otpResponse = $root.server.OtpResponse.fromObject(object.otpResponse);
            }
            if (object.verifyResponse != null) {
                if (typeof object.verifyResponse !== "object")
                    throw TypeError(".server.RegisterResponse.verifyResponse: object expected");
                message.verifyResponse = $root.server.VerifyOtpResponse.fromObject(object.verifyResponse);
            }
            if (object.hashcashResponse != null) {
                if (typeof object.hashcashResponse !== "object")
                    throw TypeError(".server.RegisterResponse.hashcashResponse: object expected");
                message.hashcashResponse = $root.server.HashcashResponse.fromObject(object.hashcashResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RegisterResponse
         * @static
         * @param {server.RegisterResponse} message RegisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.otpResponse != null && message.hasOwnProperty("otpResponse")) {
                object.otpResponse = $root.server.OtpResponse.toObject(message.otpResponse, options);
                if (options.oneofs)
                    object.response = "otpResponse";
            }
            if (message.verifyResponse != null && message.hasOwnProperty("verifyResponse")) {
                object.verifyResponse = $root.server.VerifyOtpResponse.toObject(message.verifyResponse, options);
                if (options.oneofs)
                    object.response = "verifyResponse";
            }
            if (message.hashcashResponse != null && message.hasOwnProperty("hashcashResponse")) {
                object.hashcashResponse = $root.server.HashcashResponse.toObject(message.hashcashResponse, options);
                if (options.oneofs)
                    object.response = "hashcashResponse";
            }
            return object;
        };

        /**
         * Converts this RegisterResponse to JSON.
         * @function toJSON
         * @memberof server.RegisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterResponse;
    })();

    server.HashcashRequest = (function() {

        /**
         * Properties of a HashcashRequest.
         * @memberof server
         * @interface IHashcashRequest
         * @property {string|null} [countryCode] HashcashRequest countryCode
         */

        /**
         * Constructs a new HashcashRequest.
         * @memberof server
         * @classdesc Represents a HashcashRequest.
         * @implements IHashcashRequest
         * @constructor
         * @param {server.IHashcashRequest=} [properties] Properties to set
         */
        function HashcashRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashcashRequest countryCode.
         * @member {string} countryCode
         * @memberof server.HashcashRequest
         * @instance
         */
        HashcashRequest.prototype.countryCode = "";

        /**
         * Creates a new HashcashRequest instance using the specified properties.
         * @function create
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest=} [properties] Properties to set
         * @returns {server.HashcashRequest} HashcashRequest instance
         */
        HashcashRequest.create = function create(properties) {
            return new HashcashRequest(properties);
        };

        /**
         * Encodes the specified HashcashRequest message. Does not implicitly {@link server.HashcashRequest.verify|verify} messages.
         * @function encode
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest} message HashcashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.countryCode);
            return writer;
        };

        /**
         * Encodes the specified HashcashRequest message, length delimited. Does not implicitly {@link server.HashcashRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest} message HashcashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashcashRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.HashcashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HashcashRequest} HashcashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HashcashRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.countryCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashcashRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HashcashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HashcashRequest} HashcashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashcashRequest message.
         * @function verify
         * @memberof server.HashcashRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashcashRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isString(message.countryCode))
                    return "countryCode: string expected";
            return null;
        };

        /**
         * Creates a HashcashRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HashcashRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HashcashRequest} HashcashRequest
         */
        HashcashRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HashcashRequest)
                return object;
            var message = new $root.server.HashcashRequest();
            if (object.countryCode != null)
                message.countryCode = String(object.countryCode);
            return message;
        };

        /**
         * Creates a plain object from a HashcashRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HashcashRequest
         * @static
         * @param {server.HashcashRequest} message HashcashRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashcashRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.countryCode = "";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            return object;
        };

        /**
         * Converts this HashcashRequest to JSON.
         * @function toJSON
         * @memberof server.HashcashRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashcashRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashcashRequest;
    })();

    server.HashcashResponse = (function() {

        /**
         * Properties of a HashcashResponse.
         * @memberof server
         * @interface IHashcashResponse
         * @property {string|null} [hashcashChallenge] HashcashResponse hashcashChallenge
         * @property {boolean|null} [isPhoneNotNeeded] HashcashResponse isPhoneNotNeeded
         */

        /**
         * Constructs a new HashcashResponse.
         * @memberof server
         * @classdesc Represents a HashcashResponse.
         * @implements IHashcashResponse
         * @constructor
         * @param {server.IHashcashResponse=} [properties] Properties to set
         */
        function HashcashResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashcashResponse hashcashChallenge.
         * @member {string} hashcashChallenge
         * @memberof server.HashcashResponse
         * @instance
         */
        HashcashResponse.prototype.hashcashChallenge = "";

        /**
         * HashcashResponse isPhoneNotNeeded.
         * @member {boolean} isPhoneNotNeeded
         * @memberof server.HashcashResponse
         * @instance
         */
        HashcashResponse.prototype.isPhoneNotNeeded = false;

        /**
         * Creates a new HashcashResponse instance using the specified properties.
         * @function create
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse=} [properties] Properties to set
         * @returns {server.HashcashResponse} HashcashResponse instance
         */
        HashcashResponse.create = function create(properties) {
            return new HashcashResponse(properties);
        };

        /**
         * Encodes the specified HashcashResponse message. Does not implicitly {@link server.HashcashResponse.verify|verify} messages.
         * @function encode
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse} message HashcashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashcashChallenge != null && Object.hasOwnProperty.call(message, "hashcashChallenge"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hashcashChallenge);
            if (message.isPhoneNotNeeded != null && Object.hasOwnProperty.call(message, "isPhoneNotNeeded"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPhoneNotNeeded);
            return writer;
        };

        /**
         * Encodes the specified HashcashResponse message, length delimited. Does not implicitly {@link server.HashcashResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse} message HashcashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashcashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.HashcashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HashcashResponse} HashcashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HashcashResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashcashChallenge = reader.string();
                    break;
                case 2:
                    message.isPhoneNotNeeded = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashcashResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HashcashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HashcashResponse} HashcashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashcashResponse message.
         * @function verify
         * @memberof server.HashcashResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashcashResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashcashChallenge != null && message.hasOwnProperty("hashcashChallenge"))
                if (!$util.isString(message.hashcashChallenge))
                    return "hashcashChallenge: string expected";
            if (message.isPhoneNotNeeded != null && message.hasOwnProperty("isPhoneNotNeeded"))
                if (typeof message.isPhoneNotNeeded !== "boolean")
                    return "isPhoneNotNeeded: boolean expected";
            return null;
        };

        /**
         * Creates a HashcashResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HashcashResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HashcashResponse} HashcashResponse
         */
        HashcashResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HashcashResponse)
                return object;
            var message = new $root.server.HashcashResponse();
            if (object.hashcashChallenge != null)
                message.hashcashChallenge = String(object.hashcashChallenge);
            if (object.isPhoneNotNeeded != null)
                message.isPhoneNotNeeded = Boolean(object.isPhoneNotNeeded);
            return message;
        };

        /**
         * Creates a plain object from a HashcashResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HashcashResponse
         * @static
         * @param {server.HashcashResponse} message HashcashResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashcashResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hashcashChallenge = "";
                object.isPhoneNotNeeded = false;
            }
            if (message.hashcashChallenge != null && message.hasOwnProperty("hashcashChallenge"))
                object.hashcashChallenge = message.hashcashChallenge;
            if (message.isPhoneNotNeeded != null && message.hasOwnProperty("isPhoneNotNeeded"))
                object.isPhoneNotNeeded = message.isPhoneNotNeeded;
            return object;
        };

        /**
         * Converts this HashcashResponse to JSON.
         * @function toJSON
         * @memberof server.HashcashResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashcashResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashcashResponse;
    })();

    server.OtpRequest = (function() {

        /**
         * Properties of an OtpRequest.
         * @memberof server
         * @interface IOtpRequest
         * @property {string|null} [phone] OtpRequest phone
         * @property {server.OtpRequest.Method|null} [method] OtpRequest method
         * @property {string|null} [langId] OtpRequest langId
         * @property {string|null} [groupInviteToken] OtpRequest groupInviteToken
         * @property {string|null} [userAgent] OtpRequest userAgent
         * @property {string|null} [hashcashSolution] OtpRequest hashcashSolution
         * @property {number|Long|null} [hashcashSolutionTimeTakenMs] OtpRequest hashcashSolutionTimeTakenMs
         * @property {string|null} [campaignId] OtpRequest campaignId
         */

        /**
         * Constructs a new OtpRequest.
         * @memberof server
         * @classdesc Represents an OtpRequest.
         * @implements IOtpRequest
         * @constructor
         * @param {server.IOtpRequest=} [properties] Properties to set
         */
        function OtpRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OtpRequest phone.
         * @member {string} phone
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.phone = "";

        /**
         * OtpRequest method.
         * @member {server.OtpRequest.Method} method
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.method = 0;

        /**
         * OtpRequest langId.
         * @member {string} langId
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.langId = "";

        /**
         * OtpRequest groupInviteToken.
         * @member {string} groupInviteToken
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.groupInviteToken = "";

        /**
         * OtpRequest userAgent.
         * @member {string} userAgent
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.userAgent = "";

        /**
         * OtpRequest hashcashSolution.
         * @member {string} hashcashSolution
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.hashcashSolution = "";

        /**
         * OtpRequest hashcashSolutionTimeTakenMs.
         * @member {number|Long} hashcashSolutionTimeTakenMs
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.hashcashSolutionTimeTakenMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OtpRequest campaignId.
         * @member {string} campaignId
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.campaignId = "";

        /**
         * Creates a new OtpRequest instance using the specified properties.
         * @function create
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest=} [properties] Properties to set
         * @returns {server.OtpRequest} OtpRequest instance
         */
        OtpRequest.create = function create(properties) {
            return new OtpRequest(properties);
        };

        /**
         * Encodes the specified OtpRequest message. Does not implicitly {@link server.OtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest} message OtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
            if (message.langId != null && Object.hasOwnProperty.call(message, "langId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.langId);
            if (message.groupInviteToken != null && Object.hasOwnProperty.call(message, "groupInviteToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupInviteToken);
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.userAgent);
            if (message.hashcashSolution != null && Object.hasOwnProperty.call(message, "hashcashSolution"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.hashcashSolution);
            if (message.hashcashSolutionTimeTakenMs != null && Object.hasOwnProperty.call(message, "hashcashSolutionTimeTakenMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.hashcashSolutionTimeTakenMs);
            if (message.campaignId != null && Object.hasOwnProperty.call(message, "campaignId"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.campaignId);
            return writer;
        };

        /**
         * Encodes the specified OtpRequest message, length delimited. Does not implicitly {@link server.OtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest} message OtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.OtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OtpRequest} OtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                case 3:
                    message.langId = reader.string();
                    break;
                case 4:
                    message.groupInviteToken = reader.string();
                    break;
                case 5:
                    message.userAgent = reader.string();
                    break;
                case 6:
                    message.hashcashSolution = reader.string();
                    break;
                case 7:
                    message.hashcashSolutionTimeTakenMs = reader.int64();
                    break;
                case 8:
                    message.campaignId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OtpRequest} OtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OtpRequest message.
         * @function verify
         * @memberof server.OtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.langId != null && message.hasOwnProperty("langId"))
                if (!$util.isString(message.langId))
                    return "langId: string expected";
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                if (!$util.isString(message.groupInviteToken))
                    return "groupInviteToken: string expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                if (!$util.isString(message.hashcashSolution))
                    return "hashcashSolution: string expected";
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (!$util.isInteger(message.hashcashSolutionTimeTakenMs) && !(message.hashcashSolutionTimeTakenMs && $util.isInteger(message.hashcashSolutionTimeTakenMs.low) && $util.isInteger(message.hashcashSolutionTimeTakenMs.high)))
                    return "hashcashSolutionTimeTakenMs: integer|Long expected";
            if (message.campaignId != null && message.hasOwnProperty("campaignId"))
                if (!$util.isString(message.campaignId))
                    return "campaignId: string expected";
            return null;
        };

        /**
         * Creates an OtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OtpRequest} OtpRequest
         */
        OtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OtpRequest)
                return object;
            var message = new $root.server.OtpRequest();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.method) {
            case "SMS":
            case 0:
                message.method = 0;
                break;
            case "VOICE_CALL":
            case 1:
                message.method = 1;
                break;
            }
            if (object.langId != null)
                message.langId = String(object.langId);
            if (object.groupInviteToken != null)
                message.groupInviteToken = String(object.groupInviteToken);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.hashcashSolution != null)
                message.hashcashSolution = String(object.hashcashSolution);
            if (object.hashcashSolutionTimeTakenMs != null)
                if ($util.Long)
                    (message.hashcashSolutionTimeTakenMs = $util.Long.fromValue(object.hashcashSolutionTimeTakenMs)).unsigned = false;
                else if (typeof object.hashcashSolutionTimeTakenMs === "string")
                    message.hashcashSolutionTimeTakenMs = parseInt(object.hashcashSolutionTimeTakenMs, 10);
                else if (typeof object.hashcashSolutionTimeTakenMs === "number")
                    message.hashcashSolutionTimeTakenMs = object.hashcashSolutionTimeTakenMs;
                else if (typeof object.hashcashSolutionTimeTakenMs === "object")
                    message.hashcashSolutionTimeTakenMs = new $util.LongBits(object.hashcashSolutionTimeTakenMs.low >>> 0, object.hashcashSolutionTimeTakenMs.high >>> 0).toNumber();
            if (object.campaignId != null)
                message.campaignId = String(object.campaignId);
            return message;
        };

        /**
         * Creates a plain object from an OtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OtpRequest
         * @static
         * @param {server.OtpRequest} message OtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.method = options.enums === String ? "SMS" : 0;
                object.langId = "";
                object.groupInviteToken = "";
                object.userAgent = "";
                object.hashcashSolution = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? "0" : 0;
                object.campaignId = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.server.OtpRequest.Method[message.method] : message.method;
            if (message.langId != null && message.hasOwnProperty("langId"))
                object.langId = message.langId;
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                object.groupInviteToken = message.groupInviteToken;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                object.hashcashSolution = message.hashcashSolution;
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (typeof message.hashcashSolutionTimeTakenMs === "number")
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? String(message.hashcashSolutionTimeTakenMs) : message.hashcashSolutionTimeTakenMs;
                else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? $util.Long.prototype.toString.call(message.hashcashSolutionTimeTakenMs) : options.longs === Number ? new $util.LongBits(message.hashcashSolutionTimeTakenMs.low >>> 0, message.hashcashSolutionTimeTakenMs.high >>> 0).toNumber() : message.hashcashSolutionTimeTakenMs;
            if (message.campaignId != null && message.hasOwnProperty("campaignId"))
                object.campaignId = message.campaignId;
            return object;
        };

        /**
         * Converts this OtpRequest to JSON.
         * @function toJSON
         * @memberof server.OtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Method enum.
         * @name server.OtpRequest.Method
         * @enum {number}
         * @property {number} SMS=0 SMS value
         * @property {number} VOICE_CALL=1 VOICE_CALL value
         */
        OtpRequest.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SMS"] = 0;
            values[valuesById[1] = "VOICE_CALL"] = 1;
            return values;
        })();

        return OtpRequest;
    })();

    server.OtpResponse = (function() {

        /**
         * Properties of an OtpResponse.
         * @memberof server
         * @interface IOtpResponse
         * @property {string|null} [phone] OtpResponse phone
         * @property {server.OtpResponse.Result|null} [result] OtpResponse result
         * @property {server.OtpResponse.Reason|null} [reason] OtpResponse reason
         * @property {number|Long|null} [retryAfterSecs] OtpResponse retryAfterSecs
         * @property {boolean|null} [shouldVerifyNumber] OtpResponse shouldVerifyNumber
         */

        /**
         * Constructs a new OtpResponse.
         * @memberof server
         * @classdesc Represents an OtpResponse.
         * @implements IOtpResponse
         * @constructor
         * @param {server.IOtpResponse=} [properties] Properties to set
         */
        function OtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OtpResponse phone.
         * @member {string} phone
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.phone = "";

        /**
         * OtpResponse result.
         * @member {server.OtpResponse.Result} result
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.result = 0;

        /**
         * OtpResponse reason.
         * @member {server.OtpResponse.Reason} reason
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.reason = 0;

        /**
         * OtpResponse retryAfterSecs.
         * @member {number|Long} retryAfterSecs
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.retryAfterSecs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OtpResponse shouldVerifyNumber.
         * @member {boolean} shouldVerifyNumber
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.shouldVerifyNumber = false;

        /**
         * Creates a new OtpResponse instance using the specified properties.
         * @function create
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse=} [properties] Properties to set
         * @returns {server.OtpResponse} OtpResponse instance
         */
        OtpResponse.create = function create(properties) {
            return new OtpResponse(properties);
        };

        /**
         * Encodes the specified OtpResponse message. Does not implicitly {@link server.OtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse} message OtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reason);
            if (message.retryAfterSecs != null && Object.hasOwnProperty.call(message, "retryAfterSecs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.retryAfterSecs);
            if (message.shouldVerifyNumber != null && Object.hasOwnProperty.call(message, "shouldVerifyNumber"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.shouldVerifyNumber);
            return writer;
        };

        /**
         * Encodes the specified OtpResponse message, length delimited. Does not implicitly {@link server.OtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse} message OtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.OtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OtpResponse} OtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.result = reader.int32();
                    break;
                case 3:
                    message.reason = reader.int32();
                    break;
                case 4:
                    message.retryAfterSecs = reader.int64();
                    break;
                case 5:
                    message.shouldVerifyNumber = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OtpResponse} OtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OtpResponse message.
         * @function verify
         * @memberof server.OtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                    break;
                }
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (!$util.isInteger(message.retryAfterSecs) && !(message.retryAfterSecs && $util.isInteger(message.retryAfterSecs.low) && $util.isInteger(message.retryAfterSecs.high)))
                    return "retryAfterSecs: integer|Long expected";
            if (message.shouldVerifyNumber != null && message.hasOwnProperty("shouldVerifyNumber"))
                if (typeof message.shouldVerifyNumber !== "boolean")
                    return "shouldVerifyNumber: boolean expected";
            return null;
        };

        /**
         * Creates an OtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OtpResponse} OtpResponse
         */
        OtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OtpResponse)
                return object;
            var message = new $root.server.OtpResponse();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_PHONE_NUMBER":
            case 1:
                message.reason = 1;
                break;
            case "INVALID_CLIENT_VERSION":
            case 2:
                message.reason = 2;
                break;
            case "BAD_METHOD":
            case 3:
                message.reason = 3;
                break;
            case "OTP_FAIL":
            case 4:
                message.reason = 4;
                break;
            case "NOT_INVITED":
            case 5:
                message.reason = 5;
                break;
            case "INVALID_GROUP_INVITE_TOKEN":
            case 6:
                message.reason = 6;
                break;
            case "RETRIED_TOO_SOON":
            case 7:
                message.reason = 7;
                break;
            case "BAD_REQUEST":
            case 8:
                message.reason = 8;
                break;
            case "INTERNAL_SERVER_ERROR":
            case 9:
                message.reason = 9;
                break;
            case "INVALID_HASHCASH_NONCE":
            case 10:
                message.reason = 10;
                break;
            case "WRONG_HASHCASH_SOLUTION":
            case 11:
                message.reason = 11;
                break;
            case "INVALID_COUNTRY_CODE":
            case 12:
                message.reason = 12;
                break;
            case "INVALID_LENGTH":
            case 13:
                message.reason = 13;
                break;
            case "LINE_TYPE_VOIP":
            case 14:
                message.reason = 14;
                break;
            case "LINE_TYPE_FIXED":
            case 15:
                message.reason = 15;
                break;
            case "LINE_TYPE_OTHER":
            case 16:
                message.reason = 16;
                break;
            }
            if (object.retryAfterSecs != null)
                if ($util.Long)
                    (message.retryAfterSecs = $util.Long.fromValue(object.retryAfterSecs)).unsigned = false;
                else if (typeof object.retryAfterSecs === "string")
                    message.retryAfterSecs = parseInt(object.retryAfterSecs, 10);
                else if (typeof object.retryAfterSecs === "number")
                    message.retryAfterSecs = object.retryAfterSecs;
                else if (typeof object.retryAfterSecs === "object")
                    message.retryAfterSecs = new $util.LongBits(object.retryAfterSecs.low >>> 0, object.retryAfterSecs.high >>> 0).toNumber();
            if (object.shouldVerifyNumber != null)
                message.shouldVerifyNumber = Boolean(object.shouldVerifyNumber);
            return message;
        };

        /**
         * Creates a plain object from an OtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OtpResponse
         * @static
         * @param {server.OtpResponse} message OtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.retryAfterSecs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.retryAfterSecs = options.longs === String ? "0" : 0;
                object.shouldVerifyNumber = false;
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.OtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.OtpResponse.Reason[message.reason] : message.reason;
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (typeof message.retryAfterSecs === "number")
                    object.retryAfterSecs = options.longs === String ? String(message.retryAfterSecs) : message.retryAfterSecs;
                else
                    object.retryAfterSecs = options.longs === String ? $util.Long.prototype.toString.call(message.retryAfterSecs) : options.longs === Number ? new $util.LongBits(message.retryAfterSecs.low >>> 0, message.retryAfterSecs.high >>> 0).toNumber() : message.retryAfterSecs;
            if (message.shouldVerifyNumber != null && message.hasOwnProperty("shouldVerifyNumber"))
                object.shouldVerifyNumber = message.shouldVerifyNumber;
            return object;
        };

        /**
         * Converts this OtpResponse to JSON.
         * @function toJSON
         * @memberof server.OtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.OtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        OtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.OtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_PHONE_NUMBER=1 INVALID_PHONE_NUMBER value
         * @property {number} INVALID_CLIENT_VERSION=2 INVALID_CLIENT_VERSION value
         * @property {number} BAD_METHOD=3 BAD_METHOD value
         * @property {number} OTP_FAIL=4 OTP_FAIL value
         * @property {number} NOT_INVITED=5 NOT_INVITED value
         * @property {number} INVALID_GROUP_INVITE_TOKEN=6 INVALID_GROUP_INVITE_TOKEN value
         * @property {number} RETRIED_TOO_SOON=7 RETRIED_TOO_SOON value
         * @property {number} BAD_REQUEST=8 BAD_REQUEST value
         * @property {number} INTERNAL_SERVER_ERROR=9 INTERNAL_SERVER_ERROR value
         * @property {number} INVALID_HASHCASH_NONCE=10 INVALID_HASHCASH_NONCE value
         * @property {number} WRONG_HASHCASH_SOLUTION=11 WRONG_HASHCASH_SOLUTION value
         * @property {number} INVALID_COUNTRY_CODE=12 INVALID_COUNTRY_CODE value
         * @property {number} INVALID_LENGTH=13 INVALID_LENGTH value
         * @property {number} LINE_TYPE_VOIP=14 LINE_TYPE_VOIP value
         * @property {number} LINE_TYPE_FIXED=15 LINE_TYPE_FIXED value
         * @property {number} LINE_TYPE_OTHER=16 LINE_TYPE_OTHER value
         */
        OtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_PHONE_NUMBER"] = 1;
            values[valuesById[2] = "INVALID_CLIENT_VERSION"] = 2;
            values[valuesById[3] = "BAD_METHOD"] = 3;
            values[valuesById[4] = "OTP_FAIL"] = 4;
            values[valuesById[5] = "NOT_INVITED"] = 5;
            values[valuesById[6] = "INVALID_GROUP_INVITE_TOKEN"] = 6;
            values[valuesById[7] = "RETRIED_TOO_SOON"] = 7;
            values[valuesById[8] = "BAD_REQUEST"] = 8;
            values[valuesById[9] = "INTERNAL_SERVER_ERROR"] = 9;
            values[valuesById[10] = "INVALID_HASHCASH_NONCE"] = 10;
            values[valuesById[11] = "WRONG_HASHCASH_SOLUTION"] = 11;
            values[valuesById[12] = "INVALID_COUNTRY_CODE"] = 12;
            values[valuesById[13] = "INVALID_LENGTH"] = 13;
            values[valuesById[14] = "LINE_TYPE_VOIP"] = 14;
            values[valuesById[15] = "LINE_TYPE_FIXED"] = 15;
            values[valuesById[16] = "LINE_TYPE_OTHER"] = 16;
            return values;
        })();

        return OtpResponse;
    })();

    server.VerifyOtpRequest = (function() {

        /**
         * Properties of a VerifyOtpRequest.
         * @memberof server
         * @interface IVerifyOtpRequest
         * @property {string|null} [phone] VerifyOtpRequest phone
         * @property {string|null} [code] VerifyOtpRequest code
         * @property {string|null} [name] VerifyOtpRequest name
         * @property {Uint8Array|null} [staticKey] VerifyOtpRequest staticKey
         * @property {Uint8Array|null} [signedPhrase] VerifyOtpRequest signedPhrase
         * @property {Uint8Array|null} [identityKey] VerifyOtpRequest identityKey
         * @property {Uint8Array|null} [signedKey] VerifyOtpRequest signedKey
         * @property {Array.<Uint8Array>|null} [oneTimeKeys] VerifyOtpRequest oneTimeKeys
         * @property {string|null} [groupInviteToken] VerifyOtpRequest groupInviteToken
         * @property {server.IPushRegister|null} [pushRegister] VerifyOtpRequest pushRegister
         * @property {string|null} [userAgent] VerifyOtpRequest userAgent
         * @property {string|null} [campaignId] VerifyOtpRequest campaignId
         * @property {string|null} [hashcashSolution] VerifyOtpRequest hashcashSolution
         * @property {number|Long|null} [hashcashSolutionTimeTakenMs] VerifyOtpRequest hashcashSolutionTimeTakenMs
         */

        /**
         * Constructs a new VerifyOtpRequest.
         * @memberof server
         * @classdesc Represents a VerifyOtpRequest.
         * @implements IVerifyOtpRequest
         * @constructor
         * @param {server.IVerifyOtpRequest=} [properties] Properties to set
         */
        function VerifyOtpRequest(properties) {
            this.oneTimeKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyOtpRequest phone.
         * @member {string} phone
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.phone = "";

        /**
         * VerifyOtpRequest code.
         * @member {string} code
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.code = "";

        /**
         * VerifyOtpRequest name.
         * @member {string} name
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.name = "";

        /**
         * VerifyOtpRequest staticKey.
         * @member {Uint8Array} staticKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.staticKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest signedPhrase.
         * @member {Uint8Array} signedPhrase
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.signedPhrase = $util.newBuffer([]);

        /**
         * VerifyOtpRequest identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.identityKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest signedKey.
         * @member {Uint8Array} signedKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.signedKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest oneTimeKeys.
         * @member {Array.<Uint8Array>} oneTimeKeys
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.oneTimeKeys = $util.emptyArray;

        /**
         * VerifyOtpRequest groupInviteToken.
         * @member {string} groupInviteToken
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.groupInviteToken = "";

        /**
         * VerifyOtpRequest pushRegister.
         * @member {server.IPushRegister|null|undefined} pushRegister
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.pushRegister = null;

        /**
         * VerifyOtpRequest userAgent.
         * @member {string} userAgent
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.userAgent = "";

        /**
         * VerifyOtpRequest campaignId.
         * @member {string} campaignId
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.campaignId = "";

        /**
         * VerifyOtpRequest hashcashSolution.
         * @member {string} hashcashSolution
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.hashcashSolution = "";

        /**
         * VerifyOtpRequest hashcashSolutionTimeTakenMs.
         * @member {number|Long} hashcashSolutionTimeTakenMs
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.hashcashSolutionTimeTakenMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new VerifyOtpRequest instance using the specified properties.
         * @function create
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest=} [properties] Properties to set
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest instance
         */
        VerifyOtpRequest.create = function create(properties) {
            return new VerifyOtpRequest(properties);
        };

        /**
         * Encodes the specified VerifyOtpRequest message. Does not implicitly {@link server.VerifyOtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest} message VerifyOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.staticKey != null && Object.hasOwnProperty.call(message, "staticKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.staticKey);
            if (message.signedPhrase != null && Object.hasOwnProperty.call(message, "signedPhrase"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signedPhrase);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.identityKey);
            if (message.signedKey != null && Object.hasOwnProperty.call(message, "signedKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signedKey);
            if (message.oneTimeKeys != null && message.oneTimeKeys.length)
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.oneTimeKeys[i]);
            if (message.groupInviteToken != null && Object.hasOwnProperty.call(message, "groupInviteToken"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.groupInviteToken);
            if (message.pushRegister != null && Object.hasOwnProperty.call(message, "pushRegister"))
                $root.server.PushRegister.encode(message.pushRegister, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.userAgent);
            if (message.campaignId != null && Object.hasOwnProperty.call(message, "campaignId"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.campaignId);
            if (message.hashcashSolution != null && Object.hasOwnProperty.call(message, "hashcashSolution"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.hashcashSolution);
            if (message.hashcashSolutionTimeTakenMs != null && Object.hasOwnProperty.call(message, "hashcashSolutionTimeTakenMs"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.hashcashSolutionTimeTakenMs);
            return writer;
        };

        /**
         * Encodes the specified VerifyOtpRequest message, length delimited. Does not implicitly {@link server.VerifyOtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest} message VerifyOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyOtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.VerifyOtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.code = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.staticKey = reader.bytes();
                    break;
                case 5:
                    message.signedPhrase = reader.bytes();
                    break;
                case 6:
                    message.identityKey = reader.bytes();
                    break;
                case 7:
                    message.signedKey = reader.bytes();
                    break;
                case 8:
                    if (!(message.oneTimeKeys && message.oneTimeKeys.length))
                        message.oneTimeKeys = [];
                    message.oneTimeKeys.push(reader.bytes());
                    break;
                case 9:
                    message.groupInviteToken = reader.string();
                    break;
                case 10:
                    message.pushRegister = $root.server.PushRegister.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.userAgent = reader.string();
                    break;
                case 12:
                    message.campaignId = reader.string();
                    break;
                case 13:
                    message.hashcashSolution = reader.string();
                    break;
                case 14:
                    message.hashcashSolutionTimeTakenMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyOtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyOtpRequest message.
         * @function verify
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyOtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                if (!(message.staticKey && typeof message.staticKey.length === "number" || $util.isString(message.staticKey)))
                    return "staticKey: buffer expected";
            if (message.signedPhrase != null && message.hasOwnProperty("signedPhrase"))
                if (!(message.signedPhrase && typeof message.signedPhrase.length === "number" || $util.isString(message.signedPhrase)))
                    return "signedPhrase: buffer expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                if (!(message.signedKey && typeof message.signedKey.length === "number" || $util.isString(message.signedKey)))
                    return "signedKey: buffer expected";
            if (message.oneTimeKeys != null && message.hasOwnProperty("oneTimeKeys")) {
                if (!Array.isArray(message.oneTimeKeys))
                    return "oneTimeKeys: array expected";
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    if (!(message.oneTimeKeys[i] && typeof message.oneTimeKeys[i].length === "number" || $util.isString(message.oneTimeKeys[i])))
                        return "oneTimeKeys: buffer[] expected";
            }
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                if (!$util.isString(message.groupInviteToken))
                    return "groupInviteToken: string expected";
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                var error = $root.server.PushRegister.verify(message.pushRegister);
                if (error)
                    return "pushRegister." + error;
            }
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            if (message.campaignId != null && message.hasOwnProperty("campaignId"))
                if (!$util.isString(message.campaignId))
                    return "campaignId: string expected";
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                if (!$util.isString(message.hashcashSolution))
                    return "hashcashSolution: string expected";
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (!$util.isInteger(message.hashcashSolutionTimeTakenMs) && !(message.hashcashSolutionTimeTakenMs && $util.isInteger(message.hashcashSolutionTimeTakenMs.low) && $util.isInteger(message.hashcashSolutionTimeTakenMs.high)))
                    return "hashcashSolutionTimeTakenMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a VerifyOtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         */
        VerifyOtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.VerifyOtpRequest)
                return object;
            var message = new $root.server.VerifyOtpRequest();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.staticKey != null)
                if (typeof object.staticKey === "string")
                    $util.base64.decode(object.staticKey, message.staticKey = $util.newBuffer($util.base64.length(object.staticKey)), 0);
                else if (object.staticKey.length)
                    message.staticKey = object.staticKey;
            if (object.signedPhrase != null)
                if (typeof object.signedPhrase === "string")
                    $util.base64.decode(object.signedPhrase, message.signedPhrase = $util.newBuffer($util.base64.length(object.signedPhrase)), 0);
                else if (object.signedPhrase.length)
                    message.signedPhrase = object.signedPhrase;
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedKey != null)
                if (typeof object.signedKey === "string")
                    $util.base64.decode(object.signedKey, message.signedKey = $util.newBuffer($util.base64.length(object.signedKey)), 0);
                else if (object.signedKey.length)
                    message.signedKey = object.signedKey;
            if (object.oneTimeKeys) {
                if (!Array.isArray(object.oneTimeKeys))
                    throw TypeError(".server.VerifyOtpRequest.oneTimeKeys: array expected");
                message.oneTimeKeys = [];
                for (var i = 0; i < object.oneTimeKeys.length; ++i)
                    if (typeof object.oneTimeKeys[i] === "string")
                        $util.base64.decode(object.oneTimeKeys[i], message.oneTimeKeys[i] = $util.newBuffer($util.base64.length(object.oneTimeKeys[i])), 0);
                    else if (object.oneTimeKeys[i].length)
                        message.oneTimeKeys[i] = object.oneTimeKeys[i];
            }
            if (object.groupInviteToken != null)
                message.groupInviteToken = String(object.groupInviteToken);
            if (object.pushRegister != null) {
                if (typeof object.pushRegister !== "object")
                    throw TypeError(".server.VerifyOtpRequest.pushRegister: object expected");
                message.pushRegister = $root.server.PushRegister.fromObject(object.pushRegister);
            }
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.campaignId != null)
                message.campaignId = String(object.campaignId);
            if (object.hashcashSolution != null)
                message.hashcashSolution = String(object.hashcashSolution);
            if (object.hashcashSolutionTimeTakenMs != null)
                if ($util.Long)
                    (message.hashcashSolutionTimeTakenMs = $util.Long.fromValue(object.hashcashSolutionTimeTakenMs)).unsigned = false;
                else if (typeof object.hashcashSolutionTimeTakenMs === "string")
                    message.hashcashSolutionTimeTakenMs = parseInt(object.hashcashSolutionTimeTakenMs, 10);
                else if (typeof object.hashcashSolutionTimeTakenMs === "number")
                    message.hashcashSolutionTimeTakenMs = object.hashcashSolutionTimeTakenMs;
                else if (typeof object.hashcashSolutionTimeTakenMs === "object")
                    message.hashcashSolutionTimeTakenMs = new $util.LongBits(object.hashcashSolutionTimeTakenMs.low >>> 0, object.hashcashSolutionTimeTakenMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a VerifyOtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.VerifyOtpRequest} message VerifyOtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyOtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.oneTimeKeys = [];
            if (options.defaults) {
                object.phone = "";
                object.code = "";
                object.name = "";
                if (options.bytes === String)
                    object.staticKey = "";
                else {
                    object.staticKey = [];
                    if (options.bytes !== Array)
                        object.staticKey = $util.newBuffer(object.staticKey);
                }
                if (options.bytes === String)
                    object.signedPhrase = "";
                else {
                    object.signedPhrase = [];
                    if (options.bytes !== Array)
                        object.signedPhrase = $util.newBuffer(object.signedPhrase);
                }
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.signedKey = "";
                else {
                    object.signedKey = [];
                    if (options.bytes !== Array)
                        object.signedKey = $util.newBuffer(object.signedKey);
                }
                object.groupInviteToken = "";
                object.pushRegister = null;
                object.userAgent = "";
                object.campaignId = "";
                object.hashcashSolution = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? "0" : 0;
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                object.staticKey = options.bytes === String ? $util.base64.encode(message.staticKey, 0, message.staticKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.staticKey) : message.staticKey;
            if (message.signedPhrase != null && message.hasOwnProperty("signedPhrase"))
                object.signedPhrase = options.bytes === String ? $util.base64.encode(message.signedPhrase, 0, message.signedPhrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedPhrase) : message.signedPhrase;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                object.signedKey = options.bytes === String ? $util.base64.encode(message.signedKey, 0, message.signedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedKey) : message.signedKey;
            if (message.oneTimeKeys && message.oneTimeKeys.length) {
                object.oneTimeKeys = [];
                for (var j = 0; j < message.oneTimeKeys.length; ++j)
                    object.oneTimeKeys[j] = options.bytes === String ? $util.base64.encode(message.oneTimeKeys[j], 0, message.oneTimeKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.oneTimeKeys[j]) : message.oneTimeKeys[j];
            }
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                object.groupInviteToken = message.groupInviteToken;
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister"))
                object.pushRegister = $root.server.PushRegister.toObject(message.pushRegister, options);
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.campaignId != null && message.hasOwnProperty("campaignId"))
                object.campaignId = message.campaignId;
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                object.hashcashSolution = message.hashcashSolution;
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (typeof message.hashcashSolutionTimeTakenMs === "number")
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? String(message.hashcashSolutionTimeTakenMs) : message.hashcashSolutionTimeTakenMs;
                else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? $util.Long.prototype.toString.call(message.hashcashSolutionTimeTakenMs) : options.longs === Number ? new $util.LongBits(message.hashcashSolutionTimeTakenMs.low >>> 0, message.hashcashSolutionTimeTakenMs.high >>> 0).toNumber() : message.hashcashSolutionTimeTakenMs;
            return object;
        };

        /**
         * Converts this VerifyOtpRequest to JSON.
         * @function toJSON
         * @memberof server.VerifyOtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyOtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyOtpRequest;
    })();

    server.VerifyOtpResponse = (function() {

        /**
         * Properties of a VerifyOtpResponse.
         * @memberof server
         * @interface IVerifyOtpResponse
         * @property {string|null} [phone] VerifyOtpResponse phone
         * @property {number|Long|null} [uid] VerifyOtpResponse uid
         * @property {string|null} [name] VerifyOtpResponse name
         * @property {server.VerifyOtpResponse.Result|null} [result] VerifyOtpResponse result
         * @property {server.VerifyOtpResponse.Reason|null} [reason] VerifyOtpResponse reason
         * @property {string|null} [groupInviteResult] VerifyOtpResponse groupInviteResult
         * @property {string|null} [username] VerifyOtpResponse username
         */

        /**
         * Constructs a new VerifyOtpResponse.
         * @memberof server
         * @classdesc Represents a VerifyOtpResponse.
         * @implements IVerifyOtpResponse
         * @constructor
         * @param {server.IVerifyOtpResponse=} [properties] Properties to set
         */
        function VerifyOtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyOtpResponse phone.
         * @member {string} phone
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.phone = "";

        /**
         * VerifyOtpResponse uid.
         * @member {number|Long} uid
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VerifyOtpResponse name.
         * @member {string} name
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.name = "";

        /**
         * VerifyOtpResponse result.
         * @member {server.VerifyOtpResponse.Result} result
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.result = 0;

        /**
         * VerifyOtpResponse reason.
         * @member {server.VerifyOtpResponse.Reason} reason
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.reason = 0;

        /**
         * VerifyOtpResponse groupInviteResult.
         * @member {string} groupInviteResult
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.groupInviteResult = "";

        /**
         * VerifyOtpResponse username.
         * @member {string} username
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.username = "";

        /**
         * Creates a new VerifyOtpResponse instance using the specified properties.
         * @function create
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse=} [properties] Properties to set
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse instance
         */
        VerifyOtpResponse.create = function create(properties) {
            return new VerifyOtpResponse(properties);
        };

        /**
         * Encodes the specified VerifyOtpResponse message. Does not implicitly {@link server.VerifyOtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse} message VerifyOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.reason);
            if (message.groupInviteResult != null && Object.hasOwnProperty.call(message, "groupInviteResult"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.groupInviteResult);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified VerifyOtpResponse message, length delimited. Does not implicitly {@link server.VerifyOtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse} message VerifyOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyOtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.VerifyOtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.result = reader.int32();
                    break;
                case 5:
                    message.reason = reader.int32();
                    break;
                case 6:
                    message.groupInviteResult = reader.string();
                    break;
                case 7:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyOtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyOtpResponse message.
         * @function verify
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyOtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                    break;
                }
            if (message.groupInviteResult != null && message.hasOwnProperty("groupInviteResult"))
                if (!$util.isString(message.groupInviteResult))
                    return "groupInviteResult: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a VerifyOtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         */
        VerifyOtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.VerifyOtpResponse)
                return object;
            var message = new $root.server.VerifyOtpResponse();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_PHONE_NUMBER":
            case 1:
                message.reason = 1;
                break;
            case "INVALID_CLIENT_VERSION":
            case 2:
                message.reason = 2;
                break;
            case "WRONG_SMS_CODE":
            case 3:
                message.reason = 3;
                break;
            case "MISSING_PHONE":
            case 4:
                message.reason = 4;
                break;
            case "MISSING_CODE":
            case 5:
                message.reason = 5;
                break;
            case "MISSING_NAME":
            case 6:
                message.reason = 6;
                break;
            case "INVALID_NAME":
            case 7:
                message.reason = 7;
                break;
            case "MISSING_IDENTITY_KEY":
            case 8:
                message.reason = 8;
                break;
            case "MISSING_SIGNED_KEY":
            case 9:
                message.reason = 9;
                break;
            case "MISSING_ONE_TIME_KEYS":
            case 10:
                message.reason = 10;
                break;
            case "BAD_BASE64_KEY":
            case 11:
                message.reason = 11;
                break;
            case "INVALID_ONE_TIME_KEYS":
            case 12:
                message.reason = 12;
                break;
            case "TOO_FEW_ONE_TIME_KEYS":
            case 13:
                message.reason = 13;
                break;
            case "TOO_MANY_ONE_TIME_KEYS":
            case 14:
                message.reason = 14;
                break;
            case "TOO_BIG_IDENTITY_KEY":
            case 15:
                message.reason = 15;
                break;
            case "TOO_BIG_SIGNED_KEY":
            case 16:
                message.reason = 16;
                break;
            case "TOO_BIG_ONE_TIME_KEYS":
            case 17:
                message.reason = 17;
                break;
            case "INVALID_S_ED_PUB":
            case 18:
                message.reason = 18;
                break;
            case "INVALID_SIGNED_PHRASE":
            case 19:
                message.reason = 19;
                break;
            case "UNABLE_TO_OPEN_SIGNED_PHRASE":
            case 20:
                message.reason = 20;
                break;
            case "BAD_REQUEST":
            case 21:
                message.reason = 21;
                break;
            case "INTERNAL_SERVER_ERROR":
            case 22:
                message.reason = 22;
                break;
            case "INVALID_COUNTRY_CODE":
            case 23:
                message.reason = 23;
                break;
            case "INVALID_LENGTH":
            case 24:
                message.reason = 24;
                break;
            case "LINE_TYPE_VOIP":
            case 25:
                message.reason = 25;
                break;
            case "LINE_TYPE_FIXED":
            case 26:
                message.reason = 26;
                break;
            case "LINE_TYPE_OTHER":
            case 27:
                message.reason = 27;
                break;
            case "WRONG_HASHCASH_SOLUTION":
            case 28:
                message.reason = 28;
                break;
            }
            if (object.groupInviteResult != null)
                message.groupInviteResult = String(object.groupInviteResult);
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a VerifyOtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.VerifyOtpResponse} message VerifyOtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyOtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.groupInviteResult = "";
                object.username = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.VerifyOtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.VerifyOtpResponse.Reason[message.reason] : message.reason;
            if (message.groupInviteResult != null && message.hasOwnProperty("groupInviteResult"))
                object.groupInviteResult = message.groupInviteResult;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this VerifyOtpResponse to JSON.
         * @function toJSON
         * @memberof server.VerifyOtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyOtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.VerifyOtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        VerifyOtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.VerifyOtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_PHONE_NUMBER=1 INVALID_PHONE_NUMBER value
         * @property {number} INVALID_CLIENT_VERSION=2 INVALID_CLIENT_VERSION value
         * @property {number} WRONG_SMS_CODE=3 WRONG_SMS_CODE value
         * @property {number} MISSING_PHONE=4 MISSING_PHONE value
         * @property {number} MISSING_CODE=5 MISSING_CODE value
         * @property {number} MISSING_NAME=6 MISSING_NAME value
         * @property {number} INVALID_NAME=7 INVALID_NAME value
         * @property {number} MISSING_IDENTITY_KEY=8 MISSING_IDENTITY_KEY value
         * @property {number} MISSING_SIGNED_KEY=9 MISSING_SIGNED_KEY value
         * @property {number} MISSING_ONE_TIME_KEYS=10 MISSING_ONE_TIME_KEYS value
         * @property {number} BAD_BASE64_KEY=11 BAD_BASE64_KEY value
         * @property {number} INVALID_ONE_TIME_KEYS=12 INVALID_ONE_TIME_KEYS value
         * @property {number} TOO_FEW_ONE_TIME_KEYS=13 TOO_FEW_ONE_TIME_KEYS value
         * @property {number} TOO_MANY_ONE_TIME_KEYS=14 TOO_MANY_ONE_TIME_KEYS value
         * @property {number} TOO_BIG_IDENTITY_KEY=15 TOO_BIG_IDENTITY_KEY value
         * @property {number} TOO_BIG_SIGNED_KEY=16 TOO_BIG_SIGNED_KEY value
         * @property {number} TOO_BIG_ONE_TIME_KEYS=17 TOO_BIG_ONE_TIME_KEYS value
         * @property {number} INVALID_S_ED_PUB=18 INVALID_S_ED_PUB value
         * @property {number} INVALID_SIGNED_PHRASE=19 INVALID_SIGNED_PHRASE value
         * @property {number} UNABLE_TO_OPEN_SIGNED_PHRASE=20 UNABLE_TO_OPEN_SIGNED_PHRASE value
         * @property {number} BAD_REQUEST=21 BAD_REQUEST value
         * @property {number} INTERNAL_SERVER_ERROR=22 INTERNAL_SERVER_ERROR value
         * @property {number} INVALID_COUNTRY_CODE=23 INVALID_COUNTRY_CODE value
         * @property {number} INVALID_LENGTH=24 INVALID_LENGTH value
         * @property {number} LINE_TYPE_VOIP=25 LINE_TYPE_VOIP value
         * @property {number} LINE_TYPE_FIXED=26 LINE_TYPE_FIXED value
         * @property {number} LINE_TYPE_OTHER=27 LINE_TYPE_OTHER value
         * @property {number} WRONG_HASHCASH_SOLUTION=28 WRONG_HASHCASH_SOLUTION value
         */
        VerifyOtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_PHONE_NUMBER"] = 1;
            values[valuesById[2] = "INVALID_CLIENT_VERSION"] = 2;
            values[valuesById[3] = "WRONG_SMS_CODE"] = 3;
            values[valuesById[4] = "MISSING_PHONE"] = 4;
            values[valuesById[5] = "MISSING_CODE"] = 5;
            values[valuesById[6] = "MISSING_NAME"] = 6;
            values[valuesById[7] = "INVALID_NAME"] = 7;
            values[valuesById[8] = "MISSING_IDENTITY_KEY"] = 8;
            values[valuesById[9] = "MISSING_SIGNED_KEY"] = 9;
            values[valuesById[10] = "MISSING_ONE_TIME_KEYS"] = 10;
            values[valuesById[11] = "BAD_BASE64_KEY"] = 11;
            values[valuesById[12] = "INVALID_ONE_TIME_KEYS"] = 12;
            values[valuesById[13] = "TOO_FEW_ONE_TIME_KEYS"] = 13;
            values[valuesById[14] = "TOO_MANY_ONE_TIME_KEYS"] = 14;
            values[valuesById[15] = "TOO_BIG_IDENTITY_KEY"] = 15;
            values[valuesById[16] = "TOO_BIG_SIGNED_KEY"] = 16;
            values[valuesById[17] = "TOO_BIG_ONE_TIME_KEYS"] = 17;
            values[valuesById[18] = "INVALID_S_ED_PUB"] = 18;
            values[valuesById[19] = "INVALID_SIGNED_PHRASE"] = 19;
            values[valuesById[20] = "UNABLE_TO_OPEN_SIGNED_PHRASE"] = 20;
            values[valuesById[21] = "BAD_REQUEST"] = 21;
            values[valuesById[22] = "INTERNAL_SERVER_ERROR"] = 22;
            values[valuesById[23] = "INVALID_COUNTRY_CODE"] = 23;
            values[valuesById[24] = "INVALID_LENGTH"] = 24;
            values[valuesById[25] = "LINE_TYPE_VOIP"] = 25;
            values[valuesById[26] = "LINE_TYPE_FIXED"] = 26;
            values[valuesById[27] = "LINE_TYPE_OTHER"] = 27;
            values[valuesById[28] = "WRONG_HASHCASH_SOLUTION"] = 28;
            return values;
        })();

        return VerifyOtpResponse;
    })();

    server.ClientOtpRequest = (function() {

        /**
         * Properties of a ClientOtpRequest.
         * @memberof server
         * @interface IClientOtpRequest
         * @property {server.ClientOtpRequest.Method|null} [method] ClientOtpRequest method
         * @property {string|null} [phone] ClientOtpRequest phone
         * @property {string|null} [content] ClientOtpRequest content
         */

        /**
         * Constructs a new ClientOtpRequest.
         * @memberof server
         * @classdesc Represents a ClientOtpRequest.
         * @implements IClientOtpRequest
         * @constructor
         * @param {server.IClientOtpRequest=} [properties] Properties to set
         */
        function ClientOtpRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientOtpRequest method.
         * @member {server.ClientOtpRequest.Method} method
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.method = 0;

        /**
         * ClientOtpRequest phone.
         * @member {string} phone
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.phone = "";

        /**
         * ClientOtpRequest content.
         * @member {string} content
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.content = "";

        /**
         * Creates a new ClientOtpRequest instance using the specified properties.
         * @function create
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest=} [properties] Properties to set
         * @returns {server.ClientOtpRequest} ClientOtpRequest instance
         */
        ClientOtpRequest.create = function create(properties) {
            return new ClientOtpRequest(properties);
        };

        /**
         * Encodes the specified ClientOtpRequest message. Does not implicitly {@link server.ClientOtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest} message ClientOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified ClientOtpRequest message, length delimited. Does not implicitly {@link server.ClientOtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest} message ClientOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientOtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientOtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.method = reader.int32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientOtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientOtpRequest message.
         * @function verify
         * @memberof server.ClientOtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientOtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a ClientOtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientOtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         */
        ClientOtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientOtpRequest)
                return object;
            var message = new $root.server.ClientOtpRequest();
            switch (object.method) {
            case "SMS":
            case 0:
                message.method = 0;
                break;
            case "VOICE_CALL":
            case 1:
                message.method = 1;
                break;
            }
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a ClientOtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.ClientOtpRequest} message ClientOtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientOtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.method = options.enums === String ? "SMS" : 0;
                object.phone = "";
                object.content = "";
            }
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.server.ClientOtpRequest.Method[message.method] : message.method;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this ClientOtpRequest to JSON.
         * @function toJSON
         * @memberof server.ClientOtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientOtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Method enum.
         * @name server.ClientOtpRequest.Method
         * @enum {number}
         * @property {number} SMS=0 SMS value
         * @property {number} VOICE_CALL=1 VOICE_CALL value
         */
        ClientOtpRequest.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SMS"] = 0;
            values[valuesById[1] = "VOICE_CALL"] = 1;
            return values;
        })();

        return ClientOtpRequest;
    })();

    server.ClientOtpResponse = (function() {

        /**
         * Properties of a ClientOtpResponse.
         * @memberof server
         * @interface IClientOtpResponse
         * @property {server.ClientOtpResponse.Result|null} [result] ClientOtpResponse result
         * @property {server.ClientOtpResponse.Reason|null} [reason] ClientOtpResponse reason
         */

        /**
         * Constructs a new ClientOtpResponse.
         * @memberof server
         * @classdesc Represents a ClientOtpResponse.
         * @implements IClientOtpResponse
         * @constructor
         * @param {server.IClientOtpResponse=} [properties] Properties to set
         */
        function ClientOtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientOtpResponse result.
         * @member {server.ClientOtpResponse.Result} result
         * @memberof server.ClientOtpResponse
         * @instance
         */
        ClientOtpResponse.prototype.result = 0;

        /**
         * ClientOtpResponse reason.
         * @member {server.ClientOtpResponse.Reason} reason
         * @memberof server.ClientOtpResponse
         * @instance
         */
        ClientOtpResponse.prototype.reason = 0;

        /**
         * Creates a new ClientOtpResponse instance using the specified properties.
         * @function create
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse=} [properties] Properties to set
         * @returns {server.ClientOtpResponse} ClientOtpResponse instance
         */
        ClientOtpResponse.create = function create(properties) {
            return new ClientOtpResponse(properties);
        };

        /**
         * Encodes the specified ClientOtpResponse message. Does not implicitly {@link server.ClientOtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse} message ClientOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ClientOtpResponse message, length delimited. Does not implicitly {@link server.ClientOtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse} message ClientOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientOtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientOtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientOtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientOtpResponse message.
         * @function verify
         * @memberof server.ClientOtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientOtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a ClientOtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientOtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         */
        ClientOtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientOtpResponse)
                return object;
            var message = new $root.server.ClientOtpResponse();
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "SETUP_ISSUE":
            case 1:
                message.reason = 1;
                break;
            case "PERMISSION_ISSUE":
            case 2:
                message.reason = 2;
                break;
            case "FORMATTING_ISSUE":
            case 3:
                message.reason = 3;
                break;
            case "NETWORKING_ISSUE":
            case 4:
                message.reason = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientOtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.ClientOtpResponse} message ClientOtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientOtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.ClientOtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.ClientOtpResponse.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this ClientOtpResponse to JSON.
         * @function toJSON
         * @memberof server.ClientOtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientOtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.ClientOtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        ClientOtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.ClientOtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} SETUP_ISSUE=1 SETUP_ISSUE value
         * @property {number} PERMISSION_ISSUE=2 PERMISSION_ISSUE value
         * @property {number} FORMATTING_ISSUE=3 FORMATTING_ISSUE value
         * @property {number} NETWORKING_ISSUE=4 NETWORKING_ISSUE value
         */
        ClientOtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "SETUP_ISSUE"] = 1;
            values[valuesById[2] = "PERMISSION_ISSUE"] = 2;
            values[valuesById[3] = "FORMATTING_ISSUE"] = 3;
            values[valuesById[4] = "NETWORKING_ISSUE"] = 4;
            return values;
        })();

        return ClientOtpResponse;
    })();

    server.WakeUp = (function() {

        /**
         * Properties of a WakeUp.
         * @memberof server
         * @interface IWakeUp
         * @property {server.WakeUp.AlertType|null} [alertType] WakeUp alertType
         */

        /**
         * Constructs a new WakeUp.
         * @memberof server
         * @classdesc Represents a WakeUp.
         * @implements IWakeUp
         * @constructor
         * @param {server.IWakeUp=} [properties] Properties to set
         */
        function WakeUp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WakeUp alertType.
         * @member {server.WakeUp.AlertType} alertType
         * @memberof server.WakeUp
         * @instance
         */
        WakeUp.prototype.alertType = 0;

        /**
         * Creates a new WakeUp instance using the specified properties.
         * @function create
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp=} [properties] Properties to set
         * @returns {server.WakeUp} WakeUp instance
         */
        WakeUp.create = function create(properties) {
            return new WakeUp(properties);
        };

        /**
         * Encodes the specified WakeUp message. Does not implicitly {@link server.WakeUp.verify|verify} messages.
         * @function encode
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp} message WakeUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WakeUp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alertType != null && Object.hasOwnProperty.call(message, "alertType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.alertType);
            return writer;
        };

        /**
         * Encodes the specified WakeUp message, length delimited. Does not implicitly {@link server.WakeUp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp} message WakeUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WakeUp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WakeUp message from the specified reader or buffer.
         * @function decode
         * @memberof server.WakeUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WakeUp} WakeUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WakeUp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WakeUp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.alertType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WakeUp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WakeUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WakeUp} WakeUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WakeUp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WakeUp message.
         * @function verify
         * @memberof server.WakeUp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WakeUp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alertType != null && message.hasOwnProperty("alertType"))
                switch (message.alertType) {
                default:
                    return "alertType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a WakeUp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WakeUp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WakeUp} WakeUp
         */
        WakeUp.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WakeUp)
                return object;
            var message = new $root.server.WakeUp();
            switch (object.alertType) {
            case "ALERT":
            case 0:
                message.alertType = 0;
                break;
            case "SILENT":
            case 1:
                message.alertType = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a WakeUp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WakeUp
         * @static
         * @param {server.WakeUp} message WakeUp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WakeUp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.alertType = options.enums === String ? "ALERT" : 0;
            if (message.alertType != null && message.hasOwnProperty("alertType"))
                object.alertType = options.enums === String ? $root.server.WakeUp.AlertType[message.alertType] : message.alertType;
            return object;
        };

        /**
         * Converts this WakeUp to JSON.
         * @function toJSON
         * @memberof server.WakeUp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WakeUp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AlertType enum.
         * @name server.WakeUp.AlertType
         * @enum {number}
         * @property {number} ALERT=0 ALERT value
         * @property {number} SILENT=1 SILENT value
         */
        WakeUp.AlertType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALERT"] = 0;
            values[valuesById[1] = "SILENT"] = 1;
            return values;
        })();

        return WakeUp;
    })();

    server.MarketingAlert = (function() {

        /**
         * Properties of a MarketingAlert.
         * @memberof server
         * @interface IMarketingAlert
         * @property {server.MarketingAlert.Type|null} [type] MarketingAlert type
         */

        /**
         * Constructs a new MarketingAlert.
         * @memberof server
         * @classdesc Represents a MarketingAlert.
         * @implements IMarketingAlert
         * @constructor
         * @param {server.IMarketingAlert=} [properties] Properties to set
         */
        function MarketingAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MarketingAlert type.
         * @member {server.MarketingAlert.Type} type
         * @memberof server.MarketingAlert
         * @instance
         */
        MarketingAlert.prototype.type = 0;

        /**
         * Creates a new MarketingAlert instance using the specified properties.
         * @function create
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert=} [properties] Properties to set
         * @returns {server.MarketingAlert} MarketingAlert instance
         */
        MarketingAlert.create = function create(properties) {
            return new MarketingAlert(properties);
        };

        /**
         * Encodes the specified MarketingAlert message. Does not implicitly {@link server.MarketingAlert.verify|verify} messages.
         * @function encode
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert} message MarketingAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketingAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified MarketingAlert message, length delimited. Does not implicitly {@link server.MarketingAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert} message MarketingAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketingAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MarketingAlert message from the specified reader or buffer.
         * @function decode
         * @memberof server.MarketingAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MarketingAlert} MarketingAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketingAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MarketingAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MarketingAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MarketingAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MarketingAlert} MarketingAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketingAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MarketingAlert message.
         * @function verify
         * @memberof server.MarketingAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MarketingAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a MarketingAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MarketingAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MarketingAlert} MarketingAlert
         */
        MarketingAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MarketingAlert)
                return object;
            var message = new $root.server.MarketingAlert();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "INVITE_FRIENDS":
            case 1:
                message.type = 1;
                break;
            case "SHARE_POST":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MarketingAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MarketingAlert
         * @static
         * @param {server.MarketingAlert} message MarketingAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MarketingAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNKNOWN" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MarketingAlert.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this MarketingAlert to JSON.
         * @function toJSON
         * @memberof server.MarketingAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MarketingAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MarketingAlert.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INVITE_FRIENDS=1 INVITE_FRIENDS value
         * @property {number} SHARE_POST=2 SHARE_POST value
         */
        MarketingAlert.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INVITE_FRIENDS"] = 1;
            values[valuesById[2] = "SHARE_POST"] = 2;
            return values;
        })();

        return MarketingAlert;
    })();

    /**
     * FollowStatus enum.
     * @name server.FollowStatus
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} PENDING=1 PENDING value
     * @property {number} FOLLOWING=2 FOLLOWING value
     */
    server.FollowStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "PENDING"] = 1;
        values[valuesById[2] = "FOLLOWING"] = 2;
        return values;
    })();

    server.BasicUserProfile = (function() {

        /**
         * Properties of a BasicUserProfile.
         * @memberof server
         * @interface IBasicUserProfile
         * @property {number|Long|null} [uid] BasicUserProfile uid
         * @property {string|null} [username] BasicUserProfile username
         * @property {string|null} [name] BasicUserProfile name
         * @property {string|null} [avatarId] BasicUserProfile avatarId
         * @property {server.FollowStatus|null} [followerStatus] BasicUserProfile followerStatus
         * @property {server.FollowStatus|null} [followingStatus] BasicUserProfile followingStatus
         * @property {number|null} [numMutualFollowing] BasicUserProfile numMutualFollowing
         * @property {boolean|null} [blocked] BasicUserProfile blocked
         */

        /**
         * Constructs a new BasicUserProfile.
         * @memberof server
         * @classdesc Represents a BasicUserProfile.
         * @implements IBasicUserProfile
         * @constructor
         * @param {server.IBasicUserProfile=} [properties] Properties to set
         */
        function BasicUserProfile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicUserProfile uid.
         * @member {number|Long} uid
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BasicUserProfile username.
         * @member {string} username
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.username = "";

        /**
         * BasicUserProfile name.
         * @member {string} name
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.name = "";

        /**
         * BasicUserProfile avatarId.
         * @member {string} avatarId
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.avatarId = "";

        /**
         * BasicUserProfile followerStatus.
         * @member {server.FollowStatus} followerStatus
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.followerStatus = 0;

        /**
         * BasicUserProfile followingStatus.
         * @member {server.FollowStatus} followingStatus
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.followingStatus = 0;

        /**
         * BasicUserProfile numMutualFollowing.
         * @member {number} numMutualFollowing
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.numMutualFollowing = 0;

        /**
         * BasicUserProfile blocked.
         * @member {boolean} blocked
         * @memberof server.BasicUserProfile
         * @instance
         */
        BasicUserProfile.prototype.blocked = false;

        /**
         * Creates a new BasicUserProfile instance using the specified properties.
         * @function create
         * @memberof server.BasicUserProfile
         * @static
         * @param {server.IBasicUserProfile=} [properties] Properties to set
         * @returns {server.BasicUserProfile} BasicUserProfile instance
         */
        BasicUserProfile.create = function create(properties) {
            return new BasicUserProfile(properties);
        };

        /**
         * Encodes the specified BasicUserProfile message. Does not implicitly {@link server.BasicUserProfile.verify|verify} messages.
         * @function encode
         * @memberof server.BasicUserProfile
         * @static
         * @param {server.IBasicUserProfile} message BasicUserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUserProfile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.followerStatus != null && Object.hasOwnProperty.call(message, "followerStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.followerStatus);
            if (message.followingStatus != null && Object.hasOwnProperty.call(message, "followingStatus"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.followingStatus);
            if (message.numMutualFollowing != null && Object.hasOwnProperty.call(message, "numMutualFollowing"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.numMutualFollowing);
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.blocked);
            return writer;
        };

        /**
         * Encodes the specified BasicUserProfile message, length delimited. Does not implicitly {@link server.BasicUserProfile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.BasicUserProfile
         * @static
         * @param {server.IBasicUserProfile} message BasicUserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicUserProfile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicUserProfile message from the specified reader or buffer.
         * @function decode
         * @memberof server.BasicUserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.BasicUserProfile} BasicUserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUserProfile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.BasicUserProfile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.followerStatus = reader.int32();
                    break;
                case 6:
                    message.followingStatus = reader.int32();
                    break;
                case 7:
                    message.numMutualFollowing = reader.int32();
                    break;
                case 8:
                    message.blocked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BasicUserProfile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.BasicUserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.BasicUserProfile} BasicUserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicUserProfile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicUserProfile message.
         * @function verify
         * @memberof server.BasicUserProfile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicUserProfile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.followerStatus != null && message.hasOwnProperty("followerStatus"))
                switch (message.followerStatus) {
                default:
                    return "followerStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.followingStatus != null && message.hasOwnProperty("followingStatus"))
                switch (message.followingStatus) {
                default:
                    return "followingStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.numMutualFollowing != null && message.hasOwnProperty("numMutualFollowing"))
                if (!$util.isInteger(message.numMutualFollowing))
                    return "numMutualFollowing: integer expected";
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                if (typeof message.blocked !== "boolean")
                    return "blocked: boolean expected";
            return null;
        };

        /**
         * Creates a BasicUserProfile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.BasicUserProfile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.BasicUserProfile} BasicUserProfile
         */
        BasicUserProfile.fromObject = function fromObject(object) {
            if (object instanceof $root.server.BasicUserProfile)
                return object;
            var message = new $root.server.BasicUserProfile();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.username != null)
                message.username = String(object.username);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            switch (object.followerStatus) {
            case "NONE":
            case 0:
                message.followerStatus = 0;
                break;
            case "PENDING":
            case 1:
                message.followerStatus = 1;
                break;
            case "FOLLOWING":
            case 2:
                message.followerStatus = 2;
                break;
            }
            switch (object.followingStatus) {
            case "NONE":
            case 0:
                message.followingStatus = 0;
                break;
            case "PENDING":
            case 1:
                message.followingStatus = 1;
                break;
            case "FOLLOWING":
            case 2:
                message.followingStatus = 2;
                break;
            }
            if (object.numMutualFollowing != null)
                message.numMutualFollowing = object.numMutualFollowing | 0;
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            return message;
        };

        /**
         * Creates a plain object from a BasicUserProfile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.BasicUserProfile
         * @static
         * @param {server.BasicUserProfile} message BasicUserProfile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicUserProfile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.username = "";
                object.name = "";
                object.avatarId = "";
                object.followerStatus = options.enums === String ? "NONE" : 0;
                object.followingStatus = options.enums === String ? "NONE" : 0;
                object.numMutualFollowing = 0;
                object.blocked = false;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.followerStatus != null && message.hasOwnProperty("followerStatus"))
                object.followerStatus = options.enums === String ? $root.server.FollowStatus[message.followerStatus] : message.followerStatus;
            if (message.followingStatus != null && message.hasOwnProperty("followingStatus"))
                object.followingStatus = options.enums === String ? $root.server.FollowStatus[message.followingStatus] : message.followingStatus;
            if (message.numMutualFollowing != null && message.hasOwnProperty("numMutualFollowing"))
                object.numMutualFollowing = message.numMutualFollowing;
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            return object;
        };

        /**
         * Converts this BasicUserProfile to JSON.
         * @function toJSON
         * @memberof server.BasicUserProfile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicUserProfile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicUserProfile;
    })();

    server.UserProfile = (function() {

        /**
         * Properties of a UserProfile.
         * @memberof server
         * @interface IUserProfile
         * @property {number|Long|null} [uid] UserProfile uid
         * @property {string|null} [username] UserProfile username
         * @property {string|null} [name] UserProfile name
         * @property {string|null} [avatarId] UserProfile avatarId
         * @property {server.FollowStatus|null} [followerStatus] UserProfile followerStatus
         * @property {server.FollowStatus|null} [followingStatus] UserProfile followingStatus
         * @property {number|null} [numMutualFollowing] UserProfile numMutualFollowing
         * @property {string|null} [bio] UserProfile bio
         * @property {Array.<server.ILink>|null} [links] UserProfile links
         * @property {Array.<server.IBasicUserProfile>|null} [relevantFollowers] UserProfile relevantFollowers
         * @property {boolean|null} [blocked] UserProfile blocked
         * @property {number|null} [totalPostImpressions] UserProfile totalPostImpressions
         * @property {number|null} [totalPostReactions] UserProfile totalPostReactions
         * @property {number|null} [totalNumPosts] UserProfile totalNumPosts
         */

        /**
         * Constructs a new UserProfile.
         * @memberof server
         * @classdesc Represents a UserProfile.
         * @implements IUserProfile
         * @constructor
         * @param {server.IUserProfile=} [properties] Properties to set
         */
        function UserProfile(properties) {
            this.links = [];
            this.relevantFollowers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserProfile uid.
         * @member {number|Long} uid
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserProfile username.
         * @member {string} username
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.username = "";

        /**
         * UserProfile name.
         * @member {string} name
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.name = "";

        /**
         * UserProfile avatarId.
         * @member {string} avatarId
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.avatarId = "";

        /**
         * UserProfile followerStatus.
         * @member {server.FollowStatus} followerStatus
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.followerStatus = 0;

        /**
         * UserProfile followingStatus.
         * @member {server.FollowStatus} followingStatus
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.followingStatus = 0;

        /**
         * UserProfile numMutualFollowing.
         * @member {number} numMutualFollowing
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.numMutualFollowing = 0;

        /**
         * UserProfile bio.
         * @member {string} bio
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.bio = "";

        /**
         * UserProfile links.
         * @member {Array.<server.ILink>} links
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.links = $util.emptyArray;

        /**
         * UserProfile relevantFollowers.
         * @member {Array.<server.IBasicUserProfile>} relevantFollowers
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.relevantFollowers = $util.emptyArray;

        /**
         * UserProfile blocked.
         * @member {boolean} blocked
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.blocked = false;

        /**
         * UserProfile totalPostImpressions.
         * @member {number} totalPostImpressions
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.totalPostImpressions = 0;

        /**
         * UserProfile totalPostReactions.
         * @member {number} totalPostReactions
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.totalPostReactions = 0;

        /**
         * UserProfile totalNumPosts.
         * @member {number} totalNumPosts
         * @memberof server.UserProfile
         * @instance
         */
        UserProfile.prototype.totalNumPosts = 0;

        /**
         * Creates a new UserProfile instance using the specified properties.
         * @function create
         * @memberof server.UserProfile
         * @static
         * @param {server.IUserProfile=} [properties] Properties to set
         * @returns {server.UserProfile} UserProfile instance
         */
        UserProfile.create = function create(properties) {
            return new UserProfile(properties);
        };

        /**
         * Encodes the specified UserProfile message. Does not implicitly {@link server.UserProfile.verify|verify} messages.
         * @function encode
         * @memberof server.UserProfile
         * @static
         * @param {server.IUserProfile} message UserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.followerStatus != null && Object.hasOwnProperty.call(message, "followerStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.followerStatus);
            if (message.followingStatus != null && Object.hasOwnProperty.call(message, "followingStatus"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.followingStatus);
            if (message.numMutualFollowing != null && Object.hasOwnProperty.call(message, "numMutualFollowing"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.numMutualFollowing);
            if (message.bio != null && Object.hasOwnProperty.call(message, "bio"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.bio);
            if (message.links != null && message.links.length)
                for (var i = 0; i < message.links.length; ++i)
                    $root.server.Link.encode(message.links[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.relevantFollowers != null && message.relevantFollowers.length)
                for (var i = 0; i < message.relevantFollowers.length; ++i)
                    $root.server.BasicUserProfile.encode(message.relevantFollowers[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.blocked != null && Object.hasOwnProperty.call(message, "blocked"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.blocked);
            if (message.totalPostImpressions != null && Object.hasOwnProperty.call(message, "totalPostImpressions"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.totalPostImpressions);
            if (message.totalPostReactions != null && Object.hasOwnProperty.call(message, "totalPostReactions"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.totalPostReactions);
            if (message.totalNumPosts != null && Object.hasOwnProperty.call(message, "totalNumPosts"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.totalNumPosts);
            return writer;
        };

        /**
         * Encodes the specified UserProfile message, length delimited. Does not implicitly {@link server.UserProfile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UserProfile
         * @static
         * @param {server.IUserProfile} message UserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserProfile message from the specified reader or buffer.
         * @function decode
         * @memberof server.UserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UserProfile} UserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UserProfile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.followerStatus = reader.int32();
                    break;
                case 6:
                    message.followingStatus = reader.int32();
                    break;
                case 7:
                    message.numMutualFollowing = reader.int32();
                    break;
                case 8:
                    message.bio = reader.string();
                    break;
                case 9:
                    if (!(message.links && message.links.length))
                        message.links = [];
                    message.links.push($root.server.Link.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.relevantFollowers && message.relevantFollowers.length))
                        message.relevantFollowers = [];
                    message.relevantFollowers.push($root.server.BasicUserProfile.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.blocked = reader.bool();
                    break;
                case 12:
                    message.totalPostImpressions = reader.int32();
                    break;
                case 13:
                    message.totalPostReactions = reader.int32();
                    break;
                case 14:
                    message.totalNumPosts = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserProfile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UserProfile} UserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserProfile message.
         * @function verify
         * @memberof server.UserProfile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserProfile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.followerStatus != null && message.hasOwnProperty("followerStatus"))
                switch (message.followerStatus) {
                default:
                    return "followerStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.followingStatus != null && message.hasOwnProperty("followingStatus"))
                switch (message.followingStatus) {
                default:
                    return "followingStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.numMutualFollowing != null && message.hasOwnProperty("numMutualFollowing"))
                if (!$util.isInteger(message.numMutualFollowing))
                    return "numMutualFollowing: integer expected";
            if (message.bio != null && message.hasOwnProperty("bio"))
                if (!$util.isString(message.bio))
                    return "bio: string expected";
            if (message.links != null && message.hasOwnProperty("links")) {
                if (!Array.isArray(message.links))
                    return "links: array expected";
                for (var i = 0; i < message.links.length; ++i) {
                    var error = $root.server.Link.verify(message.links[i]);
                    if (error)
                        return "links." + error;
                }
            }
            if (message.relevantFollowers != null && message.hasOwnProperty("relevantFollowers")) {
                if (!Array.isArray(message.relevantFollowers))
                    return "relevantFollowers: array expected";
                for (var i = 0; i < message.relevantFollowers.length; ++i) {
                    var error = $root.server.BasicUserProfile.verify(message.relevantFollowers[i]);
                    if (error)
                        return "relevantFollowers." + error;
                }
            }
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                if (typeof message.blocked !== "boolean")
                    return "blocked: boolean expected";
            if (message.totalPostImpressions != null && message.hasOwnProperty("totalPostImpressions"))
                if (!$util.isInteger(message.totalPostImpressions))
                    return "totalPostImpressions: integer expected";
            if (message.totalPostReactions != null && message.hasOwnProperty("totalPostReactions"))
                if (!$util.isInteger(message.totalPostReactions))
                    return "totalPostReactions: integer expected";
            if (message.totalNumPosts != null && message.hasOwnProperty("totalNumPosts"))
                if (!$util.isInteger(message.totalNumPosts))
                    return "totalNumPosts: integer expected";
            return null;
        };

        /**
         * Creates a UserProfile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UserProfile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UserProfile} UserProfile
         */
        UserProfile.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UserProfile)
                return object;
            var message = new $root.server.UserProfile();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.username != null)
                message.username = String(object.username);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            switch (object.followerStatus) {
            case "NONE":
            case 0:
                message.followerStatus = 0;
                break;
            case "PENDING":
            case 1:
                message.followerStatus = 1;
                break;
            case "FOLLOWING":
            case 2:
                message.followerStatus = 2;
                break;
            }
            switch (object.followingStatus) {
            case "NONE":
            case 0:
                message.followingStatus = 0;
                break;
            case "PENDING":
            case 1:
                message.followingStatus = 1;
                break;
            case "FOLLOWING":
            case 2:
                message.followingStatus = 2;
                break;
            }
            if (object.numMutualFollowing != null)
                message.numMutualFollowing = object.numMutualFollowing | 0;
            if (object.bio != null)
                message.bio = String(object.bio);
            if (object.links) {
                if (!Array.isArray(object.links))
                    throw TypeError(".server.UserProfile.links: array expected");
                message.links = [];
                for (var i = 0; i < object.links.length; ++i) {
                    if (typeof object.links[i] !== "object")
                        throw TypeError(".server.UserProfile.links: object expected");
                    message.links[i] = $root.server.Link.fromObject(object.links[i]);
                }
            }
            if (object.relevantFollowers) {
                if (!Array.isArray(object.relevantFollowers))
                    throw TypeError(".server.UserProfile.relevantFollowers: array expected");
                message.relevantFollowers = [];
                for (var i = 0; i < object.relevantFollowers.length; ++i) {
                    if (typeof object.relevantFollowers[i] !== "object")
                        throw TypeError(".server.UserProfile.relevantFollowers: object expected");
                    message.relevantFollowers[i] = $root.server.BasicUserProfile.fromObject(object.relevantFollowers[i]);
                }
            }
            if (object.blocked != null)
                message.blocked = Boolean(object.blocked);
            if (object.totalPostImpressions != null)
                message.totalPostImpressions = object.totalPostImpressions | 0;
            if (object.totalPostReactions != null)
                message.totalPostReactions = object.totalPostReactions | 0;
            if (object.totalNumPosts != null)
                message.totalNumPosts = object.totalNumPosts | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserProfile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UserProfile
         * @static
         * @param {server.UserProfile} message UserProfile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserProfile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.links = [];
                object.relevantFollowers = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.username = "";
                object.name = "";
                object.avatarId = "";
                object.followerStatus = options.enums === String ? "NONE" : 0;
                object.followingStatus = options.enums === String ? "NONE" : 0;
                object.numMutualFollowing = 0;
                object.bio = "";
                object.blocked = false;
                object.totalPostImpressions = 0;
                object.totalPostReactions = 0;
                object.totalNumPosts = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.followerStatus != null && message.hasOwnProperty("followerStatus"))
                object.followerStatus = options.enums === String ? $root.server.FollowStatus[message.followerStatus] : message.followerStatus;
            if (message.followingStatus != null && message.hasOwnProperty("followingStatus"))
                object.followingStatus = options.enums === String ? $root.server.FollowStatus[message.followingStatus] : message.followingStatus;
            if (message.numMutualFollowing != null && message.hasOwnProperty("numMutualFollowing"))
                object.numMutualFollowing = message.numMutualFollowing;
            if (message.bio != null && message.hasOwnProperty("bio"))
                object.bio = message.bio;
            if (message.links && message.links.length) {
                object.links = [];
                for (var j = 0; j < message.links.length; ++j)
                    object.links[j] = $root.server.Link.toObject(message.links[j], options);
            }
            if (message.relevantFollowers && message.relevantFollowers.length) {
                object.relevantFollowers = [];
                for (var j = 0; j < message.relevantFollowers.length; ++j)
                    object.relevantFollowers[j] = $root.server.BasicUserProfile.toObject(message.relevantFollowers[j], options);
            }
            if (message.blocked != null && message.hasOwnProperty("blocked"))
                object.blocked = message.blocked;
            if (message.totalPostImpressions != null && message.hasOwnProperty("totalPostImpressions"))
                object.totalPostImpressions = message.totalPostImpressions;
            if (message.totalPostReactions != null && message.hasOwnProperty("totalPostReactions"))
                object.totalPostReactions = message.totalPostReactions;
            if (message.totalNumPosts != null && message.hasOwnProperty("totalNumPosts"))
                object.totalNumPosts = message.totalNumPosts;
            return object;
        };

        /**
         * Converts this UserProfile to JSON.
         * @function toJSON
         * @memberof server.UserProfile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserProfile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserProfile;
    })();

    server.PostMetrics = (function() {

        /**
         * Properties of a PostMetrics.
         * @memberof server
         * @interface IPostMetrics
         * @property {number|null} [numImpressions] PostMetrics numImpressions
         */

        /**
         * Constructs a new PostMetrics.
         * @memberof server
         * @classdesc Represents a PostMetrics.
         * @implements IPostMetrics
         * @constructor
         * @param {server.IPostMetrics=} [properties] Properties to set
         */
        function PostMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostMetrics numImpressions.
         * @member {number} numImpressions
         * @memberof server.PostMetrics
         * @instance
         */
        PostMetrics.prototype.numImpressions = 0;

        /**
         * Creates a new PostMetrics instance using the specified properties.
         * @function create
         * @memberof server.PostMetrics
         * @static
         * @param {server.IPostMetrics=} [properties] Properties to set
         * @returns {server.PostMetrics} PostMetrics instance
         */
        PostMetrics.create = function create(properties) {
            return new PostMetrics(properties);
        };

        /**
         * Encodes the specified PostMetrics message. Does not implicitly {@link server.PostMetrics.verify|verify} messages.
         * @function encode
         * @memberof server.PostMetrics
         * @static
         * @param {server.IPostMetrics} message PostMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numImpressions != null && Object.hasOwnProperty.call(message, "numImpressions"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numImpressions);
            return writer;
        };

        /**
         * Encodes the specified PostMetrics message, length delimited. Does not implicitly {@link server.PostMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PostMetrics
         * @static
         * @param {server.IPostMetrics} message PostMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof server.PostMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PostMetrics} PostMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetrics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PostMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.numImpressions = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PostMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PostMetrics} PostMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostMetrics message.
         * @function verify
         * @memberof server.PostMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numImpressions != null && message.hasOwnProperty("numImpressions"))
                if (!$util.isInteger(message.numImpressions))
                    return "numImpressions: integer expected";
            return null;
        };

        /**
         * Creates a PostMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PostMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PostMetrics} PostMetrics
         */
        PostMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PostMetrics)
                return object;
            var message = new $root.server.PostMetrics();
            if (object.numImpressions != null)
                message.numImpressions = object.numImpressions | 0;
            return message;
        };

        /**
         * Creates a plain object from a PostMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PostMetrics
         * @static
         * @param {server.PostMetrics} message PostMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.numImpressions = 0;
            if (message.numImpressions != null && message.hasOwnProperty("numImpressions"))
                object.numImpressions = message.numImpressions;
            return object;
        };

        /**
         * Converts this PostMetrics to JSON.
         * @function toJSON
         * @memberof server.PostMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PostMetrics;
    })();

    server.ProfileUpdate = (function() {

        /**
         * Properties of a ProfileUpdate.
         * @memberof server
         * @interface IProfileUpdate
         * @property {server.ProfileUpdate.Type|null} [type] ProfileUpdate type
         * @property {server.IBasicUserProfile|null} [profile] ProfileUpdate profile
         */

        /**
         * Constructs a new ProfileUpdate.
         * @memberof server
         * @classdesc Represents a ProfileUpdate.
         * @implements IProfileUpdate
         * @constructor
         * @param {server.IProfileUpdate=} [properties] Properties to set
         */
        function ProfileUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProfileUpdate type.
         * @member {server.ProfileUpdate.Type} type
         * @memberof server.ProfileUpdate
         * @instance
         */
        ProfileUpdate.prototype.type = 0;

        /**
         * ProfileUpdate profile.
         * @member {server.IBasicUserProfile|null|undefined} profile
         * @memberof server.ProfileUpdate
         * @instance
         */
        ProfileUpdate.prototype.profile = null;

        /**
         * Creates a new ProfileUpdate instance using the specified properties.
         * @function create
         * @memberof server.ProfileUpdate
         * @static
         * @param {server.IProfileUpdate=} [properties] Properties to set
         * @returns {server.ProfileUpdate} ProfileUpdate instance
         */
        ProfileUpdate.create = function create(properties) {
            return new ProfileUpdate(properties);
        };

        /**
         * Encodes the specified ProfileUpdate message. Does not implicitly {@link server.ProfileUpdate.verify|verify} messages.
         * @function encode
         * @memberof server.ProfileUpdate
         * @static
         * @param {server.IProfileUpdate} message ProfileUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.server.BasicUserProfile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProfileUpdate message, length delimited. Does not implicitly {@link server.ProfileUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ProfileUpdate
         * @static
         * @param {server.IProfileUpdate} message ProfileUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProfileUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof server.ProfileUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ProfileUpdate} ProfileUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ProfileUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.profile = $root.server.BasicUserProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProfileUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ProfileUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ProfileUpdate} ProfileUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProfileUpdate message.
         * @function verify
         * @memberof server.ProfileUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProfileUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.server.BasicUserProfile.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a ProfileUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ProfileUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ProfileUpdate} ProfileUpdate
         */
        ProfileUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ProfileUpdate)
                return object;
            var message = new $root.server.ProfileUpdate();
            switch (object.type) {
            case "NORMAL":
            case 0:
                message.type = 0;
                break;
            case "DELETE":
            case 1:
                message.type = 1;
                break;
            case "FOLLOWER_NOTICE":
            case 2:
                message.type = 2;
                break;
            case "CONTACT_NOTICE":
            case 3:
                message.type = 3;
                break;
            }
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".server.ProfileUpdate.profile: object expected");
                message.profile = $root.server.BasicUserProfile.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProfileUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ProfileUpdate
         * @static
         * @param {server.ProfileUpdate} message ProfileUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProfileUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "NORMAL" : 0;
                object.profile = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ProfileUpdate.Type[message.type] : message.type;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.server.BasicUserProfile.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this ProfileUpdate to JSON.
         * @function toJSON
         * @memberof server.ProfileUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProfileUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ProfileUpdate.Type
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} DELETE=1 DELETE value
         * @property {number} FOLLOWER_NOTICE=2 FOLLOWER_NOTICE value
         * @property {number} CONTACT_NOTICE=3 CONTACT_NOTICE value
         */
        ProfileUpdate.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            values[valuesById[2] = "FOLLOWER_NOTICE"] = 2;
            values[valuesById[3] = "CONTACT_NOTICE"] = 3;
            return values;
        })();

        return ProfileUpdate;
    })();

    server.UserProfileRequest = (function() {

        /**
         * Properties of a UserProfileRequest.
         * @memberof server
         * @interface IUserProfileRequest
         * @property {number|Long|null} [uid] UserProfileRequest uid
         * @property {string|null} [username] UserProfileRequest username
         */

        /**
         * Constructs a new UserProfileRequest.
         * @memberof server
         * @classdesc Represents a UserProfileRequest.
         * @implements IUserProfileRequest
         * @constructor
         * @param {server.IUserProfileRequest=} [properties] Properties to set
         */
        function UserProfileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserProfileRequest uid.
         * @member {number|Long} uid
         * @memberof server.UserProfileRequest
         * @instance
         */
        UserProfileRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserProfileRequest username.
         * @member {string} username
         * @memberof server.UserProfileRequest
         * @instance
         */
        UserProfileRequest.prototype.username = "";

        /**
         * Creates a new UserProfileRequest instance using the specified properties.
         * @function create
         * @memberof server.UserProfileRequest
         * @static
         * @param {server.IUserProfileRequest=} [properties] Properties to set
         * @returns {server.UserProfileRequest} UserProfileRequest instance
         */
        UserProfileRequest.create = function create(properties) {
            return new UserProfileRequest(properties);
        };

        /**
         * Encodes the specified UserProfileRequest message. Does not implicitly {@link server.UserProfileRequest.verify|verify} messages.
         * @function encode
         * @memberof server.UserProfileRequest
         * @static
         * @param {server.IUserProfileRequest} message UserProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified UserProfileRequest message, length delimited. Does not implicitly {@link server.UserProfileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UserProfileRequest
         * @static
         * @param {server.IUserProfileRequest} message UserProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserProfileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.UserProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UserProfileRequest} UserProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UserProfileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserProfileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UserProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UserProfileRequest} UserProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserProfileRequest message.
         * @function verify
         * @memberof server.UserProfileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserProfileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a UserProfileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UserProfileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UserProfileRequest} UserProfileRequest
         */
        UserProfileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UserProfileRequest)
                return object;
            var message = new $root.server.UserProfileRequest();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a UserProfileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UserProfileRequest
         * @static
         * @param {server.UserProfileRequest} message UserProfileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserProfileRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.username = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this UserProfileRequest to JSON.
         * @function toJSON
         * @memberof server.UserProfileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserProfileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserProfileRequest;
    })();

    server.UserProfileResult = (function() {

        /**
         * Properties of a UserProfileResult.
         * @memberof server
         * @interface IUserProfileResult
         * @property {server.UserProfileResult.Result|null} [result] UserProfileResult result
         * @property {server.UserProfileResult.Reason|null} [reason] UserProfileResult reason
         * @property {server.IUserProfile|null} [profile] UserProfileResult profile
         * @property {Array.<server.IPost>|null} [recentPosts] UserProfileResult recentPosts
         */

        /**
         * Constructs a new UserProfileResult.
         * @memberof server
         * @classdesc Represents a UserProfileResult.
         * @implements IUserProfileResult
         * @constructor
         * @param {server.IUserProfileResult=} [properties] Properties to set
         */
        function UserProfileResult(properties) {
            this.recentPosts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserProfileResult result.
         * @member {server.UserProfileResult.Result} result
         * @memberof server.UserProfileResult
         * @instance
         */
        UserProfileResult.prototype.result = 0;

        /**
         * UserProfileResult reason.
         * @member {server.UserProfileResult.Reason} reason
         * @memberof server.UserProfileResult
         * @instance
         */
        UserProfileResult.prototype.reason = 0;

        /**
         * UserProfileResult profile.
         * @member {server.IUserProfile|null|undefined} profile
         * @memberof server.UserProfileResult
         * @instance
         */
        UserProfileResult.prototype.profile = null;

        /**
         * UserProfileResult recentPosts.
         * @member {Array.<server.IPost>} recentPosts
         * @memberof server.UserProfileResult
         * @instance
         */
        UserProfileResult.prototype.recentPosts = $util.emptyArray;

        /**
         * Creates a new UserProfileResult instance using the specified properties.
         * @function create
         * @memberof server.UserProfileResult
         * @static
         * @param {server.IUserProfileResult=} [properties] Properties to set
         * @returns {server.UserProfileResult} UserProfileResult instance
         */
        UserProfileResult.create = function create(properties) {
            return new UserProfileResult(properties);
        };

        /**
         * Encodes the specified UserProfileResult message. Does not implicitly {@link server.UserProfileResult.verify|verify} messages.
         * @function encode
         * @memberof server.UserProfileResult
         * @static
         * @param {server.IUserProfileResult} message UserProfileResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfileResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.server.UserProfile.encode(message.profile, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.recentPosts != null && message.recentPosts.length)
                for (var i = 0; i < message.recentPosts.length; ++i)
                    $root.server.Post.encode(message.recentPosts[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserProfileResult message, length delimited. Does not implicitly {@link server.UserProfileResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UserProfileResult
         * @static
         * @param {server.IUserProfileResult} message UserProfileResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserProfileResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserProfileResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.UserProfileResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UserProfileResult} UserProfileResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfileResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UserProfileResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.profile = $root.server.UserProfile.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.recentPosts && message.recentPosts.length))
                        message.recentPosts = [];
                    message.recentPosts.push($root.server.Post.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserProfileResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UserProfileResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UserProfileResult} UserProfileResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserProfileResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserProfileResult message.
         * @function verify
         * @memberof server.UserProfileResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserProfileResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.server.UserProfile.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            if (message.recentPosts != null && message.hasOwnProperty("recentPosts")) {
                if (!Array.isArray(message.recentPosts))
                    return "recentPosts: array expected";
                for (var i = 0; i < message.recentPosts.length; ++i) {
                    var error = $root.server.Post.verify(message.recentPosts[i]);
                    if (error)
                        return "recentPosts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserProfileResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UserProfileResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UserProfileResult} UserProfileResult
         */
        UserProfileResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UserProfileResult)
                return object;
            var message = new $root.server.UserProfileResult();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "NO_USER":
            case 1:
                message.reason = 1;
                break;
            }
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".server.UserProfileResult.profile: object expected");
                message.profile = $root.server.UserProfile.fromObject(object.profile);
            }
            if (object.recentPosts) {
                if (!Array.isArray(object.recentPosts))
                    throw TypeError(".server.UserProfileResult.recentPosts: array expected");
                message.recentPosts = [];
                for (var i = 0; i < object.recentPosts.length; ++i) {
                    if (typeof object.recentPosts[i] !== "object")
                        throw TypeError(".server.UserProfileResult.recentPosts: object expected");
                    message.recentPosts[i] = $root.server.Post.fromObject(object.recentPosts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserProfileResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UserProfileResult
         * @static
         * @param {server.UserProfileResult} message UserProfileResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserProfileResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recentPosts = [];
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.profile = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.UserProfileResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.UserProfileResult.Reason[message.reason] : message.reason;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.server.UserProfile.toObject(message.profile, options);
            if (message.recentPosts && message.recentPosts.length) {
                object.recentPosts = [];
                for (var j = 0; j < message.recentPosts.length; ++j)
                    object.recentPosts[j] = $root.server.Post.toObject(message.recentPosts[j], options);
            }
            return object;
        };

        /**
         * Converts this UserProfileResult to JSON.
         * @function toJSON
         * @memberof server.UserProfileResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserProfileResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.UserProfileResult.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        UserProfileResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.UserProfileResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} NO_USER=1 NO_USER value
         */
        UserProfileResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "NO_USER"] = 1;
            return values;
        })();

        return UserProfileResult;
    })();

    server.PostMetricsRequest = (function() {

        /**
         * Properties of a PostMetricsRequest.
         * @memberof server
         * @interface IPostMetricsRequest
         * @property {string|null} [postId] PostMetricsRequest postId
         */

        /**
         * Constructs a new PostMetricsRequest.
         * @memberof server
         * @classdesc Represents a PostMetricsRequest.
         * @implements IPostMetricsRequest
         * @constructor
         * @param {server.IPostMetricsRequest=} [properties] Properties to set
         */
        function PostMetricsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostMetricsRequest postId.
         * @member {string} postId
         * @memberof server.PostMetricsRequest
         * @instance
         */
        PostMetricsRequest.prototype.postId = "";

        /**
         * Creates a new PostMetricsRequest instance using the specified properties.
         * @function create
         * @memberof server.PostMetricsRequest
         * @static
         * @param {server.IPostMetricsRequest=} [properties] Properties to set
         * @returns {server.PostMetricsRequest} PostMetricsRequest instance
         */
        PostMetricsRequest.create = function create(properties) {
            return new PostMetricsRequest(properties);
        };

        /**
         * Encodes the specified PostMetricsRequest message. Does not implicitly {@link server.PostMetricsRequest.verify|verify} messages.
         * @function encode
         * @memberof server.PostMetricsRequest
         * @static
         * @param {server.IPostMetricsRequest} message PostMetricsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetricsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.postId);
            return writer;
        };

        /**
         * Encodes the specified PostMetricsRequest message, length delimited. Does not implicitly {@link server.PostMetricsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PostMetricsRequest
         * @static
         * @param {server.IPostMetricsRequest} message PostMetricsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetricsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostMetricsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.PostMetricsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PostMetricsRequest} PostMetricsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetricsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PostMetricsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.postId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostMetricsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PostMetricsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PostMetricsRequest} PostMetricsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetricsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostMetricsRequest message.
         * @function verify
         * @memberof server.PostMetricsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostMetricsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isString(message.postId))
                    return "postId: string expected";
            return null;
        };

        /**
         * Creates a PostMetricsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PostMetricsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PostMetricsRequest} PostMetricsRequest
         */
        PostMetricsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PostMetricsRequest)
                return object;
            var message = new $root.server.PostMetricsRequest();
            if (object.postId != null)
                message.postId = String(object.postId);
            return message;
        };

        /**
         * Creates a plain object from a PostMetricsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PostMetricsRequest
         * @static
         * @param {server.PostMetricsRequest} message PostMetricsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostMetricsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.postId = "";
            if (message.postId != null && message.hasOwnProperty("postId"))
                object.postId = message.postId;
            return object;
        };

        /**
         * Converts this PostMetricsRequest to JSON.
         * @function toJSON
         * @memberof server.PostMetricsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostMetricsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PostMetricsRequest;
    })();

    server.PostMetricsResult = (function() {

        /**
         * Properties of a PostMetricsResult.
         * @memberof server
         * @interface IPostMetricsResult
         * @property {server.PostMetricsResult.Result|null} [result] PostMetricsResult result
         * @property {server.PostMetricsResult.Reason|null} [reason] PostMetricsResult reason
         * @property {server.IPostMetrics|null} [postMetrics] PostMetricsResult postMetrics
         */

        /**
         * Constructs a new PostMetricsResult.
         * @memberof server
         * @classdesc Represents a PostMetricsResult.
         * @implements IPostMetricsResult
         * @constructor
         * @param {server.IPostMetricsResult=} [properties] Properties to set
         */
        function PostMetricsResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostMetricsResult result.
         * @member {server.PostMetricsResult.Result} result
         * @memberof server.PostMetricsResult
         * @instance
         */
        PostMetricsResult.prototype.result = 0;

        /**
         * PostMetricsResult reason.
         * @member {server.PostMetricsResult.Reason} reason
         * @memberof server.PostMetricsResult
         * @instance
         */
        PostMetricsResult.prototype.reason = 0;

        /**
         * PostMetricsResult postMetrics.
         * @member {server.IPostMetrics|null|undefined} postMetrics
         * @memberof server.PostMetricsResult
         * @instance
         */
        PostMetricsResult.prototype.postMetrics = null;

        /**
         * Creates a new PostMetricsResult instance using the specified properties.
         * @function create
         * @memberof server.PostMetricsResult
         * @static
         * @param {server.IPostMetricsResult=} [properties] Properties to set
         * @returns {server.PostMetricsResult} PostMetricsResult instance
         */
        PostMetricsResult.create = function create(properties) {
            return new PostMetricsResult(properties);
        };

        /**
         * Encodes the specified PostMetricsResult message. Does not implicitly {@link server.PostMetricsResult.verify|verify} messages.
         * @function encode
         * @memberof server.PostMetricsResult
         * @static
         * @param {server.IPostMetricsResult} message PostMetricsResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetricsResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.postMetrics != null && Object.hasOwnProperty.call(message, "postMetrics"))
                $root.server.PostMetrics.encode(message.postMetrics, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PostMetricsResult message, length delimited. Does not implicitly {@link server.PostMetricsResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PostMetricsResult
         * @static
         * @param {server.IPostMetricsResult} message PostMetricsResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostMetricsResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostMetricsResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.PostMetricsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PostMetricsResult} PostMetricsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetricsResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PostMetricsResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.postMetrics = $root.server.PostMetrics.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostMetricsResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PostMetricsResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PostMetricsResult} PostMetricsResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostMetricsResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostMetricsResult message.
         * @function verify
         * @memberof server.PostMetricsResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostMetricsResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.postMetrics != null && message.hasOwnProperty("postMetrics")) {
                var error = $root.server.PostMetrics.verify(message.postMetrics);
                if (error)
                    return "postMetrics." + error;
            }
            return null;
        };

        /**
         * Creates a PostMetricsResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PostMetricsResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PostMetricsResult} PostMetricsResult
         */
        PostMetricsResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PostMetricsResult)
                return object;
            var message = new $root.server.PostMetricsResult();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "NO_POST":
            case 1:
                message.reason = 1;
                break;
            }
            if (object.postMetrics != null) {
                if (typeof object.postMetrics !== "object")
                    throw TypeError(".server.PostMetricsResult.postMetrics: object expected");
                message.postMetrics = $root.server.PostMetrics.fromObject(object.postMetrics);
            }
            return message;
        };

        /**
         * Creates a plain object from a PostMetricsResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PostMetricsResult
         * @static
         * @param {server.PostMetricsResult} message PostMetricsResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostMetricsResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.postMetrics = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.PostMetricsResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.PostMetricsResult.Reason[message.reason] : message.reason;
            if (message.postMetrics != null && message.hasOwnProperty("postMetrics"))
                object.postMetrics = $root.server.PostMetrics.toObject(message.postMetrics, options);
            return object;
        };

        /**
         * Converts this PostMetricsResult to JSON.
         * @function toJSON
         * @memberof server.PostMetricsResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostMetricsResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.PostMetricsResult.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        PostMetricsResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.PostMetricsResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} NO_POST=1 NO_POST value
         */
        PostMetricsResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "NO_POST"] = 1;
            return values;
        })();

        return PostMetricsResult;
    })();

    server.RelationshipRequest = (function() {

        /**
         * Properties of a RelationshipRequest.
         * @memberof server
         * @interface IRelationshipRequest
         * @property {server.RelationshipRequest.Action|null} [action] RelationshipRequest action
         * @property {number|Long|null} [uid] RelationshipRequest uid
         */

        /**
         * Constructs a new RelationshipRequest.
         * @memberof server
         * @classdesc Represents a RelationshipRequest.
         * @implements IRelationshipRequest
         * @constructor
         * @param {server.IRelationshipRequest=} [properties] Properties to set
         */
        function RelationshipRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelationshipRequest action.
         * @member {server.RelationshipRequest.Action} action
         * @memberof server.RelationshipRequest
         * @instance
         */
        RelationshipRequest.prototype.action = 0;

        /**
         * RelationshipRequest uid.
         * @member {number|Long} uid
         * @memberof server.RelationshipRequest
         * @instance
         */
        RelationshipRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RelationshipRequest instance using the specified properties.
         * @function create
         * @memberof server.RelationshipRequest
         * @static
         * @param {server.IRelationshipRequest=} [properties] Properties to set
         * @returns {server.RelationshipRequest} RelationshipRequest instance
         */
        RelationshipRequest.create = function create(properties) {
            return new RelationshipRequest(properties);
        };

        /**
         * Encodes the specified RelationshipRequest message. Does not implicitly {@link server.RelationshipRequest.verify|verify} messages.
         * @function encode
         * @memberof server.RelationshipRequest
         * @static
         * @param {server.IRelationshipRequest} message RelationshipRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified RelationshipRequest message, length delimited. Does not implicitly {@link server.RelationshipRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RelationshipRequest
         * @static
         * @param {server.IRelationshipRequest} message RelationshipRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RelationshipRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.RelationshipRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RelationshipRequest} RelationshipRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RelationshipRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RelationshipRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RelationshipRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RelationshipRequest} RelationshipRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RelationshipRequest message.
         * @function verify
         * @memberof server.RelationshipRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelationshipRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates a RelationshipRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RelationshipRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RelationshipRequest} RelationshipRequest
         */
        RelationshipRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RelationshipRequest)
                return object;
            var message = new $root.server.RelationshipRequest();
            switch (object.action) {
            case "FOLLOW":
            case 0:
                message.action = 0;
                break;
            case "UNFOLLOW":
            case 1:
                message.action = 1;
                break;
            case "ACCEPT_FOLLOW":
            case 2:
                message.action = 2;
                break;
            case "IGNORE_FOLLOW":
            case 3:
                message.action = 3;
                break;
            case "REMOVE_FOLLOWER":
            case 4:
                message.action = 4;
                break;
            case "BLOCK":
            case 5:
                message.action = 5;
                break;
            case "UNBLOCK":
            case 6:
                message.action = 6;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RelationshipRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RelationshipRequest
         * @static
         * @param {server.RelationshipRequest} message RelationshipRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelationshipRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "FOLLOW" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.RelationshipRequest.Action[message.action] : message.action;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this RelationshipRequest to JSON.
         * @function toJSON
         * @memberof server.RelationshipRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelationshipRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.RelationshipRequest.Action
         * @enum {number}
         * @property {number} FOLLOW=0 FOLLOW value
         * @property {number} UNFOLLOW=1 UNFOLLOW value
         * @property {number} ACCEPT_FOLLOW=2 ACCEPT_FOLLOW value
         * @property {number} IGNORE_FOLLOW=3 IGNORE_FOLLOW value
         * @property {number} REMOVE_FOLLOWER=4 REMOVE_FOLLOWER value
         * @property {number} BLOCK=5 BLOCK value
         * @property {number} UNBLOCK=6 UNBLOCK value
         */
        RelationshipRequest.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FOLLOW"] = 0;
            values[valuesById[1] = "UNFOLLOW"] = 1;
            values[valuesById[2] = "ACCEPT_FOLLOW"] = 2;
            values[valuesById[3] = "IGNORE_FOLLOW"] = 3;
            values[valuesById[4] = "REMOVE_FOLLOWER"] = 4;
            values[valuesById[5] = "BLOCK"] = 5;
            values[valuesById[6] = "UNBLOCK"] = 6;
            return values;
        })();

        return RelationshipRequest;
    })();

    server.RelationshipResponse = (function() {

        /**
         * Properties of a RelationshipResponse.
         * @memberof server
         * @interface IRelationshipResponse
         * @property {server.RelationshipResponse.Result|null} [result] RelationshipResponse result
         * @property {server.IBasicUserProfile|null} [profile] RelationshipResponse profile
         */

        /**
         * Constructs a new RelationshipResponse.
         * @memberof server
         * @classdesc Represents a RelationshipResponse.
         * @implements IRelationshipResponse
         * @constructor
         * @param {server.IRelationshipResponse=} [properties] Properties to set
         */
        function RelationshipResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelationshipResponse result.
         * @member {server.RelationshipResponse.Result} result
         * @memberof server.RelationshipResponse
         * @instance
         */
        RelationshipResponse.prototype.result = 0;

        /**
         * RelationshipResponse profile.
         * @member {server.IBasicUserProfile|null|undefined} profile
         * @memberof server.RelationshipResponse
         * @instance
         */
        RelationshipResponse.prototype.profile = null;

        /**
         * Creates a new RelationshipResponse instance using the specified properties.
         * @function create
         * @memberof server.RelationshipResponse
         * @static
         * @param {server.IRelationshipResponse=} [properties] Properties to set
         * @returns {server.RelationshipResponse} RelationshipResponse instance
         */
        RelationshipResponse.create = function create(properties) {
            return new RelationshipResponse(properties);
        };

        /**
         * Encodes the specified RelationshipResponse message. Does not implicitly {@link server.RelationshipResponse.verify|verify} messages.
         * @function encode
         * @memberof server.RelationshipResponse
         * @static
         * @param {server.IRelationshipResponse} message RelationshipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.server.BasicUserProfile.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RelationshipResponse message, length delimited. Does not implicitly {@link server.RelationshipResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RelationshipResponse
         * @static
         * @param {server.IRelationshipResponse} message RelationshipResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RelationshipResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.RelationshipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RelationshipResponse} RelationshipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RelationshipResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.profile = $root.server.BasicUserProfile.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RelationshipResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RelationshipResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RelationshipResponse} RelationshipResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RelationshipResponse message.
         * @function verify
         * @memberof server.RelationshipResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelationshipResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.server.BasicUserProfile.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a RelationshipResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RelationshipResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RelationshipResponse} RelationshipResponse
         */
        RelationshipResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RelationshipResponse)
                return object;
            var message = new $root.server.RelationshipResponse();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".server.RelationshipResponse.profile: object expected");
                message.profile = $root.server.BasicUserProfile.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a RelationshipResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RelationshipResponse
         * @static
         * @param {server.RelationshipResponse} message RelationshipResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelationshipResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.profile = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.RelationshipResponse.Result[message.result] : message.result;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.server.BasicUserProfile.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this RelationshipResponse to JSON.
         * @function toJSON
         * @memberof server.RelationshipResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelationshipResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.RelationshipResponse.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        RelationshipResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return RelationshipResponse;
    })();

    server.RelationshipList = (function() {

        /**
         * Properties of a RelationshipList.
         * @memberof server
         * @interface IRelationshipList
         * @property {server.RelationshipList.Type|null} [type] RelationshipList type
         * @property {string|null} [cursor] RelationshipList cursor
         * @property {Array.<server.IBasicUserProfile>|null} [users] RelationshipList users
         */

        /**
         * Constructs a new RelationshipList.
         * @memberof server
         * @classdesc Represents a RelationshipList.
         * @implements IRelationshipList
         * @constructor
         * @param {server.IRelationshipList=} [properties] Properties to set
         */
        function RelationshipList(properties) {
            this.users = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelationshipList type.
         * @member {server.RelationshipList.Type} type
         * @memberof server.RelationshipList
         * @instance
         */
        RelationshipList.prototype.type = 0;

        /**
         * RelationshipList cursor.
         * @member {string} cursor
         * @memberof server.RelationshipList
         * @instance
         */
        RelationshipList.prototype.cursor = "";

        /**
         * RelationshipList users.
         * @member {Array.<server.IBasicUserProfile>} users
         * @memberof server.RelationshipList
         * @instance
         */
        RelationshipList.prototype.users = $util.emptyArray;

        /**
         * Creates a new RelationshipList instance using the specified properties.
         * @function create
         * @memberof server.RelationshipList
         * @static
         * @param {server.IRelationshipList=} [properties] Properties to set
         * @returns {server.RelationshipList} RelationshipList instance
         */
        RelationshipList.create = function create(properties) {
            return new RelationshipList(properties);
        };

        /**
         * Encodes the specified RelationshipList message. Does not implicitly {@link server.RelationshipList.verify|verify} messages.
         * @function encode
         * @memberof server.RelationshipList
         * @static
         * @param {server.IRelationshipList} message RelationshipList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cursor);
            if (message.users != null && message.users.length)
                for (var i = 0; i < message.users.length; ++i)
                    $root.server.BasicUserProfile.encode(message.users[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RelationshipList message, length delimited. Does not implicitly {@link server.RelationshipList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RelationshipList
         * @static
         * @param {server.IRelationshipList} message RelationshipList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelationshipList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RelationshipList message from the specified reader or buffer.
         * @function decode
         * @memberof server.RelationshipList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RelationshipList} RelationshipList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RelationshipList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.cursor = reader.string();
                    break;
                case 3:
                    if (!(message.users && message.users.length))
                        message.users = [];
                    message.users.push($root.server.BasicUserProfile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RelationshipList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RelationshipList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RelationshipList} RelationshipList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelationshipList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RelationshipList message.
         * @function verify
         * @memberof server.RelationshipList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RelationshipList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (!$util.isString(message.cursor))
                    return "cursor: string expected";
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (var i = 0; i < message.users.length; ++i) {
                    var error = $root.server.BasicUserProfile.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RelationshipList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RelationshipList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RelationshipList} RelationshipList
         */
        RelationshipList.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RelationshipList)
                return object;
            var message = new $root.server.RelationshipList();
            switch (object.type) {
            case "FOLLOWER":
            case 0:
                message.type = 0;
                break;
            case "FOLLOWING":
            case 1:
                message.type = 1;
                break;
            case "INCOMING":
            case 2:
                message.type = 2;
                break;
            case "OUTGOING":
            case 3:
                message.type = 3;
                break;
            case "BLOCKED":
            case 4:
                message.type = 4;
                break;
            }
            if (object.cursor != null)
                message.cursor = String(object.cursor);
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".server.RelationshipList.users: array expected");
                message.users = [];
                for (var i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".server.RelationshipList.users: object expected");
                    message.users[i] = $root.server.BasicUserProfile.fromObject(object.users[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RelationshipList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RelationshipList
         * @static
         * @param {server.RelationshipList} message RelationshipList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RelationshipList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.users = [];
            if (options.defaults) {
                object.type = options.enums === String ? "FOLLOWER" : 0;
                object.cursor = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.RelationshipList.Type[message.type] : message.type;
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                object.cursor = message.cursor;
            if (message.users && message.users.length) {
                object.users = [];
                for (var j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.server.BasicUserProfile.toObject(message.users[j], options);
            }
            return object;
        };

        /**
         * Converts this RelationshipList to JSON.
         * @function toJSON
         * @memberof server.RelationshipList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RelationshipList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.RelationshipList.Type
         * @enum {number}
         * @property {number} FOLLOWER=0 FOLLOWER value
         * @property {number} FOLLOWING=1 FOLLOWING value
         * @property {number} INCOMING=2 INCOMING value
         * @property {number} OUTGOING=3 OUTGOING value
         * @property {number} BLOCKED=4 BLOCKED value
         */
        RelationshipList.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FOLLOWER"] = 0;
            values[valuesById[1] = "FOLLOWING"] = 1;
            values[valuesById[2] = "INCOMING"] = 2;
            values[valuesById[3] = "OUTGOING"] = 3;
            values[valuesById[4] = "BLOCKED"] = 4;
            return values;
        })();

        return RelationshipList;
    })();

    server.UsernameRequest = (function() {

        /**
         * Properties of a UsernameRequest.
         * @memberof server
         * @interface IUsernameRequest
         * @property {server.UsernameRequest.Action|null} [action] UsernameRequest action
         * @property {string|null} [username] UsernameRequest username
         */

        /**
         * Constructs a new UsernameRequest.
         * @memberof server
         * @classdesc Represents a UsernameRequest.
         * @implements IUsernameRequest
         * @constructor
         * @param {server.IUsernameRequest=} [properties] Properties to set
         */
        function UsernameRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UsernameRequest action.
         * @member {server.UsernameRequest.Action} action
         * @memberof server.UsernameRequest
         * @instance
         */
        UsernameRequest.prototype.action = 0;

        /**
         * UsernameRequest username.
         * @member {string} username
         * @memberof server.UsernameRequest
         * @instance
         */
        UsernameRequest.prototype.username = "";

        /**
         * Creates a new UsernameRequest instance using the specified properties.
         * @function create
         * @memberof server.UsernameRequest
         * @static
         * @param {server.IUsernameRequest=} [properties] Properties to set
         * @returns {server.UsernameRequest} UsernameRequest instance
         */
        UsernameRequest.create = function create(properties) {
            return new UsernameRequest(properties);
        };

        /**
         * Encodes the specified UsernameRequest message. Does not implicitly {@link server.UsernameRequest.verify|verify} messages.
         * @function encode
         * @memberof server.UsernameRequest
         * @static
         * @param {server.IUsernameRequest} message UsernameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified UsernameRequest message, length delimited. Does not implicitly {@link server.UsernameRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UsernameRequest
         * @static
         * @param {server.IUsernameRequest} message UsernameRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UsernameRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.UsernameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UsernameRequest} UsernameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UsernameRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UsernameRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UsernameRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UsernameRequest} UsernameRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UsernameRequest message.
         * @function verify
         * @memberof server.UsernameRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UsernameRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a UsernameRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UsernameRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UsernameRequest} UsernameRequest
         */
        UsernameRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UsernameRequest)
                return object;
            var message = new $root.server.UsernameRequest();
            switch (object.action) {
            case "IS_AVAILABLE":
            case 0:
                message.action = 0;
                break;
            case "SET":
            case 1:
                message.action = 1;
                break;
            }
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a UsernameRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UsernameRequest
         * @static
         * @param {server.UsernameRequest} message UsernameRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UsernameRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "IS_AVAILABLE" : 0;
                object.username = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.UsernameRequest.Action[message.action] : message.action;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this UsernameRequest to JSON.
         * @function toJSON
         * @memberof server.UsernameRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UsernameRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.UsernameRequest.Action
         * @enum {number}
         * @property {number} IS_AVAILABLE=0 IS_AVAILABLE value
         * @property {number} SET=1 SET value
         */
        UsernameRequest.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IS_AVAILABLE"] = 0;
            values[valuesById[1] = "SET"] = 1;
            return values;
        })();

        return UsernameRequest;
    })();

    server.UsernameResponse = (function() {

        /**
         * Properties of a UsernameResponse.
         * @memberof server
         * @interface IUsernameResponse
         * @property {server.UsernameResponse.Result|null} [result] UsernameResponse result
         * @property {server.UsernameResponse.Reason|null} [reason] UsernameResponse reason
         */

        /**
         * Constructs a new UsernameResponse.
         * @memberof server
         * @classdesc Represents a UsernameResponse.
         * @implements IUsernameResponse
         * @constructor
         * @param {server.IUsernameResponse=} [properties] Properties to set
         */
        function UsernameResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UsernameResponse result.
         * @member {server.UsernameResponse.Result} result
         * @memberof server.UsernameResponse
         * @instance
         */
        UsernameResponse.prototype.result = 0;

        /**
         * UsernameResponse reason.
         * @member {server.UsernameResponse.Reason} reason
         * @memberof server.UsernameResponse
         * @instance
         */
        UsernameResponse.prototype.reason = 0;

        /**
         * Creates a new UsernameResponse instance using the specified properties.
         * @function create
         * @memberof server.UsernameResponse
         * @static
         * @param {server.IUsernameResponse=} [properties] Properties to set
         * @returns {server.UsernameResponse} UsernameResponse instance
         */
        UsernameResponse.create = function create(properties) {
            return new UsernameResponse(properties);
        };

        /**
         * Encodes the specified UsernameResponse message. Does not implicitly {@link server.UsernameResponse.verify|verify} messages.
         * @function encode
         * @memberof server.UsernameResponse
         * @static
         * @param {server.IUsernameResponse} message UsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified UsernameResponse message, length delimited. Does not implicitly {@link server.UsernameResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UsernameResponse
         * @static
         * @param {server.IUsernameResponse} message UsernameResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UsernameResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.UsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UsernameResponse} UsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UsernameResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UsernameResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UsernameResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UsernameResponse} UsernameResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UsernameResponse message.
         * @function verify
         * @memberof server.UsernameResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UsernameResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a UsernameResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UsernameResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UsernameResponse} UsernameResponse
         */
        UsernameResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UsernameResponse)
                return object;
            var message = new $root.server.UsernameResponse();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "TOOSHORT":
            case 0:
                message.reason = 0;
                break;
            case "TOOLONG":
            case 1:
                message.reason = 1;
                break;
            case "BADEXPR":
            case 2:
                message.reason = 2;
                break;
            case "NOTUNIQ":
            case 3:
                message.reason = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a UsernameResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UsernameResponse
         * @static
         * @param {server.UsernameResponse} message UsernameResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UsernameResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = options.enums === String ? "TOOSHORT" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.UsernameResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.UsernameResponse.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this UsernameResponse to JSON.
         * @function toJSON
         * @memberof server.UsernameResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UsernameResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.UsernameResponse.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        UsernameResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.UsernameResponse.Reason
         * @enum {number}
         * @property {number} TOOSHORT=0 TOOSHORT value
         * @property {number} TOOLONG=1 TOOLONG value
         * @property {number} BADEXPR=2 BADEXPR value
         * @property {number} NOTUNIQ=3 NOTUNIQ value
         */
        UsernameResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TOOSHORT"] = 0;
            values[valuesById[1] = "TOOLONG"] = 1;
            values[valuesById[2] = "BADEXPR"] = 2;
            values[valuesById[3] = "NOTUNIQ"] = 3;
            return values;
        })();

        return UsernameResponse;
    })();

    server.SearchRequest = (function() {

        /**
         * Properties of a SearchRequest.
         * @memberof server
         * @interface ISearchRequest
         * @property {string|null} [usernameString] SearchRequest usernameString
         */

        /**
         * Constructs a new SearchRequest.
         * @memberof server
         * @classdesc Represents a SearchRequest.
         * @implements ISearchRequest
         * @constructor
         * @param {server.ISearchRequest=} [properties] Properties to set
         */
        function SearchRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchRequest usernameString.
         * @member {string} usernameString
         * @memberof server.SearchRequest
         * @instance
         */
        SearchRequest.prototype.usernameString = "";

        /**
         * Creates a new SearchRequest instance using the specified properties.
         * @function create
         * @memberof server.SearchRequest
         * @static
         * @param {server.ISearchRequest=} [properties] Properties to set
         * @returns {server.SearchRequest} SearchRequest instance
         */
        SearchRequest.create = function create(properties) {
            return new SearchRequest(properties);
        };

        /**
         * Encodes the specified SearchRequest message. Does not implicitly {@link server.SearchRequest.verify|verify} messages.
         * @function encode
         * @memberof server.SearchRequest
         * @static
         * @param {server.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usernameString != null && Object.hasOwnProperty.call(message, "usernameString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.usernameString);
            return writer;
        };

        /**
         * Encodes the specified SearchRequest message, length delimited. Does not implicitly {@link server.SearchRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SearchRequest
         * @static
         * @param {server.ISearchRequest} message SearchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SearchRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.usernameString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SearchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SearchRequest} SearchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchRequest message.
         * @function verify
         * @memberof server.SearchRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usernameString != null && message.hasOwnProperty("usernameString"))
                if (!$util.isString(message.usernameString))
                    return "usernameString: string expected";
            return null;
        };

        /**
         * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SearchRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SearchRequest} SearchRequest
         */
        SearchRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SearchRequest)
                return object;
            var message = new $root.server.SearchRequest();
            if (object.usernameString != null)
                message.usernameString = String(object.usernameString);
            return message;
        };

        /**
         * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SearchRequest
         * @static
         * @param {server.SearchRequest} message SearchRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.usernameString = "";
            if (message.usernameString != null && message.hasOwnProperty("usernameString"))
                object.usernameString = message.usernameString;
            return object;
        };

        /**
         * Converts this SearchRequest to JSON.
         * @function toJSON
         * @memberof server.SearchRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchRequest;
    })();

    server.SearchResponse = (function() {

        /**
         * Properties of a SearchResponse.
         * @memberof server
         * @interface ISearchResponse
         * @property {server.SearchResponse.Result|null} [result] SearchResponse result
         * @property {Array.<server.IBasicUserProfile>|null} [searchResult] SearchResponse searchResult
         */

        /**
         * Constructs a new SearchResponse.
         * @memberof server
         * @classdesc Represents a SearchResponse.
         * @implements ISearchResponse
         * @constructor
         * @param {server.ISearchResponse=} [properties] Properties to set
         */
        function SearchResponse(properties) {
            this.searchResult = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchResponse result.
         * @member {server.SearchResponse.Result} result
         * @memberof server.SearchResponse
         * @instance
         */
        SearchResponse.prototype.result = 0;

        /**
         * SearchResponse searchResult.
         * @member {Array.<server.IBasicUserProfile>} searchResult
         * @memberof server.SearchResponse
         * @instance
         */
        SearchResponse.prototype.searchResult = $util.emptyArray;

        /**
         * Creates a new SearchResponse instance using the specified properties.
         * @function create
         * @memberof server.SearchResponse
         * @static
         * @param {server.ISearchResponse=} [properties] Properties to set
         * @returns {server.SearchResponse} SearchResponse instance
         */
        SearchResponse.create = function create(properties) {
            return new SearchResponse(properties);
        };

        /**
         * Encodes the specified SearchResponse message. Does not implicitly {@link server.SearchResponse.verify|verify} messages.
         * @function encode
         * @memberof server.SearchResponse
         * @static
         * @param {server.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.searchResult != null && message.searchResult.length)
                for (var i = 0; i < message.searchResult.length; ++i)
                    $root.server.BasicUserProfile.encode(message.searchResult[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link server.SearchResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SearchResponse
         * @static
         * @param {server.ISearchResponse} message SearchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SearchResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.searchResult && message.searchResult.length))
                        message.searchResult = [];
                    message.searchResult.push($root.server.BasicUserProfile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SearchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SearchResponse} SearchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchResponse message.
         * @function verify
         * @memberof server.SearchResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.searchResult != null && message.hasOwnProperty("searchResult")) {
                if (!Array.isArray(message.searchResult))
                    return "searchResult: array expected";
                for (var i = 0; i < message.searchResult.length; ++i) {
                    var error = $root.server.BasicUserProfile.verify(message.searchResult[i]);
                    if (error)
                        return "searchResult." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SearchResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SearchResponse} SearchResponse
         */
        SearchResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SearchResponse)
                return object;
            var message = new $root.server.SearchResponse();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            if (object.searchResult) {
                if (!Array.isArray(object.searchResult))
                    throw TypeError(".server.SearchResponse.searchResult: array expected");
                message.searchResult = [];
                for (var i = 0; i < object.searchResult.length; ++i) {
                    if (typeof object.searchResult[i] !== "object")
                        throw TypeError(".server.SearchResponse.searchResult: object expected");
                    message.searchResult[i] = $root.server.BasicUserProfile.fromObject(object.searchResult[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SearchResponse
         * @static
         * @param {server.SearchResponse} message SearchResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.searchResult = [];
            if (options.defaults)
                object.result = options.enums === String ? "OK" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.SearchResponse.Result[message.result] : message.result;
            if (message.searchResult && message.searchResult.length) {
                object.searchResult = [];
                for (var j = 0; j < message.searchResult.length; ++j)
                    object.searchResult[j] = $root.server.BasicUserProfile.toObject(message.searchResult[j], options);
            }
            return object;
        };

        /**
         * Converts this SearchResponse to JSON.
         * @function toJSON
         * @memberof server.SearchResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.SearchResponse.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        SearchResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return SearchResponse;
    })();

    server.FollowSuggestionsRequest = (function() {

        /**
         * Properties of a FollowSuggestionsRequest.
         * @memberof server
         * @interface IFollowSuggestionsRequest
         * @property {server.FollowSuggestionsRequest.Action|null} [action] FollowSuggestionsRequest action
         * @property {Array.<number|Long>|null} [rejectedUids] FollowSuggestionsRequest rejectedUids
         */

        /**
         * Constructs a new FollowSuggestionsRequest.
         * @memberof server
         * @classdesc Represents a FollowSuggestionsRequest.
         * @implements IFollowSuggestionsRequest
         * @constructor
         * @param {server.IFollowSuggestionsRequest=} [properties] Properties to set
         */
        function FollowSuggestionsRequest(properties) {
            this.rejectedUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FollowSuggestionsRequest action.
         * @member {server.FollowSuggestionsRequest.Action} action
         * @memberof server.FollowSuggestionsRequest
         * @instance
         */
        FollowSuggestionsRequest.prototype.action = 0;

        /**
         * FollowSuggestionsRequest rejectedUids.
         * @member {Array.<number|Long>} rejectedUids
         * @memberof server.FollowSuggestionsRequest
         * @instance
         */
        FollowSuggestionsRequest.prototype.rejectedUids = $util.emptyArray;

        /**
         * Creates a new FollowSuggestionsRequest instance using the specified properties.
         * @function create
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {server.IFollowSuggestionsRequest=} [properties] Properties to set
         * @returns {server.FollowSuggestionsRequest} FollowSuggestionsRequest instance
         */
        FollowSuggestionsRequest.create = function create(properties) {
            return new FollowSuggestionsRequest(properties);
        };

        /**
         * Encodes the specified FollowSuggestionsRequest message. Does not implicitly {@link server.FollowSuggestionsRequest.verify|verify} messages.
         * @function encode
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {server.IFollowSuggestionsRequest} message FollowSuggestionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FollowSuggestionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.rejectedUids != null && message.rejectedUids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.rejectedUids.length; ++i)
                    writer.int64(message.rejectedUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified FollowSuggestionsRequest message, length delimited. Does not implicitly {@link server.FollowSuggestionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {server.IFollowSuggestionsRequest} message FollowSuggestionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FollowSuggestionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FollowSuggestionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FollowSuggestionsRequest} FollowSuggestionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowSuggestionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FollowSuggestionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    if (!(message.rejectedUids && message.rejectedUids.length))
                        message.rejectedUids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rejectedUids.push(reader.int64());
                    } else
                        message.rejectedUids.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FollowSuggestionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FollowSuggestionsRequest} FollowSuggestionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowSuggestionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FollowSuggestionsRequest message.
         * @function verify
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FollowSuggestionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.rejectedUids != null && message.hasOwnProperty("rejectedUids")) {
                if (!Array.isArray(message.rejectedUids))
                    return "rejectedUids: array expected";
                for (var i = 0; i < message.rejectedUids.length; ++i)
                    if (!$util.isInteger(message.rejectedUids[i]) && !(message.rejectedUids[i] && $util.isInteger(message.rejectedUids[i].low) && $util.isInteger(message.rejectedUids[i].high)))
                        return "rejectedUids: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a FollowSuggestionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FollowSuggestionsRequest} FollowSuggestionsRequest
         */
        FollowSuggestionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FollowSuggestionsRequest)
                return object;
            var message = new $root.server.FollowSuggestionsRequest();
            switch (object.action) {
            case "GET":
            case 0:
                message.action = 0;
                break;
            case "REJECT":
            case 1:
                message.action = 1;
                break;
            }
            if (object.rejectedUids) {
                if (!Array.isArray(object.rejectedUids))
                    throw TypeError(".server.FollowSuggestionsRequest.rejectedUids: array expected");
                message.rejectedUids = [];
                for (var i = 0; i < object.rejectedUids.length; ++i)
                    if ($util.Long)
                        (message.rejectedUids[i] = $util.Long.fromValue(object.rejectedUids[i])).unsigned = false;
                    else if (typeof object.rejectedUids[i] === "string")
                        message.rejectedUids[i] = parseInt(object.rejectedUids[i], 10);
                    else if (typeof object.rejectedUids[i] === "number")
                        message.rejectedUids[i] = object.rejectedUids[i];
                    else if (typeof object.rejectedUids[i] === "object")
                        message.rejectedUids[i] = new $util.LongBits(object.rejectedUids[i].low >>> 0, object.rejectedUids[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a FollowSuggestionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FollowSuggestionsRequest
         * @static
         * @param {server.FollowSuggestionsRequest} message FollowSuggestionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FollowSuggestionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rejectedUids = [];
            if (options.defaults)
                object.action = options.enums === String ? "GET" : 0;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.FollowSuggestionsRequest.Action[message.action] : message.action;
            if (message.rejectedUids && message.rejectedUids.length) {
                object.rejectedUids = [];
                for (var j = 0; j < message.rejectedUids.length; ++j)
                    if (typeof message.rejectedUids[j] === "number")
                        object.rejectedUids[j] = options.longs === String ? String(message.rejectedUids[j]) : message.rejectedUids[j];
                    else
                        object.rejectedUids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedUids[j]) : options.longs === Number ? new $util.LongBits(message.rejectedUids[j].low >>> 0, message.rejectedUids[j].high >>> 0).toNumber() : message.rejectedUids[j];
            }
            return object;
        };

        /**
         * Converts this FollowSuggestionsRequest to JSON.
         * @function toJSON
         * @memberof server.FollowSuggestionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FollowSuggestionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.FollowSuggestionsRequest.Action
         * @enum {number}
         * @property {number} GET=0 GET value
         * @property {number} REJECT=1 REJECT value
         */
        FollowSuggestionsRequest.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            values[valuesById[1] = "REJECT"] = 1;
            return values;
        })();

        return FollowSuggestionsRequest;
    })();

    server.SuggestedProfile = (function() {

        /**
         * Properties of a SuggestedProfile.
         * @memberof server
         * @interface ISuggestedProfile
         * @property {server.IBasicUserProfile|null} [userProfile] SuggestedProfile userProfile
         * @property {server.SuggestedProfile.Reason|null} [reason] SuggestedProfile reason
         * @property {number|null} [rank] SuggestedProfile rank
         */

        /**
         * Constructs a new SuggestedProfile.
         * @memberof server
         * @classdesc Represents a SuggestedProfile.
         * @implements ISuggestedProfile
         * @constructor
         * @param {server.ISuggestedProfile=} [properties] Properties to set
         */
        function SuggestedProfile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SuggestedProfile userProfile.
         * @member {server.IBasicUserProfile|null|undefined} userProfile
         * @memberof server.SuggestedProfile
         * @instance
         */
        SuggestedProfile.prototype.userProfile = null;

        /**
         * SuggestedProfile reason.
         * @member {server.SuggestedProfile.Reason} reason
         * @memberof server.SuggestedProfile
         * @instance
         */
        SuggestedProfile.prototype.reason = 0;

        /**
         * SuggestedProfile rank.
         * @member {number} rank
         * @memberof server.SuggestedProfile
         * @instance
         */
        SuggestedProfile.prototype.rank = 0;

        /**
         * Creates a new SuggestedProfile instance using the specified properties.
         * @function create
         * @memberof server.SuggestedProfile
         * @static
         * @param {server.ISuggestedProfile=} [properties] Properties to set
         * @returns {server.SuggestedProfile} SuggestedProfile instance
         */
        SuggestedProfile.create = function create(properties) {
            return new SuggestedProfile(properties);
        };

        /**
         * Encodes the specified SuggestedProfile message. Does not implicitly {@link server.SuggestedProfile.verify|verify} messages.
         * @function encode
         * @memberof server.SuggestedProfile
         * @static
         * @param {server.ISuggestedProfile} message SuggestedProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SuggestedProfile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userProfile != null && Object.hasOwnProperty.call(message, "userProfile"))
                $root.server.BasicUserProfile.encode(message.userProfile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rank);
            return writer;
        };

        /**
         * Encodes the specified SuggestedProfile message, length delimited. Does not implicitly {@link server.SuggestedProfile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SuggestedProfile
         * @static
         * @param {server.ISuggestedProfile} message SuggestedProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SuggestedProfile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SuggestedProfile message from the specified reader or buffer.
         * @function decode
         * @memberof server.SuggestedProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SuggestedProfile} SuggestedProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SuggestedProfile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SuggestedProfile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userProfile = $root.server.BasicUserProfile.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.rank = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SuggestedProfile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SuggestedProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SuggestedProfile} SuggestedProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SuggestedProfile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SuggestedProfile message.
         * @function verify
         * @memberof server.SuggestedProfile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SuggestedProfile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userProfile != null && message.hasOwnProperty("userProfile")) {
                var error = $root.server.BasicUserProfile.verify(message.userProfile);
                if (error)
                    return "userProfile." + error;
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            return null;
        };

        /**
         * Creates a SuggestedProfile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SuggestedProfile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SuggestedProfile} SuggestedProfile
         */
        SuggestedProfile.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SuggestedProfile)
                return object;
            var message = new $root.server.SuggestedProfile();
            if (object.userProfile != null) {
                if (typeof object.userProfile !== "object")
                    throw TypeError(".server.SuggestedProfile.userProfile: object expected");
                message.userProfile = $root.server.BasicUserProfile.fromObject(object.userProfile);
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "DIRECT_CONTACT":
            case 1:
                message.reason = 1;
                break;
            case "FOF":
            case 2:
                message.reason = 2;
                break;
            case "CAMPUS":
            case 3:
                message.reason = 3;
                break;
            }
            if (object.rank != null)
                message.rank = object.rank | 0;
            return message;
        };

        /**
         * Creates a plain object from a SuggestedProfile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SuggestedProfile
         * @static
         * @param {server.SuggestedProfile} message SuggestedProfile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SuggestedProfile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.userProfile = null;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.rank = 0;
            }
            if (message.userProfile != null && message.hasOwnProperty("userProfile"))
                object.userProfile = $root.server.BasicUserProfile.toObject(message.userProfile, options);
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.SuggestedProfile.Reason[message.reason] : message.reason;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            return object;
        };

        /**
         * Converts this SuggestedProfile to JSON.
         * @function toJSON
         * @memberof server.SuggestedProfile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SuggestedProfile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.SuggestedProfile.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} DIRECT_CONTACT=1 DIRECT_CONTACT value
         * @property {number} FOF=2 FOF value
         * @property {number} CAMPUS=3 CAMPUS value
         */
        SuggestedProfile.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "DIRECT_CONTACT"] = 1;
            values[valuesById[2] = "FOF"] = 2;
            values[valuesById[3] = "CAMPUS"] = 3;
            return values;
        })();

        return SuggestedProfile;
    })();

    server.FollowSuggestionsResponse = (function() {

        /**
         * Properties of a FollowSuggestionsResponse.
         * @memberof server
         * @interface IFollowSuggestionsResponse
         * @property {server.FollowSuggestionsResponse.Result|null} [result] FollowSuggestionsResponse result
         * @property {Array.<server.ISuggestedProfile>|null} [suggestedProfiles] FollowSuggestionsResponse suggestedProfiles
         */

        /**
         * Constructs a new FollowSuggestionsResponse.
         * @memberof server
         * @classdesc Represents a FollowSuggestionsResponse.
         * @implements IFollowSuggestionsResponse
         * @constructor
         * @param {server.IFollowSuggestionsResponse=} [properties] Properties to set
         */
        function FollowSuggestionsResponse(properties) {
            this.suggestedProfiles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FollowSuggestionsResponse result.
         * @member {server.FollowSuggestionsResponse.Result} result
         * @memberof server.FollowSuggestionsResponse
         * @instance
         */
        FollowSuggestionsResponse.prototype.result = 0;

        /**
         * FollowSuggestionsResponse suggestedProfiles.
         * @member {Array.<server.ISuggestedProfile>} suggestedProfiles
         * @memberof server.FollowSuggestionsResponse
         * @instance
         */
        FollowSuggestionsResponse.prototype.suggestedProfiles = $util.emptyArray;

        /**
         * Creates a new FollowSuggestionsResponse instance using the specified properties.
         * @function create
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {server.IFollowSuggestionsResponse=} [properties] Properties to set
         * @returns {server.FollowSuggestionsResponse} FollowSuggestionsResponse instance
         */
        FollowSuggestionsResponse.create = function create(properties) {
            return new FollowSuggestionsResponse(properties);
        };

        /**
         * Encodes the specified FollowSuggestionsResponse message. Does not implicitly {@link server.FollowSuggestionsResponse.verify|verify} messages.
         * @function encode
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {server.IFollowSuggestionsResponse} message FollowSuggestionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FollowSuggestionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.suggestedProfiles != null && message.suggestedProfiles.length)
                for (var i = 0; i < message.suggestedProfiles.length; ++i)
                    $root.server.SuggestedProfile.encode(message.suggestedProfiles[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FollowSuggestionsResponse message, length delimited. Does not implicitly {@link server.FollowSuggestionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {server.IFollowSuggestionsResponse} message FollowSuggestionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FollowSuggestionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FollowSuggestionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FollowSuggestionsResponse} FollowSuggestionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowSuggestionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FollowSuggestionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.suggestedProfiles && message.suggestedProfiles.length))
                        message.suggestedProfiles = [];
                    message.suggestedProfiles.push($root.server.SuggestedProfile.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FollowSuggestionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FollowSuggestionsResponse} FollowSuggestionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FollowSuggestionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FollowSuggestionsResponse message.
         * @function verify
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FollowSuggestionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.suggestedProfiles != null && message.hasOwnProperty("suggestedProfiles")) {
                if (!Array.isArray(message.suggestedProfiles))
                    return "suggestedProfiles: array expected";
                for (var i = 0; i < message.suggestedProfiles.length; ++i) {
                    var error = $root.server.SuggestedProfile.verify(message.suggestedProfiles[i]);
                    if (error)
                        return "suggestedProfiles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FollowSuggestionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FollowSuggestionsResponse} FollowSuggestionsResponse
         */
        FollowSuggestionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FollowSuggestionsResponse)
                return object;
            var message = new $root.server.FollowSuggestionsResponse();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            if (object.suggestedProfiles) {
                if (!Array.isArray(object.suggestedProfiles))
                    throw TypeError(".server.FollowSuggestionsResponse.suggestedProfiles: array expected");
                message.suggestedProfiles = [];
                for (var i = 0; i < object.suggestedProfiles.length; ++i) {
                    if (typeof object.suggestedProfiles[i] !== "object")
                        throw TypeError(".server.FollowSuggestionsResponse.suggestedProfiles: object expected");
                    message.suggestedProfiles[i] = $root.server.SuggestedProfile.fromObject(object.suggestedProfiles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FollowSuggestionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FollowSuggestionsResponse
         * @static
         * @param {server.FollowSuggestionsResponse} message FollowSuggestionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FollowSuggestionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.suggestedProfiles = [];
            if (options.defaults)
                object.result = options.enums === String ? "OK" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.FollowSuggestionsResponse.Result[message.result] : message.result;
            if (message.suggestedProfiles && message.suggestedProfiles.length) {
                object.suggestedProfiles = [];
                for (var j = 0; j < message.suggestedProfiles.length; ++j)
                    object.suggestedProfiles[j] = $root.server.SuggestedProfile.toObject(message.suggestedProfiles[j], options);
            }
            return object;
        };

        /**
         * Converts this FollowSuggestionsResponse to JSON.
         * @function toJSON
         * @memberof server.FollowSuggestionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FollowSuggestionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.FollowSuggestionsResponse.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        FollowSuggestionsResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return FollowSuggestionsResponse;
    })();

    server.Link = (function() {

        /**
         * Properties of a Link.
         * @memberof server
         * @interface ILink
         * @property {server.Link.Type|null} [type] Link type
         * @property {string|null} [text] Link text
         */

        /**
         * Constructs a new Link.
         * @memberof server
         * @classdesc Represents a Link.
         * @implements ILink
         * @constructor
         * @param {server.ILink=} [properties] Properties to set
         */
        function Link(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Link type.
         * @member {server.Link.Type} type
         * @memberof server.Link
         * @instance
         */
        Link.prototype.type = 0;

        /**
         * Link text.
         * @member {string} text
         * @memberof server.Link
         * @instance
         */
        Link.prototype.text = "";

        /**
         * Creates a new Link instance using the specified properties.
         * @function create
         * @memberof server.Link
         * @static
         * @param {server.ILink=} [properties] Properties to set
         * @returns {server.Link} Link instance
         */
        Link.create = function create(properties) {
            return new Link(properties);
        };

        /**
         * Encodes the specified Link message. Does not implicitly {@link server.Link.verify|verify} messages.
         * @function encode
         * @memberof server.Link
         * @static
         * @param {server.ILink} message Link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Link.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified Link message, length delimited. Does not implicitly {@link server.Link.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Link
         * @static
         * @param {server.ILink} message Link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Link.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Link message from the specified reader or buffer.
         * @function decode
         * @memberof server.Link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Link} Link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Link.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Link();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Link message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Link} Link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Link.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Link message.
         * @function verify
         * @memberof server.Link
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Link.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a Link message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Link
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Link} Link
         */
        Link.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Link)
                return object;
            var message = new $root.server.Link();
            switch (object.type) {
            case "USER_DEFINED":
            case 0:
                message.type = 0;
                break;
            case "TIKTOK":
            case 1:
                message.type = 1;
                break;
            case "SNAPCHAT":
            case 2:
                message.type = 2;
                break;
            case "INSTAGRAM":
            case 3:
                message.type = 3;
                break;
            }
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a Link message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Link
         * @static
         * @param {server.Link} message Link
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Link.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "USER_DEFINED" : 0;
                object.text = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Link.Type[message.type] : message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this Link to JSON.
         * @function toJSON
         * @memberof server.Link
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Link.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Link.Type
         * @enum {number}
         * @property {number} USER_DEFINED=0 USER_DEFINED value
         * @property {number} TIKTOK=1 TIKTOK value
         * @property {number} SNAPCHAT=2 SNAPCHAT value
         * @property {number} INSTAGRAM=3 INSTAGRAM value
         */
        Link.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "USER_DEFINED"] = 0;
            values[valuesById[1] = "TIKTOK"] = 1;
            values[valuesById[2] = "SNAPCHAT"] = 2;
            values[valuesById[3] = "INSTAGRAM"] = 3;
            return values;
        })();

        return Link;
    })();

    server.SetLinkRequest = (function() {

        /**
         * Properties of a SetLinkRequest.
         * @memberof server
         * @interface ISetLinkRequest
         * @property {server.ILink|null} [link] SetLinkRequest link
         */

        /**
         * Constructs a new SetLinkRequest.
         * @memberof server
         * @classdesc Represents a SetLinkRequest.
         * @implements ISetLinkRequest
         * @constructor
         * @param {server.ISetLinkRequest=} [properties] Properties to set
         */
        function SetLinkRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetLinkRequest link.
         * @member {server.ILink|null|undefined} link
         * @memberof server.SetLinkRequest
         * @instance
         */
        SetLinkRequest.prototype.link = null;

        /**
         * Creates a new SetLinkRequest instance using the specified properties.
         * @function create
         * @memberof server.SetLinkRequest
         * @static
         * @param {server.ISetLinkRequest=} [properties] Properties to set
         * @returns {server.SetLinkRequest} SetLinkRequest instance
         */
        SetLinkRequest.create = function create(properties) {
            return new SetLinkRequest(properties);
        };

        /**
         * Encodes the specified SetLinkRequest message. Does not implicitly {@link server.SetLinkRequest.verify|verify} messages.
         * @function encode
         * @memberof server.SetLinkRequest
         * @static
         * @param {server.ISetLinkRequest} message SetLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLinkRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.link != null && Object.hasOwnProperty.call(message, "link"))
                $root.server.Link.encode(message.link, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetLinkRequest message, length delimited. Does not implicitly {@link server.SetLinkRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SetLinkRequest
         * @static
         * @param {server.ISetLinkRequest} message SetLinkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLinkRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetLinkRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.SetLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SetLinkRequest} SetLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLinkRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SetLinkRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.link = $root.server.Link.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetLinkRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SetLinkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SetLinkRequest} SetLinkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLinkRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetLinkRequest message.
         * @function verify
         * @memberof server.SetLinkRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetLinkRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.link != null && message.hasOwnProperty("link")) {
                var error = $root.server.Link.verify(message.link);
                if (error)
                    return "link." + error;
            }
            return null;
        };

        /**
         * Creates a SetLinkRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SetLinkRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SetLinkRequest} SetLinkRequest
         */
        SetLinkRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SetLinkRequest)
                return object;
            var message = new $root.server.SetLinkRequest();
            if (object.link != null) {
                if (typeof object.link !== "object")
                    throw TypeError(".server.SetLinkRequest.link: object expected");
                message.link = $root.server.Link.fromObject(object.link);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetLinkRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SetLinkRequest
         * @static
         * @param {server.SetLinkRequest} message SetLinkRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetLinkRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.link = null;
            if (message.link != null && message.hasOwnProperty("link"))
                object.link = $root.server.Link.toObject(message.link, options);
            return object;
        };

        /**
         * Converts this SetLinkRequest to JSON.
         * @function toJSON
         * @memberof server.SetLinkRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetLinkRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetLinkRequest;
    })();

    server.SetLinkResult = (function() {

        /**
         * Properties of a SetLinkResult.
         * @memberof server
         * @interface ISetLinkResult
         * @property {server.SetLinkResult.Result|null} [result] SetLinkResult result
         * @property {server.SetLinkResult.Reason|null} [reason] SetLinkResult reason
         */

        /**
         * Constructs a new SetLinkResult.
         * @memberof server
         * @classdesc Represents a SetLinkResult.
         * @implements ISetLinkResult
         * @constructor
         * @param {server.ISetLinkResult=} [properties] Properties to set
         */
        function SetLinkResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetLinkResult result.
         * @member {server.SetLinkResult.Result} result
         * @memberof server.SetLinkResult
         * @instance
         */
        SetLinkResult.prototype.result = 0;

        /**
         * SetLinkResult reason.
         * @member {server.SetLinkResult.Reason} reason
         * @memberof server.SetLinkResult
         * @instance
         */
        SetLinkResult.prototype.reason = 0;

        /**
         * Creates a new SetLinkResult instance using the specified properties.
         * @function create
         * @memberof server.SetLinkResult
         * @static
         * @param {server.ISetLinkResult=} [properties] Properties to set
         * @returns {server.SetLinkResult} SetLinkResult instance
         */
        SetLinkResult.create = function create(properties) {
            return new SetLinkResult(properties);
        };

        /**
         * Encodes the specified SetLinkResult message. Does not implicitly {@link server.SetLinkResult.verify|verify} messages.
         * @function encode
         * @memberof server.SetLinkResult
         * @static
         * @param {server.ISetLinkResult} message SetLinkResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLinkResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified SetLinkResult message, length delimited. Does not implicitly {@link server.SetLinkResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SetLinkResult
         * @static
         * @param {server.ISetLinkResult} message SetLinkResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLinkResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetLinkResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.SetLinkResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SetLinkResult} SetLinkResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLinkResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SetLinkResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetLinkResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SetLinkResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SetLinkResult} SetLinkResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLinkResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetLinkResult message.
         * @function verify
         * @memberof server.SetLinkResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetLinkResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetLinkResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SetLinkResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SetLinkResult} SetLinkResult
         */
        SetLinkResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SetLinkResult)
                return object;
            var message = new $root.server.SetLinkResult();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "BAD_TYPE":
            case 1:
                message.reason = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetLinkResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SetLinkResult
         * @static
         * @param {server.SetLinkResult} message SetLinkResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetLinkResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.SetLinkResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.SetLinkResult.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this SetLinkResult to JSON.
         * @function toJSON
         * @memberof server.SetLinkResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetLinkResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.SetLinkResult.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        SetLinkResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.SetLinkResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} BAD_TYPE=1 BAD_TYPE value
         */
        SetLinkResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "BAD_TYPE"] = 1;
            return values;
        })();

        return SetLinkResult;
    })();

    server.SetBioRequest = (function() {

        /**
         * Properties of a SetBioRequest.
         * @memberof server
         * @interface ISetBioRequest
         * @property {string|null} [text] SetBioRequest text
         */

        /**
         * Constructs a new SetBioRequest.
         * @memberof server
         * @classdesc Represents a SetBioRequest.
         * @implements ISetBioRequest
         * @constructor
         * @param {server.ISetBioRequest=} [properties] Properties to set
         */
        function SetBioRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetBioRequest text.
         * @member {string} text
         * @memberof server.SetBioRequest
         * @instance
         */
        SetBioRequest.prototype.text = "";

        /**
         * Creates a new SetBioRequest instance using the specified properties.
         * @function create
         * @memberof server.SetBioRequest
         * @static
         * @param {server.ISetBioRequest=} [properties] Properties to set
         * @returns {server.SetBioRequest} SetBioRequest instance
         */
        SetBioRequest.create = function create(properties) {
            return new SetBioRequest(properties);
        };

        /**
         * Encodes the specified SetBioRequest message. Does not implicitly {@link server.SetBioRequest.verify|verify} messages.
         * @function encode
         * @memberof server.SetBioRequest
         * @static
         * @param {server.ISetBioRequest} message SetBioRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetBioRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified SetBioRequest message, length delimited. Does not implicitly {@link server.SetBioRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SetBioRequest
         * @static
         * @param {server.ISetBioRequest} message SetBioRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetBioRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetBioRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.SetBioRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SetBioRequest} SetBioRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetBioRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SetBioRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetBioRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SetBioRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SetBioRequest} SetBioRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetBioRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetBioRequest message.
         * @function verify
         * @memberof server.SetBioRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetBioRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a SetBioRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SetBioRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SetBioRequest} SetBioRequest
         */
        SetBioRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SetBioRequest)
                return object;
            var message = new $root.server.SetBioRequest();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a SetBioRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SetBioRequest
         * @static
         * @param {server.SetBioRequest} message SetBioRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetBioRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this SetBioRequest to JSON.
         * @function toJSON
         * @memberof server.SetBioRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetBioRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetBioRequest;
    })();

    server.SetBioResult = (function() {

        /**
         * Properties of a SetBioResult.
         * @memberof server
         * @interface ISetBioResult
         * @property {server.SetBioResult.Result|null} [result] SetBioResult result
         * @property {server.SetBioResult.Reason|null} [reason] SetBioResult reason
         */

        /**
         * Constructs a new SetBioResult.
         * @memberof server
         * @classdesc Represents a SetBioResult.
         * @implements ISetBioResult
         * @constructor
         * @param {server.ISetBioResult=} [properties] Properties to set
         */
        function SetBioResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetBioResult result.
         * @member {server.SetBioResult.Result} result
         * @memberof server.SetBioResult
         * @instance
         */
        SetBioResult.prototype.result = 0;

        /**
         * SetBioResult reason.
         * @member {server.SetBioResult.Reason} reason
         * @memberof server.SetBioResult
         * @instance
         */
        SetBioResult.prototype.reason = 0;

        /**
         * Creates a new SetBioResult instance using the specified properties.
         * @function create
         * @memberof server.SetBioResult
         * @static
         * @param {server.ISetBioResult=} [properties] Properties to set
         * @returns {server.SetBioResult} SetBioResult instance
         */
        SetBioResult.create = function create(properties) {
            return new SetBioResult(properties);
        };

        /**
         * Encodes the specified SetBioResult message. Does not implicitly {@link server.SetBioResult.verify|verify} messages.
         * @function encode
         * @memberof server.SetBioResult
         * @static
         * @param {server.ISetBioResult} message SetBioResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetBioResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified SetBioResult message, length delimited. Does not implicitly {@link server.SetBioResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SetBioResult
         * @static
         * @param {server.ISetBioResult} message SetBioResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetBioResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetBioResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.SetBioResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SetBioResult} SetBioResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetBioResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SetBioResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetBioResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SetBioResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SetBioResult} SetBioResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetBioResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetBioResult message.
         * @function verify
         * @memberof server.SetBioResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetBioResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a SetBioResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SetBioResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SetBioResult} SetBioResult
         */
        SetBioResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SetBioResult)
                return object;
            var message = new $root.server.SetBioResult();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "TOO_LONG":
            case 1:
                message.reason = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SetBioResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SetBioResult
         * @static
         * @param {server.SetBioResult} message SetBioResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetBioResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.SetBioResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.SetBioResult.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this SetBioResult to JSON.
         * @function toJSON
         * @memberof server.SetBioResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetBioResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.SetBioResult.Result
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        SetBioResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.SetBioResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} TOO_LONG=1 TOO_LONG value
         */
        SetBioResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "TOO_LONG"] = 1;
            return values;
        })();

        return SetBioResult;
    })();

    server.AiImageRequest = (function() {

        /**
         * Properties of an AiImageRequest.
         * @memberof server
         * @interface IAiImageRequest
         * @property {string|null} [text] AiImageRequest text
         * @property {number|Long|null} [numImages] AiImageRequest numImages
         * @property {server.AiImageRequest.PromptMode|null} [promptMode] AiImageRequest promptMode
         * @property {string|null} [negativePrompt] AiImageRequest negativePrompt
         */

        /**
         * Constructs a new AiImageRequest.
         * @memberof server
         * @classdesc Represents an AiImageRequest.
         * @implements IAiImageRequest
         * @constructor
         * @param {server.IAiImageRequest=} [properties] Properties to set
         */
        function AiImageRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AiImageRequest text.
         * @member {string} text
         * @memberof server.AiImageRequest
         * @instance
         */
        AiImageRequest.prototype.text = "";

        /**
         * AiImageRequest numImages.
         * @member {number|Long} numImages
         * @memberof server.AiImageRequest
         * @instance
         */
        AiImageRequest.prototype.numImages = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AiImageRequest promptMode.
         * @member {server.AiImageRequest.PromptMode} promptMode
         * @memberof server.AiImageRequest
         * @instance
         */
        AiImageRequest.prototype.promptMode = 0;

        /**
         * AiImageRequest negativePrompt.
         * @member {string} negativePrompt
         * @memberof server.AiImageRequest
         * @instance
         */
        AiImageRequest.prototype.negativePrompt = "";

        /**
         * Creates a new AiImageRequest instance using the specified properties.
         * @function create
         * @memberof server.AiImageRequest
         * @static
         * @param {server.IAiImageRequest=} [properties] Properties to set
         * @returns {server.AiImageRequest} AiImageRequest instance
         */
        AiImageRequest.create = function create(properties) {
            return new AiImageRequest(properties);
        };

        /**
         * Encodes the specified AiImageRequest message. Does not implicitly {@link server.AiImageRequest.verify|verify} messages.
         * @function encode
         * @memberof server.AiImageRequest
         * @static
         * @param {server.IAiImageRequest} message AiImageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.numImages != null && Object.hasOwnProperty.call(message, "numImages"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.numImages);
            if (message.promptMode != null && Object.hasOwnProperty.call(message, "promptMode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.promptMode);
            if (message.negativePrompt != null && Object.hasOwnProperty.call(message, "negativePrompt"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.negativePrompt);
            return writer;
        };

        /**
         * Encodes the specified AiImageRequest message, length delimited. Does not implicitly {@link server.AiImageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AiImageRequest
         * @static
         * @param {server.IAiImageRequest} message AiImageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AiImageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.AiImageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AiImageRequest} AiImageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AiImageRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.numImages = reader.int64();
                    break;
                case 3:
                    message.promptMode = reader.int32();
                    break;
                case 4:
                    message.negativePrompt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AiImageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AiImageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AiImageRequest} AiImageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AiImageRequest message.
         * @function verify
         * @memberof server.AiImageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AiImageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                if (!$util.isInteger(message.numImages) && !(message.numImages && $util.isInteger(message.numImages.low) && $util.isInteger(message.numImages.high)))
                    return "numImages: integer|Long expected";
            if (message.promptMode != null && message.hasOwnProperty("promptMode"))
                switch (message.promptMode) {
                default:
                    return "promptMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.negativePrompt != null && message.hasOwnProperty("negativePrompt"))
                if (!$util.isString(message.negativePrompt))
                    return "negativePrompt: string expected";
            return null;
        };

        /**
         * Creates an AiImageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AiImageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AiImageRequest} AiImageRequest
         */
        AiImageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AiImageRequest)
                return object;
            var message = new $root.server.AiImageRequest();
            if (object.text != null)
                message.text = String(object.text);
            if (object.numImages != null)
                if ($util.Long)
                    (message.numImages = $util.Long.fromValue(object.numImages)).unsigned = false;
                else if (typeof object.numImages === "string")
                    message.numImages = parseInt(object.numImages, 10);
                else if (typeof object.numImages === "number")
                    message.numImages = object.numImages;
                else if (typeof object.numImages === "object")
                    message.numImages = new $util.LongBits(object.numImages.low >>> 0, object.numImages.high >>> 0).toNumber();
            switch (object.promptMode) {
            case "UNKNOWN":
            case 0:
                message.promptMode = 0;
                break;
            case "USER":
            case 1:
                message.promptMode = 1;
                break;
            case "SERVER":
            case 2:
                message.promptMode = 2;
                break;
            }
            if (object.negativePrompt != null)
                message.negativePrompt = String(object.negativePrompt);
            return message;
        };

        /**
         * Creates a plain object from an AiImageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AiImageRequest
         * @static
         * @param {server.AiImageRequest} message AiImageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AiImageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.text = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numImages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numImages = options.longs === String ? "0" : 0;
                object.promptMode = options.enums === String ? "UNKNOWN" : 0;
                object.negativePrompt = "";
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                if (typeof message.numImages === "number")
                    object.numImages = options.longs === String ? String(message.numImages) : message.numImages;
                else
                    object.numImages = options.longs === String ? $util.Long.prototype.toString.call(message.numImages) : options.longs === Number ? new $util.LongBits(message.numImages.low >>> 0, message.numImages.high >>> 0).toNumber() : message.numImages;
            if (message.promptMode != null && message.hasOwnProperty("promptMode"))
                object.promptMode = options.enums === String ? $root.server.AiImageRequest.PromptMode[message.promptMode] : message.promptMode;
            if (message.negativePrompt != null && message.hasOwnProperty("negativePrompt"))
                object.negativePrompt = message.negativePrompt;
            return object;
        };

        /**
         * Converts this AiImageRequest to JSON.
         * @function toJSON
         * @memberof server.AiImageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AiImageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PromptMode enum.
         * @name server.AiImageRequest.PromptMode
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} USER=1 USER value
         * @property {number} SERVER=2 SERVER value
         */
        AiImageRequest.PromptMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "USER"] = 1;
            values[valuesById[2] = "SERVER"] = 2;
            return values;
        })();

        return AiImageRequest;
    })();

    server.AiImageResult = (function() {

        /**
         * Properties of an AiImageResult.
         * @memberof server
         * @interface IAiImageResult
         * @property {server.AiImageResult.Result|null} [result] AiImageResult result
         * @property {server.AiImageResult.Reason|null} [reason] AiImageResult reason
         * @property {string|null} [id] AiImageResult id
         * @property {number|Long|null} [backoff] AiImageResult backoff
         */

        /**
         * Constructs a new AiImageResult.
         * @memberof server
         * @classdesc Represents an AiImageResult.
         * @implements IAiImageResult
         * @constructor
         * @param {server.IAiImageResult=} [properties] Properties to set
         */
        function AiImageResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AiImageResult result.
         * @member {server.AiImageResult.Result} result
         * @memberof server.AiImageResult
         * @instance
         */
        AiImageResult.prototype.result = 0;

        /**
         * AiImageResult reason.
         * @member {server.AiImageResult.Reason} reason
         * @memberof server.AiImageResult
         * @instance
         */
        AiImageResult.prototype.reason = 0;

        /**
         * AiImageResult id.
         * @member {string} id
         * @memberof server.AiImageResult
         * @instance
         */
        AiImageResult.prototype.id = "";

        /**
         * AiImageResult backoff.
         * @member {number|Long} backoff
         * @memberof server.AiImageResult
         * @instance
         */
        AiImageResult.prototype.backoff = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AiImageResult instance using the specified properties.
         * @function create
         * @memberof server.AiImageResult
         * @static
         * @param {server.IAiImageResult=} [properties] Properties to set
         * @returns {server.AiImageResult} AiImageResult instance
         */
        AiImageResult.create = function create(properties) {
            return new AiImageResult(properties);
        };

        /**
         * Encodes the specified AiImageResult message. Does not implicitly {@link server.AiImageResult.verify|verify} messages.
         * @function encode
         * @memberof server.AiImageResult
         * @static
         * @param {server.IAiImageResult} message AiImageResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImageResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
            if (message.backoff != null && Object.hasOwnProperty.call(message, "backoff"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.backoff);
            return writer;
        };

        /**
         * Encodes the specified AiImageResult message, length delimited. Does not implicitly {@link server.AiImageResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AiImageResult
         * @static
         * @param {server.IAiImageResult} message AiImageResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImageResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AiImageResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.AiImageResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AiImageResult} AiImageResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImageResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AiImageResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.backoff = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AiImageResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AiImageResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AiImageResult} AiImageResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImageResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AiImageResult message.
         * @function verify
         * @memberof server.AiImageResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AiImageResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.backoff != null && message.hasOwnProperty("backoff"))
                if (!$util.isInteger(message.backoff) && !(message.backoff && $util.isInteger(message.backoff.low) && $util.isInteger(message.backoff.high)))
                    return "backoff: integer|Long expected";
            return null;
        };

        /**
         * Creates an AiImageResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AiImageResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AiImageResult} AiImageResult
         */
        AiImageResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AiImageResult)
                return object;
            var message = new $root.server.AiImageResult();
            switch (object.result) {
            case "PENDING":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN":
            case 0:
                message.reason = 0;
                break;
            case "TOO_SOON":
            case 1:
                message.reason = 1;
                break;
            case "TOO_MANY_ATTEMPTS":
            case 2:
                message.reason = 2;
                break;
            }
            if (object.id != null)
                message.id = String(object.id);
            if (object.backoff != null)
                if ($util.Long)
                    (message.backoff = $util.Long.fromValue(object.backoff)).unsigned = false;
                else if (typeof object.backoff === "string")
                    message.backoff = parseInt(object.backoff, 10);
                else if (typeof object.backoff === "number")
                    message.backoff = object.backoff;
                else if (typeof object.backoff === "object")
                    message.backoff = new $util.LongBits(object.backoff.low >>> 0, object.backoff.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AiImageResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AiImageResult
         * @static
         * @param {server.AiImageResult} message AiImageResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AiImageResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "PENDING" : 0;
                object.reason = options.enums === String ? "UNKNOWN" : 0;
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.backoff = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.backoff = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.AiImageResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.AiImageResult.Reason[message.reason] : message.reason;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.backoff != null && message.hasOwnProperty("backoff"))
                if (typeof message.backoff === "number")
                    object.backoff = options.longs === String ? String(message.backoff) : message.backoff;
                else
                    object.backoff = options.longs === String ? $util.Long.prototype.toString.call(message.backoff) : options.longs === Number ? new $util.LongBits(message.backoff.low >>> 0, message.backoff.high >>> 0).toNumber() : message.backoff;
            return object;
        };

        /**
         * Converts this AiImageResult to JSON.
         * @function toJSON
         * @memberof server.AiImageResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AiImageResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.AiImageResult.Result
         * @enum {number}
         * @property {number} PENDING=0 PENDING value
         * @property {number} FAIL=1 FAIL value
         */
        AiImageResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PENDING"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.AiImageResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TOO_SOON=1 TOO_SOON value
         * @property {number} TOO_MANY_ATTEMPTS=2 TOO_MANY_ATTEMPTS value
         */
        AiImageResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TOO_SOON"] = 1;
            values[valuesById[2] = "TOO_MANY_ATTEMPTS"] = 2;
            return values;
        })();

        return AiImageResult;
    })();

    server.AiImage = (function() {

        /**
         * Properties of an AiImage.
         * @memberof server
         * @interface IAiImage
         * @property {string|null} [id] AiImage id
         * @property {Uint8Array|null} [image] AiImage image
         */

        /**
         * Constructs a new AiImage.
         * @memberof server
         * @classdesc Represents an AiImage.
         * @implements IAiImage
         * @constructor
         * @param {server.IAiImage=} [properties] Properties to set
         */
        function AiImage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AiImage id.
         * @member {string} id
         * @memberof server.AiImage
         * @instance
         */
        AiImage.prototype.id = "";

        /**
         * AiImage image.
         * @member {Uint8Array} image
         * @memberof server.AiImage
         * @instance
         */
        AiImage.prototype.image = $util.newBuffer([]);

        /**
         * Creates a new AiImage instance using the specified properties.
         * @function create
         * @memberof server.AiImage
         * @static
         * @param {server.IAiImage=} [properties] Properties to set
         * @returns {server.AiImage} AiImage instance
         */
        AiImage.create = function create(properties) {
            return new AiImage(properties);
        };

        /**
         * Encodes the specified AiImage message. Does not implicitly {@link server.AiImage.verify|verify} messages.
         * @function encode
         * @memberof server.AiImage
         * @static
         * @param {server.IAiImage} message AiImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.image);
            return writer;
        };

        /**
         * Encodes the specified AiImage message, length delimited. Does not implicitly {@link server.AiImage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AiImage
         * @static
         * @param {server.IAiImage} message AiImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AiImage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AiImage message from the specified reader or buffer.
         * @function decode
         * @memberof server.AiImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AiImage} AiImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AiImage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.image = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AiImage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AiImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AiImage} AiImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AiImage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AiImage message.
         * @function verify
         * @memberof server.AiImage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AiImage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.image != null && message.hasOwnProperty("image"))
                if (!(message.image && typeof message.image.length === "number" || $util.isString(message.image)))
                    return "image: buffer expected";
            return null;
        };

        /**
         * Creates an AiImage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AiImage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AiImage} AiImage
         */
        AiImage.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AiImage)
                return object;
            var message = new $root.server.AiImage();
            if (object.id != null)
                message.id = String(object.id);
            if (object.image != null)
                if (typeof object.image === "string")
                    $util.base64.decode(object.image, message.image = $util.newBuffer($util.base64.length(object.image)), 0);
                else if (object.image.length)
                    message.image = object.image;
            return message;
        };

        /**
         * Creates a plain object from an AiImage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AiImage
         * @static
         * @param {server.AiImage} message AiImage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AiImage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if (options.bytes === String)
                    object.image = "";
                else {
                    object.image = [];
                    if (options.bytes !== Array)
                        object.image = $util.newBuffer(object.image);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = options.bytes === String ? $util.base64.encode(message.image, 0, message.image.length) : options.bytes === Array ? Array.prototype.slice.call(message.image) : message.image;
            return object;
        };

        /**
         * Converts this AiImage to JSON.
         * @function toJSON
         * @memberof server.AiImage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AiImage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AiImage;
    })();

    server.EventData = (function() {

        /**
         * Properties of an EventData.
         * @memberof server
         * @interface IEventData
         * @property {number|Long|null} [uid] EventData uid
         * @property {server.Platform|null} [platform] EventData platform
         * @property {string|null} [version] EventData version
         * @property {number|Long|null} [timestampMs] EventData timestampMs
         * @property {string|null} [cc] EventData cc
         * @property {server.IMediaUpload|null} [mediaUpload] EventData mediaUpload
         * @property {server.IMediaDownload|null} [mediaDownload] EventData mediaDownload
         * @property {server.IMediaComposeLoad|null} [mediaComposeLoad] EventData mediaComposeLoad
         * @property {server.IPushReceived|null} [pushReceived] EventData pushReceived
         * @property {server.IDecryptionReport|null} [decryptionReport] EventData decryptionReport
         * @property {server.IPermissions|null} [permissions] EventData permissions
         * @property {server.IMediaObjectDownload|null} [mediaObjectDownload] EventData mediaObjectDownload
         * @property {server.IGroupDecryptionReport|null} [groupDecryptionReport] EventData groupDecryptionReport
         * @property {server.ICall|null} [call] EventData call
         * @property {server.IFabAction|null} [fabAction] EventData fabAction
         * @property {server.IGroupHistoryReport|null} [groupHistoryReport] EventData groupHistoryReport
         * @property {server.IHomeDecryptionReport|null} [homeDecryptionReport] EventData homeDecryptionReport
         * @property {server.IInviteRequestResult|null} [inviteRequestResult] EventData inviteRequestResult
         */

        /**
         * Constructs a new EventData.
         * @memberof server
         * @classdesc Represents an EventData.
         * @implements IEventData
         * @constructor
         * @param {server.IEventData=} [properties] Properties to set
         */
        function EventData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventData uid.
         * @member {number|Long} uid
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventData platform.
         * @member {server.Platform} platform
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.platform = 0;

        /**
         * EventData version.
         * @member {string} version
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.version = "";

        /**
         * EventData timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventData cc.
         * @member {string} cc
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.cc = "";

        /**
         * EventData mediaUpload.
         * @member {server.IMediaUpload|null|undefined} mediaUpload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaUpload = null;

        /**
         * EventData mediaDownload.
         * @member {server.IMediaDownload|null|undefined} mediaDownload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaDownload = null;

        /**
         * EventData mediaComposeLoad.
         * @member {server.IMediaComposeLoad|null|undefined} mediaComposeLoad
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaComposeLoad = null;

        /**
         * EventData pushReceived.
         * @member {server.IPushReceived|null|undefined} pushReceived
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.pushReceived = null;

        /**
         * EventData decryptionReport.
         * @member {server.IDecryptionReport|null|undefined} decryptionReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.decryptionReport = null;

        /**
         * EventData permissions.
         * @member {server.IPermissions|null|undefined} permissions
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.permissions = null;

        /**
         * EventData mediaObjectDownload.
         * @member {server.IMediaObjectDownload|null|undefined} mediaObjectDownload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaObjectDownload = null;

        /**
         * EventData groupDecryptionReport.
         * @member {server.IGroupDecryptionReport|null|undefined} groupDecryptionReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.groupDecryptionReport = null;

        /**
         * EventData call.
         * @member {server.ICall|null|undefined} call
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.call = null;

        /**
         * EventData fabAction.
         * @member {server.IFabAction|null|undefined} fabAction
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.fabAction = null;

        /**
         * EventData groupHistoryReport.
         * @member {server.IGroupHistoryReport|null|undefined} groupHistoryReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.groupHistoryReport = null;

        /**
         * EventData homeDecryptionReport.
         * @member {server.IHomeDecryptionReport|null|undefined} homeDecryptionReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.homeDecryptionReport = null;

        /**
         * EventData inviteRequestResult.
         * @member {server.IInviteRequestResult|null|undefined} inviteRequestResult
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.inviteRequestResult = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * EventData edata.
         * @member {"mediaUpload"|"mediaDownload"|"mediaComposeLoad"|"pushReceived"|"decryptionReport"|"permissions"|"mediaObjectDownload"|"groupDecryptionReport"|"call"|"fabAction"|"groupHistoryReport"|"homeDecryptionReport"|"inviteRequestResult"|undefined} edata
         * @memberof server.EventData
         * @instance
         */
        Object.defineProperty(EventData.prototype, "edata", {
            get: $util.oneOfGetter($oneOfFields = ["mediaUpload", "mediaDownload", "mediaComposeLoad", "pushReceived", "decryptionReport", "permissions", "mediaObjectDownload", "groupDecryptionReport", "call", "fabAction", "groupHistoryReport", "homeDecryptionReport", "inviteRequestResult"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EventData instance using the specified properties.
         * @function create
         * @memberof server.EventData
         * @static
         * @param {server.IEventData=} [properties] Properties to set
         * @returns {server.EventData} EventData instance
         */
        EventData.create = function create(properties) {
            return new EventData(properties);
        };

        /**
         * Encodes the specified EventData message. Does not implicitly {@link server.EventData.verify|verify} messages.
         * @function encode
         * @memberof server.EventData
         * @static
         * @param {server.IEventData} message EventData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uid);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.platform);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestampMs);
            if (message.cc != null && Object.hasOwnProperty.call(message, "cc"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.cc);
            if (message.mediaUpload != null && Object.hasOwnProperty.call(message, "mediaUpload"))
                $root.server.MediaUpload.encode(message.mediaUpload, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.mediaDownload != null && Object.hasOwnProperty.call(message, "mediaDownload"))
                $root.server.MediaDownload.encode(message.mediaDownload, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.mediaComposeLoad != null && Object.hasOwnProperty.call(message, "mediaComposeLoad"))
                $root.server.MediaComposeLoad.encode(message.mediaComposeLoad, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.pushReceived != null && Object.hasOwnProperty.call(message, "pushReceived"))
                $root.server.PushReceived.encode(message.pushReceived, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.decryptionReport != null && Object.hasOwnProperty.call(message, "decryptionReport"))
                $root.server.DecryptionReport.encode(message.decryptionReport, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.permissions != null && Object.hasOwnProperty.call(message, "permissions"))
                $root.server.Permissions.encode(message.permissions, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.mediaObjectDownload != null && Object.hasOwnProperty.call(message, "mediaObjectDownload"))
                $root.server.MediaObjectDownload.encode(message.mediaObjectDownload, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.groupDecryptionReport != null && Object.hasOwnProperty.call(message, "groupDecryptionReport"))
                $root.server.GroupDecryptionReport.encode(message.groupDecryptionReport, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                $root.server.Call.encode(message.call, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.fabAction != null && Object.hasOwnProperty.call(message, "fabAction"))
                $root.server.FabAction.encode(message.fabAction, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.groupHistoryReport != null && Object.hasOwnProperty.call(message, "groupHistoryReport"))
                $root.server.GroupHistoryReport.encode(message.groupHistoryReport, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.homeDecryptionReport != null && Object.hasOwnProperty.call(message, "homeDecryptionReport"))
                $root.server.HomeDecryptionReport.encode(message.homeDecryptionReport, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.inviteRequestResult != null && Object.hasOwnProperty.call(message, "inviteRequestResult"))
                $root.server.InviteRequestResult.encode(message.inviteRequestResult, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EventData message, length delimited. Does not implicitly {@link server.EventData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EventData
         * @static
         * @param {server.IEventData} message EventData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventData message from the specified reader or buffer.
         * @function decode
         * @memberof server.EventData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EventData} EventData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EventData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.uint64();
                    break;
                case 2:
                    message.platform = reader.int32();
                    break;
                case 3:
                    message.version = reader.string();
                    break;
                case 4:
                    message.timestampMs = reader.uint64();
                    break;
                case 5:
                    message.cc = reader.string();
                    break;
                case 10:
                    message.mediaUpload = $root.server.MediaUpload.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.mediaDownload = $root.server.MediaDownload.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.mediaComposeLoad = $root.server.MediaComposeLoad.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.pushReceived = $root.server.PushReceived.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.decryptionReport = $root.server.DecryptionReport.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.permissions = $root.server.Permissions.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.mediaObjectDownload = $root.server.MediaObjectDownload.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.groupDecryptionReport = $root.server.GroupDecryptionReport.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.call = $root.server.Call.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.fabAction = $root.server.FabAction.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.groupHistoryReport = $root.server.GroupHistoryReport.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.homeDecryptionReport = $root.server.HomeDecryptionReport.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.inviteRequestResult = $root.server.InviteRequestResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EventData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EventData} EventData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventData message.
         * @function verify
         * @memberof server.EventData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.cc != null && message.hasOwnProperty("cc"))
                if (!$util.isString(message.cc))
                    return "cc: string expected";
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload")) {
                properties.edata = 1;
                {
                    var error = $root.server.MediaUpload.verify(message.mediaUpload);
                    if (error)
                        return "mediaUpload." + error;
                }
            }
            if (message.mediaDownload != null && message.hasOwnProperty("mediaDownload")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaDownload.verify(message.mediaDownload);
                    if (error)
                        return "mediaDownload." + error;
                }
            }
            if (message.mediaComposeLoad != null && message.hasOwnProperty("mediaComposeLoad")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaComposeLoad.verify(message.mediaComposeLoad);
                    if (error)
                        return "mediaComposeLoad." + error;
                }
            }
            if (message.pushReceived != null && message.hasOwnProperty("pushReceived")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.PushReceived.verify(message.pushReceived);
                    if (error)
                        return "pushReceived." + error;
                }
            }
            if (message.decryptionReport != null && message.hasOwnProperty("decryptionReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.DecryptionReport.verify(message.decryptionReport);
                    if (error)
                        return "decryptionReport." + error;
                }
            }
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.Permissions.verify(message.permissions);
                    if (error)
                        return "permissions." + error;
                }
            }
            if (message.mediaObjectDownload != null && message.hasOwnProperty("mediaObjectDownload")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaObjectDownload.verify(message.mediaObjectDownload);
                    if (error)
                        return "mediaObjectDownload." + error;
                }
            }
            if (message.groupDecryptionReport != null && message.hasOwnProperty("groupDecryptionReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.GroupDecryptionReport.verify(message.groupDecryptionReport);
                    if (error)
                        return "groupDecryptionReport." + error;
                }
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.Call.verify(message.call);
                    if (error)
                        return "call." + error;
                }
            }
            if (message.fabAction != null && message.hasOwnProperty("fabAction")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.FabAction.verify(message.fabAction);
                    if (error)
                        return "fabAction." + error;
                }
            }
            if (message.groupHistoryReport != null && message.hasOwnProperty("groupHistoryReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.GroupHistoryReport.verify(message.groupHistoryReport);
                    if (error)
                        return "groupHistoryReport." + error;
                }
            }
            if (message.homeDecryptionReport != null && message.hasOwnProperty("homeDecryptionReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.HomeDecryptionReport.verify(message.homeDecryptionReport);
                    if (error)
                        return "homeDecryptionReport." + error;
                }
            }
            if (message.inviteRequestResult != null && message.hasOwnProperty("inviteRequestResult")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.InviteRequestResult.verify(message.inviteRequestResult);
                    if (error)
                        return "inviteRequestResult." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EventData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EventData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EventData} EventData
         */
        EventData.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EventData)
                return object;
            var message = new $root.server.EventData();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = true;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber(true);
            switch (object.platform) {
            case "UNKNOWN":
            case 0:
                message.platform = 0;
                break;
            case "IOS":
            case 1:
                message.platform = 1;
                break;
            case "ANDROID":
            case 2:
                message.platform = 2;
                break;
            }
            if (object.version != null)
                message.version = String(object.version);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = true;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber(true);
            if (object.cc != null)
                message.cc = String(object.cc);
            if (object.mediaUpload != null) {
                if (typeof object.mediaUpload !== "object")
                    throw TypeError(".server.EventData.mediaUpload: object expected");
                message.mediaUpload = $root.server.MediaUpload.fromObject(object.mediaUpload);
            }
            if (object.mediaDownload != null) {
                if (typeof object.mediaDownload !== "object")
                    throw TypeError(".server.EventData.mediaDownload: object expected");
                message.mediaDownload = $root.server.MediaDownload.fromObject(object.mediaDownload);
            }
            if (object.mediaComposeLoad != null) {
                if (typeof object.mediaComposeLoad !== "object")
                    throw TypeError(".server.EventData.mediaComposeLoad: object expected");
                message.mediaComposeLoad = $root.server.MediaComposeLoad.fromObject(object.mediaComposeLoad);
            }
            if (object.pushReceived != null) {
                if (typeof object.pushReceived !== "object")
                    throw TypeError(".server.EventData.pushReceived: object expected");
                message.pushReceived = $root.server.PushReceived.fromObject(object.pushReceived);
            }
            if (object.decryptionReport != null) {
                if (typeof object.decryptionReport !== "object")
                    throw TypeError(".server.EventData.decryptionReport: object expected");
                message.decryptionReport = $root.server.DecryptionReport.fromObject(object.decryptionReport);
            }
            if (object.permissions != null) {
                if (typeof object.permissions !== "object")
                    throw TypeError(".server.EventData.permissions: object expected");
                message.permissions = $root.server.Permissions.fromObject(object.permissions);
            }
            if (object.mediaObjectDownload != null) {
                if (typeof object.mediaObjectDownload !== "object")
                    throw TypeError(".server.EventData.mediaObjectDownload: object expected");
                message.mediaObjectDownload = $root.server.MediaObjectDownload.fromObject(object.mediaObjectDownload);
            }
            if (object.groupDecryptionReport != null) {
                if (typeof object.groupDecryptionReport !== "object")
                    throw TypeError(".server.EventData.groupDecryptionReport: object expected");
                message.groupDecryptionReport = $root.server.GroupDecryptionReport.fromObject(object.groupDecryptionReport);
            }
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".server.EventData.call: object expected");
                message.call = $root.server.Call.fromObject(object.call);
            }
            if (object.fabAction != null) {
                if (typeof object.fabAction !== "object")
                    throw TypeError(".server.EventData.fabAction: object expected");
                message.fabAction = $root.server.FabAction.fromObject(object.fabAction);
            }
            if (object.groupHistoryReport != null) {
                if (typeof object.groupHistoryReport !== "object")
                    throw TypeError(".server.EventData.groupHistoryReport: object expected");
                message.groupHistoryReport = $root.server.GroupHistoryReport.fromObject(object.groupHistoryReport);
            }
            if (object.homeDecryptionReport != null) {
                if (typeof object.homeDecryptionReport !== "object")
                    throw TypeError(".server.EventData.homeDecryptionReport: object expected");
                message.homeDecryptionReport = $root.server.HomeDecryptionReport.fromObject(object.homeDecryptionReport);
            }
            if (object.inviteRequestResult != null) {
                if (typeof object.inviteRequestResult !== "object")
                    throw TypeError(".server.EventData.inviteRequestResult: object expected");
                message.inviteRequestResult = $root.server.InviteRequestResult.fromObject(object.inviteRequestResult);
            }
            return message;
        };

        /**
         * Creates a plain object from an EventData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EventData
         * @static
         * @param {server.EventData} message EventData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.platform = options.enums === String ? "UNKNOWN" : 0;
                object.version = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.cc = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber(true) : message.uid;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.server.Platform[message.platform] : message.platform;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber(true) : message.timestampMs;
            if (message.cc != null && message.hasOwnProperty("cc"))
                object.cc = message.cc;
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload")) {
                object.mediaUpload = $root.server.MediaUpload.toObject(message.mediaUpload, options);
                if (options.oneofs)
                    object.edata = "mediaUpload";
            }
            if (message.mediaDownload != null && message.hasOwnProperty("mediaDownload")) {
                object.mediaDownload = $root.server.MediaDownload.toObject(message.mediaDownload, options);
                if (options.oneofs)
                    object.edata = "mediaDownload";
            }
            if (message.mediaComposeLoad != null && message.hasOwnProperty("mediaComposeLoad")) {
                object.mediaComposeLoad = $root.server.MediaComposeLoad.toObject(message.mediaComposeLoad, options);
                if (options.oneofs)
                    object.edata = "mediaComposeLoad";
            }
            if (message.pushReceived != null && message.hasOwnProperty("pushReceived")) {
                object.pushReceived = $root.server.PushReceived.toObject(message.pushReceived, options);
                if (options.oneofs)
                    object.edata = "pushReceived";
            }
            if (message.decryptionReport != null && message.hasOwnProperty("decryptionReport")) {
                object.decryptionReport = $root.server.DecryptionReport.toObject(message.decryptionReport, options);
                if (options.oneofs)
                    object.edata = "decryptionReport";
            }
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                object.permissions = $root.server.Permissions.toObject(message.permissions, options);
                if (options.oneofs)
                    object.edata = "permissions";
            }
            if (message.mediaObjectDownload != null && message.hasOwnProperty("mediaObjectDownload")) {
                object.mediaObjectDownload = $root.server.MediaObjectDownload.toObject(message.mediaObjectDownload, options);
                if (options.oneofs)
                    object.edata = "mediaObjectDownload";
            }
            if (message.groupDecryptionReport != null && message.hasOwnProperty("groupDecryptionReport")) {
                object.groupDecryptionReport = $root.server.GroupDecryptionReport.toObject(message.groupDecryptionReport, options);
                if (options.oneofs)
                    object.edata = "groupDecryptionReport";
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                object.call = $root.server.Call.toObject(message.call, options);
                if (options.oneofs)
                    object.edata = "call";
            }
            if (message.fabAction != null && message.hasOwnProperty("fabAction")) {
                object.fabAction = $root.server.FabAction.toObject(message.fabAction, options);
                if (options.oneofs)
                    object.edata = "fabAction";
            }
            if (message.groupHistoryReport != null && message.hasOwnProperty("groupHistoryReport")) {
                object.groupHistoryReport = $root.server.GroupHistoryReport.toObject(message.groupHistoryReport, options);
                if (options.oneofs)
                    object.edata = "groupHistoryReport";
            }
            if (message.homeDecryptionReport != null && message.hasOwnProperty("homeDecryptionReport")) {
                object.homeDecryptionReport = $root.server.HomeDecryptionReport.toObject(message.homeDecryptionReport, options);
                if (options.oneofs)
                    object.edata = "homeDecryptionReport";
            }
            if (message.inviteRequestResult != null && message.hasOwnProperty("inviteRequestResult")) {
                object.inviteRequestResult = $root.server.InviteRequestResult.toObject(message.inviteRequestResult, options);
                if (options.oneofs)
                    object.edata = "inviteRequestResult";
            }
            return object;
        };

        /**
         * Converts this EventData to JSON.
         * @function toJSON
         * @memberof server.EventData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventData;
    })();

    /**
     * Platform enum.
     * @name server.Platform
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} IOS=1 IOS value
     * @property {number} ANDROID=2 ANDROID value
     */
    server.Platform = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "IOS"] = 1;
        values[valuesById[2] = "ANDROID"] = 2;
        return values;
    })();

    server.MediaObjectDownload = (function() {

        /**
         * Properties of a MediaObjectDownload.
         * @memberof server
         * @interface IMediaObjectDownload
         * @property {string|null} [id] MediaObjectDownload id
         * @property {number|Long|null} [index] MediaObjectDownload index
         * @property {server.MediaObjectDownload.Type|null} [type] MediaObjectDownload type
         * @property {server.MediaObjectDownload.MediaType|null} [mediaType] MediaObjectDownload mediaType
         * @property {number|Long|null} [durationMs] MediaObjectDownload durationMs
         * @property {number|Long|null} [size] MediaObjectDownload size
         * @property {number|Long|null} [progressBytes] MediaObjectDownload progressBytes
         * @property {server.MediaObjectDownload.Cdn|null} [cdn] MediaObjectDownload cdn
         * @property {string|null} [cdnPop] MediaObjectDownload cdnPop
         * @property {string|null} [cdnId] MediaObjectDownload cdnId
         * @property {server.MediaObjectDownload.CdnCache|null} [cdnCache] MediaObjectDownload cdnCache
         * @property {server.MediaObjectDownload.Status|null} [status] MediaObjectDownload status
         * @property {number|Long|null} [retryCount] MediaObjectDownload retryCount
         */

        /**
         * Constructs a new MediaObjectDownload.
         * @memberof server
         * @classdesc Represents a MediaObjectDownload.
         * @implements IMediaObjectDownload
         * @constructor
         * @param {server.IMediaObjectDownload=} [properties] Properties to set
         */
        function MediaObjectDownload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaObjectDownload id.
         * @member {string} id
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.id = "";

        /**
         * MediaObjectDownload index.
         * @member {number|Long} index
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload type.
         * @member {server.MediaObjectDownload.Type} type
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.type = 0;

        /**
         * MediaObjectDownload mediaType.
         * @member {server.MediaObjectDownload.MediaType} mediaType
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.mediaType = 0;

        /**
         * MediaObjectDownload durationMs.
         * @member {number|Long} durationMs
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.durationMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload size.
         * @member {number|Long} size
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload progressBytes.
         * @member {number|Long} progressBytes
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.progressBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload cdn.
         * @member {server.MediaObjectDownload.Cdn} cdn
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdn = 0;

        /**
         * MediaObjectDownload cdnPop.
         * @member {string} cdnPop
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnPop = "";

        /**
         * MediaObjectDownload cdnId.
         * @member {string} cdnId
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnId = "";

        /**
         * MediaObjectDownload cdnCache.
         * @member {server.MediaObjectDownload.CdnCache} cdnCache
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnCache = 0;

        /**
         * MediaObjectDownload status.
         * @member {server.MediaObjectDownload.Status} status
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.status = 0;

        /**
         * MediaObjectDownload retryCount.
         * @member {number|Long} retryCount
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.retryCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new MediaObjectDownload instance using the specified properties.
         * @function create
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload=} [properties] Properties to set
         * @returns {server.MediaObjectDownload} MediaObjectDownload instance
         */
        MediaObjectDownload.create = function create(properties) {
            return new MediaObjectDownload(properties);
        };

        /**
         * Encodes the specified MediaObjectDownload message. Does not implicitly {@link server.MediaObjectDownload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload} message MediaObjectDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaObjectDownload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mediaType);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.durationMs);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.size);
            if (message.progressBytes != null && Object.hasOwnProperty.call(message, "progressBytes"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.progressBytes);
            if (message.cdn != null && Object.hasOwnProperty.call(message, "cdn"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.cdn);
            if (message.cdnPop != null && Object.hasOwnProperty.call(message, "cdnPop"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.cdnPop);
            if (message.cdnId != null && Object.hasOwnProperty.call(message, "cdnId"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.cdnId);
            if (message.cdnCache != null && Object.hasOwnProperty.call(message, "cdnCache"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.cdnCache);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaObjectDownload message, length delimited. Does not implicitly {@link server.MediaObjectDownload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload} message MediaObjectDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaObjectDownload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaObjectDownload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaObjectDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaObjectDownload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaObjectDownload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.index = reader.uint64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.mediaType = reader.int32();
                    break;
                case 5:
                    message.durationMs = reader.uint64();
                    break;
                case 6:
                    message.size = reader.uint64();
                    break;
                case 7:
                    message.progressBytes = reader.uint64();
                    break;
                case 8:
                    message.cdn = reader.int32();
                    break;
                case 9:
                    message.cdnPop = reader.string();
                    break;
                case 10:
                    message.cdnId = reader.string();
                    break;
                case 11:
                    message.cdnCache = reader.int32();
                    break;
                case 12:
                    message.status = reader.int32();
                    break;
                case 13:
                    message.retryCount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaObjectDownload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaObjectDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaObjectDownload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaObjectDownload message.
         * @function verify
         * @memberof server.MediaObjectDownload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaObjectDownload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))
                    return "durationMs: integer|Long expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            if (message.progressBytes != null && message.hasOwnProperty("progressBytes"))
                if (!$util.isInteger(message.progressBytes) && !(message.progressBytes && $util.isInteger(message.progressBytes.low) && $util.isInteger(message.progressBytes.high)))
                    return "progressBytes: integer|Long expected";
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                switch (message.cdn) {
                default:
                    return "cdn: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.cdnPop != null && message.hasOwnProperty("cdnPop"))
                if (!$util.isString(message.cdnPop))
                    return "cdnPop: string expected";
            if (message.cdnId != null && message.hasOwnProperty("cdnId"))
                if (!$util.isString(message.cdnId))
                    return "cdnId: string expected";
            if (message.cdnCache != null && message.hasOwnProperty("cdnCache"))
                switch (message.cdnCache) {
                default:
                    return "cdnCache: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount) && !(message.retryCount && $util.isInteger(message.retryCount.low) && $util.isInteger(message.retryCount.high)))
                    return "retryCount: integer|Long expected";
            return null;
        };

        /**
         * Creates a MediaObjectDownload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaObjectDownload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         */
        MediaObjectDownload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaObjectDownload)
                return object;
            var message = new $root.server.MediaObjectDownload();
            if (object.id != null)
                message.id = String(object.id);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            switch (object.mediaType) {
            case "PHOTO":
            case 0:
                message.mediaType = 0;
                break;
            case "VIDEO":
            case 1:
                message.mediaType = 1;
                break;
            case "AUDIO":
            case 2:
                message.mediaType = 2;
                break;
            }
            if (object.durationMs != null)
                if ($util.Long)
                    (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = true;
                else if (typeof object.durationMs === "string")
                    message.durationMs = parseInt(object.durationMs, 10);
                else if (typeof object.durationMs === "number")
                    message.durationMs = object.durationMs;
                else if (typeof object.durationMs === "object")
                    message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber(true);
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
            if (object.progressBytes != null)
                if ($util.Long)
                    (message.progressBytes = $util.Long.fromValue(object.progressBytes)).unsigned = true;
                else if (typeof object.progressBytes === "string")
                    message.progressBytes = parseInt(object.progressBytes, 10);
                else if (typeof object.progressBytes === "number")
                    message.progressBytes = object.progressBytes;
                else if (typeof object.progressBytes === "object")
                    message.progressBytes = new $util.LongBits(object.progressBytes.low >>> 0, object.progressBytes.high >>> 0).toNumber(true);
            switch (object.cdn) {
            case "UNKNOWN_CDN":
            case 0:
                message.cdn = 0;
                break;
            case "CLOUDFRONT":
            case 1:
                message.cdn = 1;
                break;
            }
            if (object.cdnPop != null)
                message.cdnPop = String(object.cdnPop);
            if (object.cdnId != null)
                message.cdnId = String(object.cdnId);
            switch (object.cdnCache) {
            case "UNKNOWN_CACHE":
            case 0:
                message.cdnCache = 0;
                break;
            case "HIT":
            case 1:
                message.cdnCache = 1;
                break;
            case "MISS":
            case 2:
                message.cdnCache = 2;
                break;
            case "REFRESH_HIT":
            case 3:
                message.cdnCache = 3;
                break;
            case "REFRESH_MISS":
            case 4:
                message.cdnCache = 4;
                break;
            }
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                if ($util.Long)
                    (message.retryCount = $util.Long.fromValue(object.retryCount)).unsigned = true;
                else if (typeof object.retryCount === "string")
                    message.retryCount = parseInt(object.retryCount, 10);
                else if (typeof object.retryCount === "number")
                    message.retryCount = object.retryCount;
                else if (typeof object.retryCount === "object")
                    message.retryCount = new $util.LongBits(object.retryCount.low >>> 0, object.retryCount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a MediaObjectDownload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.MediaObjectDownload} message MediaObjectDownload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaObjectDownload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "POST" : 0;
                object.mediaType = options.enums === String ? "PHOTO" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.durationMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.durationMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.progressBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.progressBytes = options.longs === String ? "0" : 0;
                object.cdn = options.enums === String ? "UNKNOWN_CDN" : 0;
                object.cdnPop = "";
                object.cdnId = "";
                object.cdnCache = options.enums === String ? "UNKNOWN_CACHE" : 0;
                object.status = options.enums === String ? "OK" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.retryCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.retryCount = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaObjectDownload.Type[message.type] : message.type;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.server.MediaObjectDownload.MediaType[message.mediaType] : message.mediaType;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (typeof message.durationMs === "number")
                    object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;
                else
                    object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber(true) : message.durationMs;
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
            if (message.progressBytes != null && message.hasOwnProperty("progressBytes"))
                if (typeof message.progressBytes === "number")
                    object.progressBytes = options.longs === String ? String(message.progressBytes) : message.progressBytes;
                else
                    object.progressBytes = options.longs === String ? $util.Long.prototype.toString.call(message.progressBytes) : options.longs === Number ? new $util.LongBits(message.progressBytes.low >>> 0, message.progressBytes.high >>> 0).toNumber(true) : message.progressBytes;
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                object.cdn = options.enums === String ? $root.server.MediaObjectDownload.Cdn[message.cdn] : message.cdn;
            if (message.cdnPop != null && message.hasOwnProperty("cdnPop"))
                object.cdnPop = message.cdnPop;
            if (message.cdnId != null && message.hasOwnProperty("cdnId"))
                object.cdnId = message.cdnId;
            if (message.cdnCache != null && message.hasOwnProperty("cdnCache"))
                object.cdnCache = options.enums === String ? $root.server.MediaObjectDownload.CdnCache[message.cdnCache] : message.cdnCache;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaObjectDownload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (typeof message.retryCount === "number")
                    object.retryCount = options.longs === String ? String(message.retryCount) : message.retryCount;
                else
                    object.retryCount = options.longs === String ? $util.Long.prototype.toString.call(message.retryCount) : options.longs === Number ? new $util.LongBits(message.retryCount.low >>> 0, message.retryCount.high >>> 0).toNumber(true) : message.retryCount;
            return object;
        };

        /**
         * Converts this MediaObjectDownload to JSON.
         * @function toJSON
         * @memberof server.MediaObjectDownload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaObjectDownload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaObjectDownload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaObjectDownload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * MediaType enum.
         * @name server.MediaObjectDownload.MediaType
         * @enum {number}
         * @property {number} PHOTO=0 PHOTO value
         * @property {number} VIDEO=1 VIDEO value
         * @property {number} AUDIO=2 AUDIO value
         */
        MediaObjectDownload.MediaType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PHOTO"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            values[valuesById[2] = "AUDIO"] = 2;
            return values;
        })();

        /**
         * Cdn enum.
         * @name server.MediaObjectDownload.Cdn
         * @enum {number}
         * @property {number} UNKNOWN_CDN=0 UNKNOWN_CDN value
         * @property {number} CLOUDFRONT=1 CLOUDFRONT value
         */
        MediaObjectDownload.Cdn = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CDN"] = 0;
            values[valuesById[1] = "CLOUDFRONT"] = 1;
            return values;
        })();

        /**
         * CdnCache enum.
         * @name server.MediaObjectDownload.CdnCache
         * @enum {number}
         * @property {number} UNKNOWN_CACHE=0 UNKNOWN_CACHE value
         * @property {number} HIT=1 HIT value
         * @property {number} MISS=2 MISS value
         * @property {number} REFRESH_HIT=3 REFRESH_HIT value
         * @property {number} REFRESH_MISS=4 REFRESH_MISS value
         */
        MediaObjectDownload.CdnCache = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CACHE"] = 0;
            values[valuesById[1] = "HIT"] = 1;
            values[valuesById[2] = "MISS"] = 2;
            values[valuesById[3] = "REFRESH_HIT"] = 3;
            values[valuesById[4] = "REFRESH_MISS"] = 4;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaObjectDownload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaObjectDownload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaObjectDownload;
    })();

    server.MediaUpload = (function() {

        /**
         * Properties of a MediaUpload.
         * @memberof server
         * @interface IMediaUpload
         * @property {string|null} [id] MediaUpload id
         * @property {server.MediaUpload.Type|null} [type] MediaUpload type
         * @property {number|null} [durationMs] MediaUpload durationMs
         * @property {number|null} [numPhotos] MediaUpload numPhotos
         * @property {number|null} [numVideos] MediaUpload numVideos
         * @property {number|null} [totalSize] MediaUpload totalSize
         * @property {server.MediaUpload.Status|null} [status] MediaUpload status
         * @property {number|null} [retryCount] MediaUpload retryCount
         */

        /**
         * Constructs a new MediaUpload.
         * @memberof server
         * @classdesc Represents a MediaUpload.
         * @implements IMediaUpload
         * @constructor
         * @param {server.IMediaUpload=} [properties] Properties to set
         */
        function MediaUpload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaUpload id.
         * @member {string} id
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.id = "";

        /**
         * MediaUpload type.
         * @member {server.MediaUpload.Type} type
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.type = 0;

        /**
         * MediaUpload durationMs.
         * @member {number} durationMs
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.durationMs = 0;

        /**
         * MediaUpload numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.numPhotos = 0;

        /**
         * MediaUpload numVideos.
         * @member {number} numVideos
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.numVideos = 0;

        /**
         * MediaUpload totalSize.
         * @member {number} totalSize
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.totalSize = 0;

        /**
         * MediaUpload status.
         * @member {server.MediaUpload.Status} status
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.status = 0;

        /**
         * MediaUpload retryCount.
         * @member {number} retryCount
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.retryCount = 0;

        /**
         * Creates a new MediaUpload instance using the specified properties.
         * @function create
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload=} [properties] Properties to set
         * @returns {server.MediaUpload} MediaUpload instance
         */
        MediaUpload.create = function create(properties) {
            return new MediaUpload(properties);
        };

        /**
         * Encodes the specified MediaUpload message. Does not implicitly {@link server.MediaUpload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload} message MediaUpload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUpload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.totalSize);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaUpload message, length delimited. Does not implicitly {@link server.MediaUpload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload} message MediaUpload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUpload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaUpload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaUpload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaUpload} MediaUpload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUpload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaUpload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.durationMs = reader.uint32();
                    break;
                case 4:
                    message.numPhotos = reader.uint32();
                    break;
                case 5:
                    message.numVideos = reader.uint32();
                    break;
                case 6:
                    message.totalSize = reader.uint32();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.retryCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaUpload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaUpload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaUpload} MediaUpload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUpload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaUpload message.
         * @function verify
         * @memberof server.MediaUpload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaUpload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            return null;
        };

        /**
         * Creates a MediaUpload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaUpload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaUpload} MediaUpload
         */
        MediaUpload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaUpload)
                return object;
            var message = new $root.server.MediaUpload();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaUpload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaUpload
         * @static
         * @param {server.MediaUpload} message MediaUpload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaUpload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "POST" : 0;
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
                object.status = options.enums === String ? "OK" : 0;
                object.retryCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaUpload.Type[message.type] : message.type;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaUpload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            return object;
        };

        /**
         * Converts this MediaUpload to JSON.
         * @function toJSON
         * @memberof server.MediaUpload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaUpload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaUpload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaUpload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaUpload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaUpload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaUpload;
    })();

    server.MediaDownload = (function() {

        /**
         * Properties of a MediaDownload.
         * @memberof server
         * @interface IMediaDownload
         * @property {string|null} [id] MediaDownload id
         * @property {server.MediaDownload.Type|null} [type] MediaDownload type
         * @property {number|null} [durationMs] MediaDownload durationMs
         * @property {number|null} [numPhotos] MediaDownload numPhotos
         * @property {number|null} [numVideos] MediaDownload numVideos
         * @property {number|null} [totalSize] MediaDownload totalSize
         * @property {server.MediaDownload.Status|null} [status] MediaDownload status
         * @property {number|null} [retryCount] MediaDownload retryCount
         */

        /**
         * Constructs a new MediaDownload.
         * @memberof server
         * @classdesc Represents a MediaDownload.
         * @implements IMediaDownload
         * @constructor
         * @param {server.IMediaDownload=} [properties] Properties to set
         */
        function MediaDownload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaDownload id.
         * @member {string} id
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.id = "";

        /**
         * MediaDownload type.
         * @member {server.MediaDownload.Type} type
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.type = 0;

        /**
         * MediaDownload durationMs.
         * @member {number} durationMs
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.durationMs = 0;

        /**
         * MediaDownload numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.numPhotos = 0;

        /**
         * MediaDownload numVideos.
         * @member {number} numVideos
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.numVideos = 0;

        /**
         * MediaDownload totalSize.
         * @member {number} totalSize
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.totalSize = 0;

        /**
         * MediaDownload status.
         * @member {server.MediaDownload.Status} status
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.status = 0;

        /**
         * MediaDownload retryCount.
         * @member {number} retryCount
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.retryCount = 0;

        /**
         * Creates a new MediaDownload instance using the specified properties.
         * @function create
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload=} [properties] Properties to set
         * @returns {server.MediaDownload} MediaDownload instance
         */
        MediaDownload.create = function create(properties) {
            return new MediaDownload(properties);
        };

        /**
         * Encodes the specified MediaDownload message. Does not implicitly {@link server.MediaDownload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload} message MediaDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaDownload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.totalSize);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaDownload message, length delimited. Does not implicitly {@link server.MediaDownload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload} message MediaDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaDownload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaDownload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaDownload} MediaDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaDownload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaDownload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.durationMs = reader.uint32();
                    break;
                case 4:
                    message.numPhotos = reader.uint32();
                    break;
                case 5:
                    message.numVideos = reader.uint32();
                    break;
                case 6:
                    message.totalSize = reader.uint32();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.retryCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaDownload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaDownload} MediaDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaDownload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaDownload message.
         * @function verify
         * @memberof server.MediaDownload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaDownload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            return null;
        };

        /**
         * Creates a MediaDownload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaDownload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaDownload} MediaDownload
         */
        MediaDownload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaDownload)
                return object;
            var message = new $root.server.MediaDownload();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaDownload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaDownload
         * @static
         * @param {server.MediaDownload} message MediaDownload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaDownload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "POST" : 0;
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
                object.status = options.enums === String ? "OK" : 0;
                object.retryCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaDownload.Type[message.type] : message.type;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaDownload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            return object;
        };

        /**
         * Converts this MediaDownload to JSON.
         * @function toJSON
         * @memberof server.MediaDownload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaDownload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaDownload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaDownload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaDownload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaDownload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaDownload;
    })();

    server.MediaComposeLoad = (function() {

        /**
         * Properties of a MediaComposeLoad.
         * @memberof server
         * @interface IMediaComposeLoad
         * @property {number|null} [durationMs] MediaComposeLoad durationMs
         * @property {number|null} [numPhotos] MediaComposeLoad numPhotos
         * @property {number|null} [numVideos] MediaComposeLoad numVideos
         * @property {number|null} [totalSize] MediaComposeLoad totalSize
         */

        /**
         * Constructs a new MediaComposeLoad.
         * @memberof server
         * @classdesc Represents a MediaComposeLoad.
         * @implements IMediaComposeLoad
         * @constructor
         * @param {server.IMediaComposeLoad=} [properties] Properties to set
         */
        function MediaComposeLoad(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaComposeLoad durationMs.
         * @member {number} durationMs
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.durationMs = 0;

        /**
         * MediaComposeLoad numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.numPhotos = 0;

        /**
         * MediaComposeLoad numVideos.
         * @member {number} numVideos
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.numVideos = 0;

        /**
         * MediaComposeLoad totalSize.
         * @member {number} totalSize
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.totalSize = 0;

        /**
         * Creates a new MediaComposeLoad instance using the specified properties.
         * @function create
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad=} [properties] Properties to set
         * @returns {server.MediaComposeLoad} MediaComposeLoad instance
         */
        MediaComposeLoad.create = function create(properties) {
            return new MediaComposeLoad(properties);
        };

        /**
         * Encodes the specified MediaComposeLoad message. Does not implicitly {@link server.MediaComposeLoad.verify|verify} messages.
         * @function encode
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad} message MediaComposeLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaComposeLoad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.totalSize);
            return writer;
        };

        /**
         * Encodes the specified MediaComposeLoad message, length delimited. Does not implicitly {@link server.MediaComposeLoad.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad} message MediaComposeLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaComposeLoad.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaComposeLoad message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaComposeLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaComposeLoad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaComposeLoad();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.durationMs = reader.uint32();
                    break;
                case 2:
                    message.numPhotos = reader.uint32();
                    break;
                case 3:
                    message.numVideos = reader.uint32();
                    break;
                case 4:
                    message.totalSize = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaComposeLoad message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaComposeLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaComposeLoad.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaComposeLoad message.
         * @function verify
         * @memberof server.MediaComposeLoad
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaComposeLoad.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            return null;
        };

        /**
         * Creates a MediaComposeLoad message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaComposeLoad
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         */
        MediaComposeLoad.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaComposeLoad)
                return object;
            var message = new $root.server.MediaComposeLoad();
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaComposeLoad message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.MediaComposeLoad} message MediaComposeLoad
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaComposeLoad.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
            }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            return object;
        };

        /**
         * Converts this MediaComposeLoad to JSON.
         * @function toJSON
         * @memberof server.MediaComposeLoad
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaComposeLoad.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaComposeLoad;
    })();

    server.PushReceived = (function() {

        /**
         * Properties of a PushReceived.
         * @memberof server
         * @interface IPushReceived
         * @property {string|null} [id] PushReceived id
         * @property {number|Long|null} [clientTimestamp] PushReceived clientTimestamp
         */

        /**
         * Constructs a new PushReceived.
         * @memberof server
         * @classdesc Represents a PushReceived.
         * @implements IPushReceived
         * @constructor
         * @param {server.IPushReceived=} [properties] Properties to set
         */
        function PushReceived(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReceived id.
         * @member {string} id
         * @memberof server.PushReceived
         * @instance
         */
        PushReceived.prototype.id = "";

        /**
         * PushReceived clientTimestamp.
         * @member {number|Long} clientTimestamp
         * @memberof server.PushReceived
         * @instance
         */
        PushReceived.prototype.clientTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PushReceived instance using the specified properties.
         * @function create
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived=} [properties] Properties to set
         * @returns {server.PushReceived} PushReceived instance
         */
        PushReceived.create = function create(properties) {
            return new PushReceived(properties);
        };

        /**
         * Encodes the specified PushReceived message. Does not implicitly {@link server.PushReceived.verify|verify} messages.
         * @function encode
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived} message PushReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReceived.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.clientTimestamp != null && Object.hasOwnProperty.call(message, "clientTimestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clientTimestamp);
            return writer;
        };

        /**
         * Encodes the specified PushReceived message, length delimited. Does not implicitly {@link server.PushReceived.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived} message PushReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReceived.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushReceived message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushReceived} PushReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReceived.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushReceived();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.clientTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushReceived message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushReceived} PushReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReceived.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushReceived message.
         * @function verify
         * @memberof server.PushReceived
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushReceived.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (!$util.isInteger(message.clientTimestamp) && !(message.clientTimestamp && $util.isInteger(message.clientTimestamp.low) && $util.isInteger(message.clientTimestamp.high)))
                    return "clientTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PushReceived message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushReceived
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushReceived} PushReceived
         */
        PushReceived.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushReceived)
                return object;
            var message = new $root.server.PushReceived();
            if (object.id != null)
                message.id = String(object.id);
            if (object.clientTimestamp != null)
                if ($util.Long)
                    (message.clientTimestamp = $util.Long.fromValue(object.clientTimestamp)).unsigned = true;
                else if (typeof object.clientTimestamp === "string")
                    message.clientTimestamp = parseInt(object.clientTimestamp, 10);
                else if (typeof object.clientTimestamp === "number")
                    message.clientTimestamp = object.clientTimestamp;
                else if (typeof object.clientTimestamp === "object")
                    message.clientTimestamp = new $util.LongBits(object.clientTimestamp.low >>> 0, object.clientTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PushReceived message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushReceived
         * @static
         * @param {server.PushReceived} message PushReceived
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushReceived.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.clientTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (typeof message.clientTimestamp === "number")
                    object.clientTimestamp = options.longs === String ? String(message.clientTimestamp) : message.clientTimestamp;
                else
                    object.clientTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.clientTimestamp) : options.longs === Number ? new $util.LongBits(message.clientTimestamp.low >>> 0, message.clientTimestamp.high >>> 0).toNumber(true) : message.clientTimestamp;
            return object;
        };

        /**
         * Converts this PushReceived to JSON.
         * @function toJSON
         * @memberof server.PushReceived
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushReceived.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushReceived;
    })();

    server.DecryptionReport = (function() {

        /**
         * Properties of a DecryptionReport.
         * @memberof server
         * @interface IDecryptionReport
         * @property {server.DecryptionReport.Status|null} [result] DecryptionReport result
         * @property {string|null} [reason] DecryptionReport reason
         * @property {string|null} [msgId] DecryptionReport msgId
         * @property {string|null} [originalVersion] DecryptionReport originalVersion
         * @property {server.Platform|null} [senderPlatform] DecryptionReport senderPlatform
         * @property {string|null} [senderVersion] DecryptionReport senderVersion
         * @property {number|null} [rerequestCount] DecryptionReport rerequestCount
         * @property {number|null} [timeTakenS] DecryptionReport timeTakenS
         * @property {boolean|null} [isSilent] DecryptionReport isSilent
         * @property {server.DecryptionReport.ContentType|null} [contentType] DecryptionReport contentType
         */

        /**
         * Constructs a new DecryptionReport.
         * @memberof server
         * @classdesc Represents a DecryptionReport.
         * @implements IDecryptionReport
         * @constructor
         * @param {server.IDecryptionReport=} [properties] Properties to set
         */
        function DecryptionReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecryptionReport result.
         * @member {server.DecryptionReport.Status} result
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.result = 0;

        /**
         * DecryptionReport reason.
         * @member {string} reason
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.reason = "";

        /**
         * DecryptionReport msgId.
         * @member {string} msgId
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.msgId = "";

        /**
         * DecryptionReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.originalVersion = "";

        /**
         * DecryptionReport senderPlatform.
         * @member {server.Platform} senderPlatform
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.senderPlatform = 0;

        /**
         * DecryptionReport senderVersion.
         * @member {string} senderVersion
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.senderVersion = "";

        /**
         * DecryptionReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.rerequestCount = 0;

        /**
         * DecryptionReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.timeTakenS = 0;

        /**
         * DecryptionReport isSilent.
         * @member {boolean} isSilent
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.isSilent = false;

        /**
         * DecryptionReport contentType.
         * @member {server.DecryptionReport.ContentType} contentType
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.contentType = 0;

        /**
         * Creates a new DecryptionReport instance using the specified properties.
         * @function create
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport=} [properties] Properties to set
         * @returns {server.DecryptionReport} DecryptionReport instance
         */
        DecryptionReport.create = function create(properties) {
            return new DecryptionReport(properties);
        };

        /**
         * Encodes the specified DecryptionReport message. Does not implicitly {@link server.DecryptionReport.verify|verify} messages.
         * @function encode
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport} message DecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecryptionReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.originalVersion);
            if (message.senderPlatform != null && Object.hasOwnProperty.call(message, "senderPlatform"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.senderPlatform);
            if (message.senderVersion != null && Object.hasOwnProperty.call(message, "senderVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeTakenS);
            if (message.isSilent != null && Object.hasOwnProperty.call(message, "isSilent"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSilent);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified DecryptionReport message, length delimited. Does not implicitly {@link server.DecryptionReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport} message DecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecryptionReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecryptionReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.DecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DecryptionReport} DecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecryptionReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DecryptionReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.msgId = reader.string();
                    break;
                case 4:
                    message.originalVersion = reader.string();
                    break;
                case 5:
                    message.senderPlatform = reader.int32();
                    break;
                case 6:
                    message.senderVersion = reader.string();
                    break;
                case 7:
                    message.rerequestCount = reader.uint32();
                    break;
                case 8:
                    message.timeTakenS = reader.uint32();
                    break;
                case 9:
                    message.isSilent = reader.bool();
                    break;
                case 10:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DecryptionReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DecryptionReport} DecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecryptionReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecryptionReport message.
         * @function verify
         * @memberof server.DecryptionReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecryptionReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                switch (message.senderPlatform) {
                default:
                    return "senderPlatform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                if (!$util.isString(message.senderVersion))
                    return "senderVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.isSilent != null && message.hasOwnProperty("isSilent"))
                if (typeof message.isSilent !== "boolean")
                    return "isSilent: boolean expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a DecryptionReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DecryptionReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DecryptionReport} DecryptionReport
         */
        DecryptionReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DecryptionReport)
                return object;
            var message = new $root.server.DecryptionReport();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            switch (object.senderPlatform) {
            case "UNKNOWN":
            case 0:
                message.senderPlatform = 0;
                break;
            case "IOS":
            case 1:
                message.senderPlatform = 1;
                break;
            case "ANDROID":
            case 2:
                message.senderPlatform = 2;
                break;
            }
            if (object.senderVersion != null)
                message.senderVersion = String(object.senderVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            if (object.isSilent != null)
                message.isSilent = Boolean(object.isSilent);
            switch (object.contentType) {
            case "CHAT":
            case 0:
                message.contentType = 0;
                break;
            case "GROUP_HISTORY":
            case 1:
                message.contentType = 1;
                break;
            case "CHAT_REACTION":
            case 2:
                message.contentType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DecryptionReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DecryptionReport
         * @static
         * @param {server.DecryptionReport} message DecryptionReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecryptionReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = "";
                object.msgId = "";
                object.originalVersion = "";
                object.senderPlatform = options.enums === String ? "UNKNOWN" : 0;
                object.senderVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.isSilent = false;
                object.contentType = options.enums === String ? "CHAT" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.DecryptionReport.Status[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                object.senderPlatform = options.enums === String ? $root.server.Platform[message.senderPlatform] : message.senderPlatform;
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                object.senderVersion = message.senderVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.isSilent != null && message.hasOwnProperty("isSilent"))
                object.isSilent = message.isSilent;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.DecryptionReport.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this DecryptionReport to JSON.
         * @function toJSON
         * @memberof server.DecryptionReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecryptionReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.DecryptionReport.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        DecryptionReport.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * ContentType enum.
         * @name server.DecryptionReport.ContentType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} GROUP_HISTORY=1 GROUP_HISTORY value
         * @property {number} CHAT_REACTION=2 CHAT_REACTION value
         */
        DecryptionReport.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "GROUP_HISTORY"] = 1;
            values[valuesById[2] = "CHAT_REACTION"] = 2;
            return values;
        })();

        return DecryptionReport;
    })();

    server.GroupDecryptionReport = (function() {

        /**
         * Properties of a GroupDecryptionReport.
         * @memberof server
         * @interface IGroupDecryptionReport
         * @property {server.GroupDecryptionReport.Status|null} [result] GroupDecryptionReport result
         * @property {string|null} [reason] GroupDecryptionReport reason
         * @property {string|null} [contentId] GroupDecryptionReport contentId
         * @property {string|null} [gid] GroupDecryptionReport gid
         * @property {server.GroupDecryptionReport.ItemType|null} [itemType] GroupDecryptionReport itemType
         * @property {string|null} [originalVersion] GroupDecryptionReport originalVersion
         * @property {number|null} [rerequestCount] GroupDecryptionReport rerequestCount
         * @property {number|null} [timeTakenS] GroupDecryptionReport timeTakenS
         * @property {server.Platform|null} [senderPlatform] GroupDecryptionReport senderPlatform
         * @property {string|null} [senderVersion] GroupDecryptionReport senderVersion
         * @property {server.GroupDecryptionReport.Schedule|null} [schedule] GroupDecryptionReport schedule
         */

        /**
         * Constructs a new GroupDecryptionReport.
         * @memberof server
         * @classdesc Represents a GroupDecryptionReport.
         * @implements IGroupDecryptionReport
         * @constructor
         * @param {server.IGroupDecryptionReport=} [properties] Properties to set
         */
        function GroupDecryptionReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupDecryptionReport result.
         * @member {server.GroupDecryptionReport.Status} result
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.result = 0;

        /**
         * GroupDecryptionReport reason.
         * @member {string} reason
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.reason = "";

        /**
         * GroupDecryptionReport contentId.
         * @member {string} contentId
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.contentId = "";

        /**
         * GroupDecryptionReport gid.
         * @member {string} gid
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.gid = "";

        /**
         * GroupDecryptionReport itemType.
         * @member {server.GroupDecryptionReport.ItemType} itemType
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.itemType = 0;

        /**
         * GroupDecryptionReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.originalVersion = "";

        /**
         * GroupDecryptionReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.rerequestCount = 0;

        /**
         * GroupDecryptionReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.timeTakenS = 0;

        /**
         * GroupDecryptionReport senderPlatform.
         * @member {server.Platform} senderPlatform
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.senderPlatform = 0;

        /**
         * GroupDecryptionReport senderVersion.
         * @member {string} senderVersion
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.senderVersion = "";

        /**
         * GroupDecryptionReport schedule.
         * @member {server.GroupDecryptionReport.Schedule} schedule
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.schedule = 0;

        /**
         * Creates a new GroupDecryptionReport instance using the specified properties.
         * @function create
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport=} [properties] Properties to set
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport instance
         */
        GroupDecryptionReport.create = function create(properties) {
            return new GroupDecryptionReport(properties);
        };

        /**
         * Encodes the specified GroupDecryptionReport message. Does not implicitly {@link server.GroupDecryptionReport.verify|verify} messages.
         * @function encode
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport} message GroupDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDecryptionReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.contentId);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.gid);
            if (message.itemType != null && Object.hasOwnProperty.call(message, "itemType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.itemType);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.originalVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeTakenS);
            if (message.senderPlatform != null && Object.hasOwnProperty.call(message, "senderPlatform"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.senderPlatform);
            if (message.senderVersion != null && Object.hasOwnProperty.call(message, "senderVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.senderVersion);
            if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.schedule);
            return writer;
        };

        /**
         * Encodes the specified GroupDecryptionReport message, length delimited. Does not implicitly {@link server.GroupDecryptionReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport} message GroupDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDecryptionReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupDecryptionReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDecryptionReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupDecryptionReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.contentId = reader.string();
                    break;
                case 4:
                    message.gid = reader.string();
                    break;
                case 5:
                    message.itemType = reader.int32();
                    break;
                case 6:
                    message.originalVersion = reader.string();
                    break;
                case 7:
                    message.rerequestCount = reader.uint32();
                    break;
                case 8:
                    message.timeTakenS = reader.uint32();
                    break;
                case 9:
                    message.senderPlatform = reader.int32();
                    break;
                case 10:
                    message.senderVersion = reader.string();
                    break;
                case 11:
                    message.schedule = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupDecryptionReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDecryptionReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupDecryptionReport message.
         * @function verify
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupDecryptionReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isString(message.contentId))
                    return "contentId: string expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                switch (message.itemType) {
                default:
                    return "itemType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                switch (message.senderPlatform) {
                default:
                    return "senderPlatform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                if (!$util.isString(message.senderVersion))
                    return "senderVersion: string expected";
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                switch (message.schedule) {
                default:
                    return "schedule: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupDecryptionReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         */
        GroupDecryptionReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupDecryptionReport)
                return object;
            var message = new $root.server.GroupDecryptionReport();
            switch (object.result) {
            case "UNKNOWN_STATUS":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.contentId != null)
                message.contentId = String(object.contentId);
            if (object.gid != null)
                message.gid = String(object.gid);
            switch (object.itemType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.itemType = 0;
                break;
            case "POST":
            case 1:
                message.itemType = 1;
                break;
            case "COMMENT":
            case 2:
                message.itemType = 2;
                break;
            case "HISTORY_RESEND":
            case 3:
                message.itemType = 3;
                break;
            case "POST_REACTION":
            case 4:
                message.itemType = 4;
                break;
            case "COMMENT_REACTION":
            case 5:
                message.itemType = 5;
                break;
            case "CHAT":
            case 6:
                message.itemType = 6;
                break;
            case "CHAT_REACTION":
            case 7:
                message.itemType = 7;
                break;
            }
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            switch (object.senderPlatform) {
            case "UNKNOWN":
            case 0:
                message.senderPlatform = 0;
                break;
            case "IOS":
            case 1:
                message.senderPlatform = 1;
                break;
            case "ANDROID":
            case 2:
                message.senderPlatform = 2;
                break;
            }
            if (object.senderVersion != null)
                message.senderVersion = String(object.senderVersion);
            switch (object.schedule) {
            case "DAILY":
            case 0:
                message.schedule = 0;
                break;
            case "RESULT_BASED":
            case 1:
                message.schedule = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupDecryptionReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.GroupDecryptionReport} message GroupDecryptionReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupDecryptionReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_STATUS" : 0;
                object.reason = "";
                object.contentId = "";
                object.gid = "";
                object.itemType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.originalVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.senderPlatform = options.enums === String ? "UNKNOWN" : 0;
                object.senderVersion = "";
                object.schedule = options.enums === String ? "DAILY" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.GroupDecryptionReport.Status[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                object.itemType = options.enums === String ? $root.server.GroupDecryptionReport.ItemType[message.itemType] : message.itemType;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                object.senderPlatform = options.enums === String ? $root.server.Platform[message.senderPlatform] : message.senderPlatform;
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                object.senderVersion = message.senderVersion;
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                object.schedule = options.enums === String ? $root.server.GroupDecryptionReport.Schedule[message.schedule] : message.schedule;
            return object;
        };

        /**
         * Converts this GroupDecryptionReport to JSON.
         * @function toJSON
         * @memberof server.GroupDecryptionReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupDecryptionReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.GroupDecryptionReport.Status
         * @enum {number}
         * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        GroupDecryptionReport.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        /**
         * ItemType enum.
         * @name server.GroupDecryptionReport.ItemType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} HISTORY_RESEND=3 HISTORY_RESEND value
         * @property {number} POST_REACTION=4 POST_REACTION value
         * @property {number} COMMENT_REACTION=5 COMMENT_REACTION value
         * @property {number} CHAT=6 CHAT value
         * @property {number} CHAT_REACTION=7 CHAT_REACTION value
         */
        GroupDecryptionReport.ItemType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[3] = "HISTORY_RESEND"] = 3;
            values[valuesById[4] = "POST_REACTION"] = 4;
            values[valuesById[5] = "COMMENT_REACTION"] = 5;
            values[valuesById[6] = "CHAT"] = 6;
            values[valuesById[7] = "CHAT_REACTION"] = 7;
            return values;
        })();

        /**
         * Schedule enum.
         * @name server.GroupDecryptionReport.Schedule
         * @enum {number}
         * @property {number} DAILY=0 DAILY value
         * @property {number} RESULT_BASED=1 RESULT_BASED value
         */
        GroupDecryptionReport.Schedule = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DAILY"] = 0;
            values[valuesById[1] = "RESULT_BASED"] = 1;
            return values;
        })();

        return GroupDecryptionReport;
    })();

    server.HomeDecryptionReport = (function() {

        /**
         * Properties of a HomeDecryptionReport.
         * @memberof server
         * @interface IHomeDecryptionReport
         * @property {server.HomeDecryptionReport.Status|null} [result] HomeDecryptionReport result
         * @property {string|null} [reason] HomeDecryptionReport reason
         * @property {string|null} [contentId] HomeDecryptionReport contentId
         * @property {server.HomeDecryptionReport.AudienceType|null} [audienceType] HomeDecryptionReport audienceType
         * @property {server.HomeDecryptionReport.ItemType|null} [itemType] HomeDecryptionReport itemType
         * @property {string|null} [originalVersion] HomeDecryptionReport originalVersion
         * @property {number|null} [rerequestCount] HomeDecryptionReport rerequestCount
         * @property {number|null} [timeTakenS] HomeDecryptionReport timeTakenS
         * @property {server.Platform|null} [senderPlatform] HomeDecryptionReport senderPlatform
         * @property {string|null} [senderVersion] HomeDecryptionReport senderVersion
         * @property {server.HomeDecryptionReport.Schedule|null} [schedule] HomeDecryptionReport schedule
         */

        /**
         * Constructs a new HomeDecryptionReport.
         * @memberof server
         * @classdesc Represents a HomeDecryptionReport.
         * @implements IHomeDecryptionReport
         * @constructor
         * @param {server.IHomeDecryptionReport=} [properties] Properties to set
         */
        function HomeDecryptionReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HomeDecryptionReport result.
         * @member {server.HomeDecryptionReport.Status} result
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.result = 0;

        /**
         * HomeDecryptionReport reason.
         * @member {string} reason
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.reason = "";

        /**
         * HomeDecryptionReport contentId.
         * @member {string} contentId
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.contentId = "";

        /**
         * HomeDecryptionReport audienceType.
         * @member {server.HomeDecryptionReport.AudienceType} audienceType
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.audienceType = 0;

        /**
         * HomeDecryptionReport itemType.
         * @member {server.HomeDecryptionReport.ItemType} itemType
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.itemType = 0;

        /**
         * HomeDecryptionReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.originalVersion = "";

        /**
         * HomeDecryptionReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.rerequestCount = 0;

        /**
         * HomeDecryptionReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.timeTakenS = 0;

        /**
         * HomeDecryptionReport senderPlatform.
         * @member {server.Platform} senderPlatform
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.senderPlatform = 0;

        /**
         * HomeDecryptionReport senderVersion.
         * @member {string} senderVersion
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.senderVersion = "";

        /**
         * HomeDecryptionReport schedule.
         * @member {server.HomeDecryptionReport.Schedule} schedule
         * @memberof server.HomeDecryptionReport
         * @instance
         */
        HomeDecryptionReport.prototype.schedule = 0;

        /**
         * Creates a new HomeDecryptionReport instance using the specified properties.
         * @function create
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {server.IHomeDecryptionReport=} [properties] Properties to set
         * @returns {server.HomeDecryptionReport} HomeDecryptionReport instance
         */
        HomeDecryptionReport.create = function create(properties) {
            return new HomeDecryptionReport(properties);
        };

        /**
         * Encodes the specified HomeDecryptionReport message. Does not implicitly {@link server.HomeDecryptionReport.verify|verify} messages.
         * @function encode
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {server.IHomeDecryptionReport} message HomeDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeDecryptionReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.contentId);
            if (message.audienceType != null && Object.hasOwnProperty.call(message, "audienceType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.audienceType);
            if (message.itemType != null && Object.hasOwnProperty.call(message, "itemType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.itemType);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.originalVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeTakenS);
            if (message.senderPlatform != null && Object.hasOwnProperty.call(message, "senderPlatform"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.senderPlatform);
            if (message.senderVersion != null && Object.hasOwnProperty.call(message, "senderVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.senderVersion);
            if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.schedule);
            return writer;
        };

        /**
         * Encodes the specified HomeDecryptionReport message, length delimited. Does not implicitly {@link server.HomeDecryptionReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {server.IHomeDecryptionReport} message HomeDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeDecryptionReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HomeDecryptionReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HomeDecryptionReport} HomeDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeDecryptionReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HomeDecryptionReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.contentId = reader.string();
                    break;
                case 4:
                    message.audienceType = reader.int32();
                    break;
                case 5:
                    message.itemType = reader.int32();
                    break;
                case 6:
                    message.originalVersion = reader.string();
                    break;
                case 7:
                    message.rerequestCount = reader.uint32();
                    break;
                case 8:
                    message.timeTakenS = reader.uint32();
                    break;
                case 9:
                    message.senderPlatform = reader.int32();
                    break;
                case 10:
                    message.senderVersion = reader.string();
                    break;
                case 11:
                    message.schedule = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HomeDecryptionReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HomeDecryptionReport} HomeDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeDecryptionReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HomeDecryptionReport message.
         * @function verify
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HomeDecryptionReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isString(message.contentId))
                    return "contentId: string expected";
            if (message.audienceType != null && message.hasOwnProperty("audienceType"))
                switch (message.audienceType) {
                default:
                    return "audienceType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                switch (message.itemType) {
                default:
                    return "itemType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 4:
                case 5:
                    break;
                }
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                switch (message.senderPlatform) {
                default:
                    return "senderPlatform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                if (!$util.isString(message.senderVersion))
                    return "senderVersion: string expected";
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                switch (message.schedule) {
                default:
                    return "schedule: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a HomeDecryptionReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HomeDecryptionReport} HomeDecryptionReport
         */
        HomeDecryptionReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HomeDecryptionReport)
                return object;
            var message = new $root.server.HomeDecryptionReport();
            switch (object.result) {
            case "UNKNOWN_STATUS":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.contentId != null)
                message.contentId = String(object.contentId);
            switch (object.audienceType) {
            case "UNKNOWN_AUDIENCE_TYPE":
            case 0:
                message.audienceType = 0;
                break;
            case "ALL":
            case 1:
                message.audienceType = 1;
                break;
            case "ONLY":
            case 2:
                message.audienceType = 2;
                break;
            }
            switch (object.itemType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.itemType = 0;
                break;
            case "POST":
            case 1:
                message.itemType = 1;
                break;
            case "COMMENT":
            case 2:
                message.itemType = 2;
                break;
            case "POST_REACTION":
            case 4:
                message.itemType = 4;
                break;
            case "COMMENT_REACTION":
            case 5:
                message.itemType = 5;
                break;
            }
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            switch (object.senderPlatform) {
            case "UNKNOWN":
            case 0:
                message.senderPlatform = 0;
                break;
            case "IOS":
            case 1:
                message.senderPlatform = 1;
                break;
            case "ANDROID":
            case 2:
                message.senderPlatform = 2;
                break;
            }
            if (object.senderVersion != null)
                message.senderVersion = String(object.senderVersion);
            switch (object.schedule) {
            case "DAILY":
            case 0:
                message.schedule = 0;
                break;
            case "RESULT_BASED":
            case 1:
                message.schedule = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a HomeDecryptionReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HomeDecryptionReport
         * @static
         * @param {server.HomeDecryptionReport} message HomeDecryptionReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HomeDecryptionReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_STATUS" : 0;
                object.reason = "";
                object.contentId = "";
                object.audienceType = options.enums === String ? "UNKNOWN_AUDIENCE_TYPE" : 0;
                object.itemType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.originalVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.senderPlatform = options.enums === String ? "UNKNOWN" : 0;
                object.senderVersion = "";
                object.schedule = options.enums === String ? "DAILY" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.HomeDecryptionReport.Status[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.audienceType != null && message.hasOwnProperty("audienceType"))
                object.audienceType = options.enums === String ? $root.server.HomeDecryptionReport.AudienceType[message.audienceType] : message.audienceType;
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                object.itemType = options.enums === String ? $root.server.HomeDecryptionReport.ItemType[message.itemType] : message.itemType;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                object.senderPlatform = options.enums === String ? $root.server.Platform[message.senderPlatform] : message.senderPlatform;
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                object.senderVersion = message.senderVersion;
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                object.schedule = options.enums === String ? $root.server.HomeDecryptionReport.Schedule[message.schedule] : message.schedule;
            return object;
        };

        /**
         * Converts this HomeDecryptionReport to JSON.
         * @function toJSON
         * @memberof server.HomeDecryptionReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HomeDecryptionReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.HomeDecryptionReport.Status
         * @enum {number}
         * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        HomeDecryptionReport.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        /**
         * AudienceType enum.
         * @name server.HomeDecryptionReport.AudienceType
         * @enum {number}
         * @property {number} UNKNOWN_AUDIENCE_TYPE=0 UNKNOWN_AUDIENCE_TYPE value
         * @property {number} ALL=1 ALL value
         * @property {number} ONLY=2 ONLY value
         */
        HomeDecryptionReport.AudienceType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_AUDIENCE_TYPE"] = 0;
            values[valuesById[1] = "ALL"] = 1;
            values[valuesById[2] = "ONLY"] = 2;
            return values;
        })();

        /**
         * ItemType enum.
         * @name server.HomeDecryptionReport.ItemType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} POST_REACTION=4 POST_REACTION value
         * @property {number} COMMENT_REACTION=5 COMMENT_REACTION value
         */
        HomeDecryptionReport.ItemType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[4] = "POST_REACTION"] = 4;
            values[valuesById[5] = "COMMENT_REACTION"] = 5;
            return values;
        })();

        /**
         * Schedule enum.
         * @name server.HomeDecryptionReport.Schedule
         * @enum {number}
         * @property {number} DAILY=0 DAILY value
         * @property {number} RESULT_BASED=1 RESULT_BASED value
         */
        HomeDecryptionReport.Schedule = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DAILY"] = 0;
            values[valuesById[1] = "RESULT_BASED"] = 1;
            return values;
        })();

        return HomeDecryptionReport;
    })();

    server.GroupHistoryReport = (function() {

        /**
         * Properties of a GroupHistoryReport.
         * @memberof server
         * @interface IGroupHistoryReport
         * @property {string|null} [gid] GroupHistoryReport gid
         * @property {number|null} [numExpected] GroupHistoryReport numExpected
         * @property {number|null} [numDecrypted] GroupHistoryReport numDecrypted
         * @property {string|null} [originalVersion] GroupHistoryReport originalVersion
         * @property {number|null} [rerequestCount] GroupHistoryReport rerequestCount
         * @property {number|null} [timeTakenS] GroupHistoryReport timeTakenS
         * @property {server.GroupHistoryReport.Schedule|null} [schedule] GroupHistoryReport schedule
         */

        /**
         * Constructs a new GroupHistoryReport.
         * @memberof server
         * @classdesc Represents a GroupHistoryReport.
         * @implements IGroupHistoryReport
         * @constructor
         * @param {server.IGroupHistoryReport=} [properties] Properties to set
         */
        function GroupHistoryReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupHistoryReport gid.
         * @member {string} gid
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.gid = "";

        /**
         * GroupHistoryReport numExpected.
         * @member {number} numExpected
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.numExpected = 0;

        /**
         * GroupHistoryReport numDecrypted.
         * @member {number} numDecrypted
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.numDecrypted = 0;

        /**
         * GroupHistoryReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.originalVersion = "";

        /**
         * GroupHistoryReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.rerequestCount = 0;

        /**
         * GroupHistoryReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.timeTakenS = 0;

        /**
         * GroupHistoryReport schedule.
         * @member {server.GroupHistoryReport.Schedule} schedule
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.schedule = 0;

        /**
         * Creates a new GroupHistoryReport instance using the specified properties.
         * @function create
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport=} [properties] Properties to set
         * @returns {server.GroupHistoryReport} GroupHistoryReport instance
         */
        GroupHistoryReport.create = function create(properties) {
            return new GroupHistoryReport(properties);
        };

        /**
         * Encodes the specified GroupHistoryReport message. Does not implicitly {@link server.GroupHistoryReport.verify|verify} messages.
         * @function encode
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport} message GroupHistoryReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupHistoryReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.numExpected != null && Object.hasOwnProperty.call(message, "numExpected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numExpected);
            if (message.numDecrypted != null && Object.hasOwnProperty.call(message, "numDecrypted"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numDecrypted);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.originalVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.timeTakenS);
            if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.schedule);
            return writer;
        };

        /**
         * Encodes the specified GroupHistoryReport message, length delimited. Does not implicitly {@link server.GroupHistoryReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport} message GroupHistoryReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupHistoryReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupHistoryReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupHistoryReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupHistoryReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupHistoryReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.numExpected = reader.uint32();
                    break;
                case 3:
                    message.numDecrypted = reader.uint32();
                    break;
                case 4:
                    message.originalVersion = reader.string();
                    break;
                case 5:
                    message.rerequestCount = reader.uint32();
                    break;
                case 6:
                    message.timeTakenS = reader.uint32();
                    break;
                case 7:
                    message.schedule = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupHistoryReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupHistoryReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupHistoryReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupHistoryReport message.
         * @function verify
         * @memberof server.GroupHistoryReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupHistoryReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.numExpected != null && message.hasOwnProperty("numExpected"))
                if (!$util.isInteger(message.numExpected))
                    return "numExpected: integer expected";
            if (message.numDecrypted != null && message.hasOwnProperty("numDecrypted"))
                if (!$util.isInteger(message.numDecrypted))
                    return "numDecrypted: integer expected";
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                switch (message.schedule) {
                default:
                    return "schedule: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupHistoryReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupHistoryReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         */
        GroupHistoryReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupHistoryReport)
                return object;
            var message = new $root.server.GroupHistoryReport();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.numExpected != null)
                message.numExpected = object.numExpected >>> 0;
            if (object.numDecrypted != null)
                message.numDecrypted = object.numDecrypted >>> 0;
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            switch (object.schedule) {
            case "DAILY":
            case 0:
                message.schedule = 0;
                break;
            case "RESULT_BASED":
            case 1:
                message.schedule = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupHistoryReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.GroupHistoryReport} message GroupHistoryReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupHistoryReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.numExpected = 0;
                object.numDecrypted = 0;
                object.originalVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.schedule = options.enums === String ? "DAILY" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.numExpected != null && message.hasOwnProperty("numExpected"))
                object.numExpected = message.numExpected;
            if (message.numDecrypted != null && message.hasOwnProperty("numDecrypted"))
                object.numDecrypted = message.numDecrypted;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                object.schedule = options.enums === String ? $root.server.GroupHistoryReport.Schedule[message.schedule] : message.schedule;
            return object;
        };

        /**
         * Converts this GroupHistoryReport to JSON.
         * @function toJSON
         * @memberof server.GroupHistoryReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupHistoryReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Schedule enum.
         * @name server.GroupHistoryReport.Schedule
         * @enum {number}
         * @property {number} DAILY=0 DAILY value
         * @property {number} RESULT_BASED=1 RESULT_BASED value
         */
        GroupHistoryReport.Schedule = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DAILY"] = 0;
            values[valuesById[1] = "RESULT_BASED"] = 1;
            return values;
        })();

        return GroupHistoryReport;
    })();

    server.Permissions = (function() {

        /**
         * Properties of a Permissions.
         * @memberof server
         * @interface IPermissions
         * @property {server.Permissions.Type|null} [type] Permissions type
         * @property {server.Permissions.Status|null} [status] Permissions status
         */

        /**
         * Constructs a new Permissions.
         * @memberof server
         * @classdesc Represents a Permissions.
         * @implements IPermissions
         * @constructor
         * @param {server.IPermissions=} [properties] Properties to set
         */
        function Permissions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Permissions type.
         * @member {server.Permissions.Type} type
         * @memberof server.Permissions
         * @instance
         */
        Permissions.prototype.type = 0;

        /**
         * Permissions status.
         * @member {server.Permissions.Status} status
         * @memberof server.Permissions
         * @instance
         */
        Permissions.prototype.status = 0;

        /**
         * Creates a new Permissions instance using the specified properties.
         * @function create
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions=} [properties] Properties to set
         * @returns {server.Permissions} Permissions instance
         */
        Permissions.create = function create(properties) {
            return new Permissions(properties);
        };

        /**
         * Encodes the specified Permissions message. Does not implicitly {@link server.Permissions.verify|verify} messages.
         * @function encode
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified Permissions message, length delimited. Does not implicitly {@link server.Permissions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer.
         * @function decode
         * @memberof server.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Permissions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Permissions message.
         * @function verify
         * @memberof server.Permissions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Permissions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Permissions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Permissions} Permissions
         */
        Permissions.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Permissions)
                return object;
            var message = new $root.server.Permissions();
            switch (object.type) {
            case "CONTACTS":
            case 0:
                message.type = 0;
                break;
            case "NOTIFICATIONS":
            case 1:
                message.type = 1;
                break;
            }
            switch (object.status) {
            case "ALLOWED":
            case 0:
                message.status = 0;
                break;
            case "DENIED":
            case 1:
                message.status = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Permissions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Permissions
         * @static
         * @param {server.Permissions} message Permissions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Permissions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "CONTACTS" : 0;
                object.status = options.enums === String ? "ALLOWED" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Permissions.Type[message.type] : message.type;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.Permissions.Status[message.status] : message.status;
            return object;
        };

        /**
         * Converts this Permissions to JSON.
         * @function toJSON
         * @memberof server.Permissions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Permissions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Permissions.Type
         * @enum {number}
         * @property {number} CONTACTS=0 CONTACTS value
         * @property {number} NOTIFICATIONS=1 NOTIFICATIONS value
         */
        Permissions.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONTACTS"] = 0;
            values[valuesById[1] = "NOTIFICATIONS"] = 1;
            return values;
        })();

        /**
         * Status enum.
         * @name server.Permissions.Status
         * @enum {number}
         * @property {number} ALLOWED=0 ALLOWED value
         * @property {number} DENIED=1 DENIED value
         */
        Permissions.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALLOWED"] = 0;
            values[valuesById[1] = "DENIED"] = 1;
            return values;
        })();

        return Permissions;
    })();

    server.Call = (function() {

        /**
         * Properties of a Call.
         * @memberof server
         * @interface ICall
         * @property {string|null} [callId] Call callId
         * @property {number|Long|null} [peerUid] Call peerUid
         * @property {server.Call.CallType|null} [type] Call type
         * @property {server.Call.CallDirection|null} [direction] Call direction
         * @property {boolean|null} [answered] Call answered
         * @property {boolean|null} [connected] Call connected
         * @property {number|Long|null} [durationMs] Call durationMs
         * @property {string|null} [endCallReason] Call endCallReason
         * @property {boolean|null} [localEndCall] Call localEndCall
         * @property {server.Call.NetworkType|null} [networkType] Call networkType
         * @property {boolean|null} [isKrispActive] Call isKrispActive
         * @property {number|Long|null} [iceTimeTakenMs] Call iceTimeTakenMs
         * @property {string|null} [webrtcStats] Call webrtcStats
         * @property {server.IWebrtcSummary|null} [webrtcSummary] Call webrtcSummary
         */

        /**
         * Constructs a new Call.
         * @memberof server
         * @classdesc Represents a Call.
         * @implements ICall
         * @constructor
         * @param {server.ICall=} [properties] Properties to set
         */
        function Call(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Call callId.
         * @member {string} callId
         * @memberof server.Call
         * @instance
         */
        Call.prototype.callId = "";

        /**
         * Call peerUid.
         * @member {number|Long} peerUid
         * @memberof server.Call
         * @instance
         */
        Call.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Call type.
         * @member {server.Call.CallType} type
         * @memberof server.Call
         * @instance
         */
        Call.prototype.type = 0;

        /**
         * Call direction.
         * @member {server.Call.CallDirection} direction
         * @memberof server.Call
         * @instance
         */
        Call.prototype.direction = 0;

        /**
         * Call answered.
         * @member {boolean} answered
         * @memberof server.Call
         * @instance
         */
        Call.prototype.answered = false;

        /**
         * Call connected.
         * @member {boolean} connected
         * @memberof server.Call
         * @instance
         */
        Call.prototype.connected = false;

        /**
         * Call durationMs.
         * @member {number|Long} durationMs
         * @memberof server.Call
         * @instance
         */
        Call.prototype.durationMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Call endCallReason.
         * @member {string} endCallReason
         * @memberof server.Call
         * @instance
         */
        Call.prototype.endCallReason = "";

        /**
         * Call localEndCall.
         * @member {boolean} localEndCall
         * @memberof server.Call
         * @instance
         */
        Call.prototype.localEndCall = false;

        /**
         * Call networkType.
         * @member {server.Call.NetworkType} networkType
         * @memberof server.Call
         * @instance
         */
        Call.prototype.networkType = 0;

        /**
         * Call isKrispActive.
         * @member {boolean} isKrispActive
         * @memberof server.Call
         * @instance
         */
        Call.prototype.isKrispActive = false;

        /**
         * Call iceTimeTakenMs.
         * @member {number|Long} iceTimeTakenMs
         * @memberof server.Call
         * @instance
         */
        Call.prototype.iceTimeTakenMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Call webrtcStats.
         * @member {string} webrtcStats
         * @memberof server.Call
         * @instance
         */
        Call.prototype.webrtcStats = "";

        /**
         * Call webrtcSummary.
         * @member {server.IWebrtcSummary|null|undefined} webrtcSummary
         * @memberof server.Call
         * @instance
         */
        Call.prototype.webrtcSummary = null;

        /**
         * Creates a new Call instance using the specified properties.
         * @function create
         * @memberof server.Call
         * @static
         * @param {server.ICall=} [properties] Properties to set
         * @returns {server.Call} Call instance
         */
        Call.create = function create(properties) {
            return new Call(properties);
        };

        /**
         * Encodes the specified Call message. Does not implicitly {@link server.Call.verify|verify} messages.
         * @function encode
         * @memberof server.Call
         * @static
         * @param {server.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.peerUid);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.direction);
            if (message.answered != null && Object.hasOwnProperty.call(message, "answered"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.answered);
            if (message.connected != null && Object.hasOwnProperty.call(message, "connected"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connected);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.durationMs);
            if (message.endCallReason != null && Object.hasOwnProperty.call(message, "endCallReason"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.endCallReason);
            if (message.localEndCall != null && Object.hasOwnProperty.call(message, "localEndCall"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.localEndCall);
            if (message.networkType != null && Object.hasOwnProperty.call(message, "networkType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.networkType);
            if (message.isKrispActive != null && Object.hasOwnProperty.call(message, "isKrispActive"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.isKrispActive);
            if (message.iceTimeTakenMs != null && Object.hasOwnProperty.call(message, "iceTimeTakenMs"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.iceTimeTakenMs);
            if (message.webrtcStats != null && Object.hasOwnProperty.call(message, "webrtcStats"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.webrtcStats);
            if (message.webrtcSummary != null && Object.hasOwnProperty.call(message, "webrtcSummary"))
                $root.server.WebrtcSummary.encode(message.webrtcSummary, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Call message, length delimited. Does not implicitly {@link server.Call.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Call
         * @static
         * @param {server.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Call message from the specified reader or buffer.
         * @function decode
         * @memberof server.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Call();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.uint64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.direction = reader.int32();
                    break;
                case 5:
                    message.answered = reader.bool();
                    break;
                case 6:
                    message.connected = reader.bool();
                    break;
                case 7:
                    message.durationMs = reader.uint64();
                    break;
                case 9:
                    message.endCallReason = reader.string();
                    break;
                case 10:
                    message.localEndCall = reader.bool();
                    break;
                case 11:
                    message.networkType = reader.int32();
                    break;
                case 12:
                    message.isKrispActive = reader.bool();
                    break;
                case 13:
                    message.iceTimeTakenMs = reader.uint64();
                    break;
                case 20:
                    message.webrtcStats = reader.string();
                    break;
                case 21:
                    message.webrtcSummary = $root.server.WebrtcSummary.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Call message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Call message.
         * @function verify
         * @memberof server.Call
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Call.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.direction != null && message.hasOwnProperty("direction"))
                switch (message.direction) {
                default:
                    return "direction: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.answered != null && message.hasOwnProperty("answered"))
                if (typeof message.answered !== "boolean")
                    return "answered: boolean expected";
            if (message.connected != null && message.hasOwnProperty("connected"))
                if (typeof message.connected !== "boolean")
                    return "connected: boolean expected";
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))
                    return "durationMs: integer|Long expected";
            if (message.endCallReason != null && message.hasOwnProperty("endCallReason"))
                if (!$util.isString(message.endCallReason))
                    return "endCallReason: string expected";
            if (message.localEndCall != null && message.hasOwnProperty("localEndCall"))
                if (typeof message.localEndCall !== "boolean")
                    return "localEndCall: boolean expected";
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                switch (message.networkType) {
                default:
                    return "networkType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.isKrispActive != null && message.hasOwnProperty("isKrispActive"))
                if (typeof message.isKrispActive !== "boolean")
                    return "isKrispActive: boolean expected";
            if (message.iceTimeTakenMs != null && message.hasOwnProperty("iceTimeTakenMs"))
                if (!$util.isInteger(message.iceTimeTakenMs) && !(message.iceTimeTakenMs && $util.isInteger(message.iceTimeTakenMs.low) && $util.isInteger(message.iceTimeTakenMs.high)))
                    return "iceTimeTakenMs: integer|Long expected";
            if (message.webrtcStats != null && message.hasOwnProperty("webrtcStats"))
                if (!$util.isString(message.webrtcStats))
                    return "webrtcStats: string expected";
            if (message.webrtcSummary != null && message.hasOwnProperty("webrtcSummary")) {
                var error = $root.server.WebrtcSummary.verify(message.webrtcSummary);
                if (error)
                    return "webrtcSummary." + error;
            }
            return null;
        };

        /**
         * Creates a Call message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Call
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Call} Call
         */
        Call.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Call)
                return object;
            var message = new $root.server.Call();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = true;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber(true);
            switch (object.type) {
            case "UNKNOWN_TYPE":
            case 0:
                message.type = 0;
                break;
            case "AUDIO":
            case 1:
                message.type = 1;
                break;
            case "VIDEO":
            case 2:
                message.type = 2;
                break;
            }
            switch (object.direction) {
            case "UNKNOWN_DIRECTION":
            case 0:
                message.direction = 0;
                break;
            case "OUTGOING":
            case 1:
                message.direction = 1;
                break;
            case "INCOMING":
            case 2:
                message.direction = 2;
                break;
            }
            if (object.answered != null)
                message.answered = Boolean(object.answered);
            if (object.connected != null)
                message.connected = Boolean(object.connected);
            if (object.durationMs != null)
                if ($util.Long)
                    (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = true;
                else if (typeof object.durationMs === "string")
                    message.durationMs = parseInt(object.durationMs, 10);
                else if (typeof object.durationMs === "number")
                    message.durationMs = object.durationMs;
                else if (typeof object.durationMs === "object")
                    message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber(true);
            if (object.endCallReason != null)
                message.endCallReason = String(object.endCallReason);
            if (object.localEndCall != null)
                message.localEndCall = Boolean(object.localEndCall);
            switch (object.networkType) {
            case "UNKNOWN_NETWORK":
            case 0:
                message.networkType = 0;
                break;
            case "WIFI":
            case 1:
                message.networkType = 1;
                break;
            case "CELLULAR":
            case 2:
                message.networkType = 2;
                break;
            }
            if (object.isKrispActive != null)
                message.isKrispActive = Boolean(object.isKrispActive);
            if (object.iceTimeTakenMs != null)
                if ($util.Long)
                    (message.iceTimeTakenMs = $util.Long.fromValue(object.iceTimeTakenMs)).unsigned = true;
                else if (typeof object.iceTimeTakenMs === "string")
                    message.iceTimeTakenMs = parseInt(object.iceTimeTakenMs, 10);
                else if (typeof object.iceTimeTakenMs === "number")
                    message.iceTimeTakenMs = object.iceTimeTakenMs;
                else if (typeof object.iceTimeTakenMs === "object")
                    message.iceTimeTakenMs = new $util.LongBits(object.iceTimeTakenMs.low >>> 0, object.iceTimeTakenMs.high >>> 0).toNumber(true);
            if (object.webrtcStats != null)
                message.webrtcStats = String(object.webrtcStats);
            if (object.webrtcSummary != null) {
                if (typeof object.webrtcSummary !== "object")
                    throw TypeError(".server.Call.webrtcSummary: object expected");
                message.webrtcSummary = $root.server.WebrtcSummary.fromObject(object.webrtcSummary);
            }
            return message;
        };

        /**
         * Creates a plain object from a Call message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Call
         * @static
         * @param {server.Call} message Call
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Call.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.direction = options.enums === String ? "UNKNOWN_DIRECTION" : 0;
                object.answered = false;
                object.connected = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.durationMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.durationMs = options.longs === String ? "0" : 0;
                object.endCallReason = "";
                object.localEndCall = false;
                object.networkType = options.enums === String ? "UNKNOWN_NETWORK" : 0;
                object.isKrispActive = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.iceTimeTakenMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.iceTimeTakenMs = options.longs === String ? "0" : 0;
                object.webrtcStats = "";
                object.webrtcSummary = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber(true) : message.peerUid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Call.CallType[message.type] : message.type;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = options.enums === String ? $root.server.Call.CallDirection[message.direction] : message.direction;
            if (message.answered != null && message.hasOwnProperty("answered"))
                object.answered = message.answered;
            if (message.connected != null && message.hasOwnProperty("connected"))
                object.connected = message.connected;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (typeof message.durationMs === "number")
                    object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;
                else
                    object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber(true) : message.durationMs;
            if (message.endCallReason != null && message.hasOwnProperty("endCallReason"))
                object.endCallReason = message.endCallReason;
            if (message.localEndCall != null && message.hasOwnProperty("localEndCall"))
                object.localEndCall = message.localEndCall;
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                object.networkType = options.enums === String ? $root.server.Call.NetworkType[message.networkType] : message.networkType;
            if (message.isKrispActive != null && message.hasOwnProperty("isKrispActive"))
                object.isKrispActive = message.isKrispActive;
            if (message.iceTimeTakenMs != null && message.hasOwnProperty("iceTimeTakenMs"))
                if (typeof message.iceTimeTakenMs === "number")
                    object.iceTimeTakenMs = options.longs === String ? String(message.iceTimeTakenMs) : message.iceTimeTakenMs;
                else
                    object.iceTimeTakenMs = options.longs === String ? $util.Long.prototype.toString.call(message.iceTimeTakenMs) : options.longs === Number ? new $util.LongBits(message.iceTimeTakenMs.low >>> 0, message.iceTimeTakenMs.high >>> 0).toNumber(true) : message.iceTimeTakenMs;
            if (message.webrtcStats != null && message.hasOwnProperty("webrtcStats"))
                object.webrtcStats = message.webrtcStats;
            if (message.webrtcSummary != null && message.hasOwnProperty("webrtcSummary"))
                object.webrtcSummary = $root.server.WebrtcSummary.toObject(message.webrtcSummary, options);
            return object;
        };

        /**
         * Converts this Call to JSON.
         * @function toJSON
         * @memberof server.Call
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Call.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CallType enum.
         * @name server.Call.CallType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} AUDIO=1 AUDIO value
         * @property {number} VIDEO=2 VIDEO value
         */
        Call.CallType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "AUDIO"] = 1;
            values[valuesById[2] = "VIDEO"] = 2;
            return values;
        })();

        /**
         * CallDirection enum.
         * @name server.Call.CallDirection
         * @enum {number}
         * @property {number} UNKNOWN_DIRECTION=0 UNKNOWN_DIRECTION value
         * @property {number} OUTGOING=1 OUTGOING value
         * @property {number} INCOMING=2 INCOMING value
         */
        Call.CallDirection = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DIRECTION"] = 0;
            values[valuesById[1] = "OUTGOING"] = 1;
            values[valuesById[2] = "INCOMING"] = 2;
            return values;
        })();

        /**
         * NetworkType enum.
         * @name server.Call.NetworkType
         * @enum {number}
         * @property {number} UNKNOWN_NETWORK=0 UNKNOWN_NETWORK value
         * @property {number} WIFI=1 WIFI value
         * @property {number} CELLULAR=2 CELLULAR value
         */
        Call.NetworkType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_NETWORK"] = 0;
            values[valuesById[1] = "WIFI"] = 1;
            values[valuesById[2] = "CELLULAR"] = 2;
            return values;
        })();

        return Call;
    })();

    server.WebrtcSummary = (function() {

        /**
         * Properties of a WebrtcSummary.
         * @memberof server
         * @interface IWebrtcSummary
         * @property {server.IStreamStats|null} [audioStream] WebrtcSummary audioStream
         * @property {server.IStreamStats|null} [videoStream] WebrtcSummary videoStream
         * @property {server.IAudioStats|null} [audio] WebrtcSummary audio
         * @property {server.IVideoStats|null} [video] WebrtcSummary video
         * @property {Array.<server.ICandidatePairStats>|null} [candidatePairs] WebrtcSummary candidatePairs
         */

        /**
         * Constructs a new WebrtcSummary.
         * @memberof server
         * @classdesc Represents a WebrtcSummary.
         * @implements IWebrtcSummary
         * @constructor
         * @param {server.IWebrtcSummary=} [properties] Properties to set
         */
        function WebrtcSummary(properties) {
            this.candidatePairs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebrtcSummary audioStream.
         * @member {server.IStreamStats|null|undefined} audioStream
         * @memberof server.WebrtcSummary
         * @instance
         */
        WebrtcSummary.prototype.audioStream = null;

        /**
         * WebrtcSummary videoStream.
         * @member {server.IStreamStats|null|undefined} videoStream
         * @memberof server.WebrtcSummary
         * @instance
         */
        WebrtcSummary.prototype.videoStream = null;

        /**
         * WebrtcSummary audio.
         * @member {server.IAudioStats|null|undefined} audio
         * @memberof server.WebrtcSummary
         * @instance
         */
        WebrtcSummary.prototype.audio = null;

        /**
         * WebrtcSummary video.
         * @member {server.IVideoStats|null|undefined} video
         * @memberof server.WebrtcSummary
         * @instance
         */
        WebrtcSummary.prototype.video = null;

        /**
         * WebrtcSummary candidatePairs.
         * @member {Array.<server.ICandidatePairStats>} candidatePairs
         * @memberof server.WebrtcSummary
         * @instance
         */
        WebrtcSummary.prototype.candidatePairs = $util.emptyArray;

        /**
         * Creates a new WebrtcSummary instance using the specified properties.
         * @function create
         * @memberof server.WebrtcSummary
         * @static
         * @param {server.IWebrtcSummary=} [properties] Properties to set
         * @returns {server.WebrtcSummary} WebrtcSummary instance
         */
        WebrtcSummary.create = function create(properties) {
            return new WebrtcSummary(properties);
        };

        /**
         * Encodes the specified WebrtcSummary message. Does not implicitly {@link server.WebrtcSummary.verify|verify} messages.
         * @function encode
         * @memberof server.WebrtcSummary
         * @static
         * @param {server.IWebrtcSummary} message WebrtcSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebrtcSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioStream != null && Object.hasOwnProperty.call(message, "audioStream"))
                $root.server.StreamStats.encode(message.audioStream, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.videoStream != null && Object.hasOwnProperty.call(message, "videoStream"))
                $root.server.StreamStats.encode(message.videoStream, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.server.AudioStats.encode(message.audio, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                $root.server.VideoStats.encode(message.video, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.candidatePairs != null && message.candidatePairs.length)
                for (var i = 0; i < message.candidatePairs.length; ++i)
                    $root.server.CandidatePairStats.encode(message.candidatePairs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WebrtcSummary message, length delimited. Does not implicitly {@link server.WebrtcSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WebrtcSummary
         * @static
         * @param {server.IWebrtcSummary} message WebrtcSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebrtcSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebrtcSummary message from the specified reader or buffer.
         * @function decode
         * @memberof server.WebrtcSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WebrtcSummary} WebrtcSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebrtcSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WebrtcSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audioStream = $root.server.StreamStats.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.videoStream = $root.server.StreamStats.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.audio = $root.server.AudioStats.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.video = $root.server.VideoStats.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.candidatePairs && message.candidatePairs.length))
                        message.candidatePairs = [];
                    message.candidatePairs.push($root.server.CandidatePairStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebrtcSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WebrtcSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WebrtcSummary} WebrtcSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebrtcSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebrtcSummary message.
         * @function verify
         * @memberof server.WebrtcSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebrtcSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioStream != null && message.hasOwnProperty("audioStream")) {
                var error = $root.server.StreamStats.verify(message.audioStream);
                if (error)
                    return "audioStream." + error;
            }
            if (message.videoStream != null && message.hasOwnProperty("videoStream")) {
                var error = $root.server.StreamStats.verify(message.videoStream);
                if (error)
                    return "videoStream." + error;
            }
            if (message.audio != null && message.hasOwnProperty("audio")) {
                var error = $root.server.AudioStats.verify(message.audio);
                if (error)
                    return "audio." + error;
            }
            if (message.video != null && message.hasOwnProperty("video")) {
                var error = $root.server.VideoStats.verify(message.video);
                if (error)
                    return "video." + error;
            }
            if (message.candidatePairs != null && message.hasOwnProperty("candidatePairs")) {
                if (!Array.isArray(message.candidatePairs))
                    return "candidatePairs: array expected";
                for (var i = 0; i < message.candidatePairs.length; ++i) {
                    var error = $root.server.CandidatePairStats.verify(message.candidatePairs[i]);
                    if (error)
                        return "candidatePairs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WebrtcSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WebrtcSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WebrtcSummary} WebrtcSummary
         */
        WebrtcSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WebrtcSummary)
                return object;
            var message = new $root.server.WebrtcSummary();
            if (object.audioStream != null) {
                if (typeof object.audioStream !== "object")
                    throw TypeError(".server.WebrtcSummary.audioStream: object expected");
                message.audioStream = $root.server.StreamStats.fromObject(object.audioStream);
            }
            if (object.videoStream != null) {
                if (typeof object.videoStream !== "object")
                    throw TypeError(".server.WebrtcSummary.videoStream: object expected");
                message.videoStream = $root.server.StreamStats.fromObject(object.videoStream);
            }
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".server.WebrtcSummary.audio: object expected");
                message.audio = $root.server.AudioStats.fromObject(object.audio);
            }
            if (object.video != null) {
                if (typeof object.video !== "object")
                    throw TypeError(".server.WebrtcSummary.video: object expected");
                message.video = $root.server.VideoStats.fromObject(object.video);
            }
            if (object.candidatePairs) {
                if (!Array.isArray(object.candidatePairs))
                    throw TypeError(".server.WebrtcSummary.candidatePairs: array expected");
                message.candidatePairs = [];
                for (var i = 0; i < object.candidatePairs.length; ++i) {
                    if (typeof object.candidatePairs[i] !== "object")
                        throw TypeError(".server.WebrtcSummary.candidatePairs: object expected");
                    message.candidatePairs[i] = $root.server.CandidatePairStats.fromObject(object.candidatePairs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WebrtcSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WebrtcSummary
         * @static
         * @param {server.WebrtcSummary} message WebrtcSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebrtcSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.candidatePairs = [];
            if (options.defaults) {
                object.audioStream = null;
                object.videoStream = null;
                object.audio = null;
                object.video = null;
            }
            if (message.audioStream != null && message.hasOwnProperty("audioStream"))
                object.audioStream = $root.server.StreamStats.toObject(message.audioStream, options);
            if (message.videoStream != null && message.hasOwnProperty("videoStream"))
                object.videoStream = $root.server.StreamStats.toObject(message.videoStream, options);
            if (message.audio != null && message.hasOwnProperty("audio"))
                object.audio = $root.server.AudioStats.toObject(message.audio, options);
            if (message.video != null && message.hasOwnProperty("video"))
                object.video = $root.server.VideoStats.toObject(message.video, options);
            if (message.candidatePairs && message.candidatePairs.length) {
                object.candidatePairs = [];
                for (var j = 0; j < message.candidatePairs.length; ++j)
                    object.candidatePairs[j] = $root.server.CandidatePairStats.toObject(message.candidatePairs[j], options);
            }
            return object;
        };

        /**
         * Converts this WebrtcSummary to JSON.
         * @function toJSON
         * @memberof server.WebrtcSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebrtcSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebrtcSummary;
    })();

    server.StreamStats = (function() {

        /**
         * Properties of a StreamStats.
         * @memberof server
         * @interface IStreamStats
         * @property {number|Long|null} [packetsSent] StreamStats packetsSent
         * @property {number|Long|null} [packetsLost] StreamStats packetsLost
         * @property {number|Long|null} [packetsReceived] StreamStats packetsReceived
         * @property {number|Long|null} [bytesReceived] StreamStats bytesReceived
         * @property {number|null} [jitter] StreamStats jitter
         * @property {number|null} [jitterBufferDelay] StreamStats jitterBufferDelay
         * @property {number|Long|null} [jitterBufferEmittedCount] StreamStats jitterBufferEmittedCount
         * @property {number|null} [jitterBufferMinimumDelay] StreamStats jitterBufferMinimumDelay
         */

        /**
         * Constructs a new StreamStats.
         * @memberof server
         * @classdesc Represents a StreamStats.
         * @implements IStreamStats
         * @constructor
         * @param {server.IStreamStats=} [properties] Properties to set
         */
        function StreamStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamStats packetsSent.
         * @member {number|Long} packetsSent
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.packetsSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StreamStats packetsLost.
         * @member {number|Long} packetsLost
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.packetsLost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StreamStats packetsReceived.
         * @member {number|Long} packetsReceived
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.packetsReceived = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StreamStats bytesReceived.
         * @member {number|Long} bytesReceived
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.bytesReceived = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StreamStats jitter.
         * @member {number} jitter
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.jitter = 0;

        /**
         * StreamStats jitterBufferDelay.
         * @member {number} jitterBufferDelay
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.jitterBufferDelay = 0;

        /**
         * StreamStats jitterBufferEmittedCount.
         * @member {number|Long} jitterBufferEmittedCount
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.jitterBufferEmittedCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StreamStats jitterBufferMinimumDelay.
         * @member {number} jitterBufferMinimumDelay
         * @memberof server.StreamStats
         * @instance
         */
        StreamStats.prototype.jitterBufferMinimumDelay = 0;

        /**
         * Creates a new StreamStats instance using the specified properties.
         * @function create
         * @memberof server.StreamStats
         * @static
         * @param {server.IStreamStats=} [properties] Properties to set
         * @returns {server.StreamStats} StreamStats instance
         */
        StreamStats.create = function create(properties) {
            return new StreamStats(properties);
        };

        /**
         * Encodes the specified StreamStats message. Does not implicitly {@link server.StreamStats.verify|verify} messages.
         * @function encode
         * @memberof server.StreamStats
         * @static
         * @param {server.IStreamStats} message StreamStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.packetsSent != null && Object.hasOwnProperty.call(message, "packetsSent"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.packetsSent);
            if (message.packetsLost != null && Object.hasOwnProperty.call(message, "packetsLost"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.packetsLost);
            if (message.packetsReceived != null && Object.hasOwnProperty.call(message, "packetsReceived"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.packetsReceived);
            if (message.bytesReceived != null && Object.hasOwnProperty.call(message, "bytesReceived"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.bytesReceived);
            if (message.jitter != null && Object.hasOwnProperty.call(message, "jitter"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.jitter);
            if (message.jitterBufferDelay != null && Object.hasOwnProperty.call(message, "jitterBufferDelay"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.jitterBufferDelay);
            if (message.jitterBufferEmittedCount != null && Object.hasOwnProperty.call(message, "jitterBufferEmittedCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.jitterBufferEmittedCount);
            if (message.jitterBufferMinimumDelay != null && Object.hasOwnProperty.call(message, "jitterBufferMinimumDelay"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.jitterBufferMinimumDelay);
            return writer;
        };

        /**
         * Encodes the specified StreamStats message, length delimited. Does not implicitly {@link server.StreamStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StreamStats
         * @static
         * @param {server.IStreamStats} message StreamStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamStats message from the specified reader or buffer.
         * @function decode
         * @memberof server.StreamStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StreamStats} StreamStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StreamStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetsSent = reader.uint64();
                    break;
                case 2:
                    message.packetsLost = reader.uint64();
                    break;
                case 3:
                    message.packetsReceived = reader.uint64();
                    break;
                case 4:
                    message.bytesReceived = reader.uint64();
                    break;
                case 5:
                    message.jitter = reader.double();
                    break;
                case 6:
                    message.jitterBufferDelay = reader.double();
                    break;
                case 7:
                    message.jitterBufferEmittedCount = reader.uint64();
                    break;
                case 8:
                    message.jitterBufferMinimumDelay = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StreamStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StreamStats} StreamStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamStats message.
         * @function verify
         * @memberof server.StreamStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.packetsSent != null && message.hasOwnProperty("packetsSent"))
                if (!$util.isInteger(message.packetsSent) && !(message.packetsSent && $util.isInteger(message.packetsSent.low) && $util.isInteger(message.packetsSent.high)))
                    return "packetsSent: integer|Long expected";
            if (message.packetsLost != null && message.hasOwnProperty("packetsLost"))
                if (!$util.isInteger(message.packetsLost) && !(message.packetsLost && $util.isInteger(message.packetsLost.low) && $util.isInteger(message.packetsLost.high)))
                    return "packetsLost: integer|Long expected";
            if (message.packetsReceived != null && message.hasOwnProperty("packetsReceived"))
                if (!$util.isInteger(message.packetsReceived) && !(message.packetsReceived && $util.isInteger(message.packetsReceived.low) && $util.isInteger(message.packetsReceived.high)))
                    return "packetsReceived: integer|Long expected";
            if (message.bytesReceived != null && message.hasOwnProperty("bytesReceived"))
                if (!$util.isInteger(message.bytesReceived) && !(message.bytesReceived && $util.isInteger(message.bytesReceived.low) && $util.isInteger(message.bytesReceived.high)))
                    return "bytesReceived: integer|Long expected";
            if (message.jitter != null && message.hasOwnProperty("jitter"))
                if (typeof message.jitter !== "number")
                    return "jitter: number expected";
            if (message.jitterBufferDelay != null && message.hasOwnProperty("jitterBufferDelay"))
                if (typeof message.jitterBufferDelay !== "number")
                    return "jitterBufferDelay: number expected";
            if (message.jitterBufferEmittedCount != null && message.hasOwnProperty("jitterBufferEmittedCount"))
                if (!$util.isInteger(message.jitterBufferEmittedCount) && !(message.jitterBufferEmittedCount && $util.isInteger(message.jitterBufferEmittedCount.low) && $util.isInteger(message.jitterBufferEmittedCount.high)))
                    return "jitterBufferEmittedCount: integer|Long expected";
            if (message.jitterBufferMinimumDelay != null && message.hasOwnProperty("jitterBufferMinimumDelay"))
                if (typeof message.jitterBufferMinimumDelay !== "number")
                    return "jitterBufferMinimumDelay: number expected";
            return null;
        };

        /**
         * Creates a StreamStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StreamStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StreamStats} StreamStats
         */
        StreamStats.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StreamStats)
                return object;
            var message = new $root.server.StreamStats();
            if (object.packetsSent != null)
                if ($util.Long)
                    (message.packetsSent = $util.Long.fromValue(object.packetsSent)).unsigned = true;
                else if (typeof object.packetsSent === "string")
                    message.packetsSent = parseInt(object.packetsSent, 10);
                else if (typeof object.packetsSent === "number")
                    message.packetsSent = object.packetsSent;
                else if (typeof object.packetsSent === "object")
                    message.packetsSent = new $util.LongBits(object.packetsSent.low >>> 0, object.packetsSent.high >>> 0).toNumber(true);
            if (object.packetsLost != null)
                if ($util.Long)
                    (message.packetsLost = $util.Long.fromValue(object.packetsLost)).unsigned = true;
                else if (typeof object.packetsLost === "string")
                    message.packetsLost = parseInt(object.packetsLost, 10);
                else if (typeof object.packetsLost === "number")
                    message.packetsLost = object.packetsLost;
                else if (typeof object.packetsLost === "object")
                    message.packetsLost = new $util.LongBits(object.packetsLost.low >>> 0, object.packetsLost.high >>> 0).toNumber(true);
            if (object.packetsReceived != null)
                if ($util.Long)
                    (message.packetsReceived = $util.Long.fromValue(object.packetsReceived)).unsigned = true;
                else if (typeof object.packetsReceived === "string")
                    message.packetsReceived = parseInt(object.packetsReceived, 10);
                else if (typeof object.packetsReceived === "number")
                    message.packetsReceived = object.packetsReceived;
                else if (typeof object.packetsReceived === "object")
                    message.packetsReceived = new $util.LongBits(object.packetsReceived.low >>> 0, object.packetsReceived.high >>> 0).toNumber(true);
            if (object.bytesReceived != null)
                if ($util.Long)
                    (message.bytesReceived = $util.Long.fromValue(object.bytesReceived)).unsigned = true;
                else if (typeof object.bytesReceived === "string")
                    message.bytesReceived = parseInt(object.bytesReceived, 10);
                else if (typeof object.bytesReceived === "number")
                    message.bytesReceived = object.bytesReceived;
                else if (typeof object.bytesReceived === "object")
                    message.bytesReceived = new $util.LongBits(object.bytesReceived.low >>> 0, object.bytesReceived.high >>> 0).toNumber(true);
            if (object.jitter != null)
                message.jitter = Number(object.jitter);
            if (object.jitterBufferDelay != null)
                message.jitterBufferDelay = Number(object.jitterBufferDelay);
            if (object.jitterBufferEmittedCount != null)
                if ($util.Long)
                    (message.jitterBufferEmittedCount = $util.Long.fromValue(object.jitterBufferEmittedCount)).unsigned = true;
                else if (typeof object.jitterBufferEmittedCount === "string")
                    message.jitterBufferEmittedCount = parseInt(object.jitterBufferEmittedCount, 10);
                else if (typeof object.jitterBufferEmittedCount === "number")
                    message.jitterBufferEmittedCount = object.jitterBufferEmittedCount;
                else if (typeof object.jitterBufferEmittedCount === "object")
                    message.jitterBufferEmittedCount = new $util.LongBits(object.jitterBufferEmittedCount.low >>> 0, object.jitterBufferEmittedCount.high >>> 0).toNumber(true);
            if (object.jitterBufferMinimumDelay != null)
                message.jitterBufferMinimumDelay = Number(object.jitterBufferMinimumDelay);
            return message;
        };

        /**
         * Creates a plain object from a StreamStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StreamStats
         * @static
         * @param {server.StreamStats} message StreamStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsLost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsLost = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bytesReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesReceived = options.longs === String ? "0" : 0;
                object.jitter = 0;
                object.jitterBufferDelay = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.jitterBufferEmittedCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.jitterBufferEmittedCount = options.longs === String ? "0" : 0;
                object.jitterBufferMinimumDelay = 0;
            }
            if (message.packetsSent != null && message.hasOwnProperty("packetsSent"))
                if (typeof message.packetsSent === "number")
                    object.packetsSent = options.longs === String ? String(message.packetsSent) : message.packetsSent;
                else
                    object.packetsSent = options.longs === String ? $util.Long.prototype.toString.call(message.packetsSent) : options.longs === Number ? new $util.LongBits(message.packetsSent.low >>> 0, message.packetsSent.high >>> 0).toNumber(true) : message.packetsSent;
            if (message.packetsLost != null && message.hasOwnProperty("packetsLost"))
                if (typeof message.packetsLost === "number")
                    object.packetsLost = options.longs === String ? String(message.packetsLost) : message.packetsLost;
                else
                    object.packetsLost = options.longs === String ? $util.Long.prototype.toString.call(message.packetsLost) : options.longs === Number ? new $util.LongBits(message.packetsLost.low >>> 0, message.packetsLost.high >>> 0).toNumber(true) : message.packetsLost;
            if (message.packetsReceived != null && message.hasOwnProperty("packetsReceived"))
                if (typeof message.packetsReceived === "number")
                    object.packetsReceived = options.longs === String ? String(message.packetsReceived) : message.packetsReceived;
                else
                    object.packetsReceived = options.longs === String ? $util.Long.prototype.toString.call(message.packetsReceived) : options.longs === Number ? new $util.LongBits(message.packetsReceived.low >>> 0, message.packetsReceived.high >>> 0).toNumber(true) : message.packetsReceived;
            if (message.bytesReceived != null && message.hasOwnProperty("bytesReceived"))
                if (typeof message.bytesReceived === "number")
                    object.bytesReceived = options.longs === String ? String(message.bytesReceived) : message.bytesReceived;
                else
                    object.bytesReceived = options.longs === String ? $util.Long.prototype.toString.call(message.bytesReceived) : options.longs === Number ? new $util.LongBits(message.bytesReceived.low >>> 0, message.bytesReceived.high >>> 0).toNumber(true) : message.bytesReceived;
            if (message.jitter != null && message.hasOwnProperty("jitter"))
                object.jitter = options.json && !isFinite(message.jitter) ? String(message.jitter) : message.jitter;
            if (message.jitterBufferDelay != null && message.hasOwnProperty("jitterBufferDelay"))
                object.jitterBufferDelay = options.json && !isFinite(message.jitterBufferDelay) ? String(message.jitterBufferDelay) : message.jitterBufferDelay;
            if (message.jitterBufferEmittedCount != null && message.hasOwnProperty("jitterBufferEmittedCount"))
                if (typeof message.jitterBufferEmittedCount === "number")
                    object.jitterBufferEmittedCount = options.longs === String ? String(message.jitterBufferEmittedCount) : message.jitterBufferEmittedCount;
                else
                    object.jitterBufferEmittedCount = options.longs === String ? $util.Long.prototype.toString.call(message.jitterBufferEmittedCount) : options.longs === Number ? new $util.LongBits(message.jitterBufferEmittedCount.low >>> 0, message.jitterBufferEmittedCount.high >>> 0).toNumber(true) : message.jitterBufferEmittedCount;
            if (message.jitterBufferMinimumDelay != null && message.hasOwnProperty("jitterBufferMinimumDelay"))
                object.jitterBufferMinimumDelay = options.json && !isFinite(message.jitterBufferMinimumDelay) ? String(message.jitterBufferMinimumDelay) : message.jitterBufferMinimumDelay;
            return object;
        };

        /**
         * Converts this StreamStats to JSON.
         * @function toJSON
         * @memberof server.StreamStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamStats;
    })();

    server.AudioStats = (function() {

        /**
         * Properties of an AudioStats.
         * @memberof server
         * @interface IAudioStats
         * @property {number|Long|null} [insertedSamplesForDeceleration] AudioStats insertedSamplesForDeceleration
         * @property {number|Long|null} [removedSamplesForAcceleration] AudioStats removedSamplesForAcceleration
         * @property {number|Long|null} [packetsDiscarded] AudioStats packetsDiscarded
         */

        /**
         * Constructs a new AudioStats.
         * @memberof server
         * @classdesc Represents an AudioStats.
         * @implements IAudioStats
         * @constructor
         * @param {server.IAudioStats=} [properties] Properties to set
         */
        function AudioStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AudioStats insertedSamplesForDeceleration.
         * @member {number|Long} insertedSamplesForDeceleration
         * @memberof server.AudioStats
         * @instance
         */
        AudioStats.prototype.insertedSamplesForDeceleration = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AudioStats removedSamplesForAcceleration.
         * @member {number|Long} removedSamplesForAcceleration
         * @memberof server.AudioStats
         * @instance
         */
        AudioStats.prototype.removedSamplesForAcceleration = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AudioStats packetsDiscarded.
         * @member {number|Long} packetsDiscarded
         * @memberof server.AudioStats
         * @instance
         */
        AudioStats.prototype.packetsDiscarded = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AudioStats instance using the specified properties.
         * @function create
         * @memberof server.AudioStats
         * @static
         * @param {server.IAudioStats=} [properties] Properties to set
         * @returns {server.AudioStats} AudioStats instance
         */
        AudioStats.create = function create(properties) {
            return new AudioStats(properties);
        };

        /**
         * Encodes the specified AudioStats message. Does not implicitly {@link server.AudioStats.verify|verify} messages.
         * @function encode
         * @memberof server.AudioStats
         * @static
         * @param {server.IAudioStats} message AudioStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.insertedSamplesForDeceleration != null && Object.hasOwnProperty.call(message, "insertedSamplesForDeceleration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.insertedSamplesForDeceleration);
            if (message.removedSamplesForAcceleration != null && Object.hasOwnProperty.call(message, "removedSamplesForAcceleration"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.removedSamplesForAcceleration);
            if (message.packetsDiscarded != null && Object.hasOwnProperty.call(message, "packetsDiscarded"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.packetsDiscarded);
            return writer;
        };

        /**
         * Encodes the specified AudioStats message, length delimited. Does not implicitly {@link server.AudioStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AudioStats
         * @static
         * @param {server.IAudioStats} message AudioStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AudioStats message from the specified reader or buffer.
         * @function decode
         * @memberof server.AudioStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AudioStats} AudioStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AudioStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.insertedSamplesForDeceleration = reader.uint64();
                    break;
                case 2:
                    message.removedSamplesForAcceleration = reader.uint64();
                    break;
                case 3:
                    message.packetsDiscarded = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AudioStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AudioStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AudioStats} AudioStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AudioStats message.
         * @function verify
         * @memberof server.AudioStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AudioStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.insertedSamplesForDeceleration != null && message.hasOwnProperty("insertedSamplesForDeceleration"))
                if (!$util.isInteger(message.insertedSamplesForDeceleration) && !(message.insertedSamplesForDeceleration && $util.isInteger(message.insertedSamplesForDeceleration.low) && $util.isInteger(message.insertedSamplesForDeceleration.high)))
                    return "insertedSamplesForDeceleration: integer|Long expected";
            if (message.removedSamplesForAcceleration != null && message.hasOwnProperty("removedSamplesForAcceleration"))
                if (!$util.isInteger(message.removedSamplesForAcceleration) && !(message.removedSamplesForAcceleration && $util.isInteger(message.removedSamplesForAcceleration.low) && $util.isInteger(message.removedSamplesForAcceleration.high)))
                    return "removedSamplesForAcceleration: integer|Long expected";
            if (message.packetsDiscarded != null && message.hasOwnProperty("packetsDiscarded"))
                if (!$util.isInteger(message.packetsDiscarded) && !(message.packetsDiscarded && $util.isInteger(message.packetsDiscarded.low) && $util.isInteger(message.packetsDiscarded.high)))
                    return "packetsDiscarded: integer|Long expected";
            return null;
        };

        /**
         * Creates an AudioStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AudioStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AudioStats} AudioStats
         */
        AudioStats.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AudioStats)
                return object;
            var message = new $root.server.AudioStats();
            if (object.insertedSamplesForDeceleration != null)
                if ($util.Long)
                    (message.insertedSamplesForDeceleration = $util.Long.fromValue(object.insertedSamplesForDeceleration)).unsigned = true;
                else if (typeof object.insertedSamplesForDeceleration === "string")
                    message.insertedSamplesForDeceleration = parseInt(object.insertedSamplesForDeceleration, 10);
                else if (typeof object.insertedSamplesForDeceleration === "number")
                    message.insertedSamplesForDeceleration = object.insertedSamplesForDeceleration;
                else if (typeof object.insertedSamplesForDeceleration === "object")
                    message.insertedSamplesForDeceleration = new $util.LongBits(object.insertedSamplesForDeceleration.low >>> 0, object.insertedSamplesForDeceleration.high >>> 0).toNumber(true);
            if (object.removedSamplesForAcceleration != null)
                if ($util.Long)
                    (message.removedSamplesForAcceleration = $util.Long.fromValue(object.removedSamplesForAcceleration)).unsigned = true;
                else if (typeof object.removedSamplesForAcceleration === "string")
                    message.removedSamplesForAcceleration = parseInt(object.removedSamplesForAcceleration, 10);
                else if (typeof object.removedSamplesForAcceleration === "number")
                    message.removedSamplesForAcceleration = object.removedSamplesForAcceleration;
                else if (typeof object.removedSamplesForAcceleration === "object")
                    message.removedSamplesForAcceleration = new $util.LongBits(object.removedSamplesForAcceleration.low >>> 0, object.removedSamplesForAcceleration.high >>> 0).toNumber(true);
            if (object.packetsDiscarded != null)
                if ($util.Long)
                    (message.packetsDiscarded = $util.Long.fromValue(object.packetsDiscarded)).unsigned = true;
                else if (typeof object.packetsDiscarded === "string")
                    message.packetsDiscarded = parseInt(object.packetsDiscarded, 10);
                else if (typeof object.packetsDiscarded === "number")
                    message.packetsDiscarded = object.packetsDiscarded;
                else if (typeof object.packetsDiscarded === "object")
                    message.packetsDiscarded = new $util.LongBits(object.packetsDiscarded.low >>> 0, object.packetsDiscarded.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AudioStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AudioStats
         * @static
         * @param {server.AudioStats} message AudioStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AudioStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.insertedSamplesForDeceleration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.insertedSamplesForDeceleration = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.removedSamplesForAcceleration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.removedSamplesForAcceleration = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsDiscarded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsDiscarded = options.longs === String ? "0" : 0;
            }
            if (message.insertedSamplesForDeceleration != null && message.hasOwnProperty("insertedSamplesForDeceleration"))
                if (typeof message.insertedSamplesForDeceleration === "number")
                    object.insertedSamplesForDeceleration = options.longs === String ? String(message.insertedSamplesForDeceleration) : message.insertedSamplesForDeceleration;
                else
                    object.insertedSamplesForDeceleration = options.longs === String ? $util.Long.prototype.toString.call(message.insertedSamplesForDeceleration) : options.longs === Number ? new $util.LongBits(message.insertedSamplesForDeceleration.low >>> 0, message.insertedSamplesForDeceleration.high >>> 0).toNumber(true) : message.insertedSamplesForDeceleration;
            if (message.removedSamplesForAcceleration != null && message.hasOwnProperty("removedSamplesForAcceleration"))
                if (typeof message.removedSamplesForAcceleration === "number")
                    object.removedSamplesForAcceleration = options.longs === String ? String(message.removedSamplesForAcceleration) : message.removedSamplesForAcceleration;
                else
                    object.removedSamplesForAcceleration = options.longs === String ? $util.Long.prototype.toString.call(message.removedSamplesForAcceleration) : options.longs === Number ? new $util.LongBits(message.removedSamplesForAcceleration.low >>> 0, message.removedSamplesForAcceleration.high >>> 0).toNumber(true) : message.removedSamplesForAcceleration;
            if (message.packetsDiscarded != null && message.hasOwnProperty("packetsDiscarded"))
                if (typeof message.packetsDiscarded === "number")
                    object.packetsDiscarded = options.longs === String ? String(message.packetsDiscarded) : message.packetsDiscarded;
                else
                    object.packetsDiscarded = options.longs === String ? $util.Long.prototype.toString.call(message.packetsDiscarded) : options.longs === Number ? new $util.LongBits(message.packetsDiscarded.low >>> 0, message.packetsDiscarded.high >>> 0).toNumber(true) : message.packetsDiscarded;
            return object;
        };

        /**
         * Converts this AudioStats to JSON.
         * @function toJSON
         * @memberof server.AudioStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AudioStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AudioStats;
    })();

    server.VideoStats = (function() {

        /**
         * Properties of a VideoStats.
         * @memberof server
         * @interface IVideoStats
         * @property {number|Long|null} [framesReceived] VideoStats framesReceived
         * @property {number|Long|null} [framesDropped] VideoStats framesDropped
         * @property {number|null} [qualityLimitationDurationBandwidth] VideoStats qualityLimitationDurationBandwidth
         * @property {number|null} [qualityLimitationDurationCpu] VideoStats qualityLimitationDurationCpu
         * @property {number|null} [qualityLimitationDurationNone] VideoStats qualityLimitationDurationNone
         * @property {number|null} [qualityLimitationDurationOther] VideoStats qualityLimitationDurationOther
         * @property {number|null} [averageQp] VideoStats averageQp
         * @property {number|null} [totalProcessingDelay] VideoStats totalProcessingDelay
         */

        /**
         * Constructs a new VideoStats.
         * @memberof server
         * @classdesc Represents a VideoStats.
         * @implements IVideoStats
         * @constructor
         * @param {server.IVideoStats=} [properties] Properties to set
         */
        function VideoStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoStats framesReceived.
         * @member {number|Long} framesReceived
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.framesReceived = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoStats framesDropped.
         * @member {number|Long} framesDropped
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.framesDropped = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoStats qualityLimitationDurationBandwidth.
         * @member {number} qualityLimitationDurationBandwidth
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.qualityLimitationDurationBandwidth = 0;

        /**
         * VideoStats qualityLimitationDurationCpu.
         * @member {number} qualityLimitationDurationCpu
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.qualityLimitationDurationCpu = 0;

        /**
         * VideoStats qualityLimitationDurationNone.
         * @member {number} qualityLimitationDurationNone
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.qualityLimitationDurationNone = 0;

        /**
         * VideoStats qualityLimitationDurationOther.
         * @member {number} qualityLimitationDurationOther
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.qualityLimitationDurationOther = 0;

        /**
         * VideoStats averageQp.
         * @member {number} averageQp
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.averageQp = 0;

        /**
         * VideoStats totalProcessingDelay.
         * @member {number} totalProcessingDelay
         * @memberof server.VideoStats
         * @instance
         */
        VideoStats.prototype.totalProcessingDelay = 0;

        /**
         * Creates a new VideoStats instance using the specified properties.
         * @function create
         * @memberof server.VideoStats
         * @static
         * @param {server.IVideoStats=} [properties] Properties to set
         * @returns {server.VideoStats} VideoStats instance
         */
        VideoStats.create = function create(properties) {
            return new VideoStats(properties);
        };

        /**
         * Encodes the specified VideoStats message. Does not implicitly {@link server.VideoStats.verify|verify} messages.
         * @function encode
         * @memberof server.VideoStats
         * @static
         * @param {server.IVideoStats} message VideoStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.framesReceived != null && Object.hasOwnProperty.call(message, "framesReceived"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.framesReceived);
            if (message.framesDropped != null && Object.hasOwnProperty.call(message, "framesDropped"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.framesDropped);
            if (message.qualityLimitationDurationBandwidth != null && Object.hasOwnProperty.call(message, "qualityLimitationDurationBandwidth"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.qualityLimitationDurationBandwidth);
            if (message.qualityLimitationDurationCpu != null && Object.hasOwnProperty.call(message, "qualityLimitationDurationCpu"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.qualityLimitationDurationCpu);
            if (message.qualityLimitationDurationNone != null && Object.hasOwnProperty.call(message, "qualityLimitationDurationNone"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.qualityLimitationDurationNone);
            if (message.qualityLimitationDurationOther != null && Object.hasOwnProperty.call(message, "qualityLimitationDurationOther"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.qualityLimitationDurationOther);
            if (message.averageQp != null && Object.hasOwnProperty.call(message, "averageQp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.averageQp);
            if (message.totalProcessingDelay != null && Object.hasOwnProperty.call(message, "totalProcessingDelay"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.totalProcessingDelay);
            return writer;
        };

        /**
         * Encodes the specified VideoStats message, length delimited. Does not implicitly {@link server.VideoStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.VideoStats
         * @static
         * @param {server.IVideoStats} message VideoStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoStats message from the specified reader or buffer.
         * @function decode
         * @memberof server.VideoStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.VideoStats} VideoStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.VideoStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.framesReceived = reader.uint64();
                    break;
                case 2:
                    message.framesDropped = reader.uint64();
                    break;
                case 3:
                    message.qualityLimitationDurationBandwidth = reader.double();
                    break;
                case 4:
                    message.qualityLimitationDurationCpu = reader.double();
                    break;
                case 5:
                    message.qualityLimitationDurationNone = reader.double();
                    break;
                case 6:
                    message.qualityLimitationDurationOther = reader.double();
                    break;
                case 7:
                    message.averageQp = reader.double();
                    break;
                case 8:
                    message.totalProcessingDelay = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.VideoStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.VideoStats} VideoStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoStats message.
         * @function verify
         * @memberof server.VideoStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.framesReceived != null && message.hasOwnProperty("framesReceived"))
                if (!$util.isInteger(message.framesReceived) && !(message.framesReceived && $util.isInteger(message.framesReceived.low) && $util.isInteger(message.framesReceived.high)))
                    return "framesReceived: integer|Long expected";
            if (message.framesDropped != null && message.hasOwnProperty("framesDropped"))
                if (!$util.isInteger(message.framesDropped) && !(message.framesDropped && $util.isInteger(message.framesDropped.low) && $util.isInteger(message.framesDropped.high)))
                    return "framesDropped: integer|Long expected";
            if (message.qualityLimitationDurationBandwidth != null && message.hasOwnProperty("qualityLimitationDurationBandwidth"))
                if (typeof message.qualityLimitationDurationBandwidth !== "number")
                    return "qualityLimitationDurationBandwidth: number expected";
            if (message.qualityLimitationDurationCpu != null && message.hasOwnProperty("qualityLimitationDurationCpu"))
                if (typeof message.qualityLimitationDurationCpu !== "number")
                    return "qualityLimitationDurationCpu: number expected";
            if (message.qualityLimitationDurationNone != null && message.hasOwnProperty("qualityLimitationDurationNone"))
                if (typeof message.qualityLimitationDurationNone !== "number")
                    return "qualityLimitationDurationNone: number expected";
            if (message.qualityLimitationDurationOther != null && message.hasOwnProperty("qualityLimitationDurationOther"))
                if (typeof message.qualityLimitationDurationOther !== "number")
                    return "qualityLimitationDurationOther: number expected";
            if (message.averageQp != null && message.hasOwnProperty("averageQp"))
                if (typeof message.averageQp !== "number")
                    return "averageQp: number expected";
            if (message.totalProcessingDelay != null && message.hasOwnProperty("totalProcessingDelay"))
                if (typeof message.totalProcessingDelay !== "number")
                    return "totalProcessingDelay: number expected";
            return null;
        };

        /**
         * Creates a VideoStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.VideoStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.VideoStats} VideoStats
         */
        VideoStats.fromObject = function fromObject(object) {
            if (object instanceof $root.server.VideoStats)
                return object;
            var message = new $root.server.VideoStats();
            if (object.framesReceived != null)
                if ($util.Long)
                    (message.framesReceived = $util.Long.fromValue(object.framesReceived)).unsigned = true;
                else if (typeof object.framesReceived === "string")
                    message.framesReceived = parseInt(object.framesReceived, 10);
                else if (typeof object.framesReceived === "number")
                    message.framesReceived = object.framesReceived;
                else if (typeof object.framesReceived === "object")
                    message.framesReceived = new $util.LongBits(object.framesReceived.low >>> 0, object.framesReceived.high >>> 0).toNumber(true);
            if (object.framesDropped != null)
                if ($util.Long)
                    (message.framesDropped = $util.Long.fromValue(object.framesDropped)).unsigned = true;
                else if (typeof object.framesDropped === "string")
                    message.framesDropped = parseInt(object.framesDropped, 10);
                else if (typeof object.framesDropped === "number")
                    message.framesDropped = object.framesDropped;
                else if (typeof object.framesDropped === "object")
                    message.framesDropped = new $util.LongBits(object.framesDropped.low >>> 0, object.framesDropped.high >>> 0).toNumber(true);
            if (object.qualityLimitationDurationBandwidth != null)
                message.qualityLimitationDurationBandwidth = Number(object.qualityLimitationDurationBandwidth);
            if (object.qualityLimitationDurationCpu != null)
                message.qualityLimitationDurationCpu = Number(object.qualityLimitationDurationCpu);
            if (object.qualityLimitationDurationNone != null)
                message.qualityLimitationDurationNone = Number(object.qualityLimitationDurationNone);
            if (object.qualityLimitationDurationOther != null)
                message.qualityLimitationDurationOther = Number(object.qualityLimitationDurationOther);
            if (object.averageQp != null)
                message.averageQp = Number(object.averageQp);
            if (object.totalProcessingDelay != null)
                message.totalProcessingDelay = Number(object.totalProcessingDelay);
            return message;
        };

        /**
         * Creates a plain object from a VideoStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.VideoStats
         * @static
         * @param {server.VideoStats} message VideoStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VideoStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.framesReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.framesReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.framesDropped = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.framesDropped = options.longs === String ? "0" : 0;
                object.qualityLimitationDurationBandwidth = 0;
                object.qualityLimitationDurationCpu = 0;
                object.qualityLimitationDurationNone = 0;
                object.qualityLimitationDurationOther = 0;
                object.averageQp = 0;
                object.totalProcessingDelay = 0;
            }
            if (message.framesReceived != null && message.hasOwnProperty("framesReceived"))
                if (typeof message.framesReceived === "number")
                    object.framesReceived = options.longs === String ? String(message.framesReceived) : message.framesReceived;
                else
                    object.framesReceived = options.longs === String ? $util.Long.prototype.toString.call(message.framesReceived) : options.longs === Number ? new $util.LongBits(message.framesReceived.low >>> 0, message.framesReceived.high >>> 0).toNumber(true) : message.framesReceived;
            if (message.framesDropped != null && message.hasOwnProperty("framesDropped"))
                if (typeof message.framesDropped === "number")
                    object.framesDropped = options.longs === String ? String(message.framesDropped) : message.framesDropped;
                else
                    object.framesDropped = options.longs === String ? $util.Long.prototype.toString.call(message.framesDropped) : options.longs === Number ? new $util.LongBits(message.framesDropped.low >>> 0, message.framesDropped.high >>> 0).toNumber(true) : message.framesDropped;
            if (message.qualityLimitationDurationBandwidth != null && message.hasOwnProperty("qualityLimitationDurationBandwidth"))
                object.qualityLimitationDurationBandwidth = options.json && !isFinite(message.qualityLimitationDurationBandwidth) ? String(message.qualityLimitationDurationBandwidth) : message.qualityLimitationDurationBandwidth;
            if (message.qualityLimitationDurationCpu != null && message.hasOwnProperty("qualityLimitationDurationCpu"))
                object.qualityLimitationDurationCpu = options.json && !isFinite(message.qualityLimitationDurationCpu) ? String(message.qualityLimitationDurationCpu) : message.qualityLimitationDurationCpu;
            if (message.qualityLimitationDurationNone != null && message.hasOwnProperty("qualityLimitationDurationNone"))
                object.qualityLimitationDurationNone = options.json && !isFinite(message.qualityLimitationDurationNone) ? String(message.qualityLimitationDurationNone) : message.qualityLimitationDurationNone;
            if (message.qualityLimitationDurationOther != null && message.hasOwnProperty("qualityLimitationDurationOther"))
                object.qualityLimitationDurationOther = options.json && !isFinite(message.qualityLimitationDurationOther) ? String(message.qualityLimitationDurationOther) : message.qualityLimitationDurationOther;
            if (message.averageQp != null && message.hasOwnProperty("averageQp"))
                object.averageQp = options.json && !isFinite(message.averageQp) ? String(message.averageQp) : message.averageQp;
            if (message.totalProcessingDelay != null && message.hasOwnProperty("totalProcessingDelay"))
                object.totalProcessingDelay = options.json && !isFinite(message.totalProcessingDelay) ? String(message.totalProcessingDelay) : message.totalProcessingDelay;
            return object;
        };

        /**
         * Converts this VideoStats to JSON.
         * @function toJSON
         * @memberof server.VideoStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VideoStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VideoStats;
    })();

    server.CandidatePairStats = (function() {

        /**
         * Properties of a CandidatePairStats.
         * @memberof server
         * @interface ICandidatePairStats
         * @property {server.CandidatePairStats.CandidateType|null} [local] CandidatePairStats local
         * @property {string|null} [localIP] CandidatePairStats localIP
         * @property {server.CandidatePairStats.CandidateType|null} [remote] CandidatePairStats remote
         * @property {string|null} [remoteIP] CandidatePairStats remoteIP
         * @property {number|Long|null} [packetsSent] CandidatePairStats packetsSent
         * @property {number|Long|null} [packetsReceived] CandidatePairStats packetsReceived
         * @property {number|Long|null} [bytesSent] CandidatePairStats bytesSent
         * @property {number|Long|null} [bytesReceived] CandidatePairStats bytesReceived
         * @property {number|null} [averageRoundTripTime] CandidatePairStats averageRoundTripTime
         * @property {number|null} [currentRoundTripTime] CandidatePairStats currentRoundTripTime
         * @property {number|null} [availableOutgoingBitrate] CandidatePairStats availableOutgoingBitrate
         * @property {number|null} [availableIncomingBitrate] CandidatePairStats availableIncomingBitrate
         * @property {server.CandidatePairStats.CandidatePairState|null} [state] CandidatePairStats state
         */

        /**
         * Constructs a new CandidatePairStats.
         * @memberof server
         * @classdesc Represents a CandidatePairStats.
         * @implements ICandidatePairStats
         * @constructor
         * @param {server.ICandidatePairStats=} [properties] Properties to set
         */
        function CandidatePairStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CandidatePairStats local.
         * @member {server.CandidatePairStats.CandidateType} local
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.local = 0;

        /**
         * CandidatePairStats localIP.
         * @member {string} localIP
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.localIP = "";

        /**
         * CandidatePairStats remote.
         * @member {server.CandidatePairStats.CandidateType} remote
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.remote = 0;

        /**
         * CandidatePairStats remoteIP.
         * @member {string} remoteIP
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.remoteIP = "";

        /**
         * CandidatePairStats packetsSent.
         * @member {number|Long} packetsSent
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.packetsSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CandidatePairStats packetsReceived.
         * @member {number|Long} packetsReceived
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.packetsReceived = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CandidatePairStats bytesSent.
         * @member {number|Long} bytesSent
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.bytesSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CandidatePairStats bytesReceived.
         * @member {number|Long} bytesReceived
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.bytesReceived = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CandidatePairStats averageRoundTripTime.
         * @member {number} averageRoundTripTime
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.averageRoundTripTime = 0;

        /**
         * CandidatePairStats currentRoundTripTime.
         * @member {number} currentRoundTripTime
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.currentRoundTripTime = 0;

        /**
         * CandidatePairStats availableOutgoingBitrate.
         * @member {number} availableOutgoingBitrate
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.availableOutgoingBitrate = 0;

        /**
         * CandidatePairStats availableIncomingBitrate.
         * @member {number} availableIncomingBitrate
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.availableIncomingBitrate = 0;

        /**
         * CandidatePairStats state.
         * @member {server.CandidatePairStats.CandidatePairState} state
         * @memberof server.CandidatePairStats
         * @instance
         */
        CandidatePairStats.prototype.state = 0;

        /**
         * Creates a new CandidatePairStats instance using the specified properties.
         * @function create
         * @memberof server.CandidatePairStats
         * @static
         * @param {server.ICandidatePairStats=} [properties] Properties to set
         * @returns {server.CandidatePairStats} CandidatePairStats instance
         */
        CandidatePairStats.create = function create(properties) {
            return new CandidatePairStats(properties);
        };

        /**
         * Encodes the specified CandidatePairStats message. Does not implicitly {@link server.CandidatePairStats.verify|verify} messages.
         * @function encode
         * @memberof server.CandidatePairStats
         * @static
         * @param {server.ICandidatePairStats} message CandidatePairStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CandidatePairStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.local != null && Object.hasOwnProperty.call(message, "local"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.local);
            if (message.localIP != null && Object.hasOwnProperty.call(message, "localIP"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.localIP);
            if (message.remote != null && Object.hasOwnProperty.call(message, "remote"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.remote);
            if (message.remoteIP != null && Object.hasOwnProperty.call(message, "remoteIP"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.remoteIP);
            if (message.packetsSent != null && Object.hasOwnProperty.call(message, "packetsSent"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.packetsSent);
            if (message.packetsReceived != null && Object.hasOwnProperty.call(message, "packetsReceived"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.packetsReceived);
            if (message.bytesSent != null && Object.hasOwnProperty.call(message, "bytesSent"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.bytesSent);
            if (message.bytesReceived != null && Object.hasOwnProperty.call(message, "bytesReceived"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.bytesReceived);
            if (message.averageRoundTripTime != null && Object.hasOwnProperty.call(message, "averageRoundTripTime"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.averageRoundTripTime);
            if (message.currentRoundTripTime != null && Object.hasOwnProperty.call(message, "currentRoundTripTime"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.currentRoundTripTime);
            if (message.availableOutgoingBitrate != null && Object.hasOwnProperty.call(message, "availableOutgoingBitrate"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.availableOutgoingBitrate);
            if (message.availableIncomingBitrate != null && Object.hasOwnProperty.call(message, "availableIncomingBitrate"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.availableIncomingBitrate);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified CandidatePairStats message, length delimited. Does not implicitly {@link server.CandidatePairStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CandidatePairStats
         * @static
         * @param {server.ICandidatePairStats} message CandidatePairStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CandidatePairStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CandidatePairStats message from the specified reader or buffer.
         * @function decode
         * @memberof server.CandidatePairStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CandidatePairStats} CandidatePairStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CandidatePairStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CandidatePairStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.local = reader.int32();
                    break;
                case 2:
                    message.localIP = reader.string();
                    break;
                case 3:
                    message.remote = reader.int32();
                    break;
                case 4:
                    message.remoteIP = reader.string();
                    break;
                case 5:
                    message.packetsSent = reader.uint64();
                    break;
                case 6:
                    message.packetsReceived = reader.uint64();
                    break;
                case 7:
                    message.bytesSent = reader.uint64();
                    break;
                case 8:
                    message.bytesReceived = reader.uint64();
                    break;
                case 9:
                    message.averageRoundTripTime = reader.double();
                    break;
                case 10:
                    message.currentRoundTripTime = reader.double();
                    break;
                case 11:
                    message.availableOutgoingBitrate = reader.double();
                    break;
                case 12:
                    message.availableIncomingBitrate = reader.double();
                    break;
                case 13:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CandidatePairStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CandidatePairStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CandidatePairStats} CandidatePairStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CandidatePairStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CandidatePairStats message.
         * @function verify
         * @memberof server.CandidatePairStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CandidatePairStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.local != null && message.hasOwnProperty("local"))
                switch (message.local) {
                default:
                    return "local: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.localIP != null && message.hasOwnProperty("localIP"))
                if (!$util.isString(message.localIP))
                    return "localIP: string expected";
            if (message.remote != null && message.hasOwnProperty("remote"))
                switch (message.remote) {
                default:
                    return "remote: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.remoteIP != null && message.hasOwnProperty("remoteIP"))
                if (!$util.isString(message.remoteIP))
                    return "remoteIP: string expected";
            if (message.packetsSent != null && message.hasOwnProperty("packetsSent"))
                if (!$util.isInteger(message.packetsSent) && !(message.packetsSent && $util.isInteger(message.packetsSent.low) && $util.isInteger(message.packetsSent.high)))
                    return "packetsSent: integer|Long expected";
            if (message.packetsReceived != null && message.hasOwnProperty("packetsReceived"))
                if (!$util.isInteger(message.packetsReceived) && !(message.packetsReceived && $util.isInteger(message.packetsReceived.low) && $util.isInteger(message.packetsReceived.high)))
                    return "packetsReceived: integer|Long expected";
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (!$util.isInteger(message.bytesSent) && !(message.bytesSent && $util.isInteger(message.bytesSent.low) && $util.isInteger(message.bytesSent.high)))
                    return "bytesSent: integer|Long expected";
            if (message.bytesReceived != null && message.hasOwnProperty("bytesReceived"))
                if (!$util.isInteger(message.bytesReceived) && !(message.bytesReceived && $util.isInteger(message.bytesReceived.low) && $util.isInteger(message.bytesReceived.high)))
                    return "bytesReceived: integer|Long expected";
            if (message.averageRoundTripTime != null && message.hasOwnProperty("averageRoundTripTime"))
                if (typeof message.averageRoundTripTime !== "number")
                    return "averageRoundTripTime: number expected";
            if (message.currentRoundTripTime != null && message.hasOwnProperty("currentRoundTripTime"))
                if (typeof message.currentRoundTripTime !== "number")
                    return "currentRoundTripTime: number expected";
            if (message.availableOutgoingBitrate != null && message.hasOwnProperty("availableOutgoingBitrate"))
                if (typeof message.availableOutgoingBitrate !== "number")
                    return "availableOutgoingBitrate: number expected";
            if (message.availableIncomingBitrate != null && message.hasOwnProperty("availableIncomingBitrate"))
                if (typeof message.availableIncomingBitrate !== "number")
                    return "availableIncomingBitrate: number expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a CandidatePairStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CandidatePairStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CandidatePairStats} CandidatePairStats
         */
        CandidatePairStats.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CandidatePairStats)
                return object;
            var message = new $root.server.CandidatePairStats();
            switch (object.local) {
            case "PRFLX":
            case 0:
                message.local = 0;
                break;
            case "SRFLX":
            case 1:
                message.local = 1;
                break;
            case "RELAY":
            case 2:
                message.local = 2;
                break;
            case "HOST":
            case 3:
                message.local = 3;
                break;
            }
            if (object.localIP != null)
                message.localIP = String(object.localIP);
            switch (object.remote) {
            case "PRFLX":
            case 0:
                message.remote = 0;
                break;
            case "SRFLX":
            case 1:
                message.remote = 1;
                break;
            case "RELAY":
            case 2:
                message.remote = 2;
                break;
            case "HOST":
            case 3:
                message.remote = 3;
                break;
            }
            if (object.remoteIP != null)
                message.remoteIP = String(object.remoteIP);
            if (object.packetsSent != null)
                if ($util.Long)
                    (message.packetsSent = $util.Long.fromValue(object.packetsSent)).unsigned = true;
                else if (typeof object.packetsSent === "string")
                    message.packetsSent = parseInt(object.packetsSent, 10);
                else if (typeof object.packetsSent === "number")
                    message.packetsSent = object.packetsSent;
                else if (typeof object.packetsSent === "object")
                    message.packetsSent = new $util.LongBits(object.packetsSent.low >>> 0, object.packetsSent.high >>> 0).toNumber(true);
            if (object.packetsReceived != null)
                if ($util.Long)
                    (message.packetsReceived = $util.Long.fromValue(object.packetsReceived)).unsigned = true;
                else if (typeof object.packetsReceived === "string")
                    message.packetsReceived = parseInt(object.packetsReceived, 10);
                else if (typeof object.packetsReceived === "number")
                    message.packetsReceived = object.packetsReceived;
                else if (typeof object.packetsReceived === "object")
                    message.packetsReceived = new $util.LongBits(object.packetsReceived.low >>> 0, object.packetsReceived.high >>> 0).toNumber(true);
            if (object.bytesSent != null)
                if ($util.Long)
                    (message.bytesSent = $util.Long.fromValue(object.bytesSent)).unsigned = true;
                else if (typeof object.bytesSent === "string")
                    message.bytesSent = parseInt(object.bytesSent, 10);
                else if (typeof object.bytesSent === "number")
                    message.bytesSent = object.bytesSent;
                else if (typeof object.bytesSent === "object")
                    message.bytesSent = new $util.LongBits(object.bytesSent.low >>> 0, object.bytesSent.high >>> 0).toNumber(true);
            if (object.bytesReceived != null)
                if ($util.Long)
                    (message.bytesReceived = $util.Long.fromValue(object.bytesReceived)).unsigned = true;
                else if (typeof object.bytesReceived === "string")
                    message.bytesReceived = parseInt(object.bytesReceived, 10);
                else if (typeof object.bytesReceived === "number")
                    message.bytesReceived = object.bytesReceived;
                else if (typeof object.bytesReceived === "object")
                    message.bytesReceived = new $util.LongBits(object.bytesReceived.low >>> 0, object.bytesReceived.high >>> 0).toNumber(true);
            if (object.averageRoundTripTime != null)
                message.averageRoundTripTime = Number(object.averageRoundTripTime);
            if (object.currentRoundTripTime != null)
                message.currentRoundTripTime = Number(object.currentRoundTripTime);
            if (object.availableOutgoingBitrate != null)
                message.availableOutgoingBitrate = Number(object.availableOutgoingBitrate);
            if (object.availableIncomingBitrate != null)
                message.availableIncomingBitrate = Number(object.availableIncomingBitrate);
            switch (object.state) {
            case "FROZEN":
            case 0:
                message.state = 0;
                break;
            case "WAITING":
            case 1:
                message.state = 1;
                break;
            case "IN_PROGRESS":
            case 2:
                message.state = 2;
                break;
            case "FAILED":
            case 3:
                message.state = 3;
                break;
            case "SUCCEEDED":
            case 4:
                message.state = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CandidatePairStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CandidatePairStats
         * @static
         * @param {server.CandidatePairStats} message CandidatePairStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CandidatePairStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.local = options.enums === String ? "PRFLX" : 0;
                object.localIP = "";
                object.remote = options.enums === String ? "PRFLX" : 0;
                object.remoteIP = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.packetsReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetsReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bytesSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.bytesReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesReceived = options.longs === String ? "0" : 0;
                object.averageRoundTripTime = 0;
                object.currentRoundTripTime = 0;
                object.availableOutgoingBitrate = 0;
                object.availableIncomingBitrate = 0;
                object.state = options.enums === String ? "FROZEN" : 0;
            }
            if (message.local != null && message.hasOwnProperty("local"))
                object.local = options.enums === String ? $root.server.CandidatePairStats.CandidateType[message.local] : message.local;
            if (message.localIP != null && message.hasOwnProperty("localIP"))
                object.localIP = message.localIP;
            if (message.remote != null && message.hasOwnProperty("remote"))
                object.remote = options.enums === String ? $root.server.CandidatePairStats.CandidateType[message.remote] : message.remote;
            if (message.remoteIP != null && message.hasOwnProperty("remoteIP"))
                object.remoteIP = message.remoteIP;
            if (message.packetsSent != null && message.hasOwnProperty("packetsSent"))
                if (typeof message.packetsSent === "number")
                    object.packetsSent = options.longs === String ? String(message.packetsSent) : message.packetsSent;
                else
                    object.packetsSent = options.longs === String ? $util.Long.prototype.toString.call(message.packetsSent) : options.longs === Number ? new $util.LongBits(message.packetsSent.low >>> 0, message.packetsSent.high >>> 0).toNumber(true) : message.packetsSent;
            if (message.packetsReceived != null && message.hasOwnProperty("packetsReceived"))
                if (typeof message.packetsReceived === "number")
                    object.packetsReceived = options.longs === String ? String(message.packetsReceived) : message.packetsReceived;
                else
                    object.packetsReceived = options.longs === String ? $util.Long.prototype.toString.call(message.packetsReceived) : options.longs === Number ? new $util.LongBits(message.packetsReceived.low >>> 0, message.packetsReceived.high >>> 0).toNumber(true) : message.packetsReceived;
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (typeof message.bytesSent === "number")
                    object.bytesSent = options.longs === String ? String(message.bytesSent) : message.bytesSent;
                else
                    object.bytesSent = options.longs === String ? $util.Long.prototype.toString.call(message.bytesSent) : options.longs === Number ? new $util.LongBits(message.bytesSent.low >>> 0, message.bytesSent.high >>> 0).toNumber(true) : message.bytesSent;
            if (message.bytesReceived != null && message.hasOwnProperty("bytesReceived"))
                if (typeof message.bytesReceived === "number")
                    object.bytesReceived = options.longs === String ? String(message.bytesReceived) : message.bytesReceived;
                else
                    object.bytesReceived = options.longs === String ? $util.Long.prototype.toString.call(message.bytesReceived) : options.longs === Number ? new $util.LongBits(message.bytesReceived.low >>> 0, message.bytesReceived.high >>> 0).toNumber(true) : message.bytesReceived;
            if (message.averageRoundTripTime != null && message.hasOwnProperty("averageRoundTripTime"))
                object.averageRoundTripTime = options.json && !isFinite(message.averageRoundTripTime) ? String(message.averageRoundTripTime) : message.averageRoundTripTime;
            if (message.currentRoundTripTime != null && message.hasOwnProperty("currentRoundTripTime"))
                object.currentRoundTripTime = options.json && !isFinite(message.currentRoundTripTime) ? String(message.currentRoundTripTime) : message.currentRoundTripTime;
            if (message.availableOutgoingBitrate != null && message.hasOwnProperty("availableOutgoingBitrate"))
                object.availableOutgoingBitrate = options.json && !isFinite(message.availableOutgoingBitrate) ? String(message.availableOutgoingBitrate) : message.availableOutgoingBitrate;
            if (message.availableIncomingBitrate != null && message.hasOwnProperty("availableIncomingBitrate"))
                object.availableIncomingBitrate = options.json && !isFinite(message.availableIncomingBitrate) ? String(message.availableIncomingBitrate) : message.availableIncomingBitrate;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.server.CandidatePairStats.CandidatePairState[message.state] : message.state;
            return object;
        };

        /**
         * Converts this CandidatePairStats to JSON.
         * @function toJSON
         * @memberof server.CandidatePairStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CandidatePairStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CandidateType enum.
         * @name server.CandidatePairStats.CandidateType
         * @enum {number}
         * @property {number} PRFLX=0 PRFLX value
         * @property {number} SRFLX=1 SRFLX value
         * @property {number} RELAY=2 RELAY value
         * @property {number} HOST=3 HOST value
         */
        CandidatePairStats.CandidateType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PRFLX"] = 0;
            values[valuesById[1] = "SRFLX"] = 1;
            values[valuesById[2] = "RELAY"] = 2;
            values[valuesById[3] = "HOST"] = 3;
            return values;
        })();

        /**
         * CandidatePairState enum.
         * @name server.CandidatePairStats.CandidatePairState
         * @enum {number}
         * @property {number} FROZEN=0 FROZEN value
         * @property {number} WAITING=1 WAITING value
         * @property {number} IN_PROGRESS=2 IN_PROGRESS value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SUCCEEDED=4 SUCCEEDED value
         */
        CandidatePairStats.CandidatePairState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FROZEN"] = 0;
            values[valuesById[1] = "WAITING"] = 1;
            values[valuesById[2] = "IN_PROGRESS"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SUCCEEDED"] = 4;
            return values;
        })();

        return CandidatePairStats;
    })();

    server.FabAction = (function() {

        /**
         * Properties of a FabAction.
         * @memberof server
         * @interface IFabAction
         * @property {server.FabAction.FabActionType|null} [type] FabAction type
         */

        /**
         * Constructs a new FabAction.
         * @memberof server
         * @classdesc Represents a FabAction.
         * @implements IFabAction
         * @constructor
         * @param {server.IFabAction=} [properties] Properties to set
         */
        function FabAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FabAction type.
         * @member {server.FabAction.FabActionType} type
         * @memberof server.FabAction
         * @instance
         */
        FabAction.prototype.type = 0;

        /**
         * Creates a new FabAction instance using the specified properties.
         * @function create
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction=} [properties] Properties to set
         * @returns {server.FabAction} FabAction instance
         */
        FabAction.create = function create(properties) {
            return new FabAction(properties);
        };

        /**
         * Encodes the specified FabAction message. Does not implicitly {@link server.FabAction.verify|verify} messages.
         * @function encode
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction} message FabAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FabAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified FabAction message, length delimited. Does not implicitly {@link server.FabAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction} message FabAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FabAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FabAction message from the specified reader or buffer.
         * @function decode
         * @memberof server.FabAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FabAction} FabAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FabAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FabAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FabAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FabAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FabAction} FabAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FabAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FabAction message.
         * @function verify
         * @memberof server.FabAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FabAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a FabAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FabAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FabAction} FabAction
         */
        FabAction.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FabAction)
                return object;
            var message = new $root.server.FabAction();
            switch (object.type) {
            case "UNKNOWN_TYPE":
            case 0:
                message.type = 0;
                break;
            case "GALLERY":
            case 1:
                message.type = 1;
                break;
            case "AUDIO":
            case 2:
                message.type = 2;
                break;
            case "TEXT":
            case 3:
                message.type = 3;
                break;
            case "CAMERA":
            case 4:
                message.type = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FabAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FabAction
         * @static
         * @param {server.FabAction} message FabAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FabAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNKNOWN_TYPE" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.FabAction.FabActionType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this FabAction to JSON.
         * @function toJSON
         * @memberof server.FabAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FabAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * FabActionType enum.
         * @name server.FabAction.FabActionType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} GALLERY=1 GALLERY value
         * @property {number} AUDIO=2 AUDIO value
         * @property {number} TEXT=3 TEXT value
         * @property {number} CAMERA=4 CAMERA value
         */
        FabAction.FabActionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "GALLERY"] = 1;
            values[valuesById[2] = "AUDIO"] = 2;
            values[valuesById[3] = "TEXT"] = 3;
            values[valuesById[4] = "CAMERA"] = 4;
            return values;
        })();

        return FabAction;
    })();

    server.InviteRequestResult = (function() {

        /**
         * Properties of an InviteRequestResult.
         * @memberof server
         * @interface IInviteRequestResult
         * @property {server.InviteRequestResult.Type|null} [type] InviteRequestResult type
         * @property {string|null} [invitedPhone] InviteRequestResult invitedPhone
         * @property {string|null} [langId] InviteRequestResult langId
         * @property {string|null} [inviteStringId] InviteRequestResult inviteStringId
         */

        /**
         * Constructs a new InviteRequestResult.
         * @memberof server
         * @classdesc Represents an InviteRequestResult.
         * @implements IInviteRequestResult
         * @constructor
         * @param {server.IInviteRequestResult=} [properties] Properties to set
         */
        function InviteRequestResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteRequestResult type.
         * @member {server.InviteRequestResult.Type} type
         * @memberof server.InviteRequestResult
         * @instance
         */
        InviteRequestResult.prototype.type = 0;

        /**
         * InviteRequestResult invitedPhone.
         * @member {string} invitedPhone
         * @memberof server.InviteRequestResult
         * @instance
         */
        InviteRequestResult.prototype.invitedPhone = "";

        /**
         * InviteRequestResult langId.
         * @member {string} langId
         * @memberof server.InviteRequestResult
         * @instance
         */
        InviteRequestResult.prototype.langId = "";

        /**
         * InviteRequestResult inviteStringId.
         * @member {string} inviteStringId
         * @memberof server.InviteRequestResult
         * @instance
         */
        InviteRequestResult.prototype.inviteStringId = "";

        /**
         * Creates a new InviteRequestResult instance using the specified properties.
         * @function create
         * @memberof server.InviteRequestResult
         * @static
         * @param {server.IInviteRequestResult=} [properties] Properties to set
         * @returns {server.InviteRequestResult} InviteRequestResult instance
         */
        InviteRequestResult.create = function create(properties) {
            return new InviteRequestResult(properties);
        };

        /**
         * Encodes the specified InviteRequestResult message. Does not implicitly {@link server.InviteRequestResult.verify|verify} messages.
         * @function encode
         * @memberof server.InviteRequestResult
         * @static
         * @param {server.IInviteRequestResult} message InviteRequestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteRequestResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.invitedPhone != null && Object.hasOwnProperty.call(message, "invitedPhone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.invitedPhone);
            if (message.langId != null && Object.hasOwnProperty.call(message, "langId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.langId);
            if (message.inviteStringId != null && Object.hasOwnProperty.call(message, "inviteStringId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.inviteStringId);
            return writer;
        };

        /**
         * Encodes the specified InviteRequestResult message, length delimited. Does not implicitly {@link server.InviteRequestResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InviteRequestResult
         * @static
         * @param {server.IInviteRequestResult} message InviteRequestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteRequestResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteRequestResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.InviteRequestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InviteRequestResult} InviteRequestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteRequestResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InviteRequestResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.invitedPhone = reader.string();
                    break;
                case 3:
                    message.langId = reader.string();
                    break;
                case 4:
                    message.inviteStringId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteRequestResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InviteRequestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InviteRequestResult} InviteRequestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteRequestResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteRequestResult message.
         * @function verify
         * @memberof server.InviteRequestResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteRequestResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.invitedPhone != null && message.hasOwnProperty("invitedPhone"))
                if (!$util.isString(message.invitedPhone))
                    return "invitedPhone: string expected";
            if (message.langId != null && message.hasOwnProperty("langId"))
                if (!$util.isString(message.langId))
                    return "langId: string expected";
            if (message.inviteStringId != null && message.hasOwnProperty("inviteStringId"))
                if (!$util.isString(message.inviteStringId))
                    return "inviteStringId: string expected";
            return null;
        };

        /**
         * Creates an InviteRequestResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InviteRequestResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InviteRequestResult} InviteRequestResult
         */
        InviteRequestResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InviteRequestResult)
                return object;
            var message = new $root.server.InviteRequestResult();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "CANCELLED":
            case 1:
                message.type = 1;
                break;
            case "SENT":
            case 2:
                message.type = 2;
                break;
            case "FAILED":
            case 3:
                message.type = 3;
                break;
            }
            if (object.invitedPhone != null)
                message.invitedPhone = String(object.invitedPhone);
            if (object.langId != null)
                message.langId = String(object.langId);
            if (object.inviteStringId != null)
                message.inviteStringId = String(object.inviteStringId);
            return message;
        };

        /**
         * Creates a plain object from an InviteRequestResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InviteRequestResult
         * @static
         * @param {server.InviteRequestResult} message InviteRequestResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InviteRequestResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.invitedPhone = "";
                object.langId = "";
                object.inviteStringId = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.InviteRequestResult.Type[message.type] : message.type;
            if (message.invitedPhone != null && message.hasOwnProperty("invitedPhone"))
                object.invitedPhone = message.invitedPhone;
            if (message.langId != null && message.hasOwnProperty("langId"))
                object.langId = message.langId;
            if (message.inviteStringId != null && message.hasOwnProperty("inviteStringId"))
                object.inviteStringId = message.inviteStringId;
            return object;
        };

        /**
         * Converts this InviteRequestResult to JSON.
         * @function toJSON
         * @memberof server.InviteRequestResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InviteRequestResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.InviteRequestResult.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CANCELLED=1 CANCELLED value
         * @property {number} SENT=2 SENT value
         * @property {number} FAILED=3 FAILED value
         */
        InviteRequestResult.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CANCELLED"] = 1;
            values[valuesById[2] = "SENT"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            return values;
        })();

        return InviteRequestResult;
    })();

    return server;
})();

module.exports = $root;
