/* eslint-disable */
// @ts-nocheck
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.server = (function() {

    /**
     * Namespace server.
     * @exports server
     * @namespace
     */
    var server = {};

    server.UploadAvatar = (function() {

        /**
         * Properties of an UploadAvatar.
         * @memberof server
         * @interface IUploadAvatar
         * @property {string|null} [id] UploadAvatar id
         * @property {Uint8Array|null} [data] UploadAvatar data
         * @property {Uint8Array|null} [fullData] UploadAvatar fullData
         */

        /**
         * Constructs a new UploadAvatar.
         * @memberof server
         * @classdesc Represents an UploadAvatar.
         * @implements IUploadAvatar
         * @constructor
         * @param {server.IUploadAvatar=} [properties] Properties to set
         */
        function UploadAvatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadAvatar id.
         * @member {string} id
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.id = "";

        /**
         * UploadAvatar data.
         * @member {Uint8Array} data
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.data = $util.newBuffer([]);

        /**
         * UploadAvatar fullData.
         * @member {Uint8Array} fullData
         * @memberof server.UploadAvatar
         * @instance
         */
        UploadAvatar.prototype.fullData = $util.newBuffer([]);

        /**
         * Creates a new UploadAvatar instance using the specified properties.
         * @function create
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar=} [properties] Properties to set
         * @returns {server.UploadAvatar} UploadAvatar instance
         */
        UploadAvatar.create = function create(properties) {
            return new UploadAvatar(properties);
        };

        /**
         * Encodes the specified UploadAvatar message. Does not implicitly {@link server.UploadAvatar.verify|verify} messages.
         * @function encode
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar} message UploadAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadAvatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.fullData != null && Object.hasOwnProperty.call(message, "fullData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fullData);
            return writer;
        };

        /**
         * Encodes the specified UploadAvatar message, length delimited. Does not implicitly {@link server.UploadAvatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadAvatar
         * @static
         * @param {server.IUploadAvatar} message UploadAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadAvatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadAvatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadAvatar} UploadAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadAvatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadAvatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.fullData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadAvatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadAvatar} UploadAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadAvatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadAvatar message.
         * @function verify
         * @memberof server.UploadAvatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadAvatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                if (!(message.fullData && typeof message.fullData.length === "number" || $util.isString(message.fullData)))
                    return "fullData: buffer expected";
            return null;
        };

        /**
         * Creates an UploadAvatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadAvatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadAvatar} UploadAvatar
         */
        UploadAvatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadAvatar)
                return object;
            var message = new $root.server.UploadAvatar();
            if (object.id != null)
                message.id = String(object.id);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.fullData != null)
                if (typeof object.fullData === "string")
                    $util.base64.decode(object.fullData, message.fullData = $util.newBuffer($util.base64.length(object.fullData)), 0);
                else if (object.fullData.length)
                    message.fullData = object.fullData;
            return message;
        };

        /**
         * Creates a plain object from an UploadAvatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadAvatar
         * @static
         * @param {server.UploadAvatar} message UploadAvatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadAvatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.fullData = "";
                else {
                    object.fullData = [];
                    if (options.bytes !== Array)
                        object.fullData = $util.newBuffer(object.fullData);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                object.fullData = options.bytes === String ? $util.base64.encode(message.fullData, 0, message.fullData.length) : options.bytes === Array ? Array.prototype.slice.call(message.fullData) : message.fullData;
            return object;
        };

        /**
         * Converts this UploadAvatar to JSON.
         * @function toJSON
         * @memberof server.UploadAvatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadAvatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UploadAvatar;
    })();

    server.Avatar = (function() {

        /**
         * Properties of an Avatar.
         * @memberof server
         * @interface IAvatar
         * @property {string|null} [id] Avatar id
         * @property {number|Long|null} [uid] Avatar uid
         */

        /**
         * Constructs a new Avatar.
         * @memberof server
         * @classdesc Represents an Avatar.
         * @implements IAvatar
         * @constructor
         * @param {server.IAvatar=} [properties] Properties to set
         */
        function Avatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Avatar id.
         * @member {string} id
         * @memberof server.Avatar
         * @instance
         */
        Avatar.prototype.id = "";

        /**
         * Avatar uid.
         * @member {number|Long} uid
         * @memberof server.Avatar
         * @instance
         */
        Avatar.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Avatar instance using the specified properties.
         * @function create
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar=} [properties] Properties to set
         * @returns {server.Avatar} Avatar instance
         */
        Avatar.create = function create(properties) {
            return new Avatar(properties);
        };

        /**
         * Encodes the specified Avatar message. Does not implicitly {@link server.Avatar.verify|verify} messages.
         * @function encode
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar} message Avatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified Avatar message, length delimited. Does not implicitly {@link server.Avatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Avatar
         * @static
         * @param {server.IAvatar} message Avatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Avatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.Avatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Avatar} Avatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Avatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Avatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Avatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Avatar} Avatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Avatar message.
         * @function verify
         * @memberof server.Avatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Avatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Avatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Avatar} Avatar
         */
        Avatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Avatar)
                return object;
            var message = new $root.server.Avatar();
            if (object.id != null)
                message.id = String(object.id);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Avatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Avatar
         * @static
         * @param {server.Avatar} message Avatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Avatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this Avatar to JSON.
         * @function toJSON
         * @memberof server.Avatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Avatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Avatar;
    })();

    server.Avatars = (function() {

        /**
         * Properties of an Avatars.
         * @memberof server
         * @interface IAvatars
         * @property {Array.<server.IAvatar>|null} [avatars] Avatars avatars
         */

        /**
         * Constructs a new Avatars.
         * @memberof server
         * @classdesc Represents an Avatars.
         * @implements IAvatars
         * @constructor
         * @param {server.IAvatars=} [properties] Properties to set
         */
        function Avatars(properties) {
            this.avatars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Avatars avatars.
         * @member {Array.<server.IAvatar>} avatars
         * @memberof server.Avatars
         * @instance
         */
        Avatars.prototype.avatars = $util.emptyArray;

        /**
         * Creates a new Avatars instance using the specified properties.
         * @function create
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars=} [properties] Properties to set
         * @returns {server.Avatars} Avatars instance
         */
        Avatars.create = function create(properties) {
            return new Avatars(properties);
        };

        /**
         * Encodes the specified Avatars message. Does not implicitly {@link server.Avatars.verify|verify} messages.
         * @function encode
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars} message Avatars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.avatars != null && message.avatars.length)
                for (var i = 0; i < message.avatars.length; ++i)
                    $root.server.Avatar.encode(message.avatars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Avatars message, length delimited. Does not implicitly {@link server.Avatars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Avatars
         * @static
         * @param {server.IAvatars} message Avatars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Avatars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Avatars message from the specified reader or buffer.
         * @function decode
         * @memberof server.Avatars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Avatars} Avatars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Avatars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.avatars && message.avatars.length))
                        message.avatars = [];
                    message.avatars.push($root.server.Avatar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Avatars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Avatars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Avatars} Avatars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Avatars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Avatars message.
         * @function verify
         * @memberof server.Avatars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Avatars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                if (!Array.isArray(message.avatars))
                    return "avatars: array expected";
                for (var i = 0; i < message.avatars.length; ++i) {
                    var error = $root.server.Avatar.verify(message.avatars[i]);
                    if (error)
                        return "avatars." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Avatars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Avatars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Avatars} Avatars
         */
        Avatars.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Avatars)
                return object;
            var message = new $root.server.Avatars();
            if (object.avatars) {
                if (!Array.isArray(object.avatars))
                    throw TypeError(".server.Avatars.avatars: array expected");
                message.avatars = [];
                for (var i = 0; i < object.avatars.length; ++i) {
                    if (typeof object.avatars[i] !== "object")
                        throw TypeError(".server.Avatars.avatars: object expected");
                    message.avatars[i] = $root.server.Avatar.fromObject(object.avatars[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Avatars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Avatars
         * @static
         * @param {server.Avatars} message Avatars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Avatars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.avatars = [];
            if (message.avatars && message.avatars.length) {
                object.avatars = [];
                for (var j = 0; j < message.avatars.length; ++j)
                    object.avatars[j] = $root.server.Avatar.toObject(message.avatars[j], options);
            }
            return object;
        };

        /**
         * Converts this Avatars to JSON.
         * @function toJSON
         * @memberof server.Avatars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Avatars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Avatars;
    })();

    server.UploadGroupAvatar = (function() {

        /**
         * Properties of an UploadGroupAvatar.
         * @memberof server
         * @interface IUploadGroupAvatar
         * @property {string|null} [gid] UploadGroupAvatar gid
         * @property {Uint8Array|null} [data] UploadGroupAvatar data
         * @property {Uint8Array|null} [fullData] UploadGroupAvatar fullData
         */

        /**
         * Constructs a new UploadGroupAvatar.
         * @memberof server
         * @classdesc Represents an UploadGroupAvatar.
         * @implements IUploadGroupAvatar
         * @constructor
         * @param {server.IUploadGroupAvatar=} [properties] Properties to set
         */
        function UploadGroupAvatar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadGroupAvatar gid.
         * @member {string} gid
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.gid = "";

        /**
         * UploadGroupAvatar data.
         * @member {Uint8Array} data
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.data = $util.newBuffer([]);

        /**
         * UploadGroupAvatar fullData.
         * @member {Uint8Array} fullData
         * @memberof server.UploadGroupAvatar
         * @instance
         */
        UploadGroupAvatar.prototype.fullData = $util.newBuffer([]);

        /**
         * Creates a new UploadGroupAvatar instance using the specified properties.
         * @function create
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar=} [properties] Properties to set
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar instance
         */
        UploadGroupAvatar.create = function create(properties) {
            return new UploadGroupAvatar(properties);
        };

        /**
         * Encodes the specified UploadGroupAvatar message. Does not implicitly {@link server.UploadGroupAvatar.verify|verify} messages.
         * @function encode
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar} message UploadGroupAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadGroupAvatar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.fullData != null && Object.hasOwnProperty.call(message, "fullData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fullData);
            return writer;
        };

        /**
         * Encodes the specified UploadGroupAvatar message, length delimited. Does not implicitly {@link server.UploadGroupAvatar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.IUploadGroupAvatar} message UploadGroupAvatar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadGroupAvatar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadGroupAvatar message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadGroupAvatar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadGroupAvatar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.fullData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadGroupAvatar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadGroupAvatar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadGroupAvatar message.
         * @function verify
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadGroupAvatar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                if (!(message.fullData && typeof message.fullData.length === "number" || $util.isString(message.fullData)))
                    return "fullData: buffer expected";
            return null;
        };

        /**
         * Creates an UploadGroupAvatar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadGroupAvatar} UploadGroupAvatar
         */
        UploadGroupAvatar.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadGroupAvatar)
                return object;
            var message = new $root.server.UploadGroupAvatar();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.fullData != null)
                if (typeof object.fullData === "string")
                    $util.base64.decode(object.fullData, message.fullData = $util.newBuffer($util.base64.length(object.fullData)), 0);
                else if (object.fullData.length)
                    message.fullData = object.fullData;
            return message;
        };

        /**
         * Creates a plain object from an UploadGroupAvatar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadGroupAvatar
         * @static
         * @param {server.UploadGroupAvatar} message UploadGroupAvatar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadGroupAvatar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.fullData = "";
                else {
                    object.fullData = [];
                    if (options.bytes !== Array)
                        object.fullData = $util.newBuffer(object.fullData);
                }
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fullData != null && message.hasOwnProperty("fullData"))
                object.fullData = options.bytes === String ? $util.base64.encode(message.fullData, 0, message.fullData.length) : options.bytes === Array ? Array.prototype.slice.call(message.fullData) : message.fullData;
            return object;
        };

        /**
         * Converts this UploadGroupAvatar to JSON.
         * @function toJSON
         * @memberof server.UploadGroupAvatar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadGroupAvatar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UploadGroupAvatar;
    })();

    server.CertMessage = (function() {

        /**
         * Properties of a CertMessage.
         * @memberof server
         * @interface ICertMessage
         * @property {number|Long|null} [timestamp] CertMessage timestamp
         * @property {Uint8Array|null} [serverKey] CertMessage serverKey
         */

        /**
         * Constructs a new CertMessage.
         * @memberof server
         * @classdesc Represents a CertMessage.
         * @implements ICertMessage
         * @constructor
         * @param {server.ICertMessage=} [properties] Properties to set
         */
        function CertMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CertMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof server.CertMessage
         * @instance
         */
        CertMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CertMessage serverKey.
         * @member {Uint8Array} serverKey
         * @memberof server.CertMessage
         * @instance
         */
        CertMessage.prototype.serverKey = $util.newBuffer([]);

        /**
         * Creates a new CertMessage instance using the specified properties.
         * @function create
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage=} [properties] Properties to set
         * @returns {server.CertMessage} CertMessage instance
         */
        CertMessage.create = function create(properties) {
            return new CertMessage(properties);
        };

        /**
         * Encodes the specified CertMessage message. Does not implicitly {@link server.CertMessage.verify|verify} messages.
         * @function encode
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage} message CertMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.serverKey != null && Object.hasOwnProperty.call(message, "serverKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverKey);
            return writer;
        };

        /**
         * Encodes the specified CertMessage message, length delimited. Does not implicitly {@link server.CertMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CertMessage
         * @static
         * @param {server.ICertMessage} message CertMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CertMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CertMessage message from the specified reader or buffer.
         * @function decode
         * @memberof server.CertMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CertMessage} CertMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CertMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.serverKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CertMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CertMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CertMessage} CertMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CertMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CertMessage message.
         * @function verify
         * @memberof server.CertMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CertMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                if (!(message.serverKey && typeof message.serverKey.length === "number" || $util.isString(message.serverKey)))
                    return "serverKey: buffer expected";
            return null;
        };

        /**
         * Creates a CertMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CertMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CertMessage} CertMessage
         */
        CertMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CertMessage)
                return object;
            var message = new $root.server.CertMessage();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.serverKey != null)
                if (typeof object.serverKey === "string")
                    $util.base64.decode(object.serverKey, message.serverKey = $util.newBuffer($util.base64.length(object.serverKey)), 0);
                else if (object.serverKey.length)
                    message.serverKey = object.serverKey;
            return message;
        };

        /**
         * Creates a plain object from a CertMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CertMessage
         * @static
         * @param {server.CertMessage} message CertMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CertMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.serverKey = "";
                else {
                    object.serverKey = [];
                    if (options.bytes !== Array)
                        object.serverKey = $util.newBuffer(object.serverKey);
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.serverKey != null && message.hasOwnProperty("serverKey"))
                object.serverKey = options.bytes === String ? $util.base64.encode(message.serverKey, 0, message.serverKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverKey) : message.serverKey;
            return object;
        };

        /**
         * Converts this CertMessage to JSON.
         * @function toJSON
         * @memberof server.CertMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CertMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CertMessage;
    })();

    server.ClientMode = (function() {

        /**
         * Properties of a ClientMode.
         * @memberof server
         * @interface IClientMode
         * @property {server.ClientMode.Mode|null} [mode] ClientMode mode
         */

        /**
         * Constructs a new ClientMode.
         * @memberof server
         * @classdesc Represents a ClientMode.
         * @implements IClientMode
         * @constructor
         * @param {server.IClientMode=} [properties] Properties to set
         */
        function ClientMode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientMode mode.
         * @member {server.ClientMode.Mode} mode
         * @memberof server.ClientMode
         * @instance
         */
        ClientMode.prototype.mode = 0;

        /**
         * Creates a new ClientMode instance using the specified properties.
         * @function create
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode=} [properties] Properties to set
         * @returns {server.ClientMode} ClientMode instance
         */
        ClientMode.create = function create(properties) {
            return new ClientMode(properties);
        };

        /**
         * Encodes the specified ClientMode message. Does not implicitly {@link server.ClientMode.verify|verify} messages.
         * @function encode
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode} message ClientMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
            return writer;
        };

        /**
         * Encodes the specified ClientMode message, length delimited. Does not implicitly {@link server.ClientMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientMode
         * @static
         * @param {server.IClientMode} message ClientMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientMode message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientMode} ClientMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientMode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientMode} ClientMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientMode message.
         * @function verify
         * @memberof server.ClientMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a ClientMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientMode} ClientMode
         */
        ClientMode.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientMode)
                return object;
            var message = new $root.server.ClientMode();
            switch (object.mode) {
            case "ACTIVE":
            case 0:
                message.mode = 0;
                break;
            case "PASSIVE":
            case 1:
                message.mode = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientMode
         * @static
         * @param {server.ClientMode} message ClientMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mode = options.enums === String ? "ACTIVE" : 0;
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.server.ClientMode.Mode[message.mode] : message.mode;
            return object;
        };

        /**
         * Converts this ClientMode to JSON.
         * @function toJSON
         * @memberof server.ClientMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Mode enum.
         * @name server.ClientMode.Mode
         * @enum {number}
         * @property {number} ACTIVE=0 ACTIVE value
         * @property {number} PASSIVE=1 PASSIVE value
         */
        ClientMode.Mode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ACTIVE"] = 0;
            values[valuesById[1] = "PASSIVE"] = 1;
            return values;
        })();

        return ClientMode;
    })();

    server.ClientVersion = (function() {

        /**
         * Properties of a ClientVersion.
         * @memberof server
         * @interface IClientVersion
         * @property {string|null} [version] ClientVersion version
         * @property {number|Long|null} [expiresInSeconds] ClientVersion expiresInSeconds
         */

        /**
         * Constructs a new ClientVersion.
         * @memberof server
         * @classdesc Represents a ClientVersion.
         * @implements IClientVersion
         * @constructor
         * @param {server.IClientVersion=} [properties] Properties to set
         */
        function ClientVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientVersion version.
         * @member {string} version
         * @memberof server.ClientVersion
         * @instance
         */
        ClientVersion.prototype.version = "";

        /**
         * ClientVersion expiresInSeconds.
         * @member {number|Long} expiresInSeconds
         * @memberof server.ClientVersion
         * @instance
         */
        ClientVersion.prototype.expiresInSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ClientVersion instance using the specified properties.
         * @function create
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion=} [properties] Properties to set
         * @returns {server.ClientVersion} ClientVersion instance
         */
        ClientVersion.create = function create(properties) {
            return new ClientVersion(properties);
        };

        /**
         * Encodes the specified ClientVersion message. Does not implicitly {@link server.ClientVersion.verify|verify} messages.
         * @function encode
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion} message ClientVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.expiresInSeconds != null && Object.hasOwnProperty.call(message, "expiresInSeconds"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiresInSeconds);
            return writer;
        };

        /**
         * Encodes the specified ClientVersion message, length delimited. Does not implicitly {@link server.ClientVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientVersion
         * @static
         * @param {server.IClientVersion} message ClientVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientVersion message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientVersion} ClientVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.expiresInSeconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientVersion} ClientVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientVersion message.
         * @function verify
         * @memberof server.ClientVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (!$util.isInteger(message.expiresInSeconds) && !(message.expiresInSeconds && $util.isInteger(message.expiresInSeconds.low) && $util.isInteger(message.expiresInSeconds.high)))
                    return "expiresInSeconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a ClientVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientVersion} ClientVersion
         */
        ClientVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientVersion)
                return object;
            var message = new $root.server.ClientVersion();
            if (object.version != null)
                message.version = String(object.version);
            if (object.expiresInSeconds != null)
                if ($util.Long)
                    (message.expiresInSeconds = $util.Long.fromValue(object.expiresInSeconds)).unsigned = false;
                else if (typeof object.expiresInSeconds === "string")
                    message.expiresInSeconds = parseInt(object.expiresInSeconds, 10);
                else if (typeof object.expiresInSeconds === "number")
                    message.expiresInSeconds = object.expiresInSeconds;
                else if (typeof object.expiresInSeconds === "object")
                    message.expiresInSeconds = new $util.LongBits(object.expiresInSeconds.low >>> 0, object.expiresInSeconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ClientVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientVersion
         * @static
         * @param {server.ClientVersion} message ClientVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiresInSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresInSeconds = options.longs === String ? "0" : 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (typeof message.expiresInSeconds === "number")
                    object.expiresInSeconds = options.longs === String ? String(message.expiresInSeconds) : message.expiresInSeconds;
                else
                    object.expiresInSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.expiresInSeconds) : options.longs === Number ? new $util.LongBits(message.expiresInSeconds.low >>> 0, message.expiresInSeconds.high >>> 0).toNumber() : message.expiresInSeconds;
            return object;
        };

        /**
         * Converts this ClientVersion to JSON.
         * @function toJSON
         * @memberof server.ClientVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientVersion;
    })();

    server.DeviceInfo = (function() {

        /**
         * Properties of a DeviceInfo.
         * @memberof server
         * @interface IDeviceInfo
         * @property {string|null} [device] DeviceInfo device
         * @property {string|null} [osVersion] DeviceInfo osVersion
         */

        /**
         * Constructs a new DeviceInfo.
         * @memberof server
         * @classdesc Represents a DeviceInfo.
         * @implements IDeviceInfo
         * @constructor
         * @param {server.IDeviceInfo=} [properties] Properties to set
         */
        function DeviceInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceInfo device.
         * @member {string} device
         * @memberof server.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.device = "";

        /**
         * DeviceInfo osVersion.
         * @member {string} osVersion
         * @memberof server.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.osVersion = "";

        /**
         * Creates a new DeviceInfo instance using the specified properties.
         * @function create
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo=} [properties] Properties to set
         * @returns {server.DeviceInfo} DeviceInfo instance
         */
        DeviceInfo.create = function create(properties) {
            return new DeviceInfo(properties);
        };

        /**
         * Encodes the specified DeviceInfo message. Does not implicitly {@link server.DeviceInfo.verify|verify} messages.
         * @function encode
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
            if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.osVersion);
            return writer;
        };

        /**
         * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link server.DeviceInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeviceInfo
         * @static
         * @param {server.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeviceInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.device = reader.string();
                    break;
                case 2:
                    message.osVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceInfo message.
         * @function verify
         * @memberof server.DeviceInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                if (!$util.isString(message.osVersion))
                    return "osVersion: string expected";
            return null;
        };

        /**
         * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeviceInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeviceInfo} DeviceInfo
         */
        DeviceInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeviceInfo)
                return object;
            var message = new $root.server.DeviceInfo();
            if (object.device != null)
                message.device = String(object.device);
            if (object.osVersion != null)
                message.osVersion = String(object.osVersion);
            return message;
        };

        /**
         * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeviceInfo
         * @static
         * @param {server.DeviceInfo} message DeviceInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.device = "";
                object.osVersion = "";
            }
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                object.osVersion = message.osVersion;
            return object;
        };

        /**
         * Converts this DeviceInfo to JSON.
         * @function toJSON
         * @memberof server.DeviceInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceInfo;
    })();

    server.ClientLog = (function() {

        /**
         * Properties of a ClientLog.
         * @memberof server
         * @interface IClientLog
         * @property {Array.<server.ICount>|null} [counts] ClientLog counts
         * @property {Array.<server.IEventData>|null} [events] ClientLog events
         */

        /**
         * Constructs a new ClientLog.
         * @memberof server
         * @classdesc Represents a ClientLog.
         * @implements IClientLog
         * @constructor
         * @param {server.IClientLog=} [properties] Properties to set
         */
        function ClientLog(properties) {
            this.counts = [];
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientLog counts.
         * @member {Array.<server.ICount>} counts
         * @memberof server.ClientLog
         * @instance
         */
        ClientLog.prototype.counts = $util.emptyArray;

        /**
         * ClientLog events.
         * @member {Array.<server.IEventData>} events
         * @memberof server.ClientLog
         * @instance
         */
        ClientLog.prototype.events = $util.emptyArray;

        /**
         * Creates a new ClientLog instance using the specified properties.
         * @function create
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog=} [properties] Properties to set
         * @returns {server.ClientLog} ClientLog instance
         */
        ClientLog.create = function create(properties) {
            return new ClientLog(properties);
        };

        /**
         * Encodes the specified ClientLog message. Does not implicitly {@link server.ClientLog.verify|verify} messages.
         * @function encode
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog} message ClientLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.counts != null && message.counts.length)
                for (var i = 0; i < message.counts.length; ++i)
                    $root.server.Count.encode(message.counts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.server.EventData.encode(message.events[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientLog message, length delimited. Does not implicitly {@link server.ClientLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientLog
         * @static
         * @param {server.IClientLog} message ClientLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientLog message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientLog} ClientLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.counts && message.counts.length))
                        message.counts = [];
                    message.counts.push($root.server.Count.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.server.EventData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientLog} ClientLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientLog message.
         * @function verify
         * @memberof server.ClientLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.counts != null && message.hasOwnProperty("counts")) {
                if (!Array.isArray(message.counts))
                    return "counts: array expected";
                for (var i = 0; i < message.counts.length; ++i) {
                    var error = $root.server.Count.verify(message.counts[i]);
                    if (error)
                        return "counts." + error;
                }
            }
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.server.EventData.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientLog} ClientLog
         */
        ClientLog.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientLog)
                return object;
            var message = new $root.server.ClientLog();
            if (object.counts) {
                if (!Array.isArray(object.counts))
                    throw TypeError(".server.ClientLog.counts: array expected");
                message.counts = [];
                for (var i = 0; i < object.counts.length; ++i) {
                    if (typeof object.counts[i] !== "object")
                        throw TypeError(".server.ClientLog.counts: object expected");
                    message.counts[i] = $root.server.Count.fromObject(object.counts[i]);
                }
            }
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".server.ClientLog.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".server.ClientLog.events: object expected");
                    message.events[i] = $root.server.EventData.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientLog
         * @static
         * @param {server.ClientLog} message ClientLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.counts = [];
                object.events = [];
            }
            if (message.counts && message.counts.length) {
                object.counts = [];
                for (var j = 0; j < message.counts.length; ++j)
                    object.counts[j] = $root.server.Count.toObject(message.counts[j], options);
            }
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.server.EventData.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientLog to JSON.
         * @function toJSON
         * @memberof server.ClientLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientLog;
    })();

    server.Count = (function() {

        /**
         * Properties of a Count.
         * @memberof server
         * @interface ICount
         * @property {string|null} [namespace] Count namespace
         * @property {string|null} [metric] Count metric
         * @property {number|Long|null} [count] Count count
         * @property {Array.<server.IDim>|null} [dims] Count dims
         */

        /**
         * Constructs a new Count.
         * @memberof server
         * @classdesc Represents a Count.
         * @implements ICount
         * @constructor
         * @param {server.ICount=} [properties] Properties to set
         */
        function Count(properties) {
            this.dims = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Count namespace.
         * @member {string} namespace
         * @memberof server.Count
         * @instance
         */
        Count.prototype.namespace = "";

        /**
         * Count metric.
         * @member {string} metric
         * @memberof server.Count
         * @instance
         */
        Count.prototype.metric = "";

        /**
         * Count count.
         * @member {number|Long} count
         * @memberof server.Count
         * @instance
         */
        Count.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Count dims.
         * @member {Array.<server.IDim>} dims
         * @memberof server.Count
         * @instance
         */
        Count.prototype.dims = $util.emptyArray;

        /**
         * Creates a new Count instance using the specified properties.
         * @function create
         * @memberof server.Count
         * @static
         * @param {server.ICount=} [properties] Properties to set
         * @returns {server.Count} Count instance
         */
        Count.create = function create(properties) {
            return new Count(properties);
        };

        /**
         * Encodes the specified Count message. Does not implicitly {@link server.Count.verify|verify} messages.
         * @function encode
         * @memberof server.Count
         * @static
         * @param {server.ICount} message Count message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Count.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
            if (message.metric != null && Object.hasOwnProperty.call(message, "metric"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.metric);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.count);
            if (message.dims != null && message.dims.length)
                for (var i = 0; i < message.dims.length; ++i)
                    $root.server.Dim.encode(message.dims[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Count message, length delimited. Does not implicitly {@link server.Count.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Count
         * @static
         * @param {server.ICount} message Count message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Count.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Count message from the specified reader or buffer.
         * @function decode
         * @memberof server.Count
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Count} Count
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Count.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Count();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.namespace = reader.string();
                    break;
                case 2:
                    message.metric = reader.string();
                    break;
                case 3:
                    message.count = reader.int64();
                    break;
                case 4:
                    if (!(message.dims && message.dims.length))
                        message.dims = [];
                    message.dims.push($root.server.Dim.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Count message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Count
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Count} Count
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Count.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Count message.
         * @function verify
         * @memberof server.Count
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Count.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                if (!$util.isString(message.namespace))
                    return "namespace: string expected";
            if (message.metric != null && message.hasOwnProperty("metric"))
                if (!$util.isString(message.metric))
                    return "metric: string expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
                if (!Array.isArray(message.dims))
                    return "dims: array expected";
                for (var i = 0; i < message.dims.length; ++i) {
                    var error = $root.server.Dim.verify(message.dims[i]);
                    if (error)
                        return "dims." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Count message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Count
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Count} Count
         */
        Count.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Count)
                return object;
            var message = new $root.server.Count();
            if (object.namespace != null)
                message.namespace = String(object.namespace);
            if (object.metric != null)
                message.metric = String(object.metric);
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            if (object.dims) {
                if (!Array.isArray(object.dims))
                    throw TypeError(".server.Count.dims: array expected");
                message.dims = [];
                for (var i = 0; i < object.dims.length; ++i) {
                    if (typeof object.dims[i] !== "object")
                        throw TypeError(".server.Count.dims: object expected");
                    message.dims[i] = $root.server.Dim.fromObject(object.dims[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Count message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Count
         * @static
         * @param {server.Count} message Count
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Count.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dims = [];
            if (options.defaults) {
                object.namespace = "";
                object.metric = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
            }
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                object.namespace = message.namespace;
            if (message.metric != null && message.hasOwnProperty("metric"))
                object.metric = message.metric;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            if (message.dims && message.dims.length) {
                object.dims = [];
                for (var j = 0; j < message.dims.length; ++j)
                    object.dims[j] = $root.server.Dim.toObject(message.dims[j], options);
            }
            return object;
        };

        /**
         * Converts this Count to JSON.
         * @function toJSON
         * @memberof server.Count
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Count.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Count;
    })();

    server.Dim = (function() {

        /**
         * Properties of a Dim.
         * @memberof server
         * @interface IDim
         * @property {string|null} [name] Dim name
         * @property {string|null} [value] Dim value
         */

        /**
         * Constructs a new Dim.
         * @memberof server
         * @classdesc Represents a Dim.
         * @implements IDim
         * @constructor
         * @param {server.IDim=} [properties] Properties to set
         */
        function Dim(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dim name.
         * @member {string} name
         * @memberof server.Dim
         * @instance
         */
        Dim.prototype.name = "";

        /**
         * Dim value.
         * @member {string} value
         * @memberof server.Dim
         * @instance
         */
        Dim.prototype.value = "";

        /**
         * Creates a new Dim instance using the specified properties.
         * @function create
         * @memberof server.Dim
         * @static
         * @param {server.IDim=} [properties] Properties to set
         * @returns {server.Dim} Dim instance
         */
        Dim.create = function create(properties) {
            return new Dim(properties);
        };

        /**
         * Encodes the specified Dim message. Does not implicitly {@link server.Dim.verify|verify} messages.
         * @function encode
         * @memberof server.Dim
         * @static
         * @param {server.IDim} message Dim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dim.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Dim message, length delimited. Does not implicitly {@link server.Dim.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Dim
         * @static
         * @param {server.IDim} message Dim message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dim.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dim message from the specified reader or buffer.
         * @function decode
         * @memberof server.Dim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Dim} Dim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dim.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Dim();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dim message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Dim
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Dim} Dim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dim.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dim message.
         * @function verify
         * @memberof server.Dim
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dim.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Dim message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Dim
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Dim} Dim
         */
        Dim.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Dim)
                return object;
            var message = new $root.server.Dim();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Dim message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Dim
         * @static
         * @param {server.Dim} message Dim
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dim.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Dim to JSON.
         * @function toJSON
         * @memberof server.Dim
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dim.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Dim;
    })();

    server.Contact = (function() {

        /**
         * Properties of a Contact.
         * @memberof server
         * @interface IContact
         * @property {server.Contact.Action|null} [action] Contact action
         * @property {string|null} [raw] Contact raw
         * @property {string|null} [normalized] Contact normalized
         * @property {number|Long|null} [uid] Contact uid
         * @property {string|null} [avatarId] Contact avatarId
         * @property {string|null} [name] Contact name
         * @property {number|Long|null} [numPotentialFriends] Contact numPotentialFriends
         */

        /**
         * Constructs a new Contact.
         * @memberof server
         * @classdesc Represents a Contact.
         * @implements IContact
         * @constructor
         * @param {server.IContact=} [properties] Properties to set
         */
        function Contact(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Contact action.
         * @member {server.Contact.Action} action
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.action = 0;

        /**
         * Contact raw.
         * @member {string} raw
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.raw = "";

        /**
         * Contact normalized.
         * @member {string} normalized
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.normalized = "";

        /**
         * Contact uid.
         * @member {number|Long} uid
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contact avatarId.
         * @member {string} avatarId
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.avatarId = "";

        /**
         * Contact name.
         * @member {string} name
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.name = "";

        /**
         * Contact numPotentialFriends.
         * @member {number|Long} numPotentialFriends
         * @memberof server.Contact
         * @instance
         */
        Contact.prototype.numPotentialFriends = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Contact instance using the specified properties.
         * @function create
         * @memberof server.Contact
         * @static
         * @param {server.IContact=} [properties] Properties to set
         * @returns {server.Contact} Contact instance
         */
        Contact.create = function create(properties) {
            return new Contact(properties);
        };

        /**
         * Encodes the specified Contact message. Does not implicitly {@link server.Contact.verify|verify} messages.
         * @function encode
         * @memberof server.Contact
         * @static
         * @param {server.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.raw != null && Object.hasOwnProperty.call(message, "raw"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.raw);
            if (message.normalized != null && Object.hasOwnProperty.call(message, "normalized"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.normalized);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.uid);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.numPotentialFriends != null && Object.hasOwnProperty.call(message, "numPotentialFriends"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.numPotentialFriends);
            return writer;
        };

        /**
         * Encodes the specified Contact message, length delimited. Does not implicitly {@link server.Contact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Contact
         * @static
         * @param {server.IContact} message Contact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Contact message from the specified reader or buffer.
         * @function decode
         * @memberof server.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Contact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.raw = reader.string();
                    break;
                case 3:
                    message.normalized = reader.string();
                    break;
                case 4:
                    message.uid = reader.int64();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.numPotentialFriends = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Contact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Contact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Contact} Contact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Contact message.
         * @function verify
         * @memberof server.Contact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Contact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.raw != null && message.hasOwnProperty("raw"))
                if (!$util.isString(message.raw))
                    return "raw: string expected";
            if (message.normalized != null && message.hasOwnProperty("normalized"))
                if (!$util.isString(message.normalized))
                    return "normalized: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.numPotentialFriends != null && message.hasOwnProperty("numPotentialFriends"))
                if (!$util.isInteger(message.numPotentialFriends) && !(message.numPotentialFriends && $util.isInteger(message.numPotentialFriends.low) && $util.isInteger(message.numPotentialFriends.high)))
                    return "numPotentialFriends: integer|Long expected";
            return null;
        };

        /**
         * Creates a Contact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Contact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Contact} Contact
         */
        Contact.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Contact)
                return object;
            var message = new $root.server.Contact();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.raw != null)
                message.raw = String(object.raw);
            if (object.normalized != null)
                message.normalized = String(object.normalized);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.name != null)
                message.name = String(object.name);
            if (object.numPotentialFriends != null)
                if ($util.Long)
                    (message.numPotentialFriends = $util.Long.fromValue(object.numPotentialFriends)).unsigned = false;
                else if (typeof object.numPotentialFriends === "string")
                    message.numPotentialFriends = parseInt(object.numPotentialFriends, 10);
                else if (typeof object.numPotentialFriends === "number")
                    message.numPotentialFriends = object.numPotentialFriends;
                else if (typeof object.numPotentialFriends === "object")
                    message.numPotentialFriends = new $util.LongBits(object.numPotentialFriends.low >>> 0, object.numPotentialFriends.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Contact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Contact
         * @static
         * @param {server.Contact} message Contact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Contact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                object.raw = "";
                object.normalized = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.avatarId = "";
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.numPotentialFriends = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numPotentialFriends = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.Contact.Action[message.action] : message.action;
            if (message.raw != null && message.hasOwnProperty("raw"))
                object.raw = message.raw;
            if (message.normalized != null && message.hasOwnProperty("normalized"))
                object.normalized = message.normalized;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.numPotentialFriends != null && message.hasOwnProperty("numPotentialFriends"))
                if (typeof message.numPotentialFriends === "number")
                    object.numPotentialFriends = options.longs === String ? String(message.numPotentialFriends) : message.numPotentialFriends;
                else
                    object.numPotentialFriends = options.longs === String ? $util.Long.prototype.toString.call(message.numPotentialFriends) : options.longs === Number ? new $util.LongBits(message.numPotentialFriends.low >>> 0, message.numPotentialFriends.high >>> 0).toNumber() : message.numPotentialFriends;
            return object;
        };

        /**
         * Converts this Contact to JSON.
         * @function toJSON
         * @memberof server.Contact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Contact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.Contact.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        Contact.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return Contact;
    })();

    server.ContactList = (function() {

        /**
         * Properties of a ContactList.
         * @memberof server
         * @interface IContactList
         * @property {server.ContactList.Type|null} [type] ContactList type
         * @property {string|null} [syncId] ContactList syncId
         * @property {number|null} [batchIndex] ContactList batchIndex
         * @property {boolean|null} [isLast] ContactList isLast
         * @property {Array.<server.IContact>|null} [contacts] ContactList contacts
         */

        /**
         * Constructs a new ContactList.
         * @memberof server
         * @classdesc Represents a ContactList.
         * @implements IContactList
         * @constructor
         * @param {server.IContactList=} [properties] Properties to set
         */
        function ContactList(properties) {
            this.contacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactList type.
         * @member {server.ContactList.Type} type
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.type = 0;

        /**
         * ContactList syncId.
         * @member {string} syncId
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.syncId = "";

        /**
         * ContactList batchIndex.
         * @member {number} batchIndex
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.batchIndex = 0;

        /**
         * ContactList isLast.
         * @member {boolean} isLast
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.isLast = false;

        /**
         * ContactList contacts.
         * @member {Array.<server.IContact>} contacts
         * @memberof server.ContactList
         * @instance
         */
        ContactList.prototype.contacts = $util.emptyArray;

        /**
         * Creates a new ContactList instance using the specified properties.
         * @function create
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList=} [properties] Properties to set
         * @returns {server.ContactList} ContactList instance
         */
        ContactList.create = function create(properties) {
            return new ContactList(properties);
        };

        /**
         * Encodes the specified ContactList message. Does not implicitly {@link server.ContactList.verify|verify} messages.
         * @function encode
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList} message ContactList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.syncId != null && Object.hasOwnProperty.call(message, "syncId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.syncId);
            if (message.batchIndex != null && Object.hasOwnProperty.call(message, "batchIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchIndex);
            if (message.isLast != null && Object.hasOwnProperty.call(message, "isLast"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isLast);
            if (message.contacts != null && message.contacts.length)
                for (var i = 0; i < message.contacts.length; ++i)
                    $root.server.Contact.encode(message.contacts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContactList message, length delimited. Does not implicitly {@link server.ContactList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactList
         * @static
         * @param {server.IContactList} message ContactList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactList message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactList} ContactList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.syncId = reader.string();
                    break;
                case 3:
                    message.batchIndex = reader.int32();
                    break;
                case 4:
                    message.isLast = reader.bool();
                    break;
                case 5:
                    if (!(message.contacts && message.contacts.length))
                        message.contacts = [];
                    message.contacts.push($root.server.Contact.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactList} ContactList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactList message.
         * @function verify
         * @memberof server.ContactList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.syncId != null && message.hasOwnProperty("syncId"))
                if (!$util.isString(message.syncId))
                    return "syncId: string expected";
            if (message.batchIndex != null && message.hasOwnProperty("batchIndex"))
                if (!$util.isInteger(message.batchIndex))
                    return "batchIndex: integer expected";
            if (message.isLast != null && message.hasOwnProperty("isLast"))
                if (typeof message.isLast !== "boolean")
                    return "isLast: boolean expected";
            if (message.contacts != null && message.hasOwnProperty("contacts")) {
                if (!Array.isArray(message.contacts))
                    return "contacts: array expected";
                for (var i = 0; i < message.contacts.length; ++i) {
                    var error = $root.server.Contact.verify(message.contacts[i]);
                    if (error)
                        return "contacts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ContactList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactList} ContactList
         */
        ContactList.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactList)
                return object;
            var message = new $root.server.ContactList();
            switch (object.type) {
            case "FULL":
            case 0:
                message.type = 0;
                break;
            case "DELTA":
            case 1:
                message.type = 1;
                break;
            case "NORMAL":
            case 2:
                message.type = 2;
                break;
            case "FRIEND_NOTICE":
            case 3:
                message.type = 3;
                break;
            case "INVITER_NOTICE":
            case 4:
                message.type = 4;
                break;
            case "DELETE_NOTICE":
            case 5:
                message.type = 5;
                break;
            case "CONTACT_NOTICE":
            case 6:
                message.type = 6;
                break;
            }
            if (object.syncId != null)
                message.syncId = String(object.syncId);
            if (object.batchIndex != null)
                message.batchIndex = object.batchIndex | 0;
            if (object.isLast != null)
                message.isLast = Boolean(object.isLast);
            if (object.contacts) {
                if (!Array.isArray(object.contacts))
                    throw TypeError(".server.ContactList.contacts: array expected");
                message.contacts = [];
                for (var i = 0; i < object.contacts.length; ++i) {
                    if (typeof object.contacts[i] !== "object")
                        throw TypeError(".server.ContactList.contacts: object expected");
                    message.contacts[i] = $root.server.Contact.fromObject(object.contacts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ContactList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactList
         * @static
         * @param {server.ContactList} message ContactList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contacts = [];
            if (options.defaults) {
                object.type = options.enums === String ? "FULL" : 0;
                object.syncId = "";
                object.batchIndex = 0;
                object.isLast = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ContactList.Type[message.type] : message.type;
            if (message.syncId != null && message.hasOwnProperty("syncId"))
                object.syncId = message.syncId;
            if (message.batchIndex != null && message.hasOwnProperty("batchIndex"))
                object.batchIndex = message.batchIndex;
            if (message.isLast != null && message.hasOwnProperty("isLast"))
                object.isLast = message.isLast;
            if (message.contacts && message.contacts.length) {
                object.contacts = [];
                for (var j = 0; j < message.contacts.length; ++j)
                    object.contacts[j] = $root.server.Contact.toObject(message.contacts[j], options);
            }
            return object;
        };

        /**
         * Converts this ContactList to JSON.
         * @function toJSON
         * @memberof server.ContactList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ContactList.Type
         * @enum {number}
         * @property {number} FULL=0 FULL value
         * @property {number} DELTA=1 DELTA value
         * @property {number} NORMAL=2 NORMAL value
         * @property {number} FRIEND_NOTICE=3 FRIEND_NOTICE value
         * @property {number} INVITER_NOTICE=4 INVITER_NOTICE value
         * @property {number} DELETE_NOTICE=5 DELETE_NOTICE value
         * @property {number} CONTACT_NOTICE=6 CONTACT_NOTICE value
         */
        ContactList.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FULL"] = 0;
            values[valuesById[1] = "DELTA"] = 1;
            values[valuesById[2] = "NORMAL"] = 2;
            values[valuesById[3] = "FRIEND_NOTICE"] = 3;
            values[valuesById[4] = "INVITER_NOTICE"] = 4;
            values[valuesById[5] = "DELETE_NOTICE"] = 5;
            values[valuesById[6] = "CONTACT_NOTICE"] = 6;
            return values;
        })();

        return ContactList;
    })();

    server.ContactHash = (function() {

        /**
         * Properties of a ContactHash.
         * @memberof server
         * @interface IContactHash
         * @property {Uint8Array|null} [hash] ContactHash hash
         */

        /**
         * Constructs a new ContactHash.
         * @memberof server
         * @classdesc Represents a ContactHash.
         * @implements IContactHash
         * @constructor
         * @param {server.IContactHash=} [properties] Properties to set
         */
        function ContactHash(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactHash hash.
         * @member {Uint8Array} hash
         * @memberof server.ContactHash
         * @instance
         */
        ContactHash.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new ContactHash instance using the specified properties.
         * @function create
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash=} [properties] Properties to set
         * @returns {server.ContactHash} ContactHash instance
         */
        ContactHash.create = function create(properties) {
            return new ContactHash(properties);
        };

        /**
         * Encodes the specified ContactHash message. Does not implicitly {@link server.ContactHash.verify|verify} messages.
         * @function encode
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash} message ContactHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            return writer;
        };

        /**
         * Encodes the specified ContactHash message, length delimited. Does not implicitly {@link server.ContactHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactHash
         * @static
         * @param {server.IContactHash} message ContactHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactHash message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactHash} ContactHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactHash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactHash();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactHash} ContactHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactHash message.
         * @function verify
         * @memberof server.ContactHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            return null;
        };

        /**
         * Creates a ContactHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactHash} ContactHash
         */
        ContactHash.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactHash)
                return object;
            var message = new $root.server.ContactHash();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            return message;
        };

        /**
         * Creates a plain object from a ContactHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactHash
         * @static
         * @param {server.ContactHash} message ContactHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            return object;
        };

        /**
         * Converts this ContactHash to JSON.
         * @function toJSON
         * @memberof server.ContactHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactHash;
    })();

    server.ContactSyncError = (function() {

        /**
         * Properties of a ContactSyncError.
         * @memberof server
         * @interface IContactSyncError
         * @property {number|null} [retryAfterSecs] ContactSyncError retryAfterSecs
         */

        /**
         * Constructs a new ContactSyncError.
         * @memberof server
         * @classdesc Represents a ContactSyncError.
         * @implements IContactSyncError
         * @constructor
         * @param {server.IContactSyncError=} [properties] Properties to set
         */
        function ContactSyncError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactSyncError retryAfterSecs.
         * @member {number} retryAfterSecs
         * @memberof server.ContactSyncError
         * @instance
         */
        ContactSyncError.prototype.retryAfterSecs = 0;

        /**
         * Creates a new ContactSyncError instance using the specified properties.
         * @function create
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError=} [properties] Properties to set
         * @returns {server.ContactSyncError} ContactSyncError instance
         */
        ContactSyncError.create = function create(properties) {
            return new ContactSyncError(properties);
        };

        /**
         * Encodes the specified ContactSyncError message. Does not implicitly {@link server.ContactSyncError.verify|verify} messages.
         * @function encode
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError} message ContactSyncError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactSyncError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retryAfterSecs != null && Object.hasOwnProperty.call(message, "retryAfterSecs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retryAfterSecs);
            return writer;
        };

        /**
         * Encodes the specified ContactSyncError message, length delimited. Does not implicitly {@link server.ContactSyncError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ContactSyncError
         * @static
         * @param {server.IContactSyncError} message ContactSyncError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactSyncError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactSyncError message from the specified reader or buffer.
         * @function decode
         * @memberof server.ContactSyncError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ContactSyncError} ContactSyncError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactSyncError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ContactSyncError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retryAfterSecs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactSyncError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ContactSyncError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ContactSyncError} ContactSyncError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactSyncError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactSyncError message.
         * @function verify
         * @memberof server.ContactSyncError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactSyncError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (!$util.isInteger(message.retryAfterSecs))
                    return "retryAfterSecs: integer expected";
            return null;
        };

        /**
         * Creates a ContactSyncError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ContactSyncError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ContactSyncError} ContactSyncError
         */
        ContactSyncError.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ContactSyncError)
                return object;
            var message = new $root.server.ContactSyncError();
            if (object.retryAfterSecs != null)
                message.retryAfterSecs = object.retryAfterSecs | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContactSyncError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ContactSyncError
         * @static
         * @param {server.ContactSyncError} message ContactSyncError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactSyncError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.retryAfterSecs = 0;
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                object.retryAfterSecs = message.retryAfterSecs;
            return object;
        };

        /**
         * Converts this ContactSyncError to JSON.
         * @function toJSON
         * @memberof server.ContactSyncError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactSyncError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactSyncError;
    })();

    server.MediaCounters = (function() {

        /**
         * Properties of a MediaCounters.
         * @memberof server
         * @interface IMediaCounters
         * @property {number|null} [numImages] MediaCounters numImages
         * @property {number|null} [numVideos] MediaCounters numVideos
         * @property {number|null} [numAudio] MediaCounters numAudio
         */

        /**
         * Constructs a new MediaCounters.
         * @memberof server
         * @classdesc Represents a MediaCounters.
         * @implements IMediaCounters
         * @constructor
         * @param {server.IMediaCounters=} [properties] Properties to set
         */
        function MediaCounters(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaCounters numImages.
         * @member {number} numImages
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numImages = 0;

        /**
         * MediaCounters numVideos.
         * @member {number} numVideos
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numVideos = 0;

        /**
         * MediaCounters numAudio.
         * @member {number} numAudio
         * @memberof server.MediaCounters
         * @instance
         */
        MediaCounters.prototype.numAudio = 0;

        /**
         * Creates a new MediaCounters instance using the specified properties.
         * @function create
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters=} [properties] Properties to set
         * @returns {server.MediaCounters} MediaCounters instance
         */
        MediaCounters.create = function create(properties) {
            return new MediaCounters(properties);
        };

        /**
         * Encodes the specified MediaCounters message. Does not implicitly {@link server.MediaCounters.verify|verify} messages.
         * @function encode
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters} message MediaCounters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaCounters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numImages != null && Object.hasOwnProperty.call(message, "numImages"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numImages);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numVideos);
            if (message.numAudio != null && Object.hasOwnProperty.call(message, "numAudio"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numAudio);
            return writer;
        };

        /**
         * Encodes the specified MediaCounters message, length delimited. Does not implicitly {@link server.MediaCounters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaCounters
         * @static
         * @param {server.IMediaCounters} message MediaCounters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaCounters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaCounters message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaCounters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaCounters} MediaCounters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaCounters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaCounters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.numImages = reader.int32();
                    break;
                case 2:
                    message.numVideos = reader.int32();
                    break;
                case 3:
                    message.numAudio = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaCounters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaCounters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaCounters} MediaCounters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaCounters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaCounters message.
         * @function verify
         * @memberof server.MediaCounters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaCounters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                if (!$util.isInteger(message.numImages))
                    return "numImages: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.numAudio != null && message.hasOwnProperty("numAudio"))
                if (!$util.isInteger(message.numAudio))
                    return "numAudio: integer expected";
            return null;
        };

        /**
         * Creates a MediaCounters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaCounters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaCounters} MediaCounters
         */
        MediaCounters.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaCounters)
                return object;
            var message = new $root.server.MediaCounters();
            if (object.numImages != null)
                message.numImages = object.numImages | 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos | 0;
            if (object.numAudio != null)
                message.numAudio = object.numAudio | 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaCounters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaCounters
         * @static
         * @param {server.MediaCounters} message MediaCounters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaCounters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numImages = 0;
                object.numVideos = 0;
                object.numAudio = 0;
            }
            if (message.numImages != null && message.hasOwnProperty("numImages"))
                object.numImages = message.numImages;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.numAudio != null && message.hasOwnProperty("numAudio"))
                object.numAudio = message.numAudio;
            return object;
        };

        /**
         * Converts this MediaCounters to JSON.
         * @function toJSON
         * @memberof server.MediaCounters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaCounters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaCounters;
    })();

    server.Audience = (function() {

        /**
         * Properties of an Audience.
         * @memberof server
         * @interface IAudience
         * @property {server.Audience.Type|null} [type] Audience type
         * @property {Array.<number|Long>|null} [uids] Audience uids
         */

        /**
         * Constructs a new Audience.
         * @memberof server
         * @classdesc Represents an Audience.
         * @implements IAudience
         * @constructor
         * @param {server.IAudience=} [properties] Properties to set
         */
        function Audience(properties) {
            this.uids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Audience type.
         * @member {server.Audience.Type} type
         * @memberof server.Audience
         * @instance
         */
        Audience.prototype.type = 0;

        /**
         * Audience uids.
         * @member {Array.<number|Long>} uids
         * @memberof server.Audience
         * @instance
         */
        Audience.prototype.uids = $util.emptyArray;

        /**
         * Creates a new Audience instance using the specified properties.
         * @function create
         * @memberof server.Audience
         * @static
         * @param {server.IAudience=} [properties] Properties to set
         * @returns {server.Audience} Audience instance
         */
        Audience.create = function create(properties) {
            return new Audience(properties);
        };

        /**
         * Encodes the specified Audience message. Does not implicitly {@link server.Audience.verify|verify} messages.
         * @function encode
         * @memberof server.Audience
         * @static
         * @param {server.IAudience} message Audience message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Audience.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.uids != null && message.uids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.uids.length; ++i)
                    writer.int64(message.uids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Audience message, length delimited. Does not implicitly {@link server.Audience.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Audience
         * @static
         * @param {server.IAudience} message Audience message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Audience.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Audience message from the specified reader or buffer.
         * @function decode
         * @memberof server.Audience
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Audience} Audience
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Audience.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Audience();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.uids && message.uids.length))
                        message.uids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uids.push(reader.int64());
                    } else
                        message.uids.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Audience message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Audience
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Audience} Audience
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Audience.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Audience message.
         * @function verify
         * @memberof server.Audience
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Audience.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.uids != null && message.hasOwnProperty("uids")) {
                if (!Array.isArray(message.uids))
                    return "uids: array expected";
                for (var i = 0; i < message.uids.length; ++i)
                    if (!$util.isInteger(message.uids[i]) && !(message.uids[i] && $util.isInteger(message.uids[i].low) && $util.isInteger(message.uids[i].high)))
                        return "uids: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an Audience message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Audience
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Audience} Audience
         */
        Audience.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Audience)
                return object;
            var message = new $root.server.Audience();
            switch (object.type) {
            case "ALL":
            case 0:
                message.type = 0;
                break;
            case "EXCEPT":
            case 1:
                message.type = 1;
                break;
            case "ONLY":
            case 2:
                message.type = 2;
                break;
            }
            if (object.uids) {
                if (!Array.isArray(object.uids))
                    throw TypeError(".server.Audience.uids: array expected");
                message.uids = [];
                for (var i = 0; i < object.uids.length; ++i)
                    if ($util.Long)
                        (message.uids[i] = $util.Long.fromValue(object.uids[i])).unsigned = false;
                    else if (typeof object.uids[i] === "string")
                        message.uids[i] = parseInt(object.uids[i], 10);
                    else if (typeof object.uids[i] === "number")
                        message.uids[i] = object.uids[i];
                    else if (typeof object.uids[i] === "object")
                        message.uids[i] = new $util.LongBits(object.uids[i].low >>> 0, object.uids[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an Audience message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Audience
         * @static
         * @param {server.Audience} message Audience
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Audience.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.uids = [];
            if (options.defaults)
                object.type = options.enums === String ? "ALL" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Audience.Type[message.type] : message.type;
            if (message.uids && message.uids.length) {
                object.uids = [];
                for (var j = 0; j < message.uids.length; ++j)
                    if (typeof message.uids[j] === "number")
                        object.uids[j] = options.longs === String ? String(message.uids[j]) : message.uids[j];
                    else
                        object.uids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uids[j]) : options.longs === Number ? new $util.LongBits(message.uids[j].low >>> 0, message.uids[j].high >>> 0).toNumber() : message.uids[j];
            }
            return object;
        };

        /**
         * Converts this Audience to JSON.
         * @function toJSON
         * @memberof server.Audience
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Audience.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Audience.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} EXCEPT=1 EXCEPT value
         * @property {number} ONLY=2 ONLY value
         */
        Audience.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "EXCEPT"] = 1;
            values[valuesById[2] = "ONLY"] = 2;
            return values;
        })();

        return Audience;
    })();

    server.Post = (function() {

        /**
         * Properties of a Post.
         * @memberof server
         * @interface IPost
         * @property {string|null} [id] Post id
         * @property {number|Long|null} [publisherUid] Post publisherUid
         * @property {Uint8Array|null} [payload] Post payload
         * @property {server.IAudience|null} [audience] Post audience
         * @property {number|Long|null} [timestamp] Post timestamp
         * @property {string|null} [publisherName] Post publisherName
         * @property {Uint8Array|null} [encPayload] Post encPayload
         * @property {server.IMediaCounters|null} [mediaCounters] Post mediaCounters
         */

        /**
         * Constructs a new Post.
         * @memberof server
         * @classdesc Represents a Post.
         * @implements IPost
         * @constructor
         * @param {server.IPost=} [properties] Properties to set
         */
        function Post(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Post id.
         * @member {string} id
         * @memberof server.Post
         * @instance
         */
        Post.prototype.id = "";

        /**
         * Post publisherUid.
         * @member {number|Long} publisherUid
         * @memberof server.Post
         * @instance
         */
        Post.prototype.publisherUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Post payload.
         * @member {Uint8Array} payload
         * @memberof server.Post
         * @instance
         */
        Post.prototype.payload = $util.newBuffer([]);

        /**
         * Post audience.
         * @member {server.IAudience|null|undefined} audience
         * @memberof server.Post
         * @instance
         */
        Post.prototype.audience = null;

        /**
         * Post timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Post
         * @instance
         */
        Post.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Post publisherName.
         * @member {string} publisherName
         * @memberof server.Post
         * @instance
         */
        Post.prototype.publisherName = "";

        /**
         * Post encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.Post
         * @instance
         */
        Post.prototype.encPayload = $util.newBuffer([]);

        /**
         * Post mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.Post
         * @instance
         */
        Post.prototype.mediaCounters = null;

        /**
         * Creates a new Post instance using the specified properties.
         * @function create
         * @memberof server.Post
         * @static
         * @param {server.IPost=} [properties] Properties to set
         * @returns {server.Post} Post instance
         */
        Post.create = function create(properties) {
            return new Post(properties);
        };

        /**
         * Encodes the specified Post message. Does not implicitly {@link server.Post.verify|verify} messages.
         * @function encode
         * @memberof server.Post
         * @static
         * @param {server.IPost} message Post message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Post.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.publisherUid != null && Object.hasOwnProperty.call(message, "publisherUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.publisherUid);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.audience != null && Object.hasOwnProperty.call(message, "audience"))
                $root.server.Audience.encode(message.audience, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
            if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.publisherName);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.encPayload);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Post message, length delimited. Does not implicitly {@link server.Post.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Post
         * @static
         * @param {server.IPost} message Post message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Post.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Post message from the specified reader or buffer.
         * @function decode
         * @memberof server.Post
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Post} Post
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Post.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Post();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.publisherUid = reader.int64();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    message.audience = $root.server.Audience.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.timestamp = reader.int64();
                    break;
                case 6:
                    message.publisherName = reader.string();
                    break;
                case 7:
                    message.encPayload = reader.bytes();
                    break;
                case 8:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Post message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Post
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Post} Post
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Post.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Post message.
         * @function verify
         * @memberof server.Post
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Post.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (!$util.isInteger(message.publisherUid) && !(message.publisherUid && $util.isInteger(message.publisherUid.low) && $util.isInteger(message.publisherUid.high)))
                    return "publisherUid: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.audience != null && message.hasOwnProperty("audience")) {
                var error = $root.server.Audience.verify(message.audience);
                if (error)
                    return "audience." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                if (!$util.isString(message.publisherName))
                    return "publisherName: string expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            return null;
        };

        /**
         * Creates a Post message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Post
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Post} Post
         */
        Post.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Post)
                return object;
            var message = new $root.server.Post();
            if (object.id != null)
                message.id = String(object.id);
            if (object.publisherUid != null)
                if ($util.Long)
                    (message.publisherUid = $util.Long.fromValue(object.publisherUid)).unsigned = false;
                else if (typeof object.publisherUid === "string")
                    message.publisherUid = parseInt(object.publisherUid, 10);
                else if (typeof object.publisherUid === "number")
                    message.publisherUid = object.publisherUid;
                else if (typeof object.publisherUid === "object")
                    message.publisherUid = new $util.LongBits(object.publisherUid.low >>> 0, object.publisherUid.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.audience != null) {
                if (typeof object.audience !== "object")
                    throw TypeError(".server.Post.audience: object expected");
                message.audience = $root.server.Audience.fromObject(object.audience);
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.publisherName != null)
                message.publisherName = String(object.publisherName);
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.Post.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            return message;
        };

        /**
         * Creates a plain object from a Post message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Post
         * @static
         * @param {server.Post} message Post
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Post.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publisherUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publisherUid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.audience = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.publisherName = "";
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.mediaCounters = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (typeof message.publisherUid === "number")
                    object.publisherUid = options.longs === String ? String(message.publisherUid) : message.publisherUid;
                else
                    object.publisherUid = options.longs === String ? $util.Long.prototype.toString.call(message.publisherUid) : options.longs === Number ? new $util.LongBits(message.publisherUid.low >>> 0, message.publisherUid.high >>> 0).toNumber() : message.publisherUid;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.audience != null && message.hasOwnProperty("audience"))
                object.audience = $root.server.Audience.toObject(message.audience, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                object.publisherName = message.publisherName;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            return object;
        };

        /**
         * Converts this Post to JSON.
         * @function toJSON
         * @memberof server.Post
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Post.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Post;
    })();

    server.Comment = (function() {

        /**
         * Properties of a Comment.
         * @memberof server
         * @interface IComment
         * @property {string|null} [id] Comment id
         * @property {string|null} [postId] Comment postId
         * @property {string|null} [parentCommentId] Comment parentCommentId
         * @property {number|Long|null} [publisherUid] Comment publisherUid
         * @property {string|null} [publisherName] Comment publisherName
         * @property {Uint8Array|null} [payload] Comment payload
         * @property {number|Long|null} [timestamp] Comment timestamp
         * @property {Uint8Array|null} [encPayload] Comment encPayload
         * @property {server.IMediaCounters|null} [mediaCounters] Comment mediaCounters
         */

        /**
         * Constructs a new Comment.
         * @memberof server
         * @classdesc Represents a Comment.
         * @implements IComment
         * @constructor
         * @param {server.IComment=} [properties] Properties to set
         */
        function Comment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Comment id.
         * @member {string} id
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.id = "";

        /**
         * Comment postId.
         * @member {string} postId
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.postId = "";

        /**
         * Comment parentCommentId.
         * @member {string} parentCommentId
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.parentCommentId = "";

        /**
         * Comment publisherUid.
         * @member {number|Long} publisherUid
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.publisherUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Comment publisherName.
         * @member {string} publisherName
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.publisherName = "";

        /**
         * Comment payload.
         * @member {Uint8Array} payload
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.payload = $util.newBuffer([]);

        /**
         * Comment timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Comment encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.encPayload = $util.newBuffer([]);

        /**
         * Comment mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.Comment
         * @instance
         */
        Comment.prototype.mediaCounters = null;

        /**
         * Creates a new Comment instance using the specified properties.
         * @function create
         * @memberof server.Comment
         * @static
         * @param {server.IComment=} [properties] Properties to set
         * @returns {server.Comment} Comment instance
         */
        Comment.create = function create(properties) {
            return new Comment(properties);
        };

        /**
         * Encodes the specified Comment message. Does not implicitly {@link server.Comment.verify|verify} messages.
         * @function encode
         * @memberof server.Comment
         * @static
         * @param {server.IComment} message Comment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Comment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.postId != null && Object.hasOwnProperty.call(message, "postId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.postId);
            if (message.parentCommentId != null && Object.hasOwnProperty.call(message, "parentCommentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentCommentId);
            if (message.publisherUid != null && Object.hasOwnProperty.call(message, "publisherUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.publisherUid);
            if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.publisherName);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encPayload);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Comment message, length delimited. Does not implicitly {@link server.Comment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Comment
         * @static
         * @param {server.IComment} message Comment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Comment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Comment message from the specified reader or buffer.
         * @function decode
         * @memberof server.Comment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Comment} Comment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Comment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Comment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.postId = reader.string();
                    break;
                case 3:
                    message.parentCommentId = reader.string();
                    break;
                case 4:
                    message.publisherUid = reader.int64();
                    break;
                case 5:
                    message.publisherName = reader.string();
                    break;
                case 6:
                    message.payload = reader.bytes();
                    break;
                case 7:
                    message.timestamp = reader.int64();
                    break;
                case 8:
                    message.encPayload = reader.bytes();
                    break;
                case 9:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Comment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Comment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Comment} Comment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Comment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Comment message.
         * @function verify
         * @memberof server.Comment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Comment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.postId != null && message.hasOwnProperty("postId"))
                if (!$util.isString(message.postId))
                    return "postId: string expected";
            if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
                if (!$util.isString(message.parentCommentId))
                    return "parentCommentId: string expected";
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (!$util.isInteger(message.publisherUid) && !(message.publisherUid && $util.isInteger(message.publisherUid.low) && $util.isInteger(message.publisherUid.high)))
                    return "publisherUid: integer|Long expected";
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                if (!$util.isString(message.publisherName))
                    return "publisherName: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            return null;
        };

        /**
         * Creates a Comment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Comment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Comment} Comment
         */
        Comment.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Comment)
                return object;
            var message = new $root.server.Comment();
            if (object.id != null)
                message.id = String(object.id);
            if (object.postId != null)
                message.postId = String(object.postId);
            if (object.parentCommentId != null)
                message.parentCommentId = String(object.parentCommentId);
            if (object.publisherUid != null)
                if ($util.Long)
                    (message.publisherUid = $util.Long.fromValue(object.publisherUid)).unsigned = false;
                else if (typeof object.publisherUid === "string")
                    message.publisherUid = parseInt(object.publisherUid, 10);
                else if (typeof object.publisherUid === "number")
                    message.publisherUid = object.publisherUid;
                else if (typeof object.publisherUid === "object")
                    message.publisherUid = new $util.LongBits(object.publisherUid.low >>> 0, object.publisherUid.high >>> 0).toNumber();
            if (object.publisherName != null)
                message.publisherName = String(object.publisherName);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.Comment.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            return message;
        };

        /**
         * Creates a plain object from a Comment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Comment
         * @static
         * @param {server.Comment} message Comment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Comment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.postId = "";
                object.parentCommentId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publisherUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.publisherUid = options.longs === String ? "0" : 0;
                object.publisherName = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.mediaCounters = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.postId != null && message.hasOwnProperty("postId"))
                object.postId = message.postId;
            if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
                object.parentCommentId = message.parentCommentId;
            if (message.publisherUid != null && message.hasOwnProperty("publisherUid"))
                if (typeof message.publisherUid === "number")
                    object.publisherUid = options.longs === String ? String(message.publisherUid) : message.publisherUid;
                else
                    object.publisherUid = options.longs === String ? $util.Long.prototype.toString.call(message.publisherUid) : options.longs === Number ? new $util.LongBits(message.publisherUid.low >>> 0, message.publisherUid.high >>> 0).toNumber() : message.publisherUid;
            if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                object.publisherName = message.publisherName;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            return object;
        };

        /**
         * Converts this Comment to JSON.
         * @function toJSON
         * @memberof server.Comment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Comment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Comment;
    })();

    server.ShareStanza = (function() {

        /**
         * Properties of a ShareStanza.
         * @memberof server
         * @interface IShareStanza
         * @property {number|Long|null} [uid] ShareStanza uid
         * @property {Array.<string>|null} [postIds] ShareStanza postIds
         * @property {string|null} [result] ShareStanza result
         * @property {string|null} [reason] ShareStanza reason
         */

        /**
         * Constructs a new ShareStanza.
         * @memberof server
         * @classdesc Represents a ShareStanza.
         * @implements IShareStanza
         * @constructor
         * @param {server.IShareStanza=} [properties] Properties to set
         */
        function ShareStanza(properties) {
            this.postIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareStanza uid.
         * @member {number|Long} uid
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ShareStanza postIds.
         * @member {Array.<string>} postIds
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.postIds = $util.emptyArray;

        /**
         * ShareStanza result.
         * @member {string} result
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.result = "";

        /**
         * ShareStanza reason.
         * @member {string} reason
         * @memberof server.ShareStanza
         * @instance
         */
        ShareStanza.prototype.reason = "";

        /**
         * Creates a new ShareStanza instance using the specified properties.
         * @function create
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza=} [properties] Properties to set
         * @returns {server.ShareStanza} ShareStanza instance
         */
        ShareStanza.create = function create(properties) {
            return new ShareStanza(properties);
        };

        /**
         * Encodes the specified ShareStanza message. Does not implicitly {@link server.ShareStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza} message ShareStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.postIds != null && message.postIds.length)
                for (var i = 0; i < message.postIds.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.postIds[i]);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ShareStanza message, length delimited. Does not implicitly {@link server.ShareStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ShareStanza
         * @static
         * @param {server.IShareStanza} message ShareStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ShareStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ShareStanza} ShareStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ShareStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    if (!(message.postIds && message.postIds.length))
                        message.postIds = [];
                    message.postIds.push(reader.string());
                    break;
                case 3:
                    message.result = reader.string();
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShareStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ShareStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ShareStanza} ShareStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareStanza message.
         * @function verify
         * @memberof server.ShareStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.postIds != null && message.hasOwnProperty("postIds")) {
                if (!Array.isArray(message.postIds))
                    return "postIds: array expected";
                for (var i = 0; i < message.postIds.length; ++i)
                    if (!$util.isString(message.postIds[i]))
                        return "postIds: string[] expected";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ShareStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ShareStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ShareStanza} ShareStanza
         */
        ShareStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ShareStanza)
                return object;
            var message = new $root.server.ShareStanza();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.postIds) {
                if (!Array.isArray(object.postIds))
                    throw TypeError(".server.ShareStanza.postIds: array expected");
                message.postIds = [];
                for (var i = 0; i < object.postIds.length; ++i)
                    message.postIds[i] = String(object.postIds[i]);
            }
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ShareStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ShareStanza
         * @static
         * @param {server.ShareStanza} message ShareStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShareStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.postIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.result = "";
                object.reason = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.postIds && message.postIds.length) {
                object.postIds = [];
                for (var j = 0; j < message.postIds.length; ++j)
                    object.postIds[j] = message.postIds[j];
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ShareStanza to JSON.
         * @function toJSON
         * @memberof server.ShareStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShareStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShareStanza;
    })();

    server.FeedItem = (function() {

        /**
         * Properties of a FeedItem.
         * @memberof server
         * @interface IFeedItem
         * @property {server.FeedItem.Action|null} [action] FeedItem action
         * @property {server.IPost|null} [post] FeedItem post
         * @property {server.IComment|null} [comment] FeedItem comment
         * @property {Array.<server.IShareStanza>|null} [shareStanzas] FeedItem shareStanzas
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] FeedItem senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] FeedItem senderState
         */

        /**
         * Constructs a new FeedItem.
         * @memberof server
         * @classdesc Represents a FeedItem.
         * @implements IFeedItem
         * @constructor
         * @param {server.IFeedItem=} [properties] Properties to set
         */
        function FeedItem(properties) {
            this.shareStanzas = [];
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedItem action.
         * @member {server.FeedItem.Action} action
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.action = 0;

        /**
         * FeedItem post.
         * @member {server.IPost|null|undefined} post
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.post = null;

        /**
         * FeedItem comment.
         * @member {server.IComment|null|undefined} comment
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.comment = null;

        /**
         * FeedItem shareStanzas.
         * @member {Array.<server.IShareStanza>} shareStanzas
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.shareStanzas = $util.emptyArray;

        /**
         * FeedItem senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.senderStateBundles = $util.emptyArray;

        /**
         * FeedItem senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.FeedItem
         * @instance
         */
        FeedItem.prototype.senderState = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * FeedItem item.
         * @member {"post"|"comment"|undefined} item
         * @memberof server.FeedItem
         * @instance
         */
        Object.defineProperty(FeedItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["post", "comment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FeedItem instance using the specified properties.
         * @function create
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem=} [properties] Properties to set
         * @returns {server.FeedItem} FeedItem instance
         */
        FeedItem.create = function create(properties) {
            return new FeedItem(properties);
        };

        /**
         * Encodes the specified FeedItem message. Does not implicitly {@link server.FeedItem.verify|verify} messages.
         * @function encode
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem} message FeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                $root.server.Post.encode(message.post, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                $root.server.Comment.encode(message.comment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.shareStanzas != null && message.shareStanzas.length)
                for (var i = 0; i < message.shareStanzas.length; ++i)
                    $root.server.ShareStanza.encode(message.shareStanzas[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedItem message, length delimited. Does not implicitly {@link server.FeedItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FeedItem
         * @static
         * @param {server.IFeedItem} message FeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedItem message from the specified reader or buffer.
         * @function decode
         * @memberof server.FeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FeedItem} FeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FeedItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.post = $root.server.Post.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.comment = $root.server.Comment.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.shareStanzas && message.shareStanzas.length))
                        message.shareStanzas = [];
                    message.shareStanzas.push($root.server.ShareStanza.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FeedItem} FeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedItem message.
         * @function verify
         * @memberof server.FeedItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.post != null && message.hasOwnProperty("post")) {
                properties.item = 1;
                {
                    var error = $root.server.Post.verify(message.post);
                    if (error)
                        return "post." + error;
                }
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    var error = $root.server.Comment.verify(message.comment);
                    if (error)
                        return "comment." + error;
                }
            }
            if (message.shareStanzas != null && message.hasOwnProperty("shareStanzas")) {
                if (!Array.isArray(message.shareStanzas))
                    return "shareStanzas: array expected";
                for (var i = 0; i < message.shareStanzas.length; ++i) {
                    var error = $root.server.ShareStanza.verify(message.shareStanzas[i]);
                    if (error)
                        return "shareStanzas." + error;
                }
            }
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            return null;
        };

        /**
         * Creates a FeedItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FeedItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FeedItem} FeedItem
         */
        FeedItem.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FeedItem)
                return object;
            var message = new $root.server.FeedItem();
            switch (object.action) {
            case "PUBLISH":
            case 0:
                message.action = 0;
                break;
            case "RETRACT":
            case 1:
                message.action = 1;
                break;
            case "SHARE":
            case 2:
                message.action = 2;
                break;
            }
            if (object.post != null) {
                if (typeof object.post !== "object")
                    throw TypeError(".server.FeedItem.post: object expected");
                message.post = $root.server.Post.fromObject(object.post);
            }
            if (object.comment != null) {
                if (typeof object.comment !== "object")
                    throw TypeError(".server.FeedItem.comment: object expected");
                message.comment = $root.server.Comment.fromObject(object.comment);
            }
            if (object.shareStanzas) {
                if (!Array.isArray(object.shareStanzas))
                    throw TypeError(".server.FeedItem.shareStanzas: array expected");
                message.shareStanzas = [];
                for (var i = 0; i < object.shareStanzas.length; ++i) {
                    if (typeof object.shareStanzas[i] !== "object")
                        throw TypeError(".server.FeedItem.shareStanzas: object expected");
                    message.shareStanzas[i] = $root.server.ShareStanza.fromObject(object.shareStanzas[i]);
                }
            }
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.FeedItem.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.FeedItem.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.FeedItem.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FeedItem
         * @static
         * @param {server.FeedItem} message FeedItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.shareStanzas = [];
                object.senderStateBundles = [];
            }
            if (options.defaults) {
                object.action = options.enums === String ? "PUBLISH" : 0;
                object.senderState = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.FeedItem.Action[message.action] : message.action;
            if (message.post != null && message.hasOwnProperty("post")) {
                object.post = $root.server.Post.toObject(message.post, options);
                if (options.oneofs)
                    object.item = "post";
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                object.comment = $root.server.Comment.toObject(message.comment, options);
                if (options.oneofs)
                    object.item = "comment";
            }
            if (message.shareStanzas && message.shareStanzas.length) {
                object.shareStanzas = [];
                for (var j = 0; j < message.shareStanzas.length; ++j)
                    object.shareStanzas[j] = $root.server.ShareStanza.toObject(message.shareStanzas[j], options);
            }
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            return object;
        };

        /**
         * Converts this FeedItem to JSON.
         * @function toJSON
         * @memberof server.FeedItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.FeedItem.Action
         * @enum {number}
         * @property {number} PUBLISH=0 PUBLISH value
         * @property {number} RETRACT=1 RETRACT value
         * @property {number} SHARE=2 SHARE value
         */
        FeedItem.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUBLISH"] = 0;
            values[valuesById[1] = "RETRACT"] = 1;
            values[valuesById[2] = "SHARE"] = 2;
            return values;
        })();

        return FeedItem;
    })();

    server.FeedItems = (function() {

        /**
         * Properties of a FeedItems.
         * @memberof server
         * @interface IFeedItems
         * @property {number|Long|null} [uid] FeedItems uid
         * @property {Array.<server.IFeedItem>|null} [items] FeedItems items
         */

        /**
         * Constructs a new FeedItems.
         * @memberof server
         * @classdesc Represents a FeedItems.
         * @implements IFeedItems
         * @constructor
         * @param {server.IFeedItems=} [properties] Properties to set
         */
        function FeedItems(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedItems uid.
         * @member {number|Long} uid
         * @memberof server.FeedItems
         * @instance
         */
        FeedItems.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeedItems items.
         * @member {Array.<server.IFeedItem>} items
         * @memberof server.FeedItems
         * @instance
         */
        FeedItems.prototype.items = $util.emptyArray;

        /**
         * Creates a new FeedItems instance using the specified properties.
         * @function create
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems=} [properties] Properties to set
         * @returns {server.FeedItems} FeedItems instance
         */
        FeedItems.create = function create(properties) {
            return new FeedItems(properties);
        };

        /**
         * Encodes the specified FeedItems message. Does not implicitly {@link server.FeedItems.verify|verify} messages.
         * @function encode
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems} message FeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.FeedItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedItems message, length delimited. Does not implicitly {@link server.FeedItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FeedItems
         * @static
         * @param {server.IFeedItems} message FeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedItems message from the specified reader or buffer.
         * @function decode
         * @memberof server.FeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FeedItems} FeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FeedItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.FeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FeedItems} FeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedItems message.
         * @function verify
         * @memberof server.FeedItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.FeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FeedItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FeedItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FeedItems} FeedItems
         */
        FeedItems.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FeedItems)
                return object;
            var message = new $root.server.FeedItems();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.FeedItems.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.FeedItems.items: object expected");
                    message.items[i] = $root.server.FeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FeedItems
         * @static
         * @param {server.FeedItems} message FeedItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.FeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this FeedItems to JSON.
         * @function toJSON
         * @memberof server.FeedItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeedItems;
    })();

    server.SenderStateWithKeyInfo = (function() {

        /**
         * Properties of a SenderStateWithKeyInfo.
         * @memberof server
         * @interface ISenderStateWithKeyInfo
         * @property {Uint8Array|null} [publicKey] SenderStateWithKeyInfo publicKey
         * @property {number|Long|null} [oneTimePreKeyId] SenderStateWithKeyInfo oneTimePreKeyId
         * @property {Uint8Array|null} [encSenderState] SenderStateWithKeyInfo encSenderState
         */

        /**
         * Constructs a new SenderStateWithKeyInfo.
         * @memberof server
         * @classdesc Represents a SenderStateWithKeyInfo.
         * @implements ISenderStateWithKeyInfo
         * @constructor
         * @param {server.ISenderStateWithKeyInfo=} [properties] Properties to set
         */
        function SenderStateWithKeyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderStateWithKeyInfo publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.publicKey = $util.newBuffer([]);

        /**
         * SenderStateWithKeyInfo oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SenderStateWithKeyInfo encSenderState.
         * @member {Uint8Array} encSenderState
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         */
        SenderStateWithKeyInfo.prototype.encSenderState = $util.newBuffer([]);

        /**
         * Creates a new SenderStateWithKeyInfo instance using the specified properties.
         * @function create
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo=} [properties] Properties to set
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo instance
         */
        SenderStateWithKeyInfo.create = function create(properties) {
            return new SenderStateWithKeyInfo(properties);
        };

        /**
         * Encodes the specified SenderStateWithKeyInfo message. Does not implicitly {@link server.SenderStateWithKeyInfo.verify|verify} messages.
         * @function encode
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo} message SenderStateWithKeyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateWithKeyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.oneTimePreKeyId);
            if (message.encSenderState != null && Object.hasOwnProperty.call(message, "encSenderState"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encSenderState);
            return writer;
        };

        /**
         * Encodes the specified SenderStateWithKeyInfo message, length delimited. Does not implicitly {@link server.SenderStateWithKeyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.ISenderStateWithKeyInfo} message SenderStateWithKeyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateWithKeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderStateWithKeyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateWithKeyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SenderStateWithKeyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 3:
                    message.encSenderState = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderStateWithKeyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateWithKeyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderStateWithKeyInfo message.
         * @function verify
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderStateWithKeyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.encSenderState != null && message.hasOwnProperty("encSenderState"))
                if (!(message.encSenderState && typeof message.encSenderState.length === "number" || $util.isString(message.encSenderState)))
                    return "encSenderState: buffer expected";
            return null;
        };

        /**
         * Creates a SenderStateWithKeyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SenderStateWithKeyInfo} SenderStateWithKeyInfo
         */
        SenderStateWithKeyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SenderStateWithKeyInfo)
                return object;
            var message = new $root.server.SenderStateWithKeyInfo();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.encSenderState != null)
                if (typeof object.encSenderState === "string")
                    $util.base64.decode(object.encSenderState, message.encSenderState = $util.newBuffer($util.base64.length(object.encSenderState)), 0);
                else if (object.encSenderState.length)
                    message.encSenderState = object.encSenderState;
            return message;
        };

        /**
         * Creates a plain object from a SenderStateWithKeyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SenderStateWithKeyInfo
         * @static
         * @param {server.SenderStateWithKeyInfo} message SenderStateWithKeyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderStateWithKeyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encSenderState = "";
                else {
                    object.encSenderState = [];
                    if (options.bytes !== Array)
                        object.encSenderState = $util.newBuffer(object.encSenderState);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.encSenderState != null && message.hasOwnProperty("encSenderState"))
                object.encSenderState = options.bytes === String ? $util.base64.encode(message.encSenderState, 0, message.encSenderState.length) : options.bytes === Array ? Array.prototype.slice.call(message.encSenderState) : message.encSenderState;
            return object;
        };

        /**
         * Converts this SenderStateWithKeyInfo to JSON.
         * @function toJSON
         * @memberof server.SenderStateWithKeyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderStateWithKeyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderStateWithKeyInfo;
    })();

    server.SenderStateBundle = (function() {

        /**
         * Properties of a SenderStateBundle.
         * @memberof server
         * @interface ISenderStateBundle
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] SenderStateBundle senderState
         * @property {number|Long|null} [uid] SenderStateBundle uid
         */

        /**
         * Constructs a new SenderStateBundle.
         * @memberof server
         * @classdesc Represents a SenderStateBundle.
         * @implements ISenderStateBundle
         * @constructor
         * @param {server.ISenderStateBundle=} [properties] Properties to set
         */
        function SenderStateBundle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderStateBundle senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.SenderStateBundle
         * @instance
         */
        SenderStateBundle.prototype.senderState = null;

        /**
         * SenderStateBundle uid.
         * @member {number|Long} uid
         * @memberof server.SenderStateBundle
         * @instance
         */
        SenderStateBundle.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SenderStateBundle instance using the specified properties.
         * @function create
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle=} [properties] Properties to set
         * @returns {server.SenderStateBundle} SenderStateBundle instance
         */
        SenderStateBundle.create = function create(properties) {
            return new SenderStateBundle(properties);
        };

        /**
         * Encodes the specified SenderStateBundle message. Does not implicitly {@link server.SenderStateBundle.verify|verify} messages.
         * @function encode
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle} message SenderStateBundle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateBundle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified SenderStateBundle message, length delimited. Does not implicitly {@link server.SenderStateBundle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.ISenderStateBundle} message SenderStateBundle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderStateBundle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderStateBundle message from the specified reader or buffer.
         * @function decode
         * @memberof server.SenderStateBundle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SenderStateBundle} SenderStateBundle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateBundle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SenderStateBundle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderStateBundle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SenderStateBundle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SenderStateBundle} SenderStateBundle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderStateBundle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderStateBundle message.
         * @function verify
         * @memberof server.SenderStateBundle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderStateBundle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates a SenderStateBundle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SenderStateBundle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SenderStateBundle} SenderStateBundle
         */
        SenderStateBundle.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SenderStateBundle)
                return object;
            var message = new $root.server.SenderStateBundle();
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.SenderStateBundle.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SenderStateBundle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SenderStateBundle
         * @static
         * @param {server.SenderStateBundle} message SenderStateBundle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderStateBundle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.senderState = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this SenderStateBundle to JSON.
         * @function toJSON
         * @memberof server.SenderStateBundle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderStateBundle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderStateBundle;
    })();

    server.GroupFeedItem = (function() {

        /**
         * Properties of a GroupFeedItem.
         * @memberof server
         * @interface IGroupFeedItem
         * @property {server.GroupFeedItem.Action|null} [action] GroupFeedItem action
         * @property {string|null} [gid] GroupFeedItem gid
         * @property {string|null} [name] GroupFeedItem name
         * @property {string|null} [avatarId] GroupFeedItem avatarId
         * @property {server.IPost|null} [post] GroupFeedItem post
         * @property {server.IComment|null} [comment] GroupFeedItem comment
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] GroupFeedItem senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] GroupFeedItem senderState
         * @property {Uint8Array|null} [audienceHash] GroupFeedItem audienceHash
         * @property {boolean|null} [isResentHistory] GroupFeedItem isResentHistory
         * @property {string|null} [senderLogInfo] GroupFeedItem senderLogInfo
         * @property {string|null} [senderClientVersion] GroupFeedItem senderClientVersion
         */

        /**
         * Constructs a new GroupFeedItem.
         * @memberof server
         * @classdesc Represents a GroupFeedItem.
         * @implements IGroupFeedItem
         * @constructor
         * @param {server.IGroupFeedItem=} [properties] Properties to set
         */
        function GroupFeedItem(properties) {
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedItem action.
         * @member {server.GroupFeedItem.Action} action
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.action = 0;

        /**
         * GroupFeedItem gid.
         * @member {string} gid
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.gid = "";

        /**
         * GroupFeedItem name.
         * @member {string} name
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.name = "";

        /**
         * GroupFeedItem avatarId.
         * @member {string} avatarId
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.avatarId = "";

        /**
         * GroupFeedItem post.
         * @member {server.IPost|null|undefined} post
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.post = null;

        /**
         * GroupFeedItem comment.
         * @member {server.IComment|null|undefined} comment
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.comment = null;

        /**
         * GroupFeedItem senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderStateBundles = $util.emptyArray;

        /**
         * GroupFeedItem senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderState = null;

        /**
         * GroupFeedItem audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.audienceHash = $util.newBuffer([]);

        /**
         * GroupFeedItem isResentHistory.
         * @member {boolean} isResentHistory
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.isResentHistory = false;

        /**
         * GroupFeedItem senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderLogInfo = "";

        /**
         * GroupFeedItem senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.GroupFeedItem
         * @instance
         */
        GroupFeedItem.prototype.senderClientVersion = "";

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GroupFeedItem item.
         * @member {"post"|"comment"|undefined} item
         * @memberof server.GroupFeedItem
         * @instance
         */
        Object.defineProperty(GroupFeedItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["post", "comment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GroupFeedItem instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem=} [properties] Properties to set
         * @returns {server.GroupFeedItem} GroupFeedItem instance
         */
        GroupFeedItem.create = function create(properties) {
            return new GroupFeedItem(properties);
        };

        /**
         * Encodes the specified GroupFeedItem message. Does not implicitly {@link server.GroupFeedItem.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem} message GroupFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                $root.server.Post.encode(message.post, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                $root.server.Comment.encode(message.comment, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.audienceHash);
            if (message.isResentHistory != null && Object.hasOwnProperty.call(message, "isResentHistory"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isResentHistory);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedItem message, length delimited. Does not implicitly {@link server.GroupFeedItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.IGroupFeedItem} message GroupFeedItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedItem message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedItem} GroupFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.post = $root.server.Post.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.comment = $root.server.Comment.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.audienceHash = reader.bytes();
                    break;
                case 10:
                    message.isResentHistory = reader.bool();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedItem} GroupFeedItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedItem message.
         * @function verify
         * @memberof server.GroupFeedItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.post != null && message.hasOwnProperty("post")) {
                properties.item = 1;
                {
                    var error = $root.server.Post.verify(message.post);
                    if (error)
                        return "post." + error;
                }
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    var error = $root.server.Comment.verify(message.comment);
                    if (error)
                        return "comment." + error;
                }
            }
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.isResentHistory != null && message.hasOwnProperty("isResentHistory"))
                if (typeof message.isResentHistory !== "boolean")
                    return "isResentHistory: boolean expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a GroupFeedItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedItem} GroupFeedItem
         */
        GroupFeedItem.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedItem)
                return object;
            var message = new $root.server.GroupFeedItem();
            switch (object.action) {
            case "PUBLISH":
            case 0:
                message.action = 0;
                break;
            case "RETRACT":
            case 1:
                message.action = 1;
                break;
            case "SHARE":
            case 2:
                message.action = 2;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.post != null) {
                if (typeof object.post !== "object")
                    throw TypeError(".server.GroupFeedItem.post: object expected");
                message.post = $root.server.Post.fromObject(object.post);
            }
            if (object.comment != null) {
                if (typeof object.comment !== "object")
                    throw TypeError(".server.GroupFeedItem.comment: object expected");
                message.comment = $root.server.Comment.fromObject(object.comment);
            }
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.GroupFeedItem.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.GroupFeedItem.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.GroupFeedItem.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.isResentHistory != null)
                message.isResentHistory = Boolean(object.isResentHistory);
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedItem
         * @static
         * @param {server.GroupFeedItem} message GroupFeedItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderStateBundles = [];
            if (options.defaults) {
                object.action = options.enums === String ? "PUBLISH" : 0;
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                object.senderState = null;
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.isResentHistory = false;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupFeedItem.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.post != null && message.hasOwnProperty("post")) {
                object.post = $root.server.Post.toObject(message.post, options);
                if (options.oneofs)
                    object.item = "post";
            }
            if (message.comment != null && message.hasOwnProperty("comment")) {
                object.comment = $root.server.Comment.toObject(message.comment, options);
                if (options.oneofs)
                    object.item = "comment";
            }
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.isResentHistory != null && message.hasOwnProperty("isResentHistory"))
                object.isResentHistory = message.isResentHistory;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this GroupFeedItem to JSON.
         * @function toJSON
         * @memberof server.GroupFeedItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupFeedItem.Action
         * @enum {number}
         * @property {number} PUBLISH=0 PUBLISH value
         * @property {number} RETRACT=1 RETRACT value
         * @property {number} SHARE=2 SHARE value
         */
        GroupFeedItem.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUBLISH"] = 0;
            values[valuesById[1] = "RETRACT"] = 1;
            values[valuesById[2] = "SHARE"] = 2;
            return values;
        })();

        return GroupFeedItem;
    })();

    server.GroupFeedItems = (function() {

        /**
         * Properties of a GroupFeedItems.
         * @memberof server
         * @interface IGroupFeedItems
         * @property {string|null} [gid] GroupFeedItems gid
         * @property {string|null} [name] GroupFeedItems name
         * @property {string|null} [avatarId] GroupFeedItems avatarId
         * @property {Array.<server.IGroupFeedItem>|null} [items] GroupFeedItems items
         */

        /**
         * Constructs a new GroupFeedItems.
         * @memberof server
         * @classdesc Represents a GroupFeedItems.
         * @implements IGroupFeedItems
         * @constructor
         * @param {server.IGroupFeedItems=} [properties] Properties to set
         */
        function GroupFeedItems(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedItems gid.
         * @member {string} gid
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.gid = "";

        /**
         * GroupFeedItems name.
         * @member {string} name
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.name = "";

        /**
         * GroupFeedItems avatarId.
         * @member {string} avatarId
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.avatarId = "";

        /**
         * GroupFeedItems items.
         * @member {Array.<server.IGroupFeedItem>} items
         * @memberof server.GroupFeedItems
         * @instance
         */
        GroupFeedItems.prototype.items = $util.emptyArray;

        /**
         * Creates a new GroupFeedItems instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems=} [properties] Properties to set
         * @returns {server.GroupFeedItems} GroupFeedItems instance
         */
        GroupFeedItems.create = function create(properties) {
            return new GroupFeedItems(properties);
        };

        /**
         * Encodes the specified GroupFeedItems message. Does not implicitly {@link server.GroupFeedItems.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems} message GroupFeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItems.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.server.GroupFeedItem.encode(message.items[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupFeedItems message, length delimited. Does not implicitly {@link server.GroupFeedItems.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.IGroupFeedItems} message GroupFeedItems message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedItems.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedItems message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedItems} GroupFeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItems.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedItems();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                case 4:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.server.GroupFeedItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedItems message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedItems
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedItems} GroupFeedItems
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedItems.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedItems message.
         * @function verify
         * @memberof server.GroupFeedItems
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedItems.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.server.GroupFeedItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupFeedItems message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedItems
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedItems} GroupFeedItems
         */
        GroupFeedItems.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedItems)
                return object;
            var message = new $root.server.GroupFeedItems();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".server.GroupFeedItems.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".server.GroupFeedItems.items: object expected");
                    message.items[i] = $root.server.GroupFeedItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedItems message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedItems
         * @static
         * @param {server.GroupFeedItems} message GroupFeedItems
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedItems.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.gid = "";
                object.name = "";
                object.avatarId = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.server.GroupFeedItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupFeedItems to JSON.
         * @function toJSON
         * @memberof server.GroupFeedItems
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedItems.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupFeedItems;
    })();

    server.GroupFeedHistory = (function() {

        /**
         * Properties of a GroupFeedHistory.
         * @memberof server
         * @interface IGroupFeedHistory
         * @property {string|null} [gid] GroupFeedHistory gid
         * @property {string|null} [id] GroupFeedHistory id
         * @property {Uint8Array|null} [payload] GroupFeedHistory payload
         * @property {Uint8Array|null} [encPayload] GroupFeedHistory encPayload
         * @property {Uint8Array|null} [publicKey] GroupFeedHistory publicKey
         * @property {number|null} [oneTimePreKeyId] GroupFeedHistory oneTimePreKeyId
         * @property {string|null} [senderLogInfo] GroupFeedHistory senderLogInfo
         * @property {string|null} [senderClientVersion] GroupFeedHistory senderClientVersion
         */

        /**
         * Constructs a new GroupFeedHistory.
         * @memberof server
         * @classdesc Represents a GroupFeedHistory.
         * @implements IGroupFeedHistory
         * @constructor
         * @param {server.IGroupFeedHistory=} [properties] Properties to set
         */
        function GroupFeedHistory(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedHistory gid.
         * @member {string} gid
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.gid = "";

        /**
         * GroupFeedHistory id.
         * @member {string} id
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.id = "";

        /**
         * GroupFeedHistory payload.
         * @member {Uint8Array} payload
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.payload = $util.newBuffer([]);

        /**
         * GroupFeedHistory encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.encPayload = $util.newBuffer([]);

        /**
         * GroupFeedHistory publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.publicKey = $util.newBuffer([]);

        /**
         * GroupFeedHistory oneTimePreKeyId.
         * @member {number} oneTimePreKeyId
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.oneTimePreKeyId = 0;

        /**
         * GroupFeedHistory senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.senderLogInfo = "";

        /**
         * GroupFeedHistory senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.GroupFeedHistory
         * @instance
         */
        GroupFeedHistory.prototype.senderClientVersion = "";

        /**
         * Creates a new GroupFeedHistory instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory=} [properties] Properties to set
         * @returns {server.GroupFeedHistory} GroupFeedHistory instance
         */
        GroupFeedHistory.create = function create(properties) {
            return new GroupFeedHistory(properties);
        };

        /**
         * Encodes the specified GroupFeedHistory message. Does not implicitly {@link server.GroupFeedHistory.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory} message GroupFeedHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedHistory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.oneTimePreKeyId);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedHistory message, length delimited. Does not implicitly {@link server.GroupFeedHistory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.IGroupFeedHistory} message GroupFeedHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedHistory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedHistory message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedHistory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedHistory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                case 4:
                    message.encPayload = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                case 6:
                    message.oneTimePreKeyId = reader.int32();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedHistory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedHistory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedHistory message.
         * @function verify
         * @memberof server.GroupFeedHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedHistory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId))
                    return "oneTimePreKeyId: integer expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a GroupFeedHistory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedHistory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedHistory} GroupFeedHistory
         */
        GroupFeedHistory.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedHistory)
                return object;
            var message = new $root.server.GroupFeedHistory();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                message.oneTimePreKeyId = object.oneTimePreKeyId | 0;
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedHistory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedHistory
         * @static
         * @param {server.GroupFeedHistory} message GroupFeedHistory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedHistory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.oneTimePreKeyId = 0;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                object.oneTimePreKeyId = message.oneTimePreKeyId;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this GroupFeedHistory to JSON.
         * @function toJSON
         * @memberof server.GroupFeedHistory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedHistory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupFeedHistory;
    })();

    server.GroupMember = (function() {

        /**
         * Properties of a GroupMember.
         * @memberof server
         * @interface IGroupMember
         * @property {server.GroupMember.Action|null} [action] GroupMember action
         * @property {number|Long|null} [uid] GroupMember uid
         * @property {server.GroupMember.Type|null} [type] GroupMember type
         * @property {string|null} [name] GroupMember name
         * @property {string|null} [avatarId] GroupMember avatarId
         * @property {string|null} [result] GroupMember result
         * @property {string|null} [reason] GroupMember reason
         * @property {Uint8Array|null} [identityKey] GroupMember identityKey
         */

        /**
         * Constructs a new GroupMember.
         * @memberof server
         * @classdesc Represents a GroupMember.
         * @implements IGroupMember
         * @constructor
         * @param {server.IGroupMember=} [properties] Properties to set
         */
        function GroupMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupMember action.
         * @member {server.GroupMember.Action} action
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.action = 0;

        /**
         * GroupMember uid.
         * @member {number|Long} uid
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupMember type.
         * @member {server.GroupMember.Type} type
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.type = 0;

        /**
         * GroupMember name.
         * @member {string} name
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.name = "";

        /**
         * GroupMember avatarId.
         * @member {string} avatarId
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.avatarId = "";

        /**
         * GroupMember result.
         * @member {string} result
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.result = "";

        /**
         * GroupMember reason.
         * @member {string} reason
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.reason = "";

        /**
         * GroupMember identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.GroupMember
         * @instance
         */
        GroupMember.prototype.identityKey = $util.newBuffer([]);

        /**
         * Creates a new GroupMember instance using the specified properties.
         * @function create
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember=} [properties] Properties to set
         * @returns {server.GroupMember} GroupMember instance
         */
        GroupMember.create = function create(properties) {
            return new GroupMember(properties);
        };

        /**
         * Encodes the specified GroupMember message. Does not implicitly {@link server.GroupMember.verify|verify} messages.
         * @function encode
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.reason);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.identityKey);
            return writer;
        };

        /**
         * Encodes the specified GroupMember message, length delimited. Does not implicitly {@link server.GroupMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupMember
         * @static
         * @param {server.IGroupMember} message GroupMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                case 6:
                    message.result = reader.string();
                    break;
                case 7:
                    message.reason = reader.string();
                    break;
                case 8:
                    message.identityKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupMember} GroupMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupMember message.
         * @function verify
         * @memberof server.GroupMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            return null;
        };

        /**
         * Creates a GroupMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupMember} GroupMember
         */
        GroupMember.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupMember)
                return object;
            var message = new $root.server.GroupMember();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "REMOVE":
            case 1:
                message.action = 1;
                break;
            case "PROMOTE":
            case 2:
                message.action = 2;
                break;
            case "DEMOTE":
            case 3:
                message.action = 3;
                break;
            case "LEAVE":
            case 4:
                message.action = 4;
                break;
            case "JOIN":
            case 5:
                message.action = 5;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            switch (object.type) {
            case "MEMBER":
            case 0:
                message.type = 0;
                break;
            case "ADMIN":
            case 1:
                message.type = 1;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            return message;
        };

        /**
         * Creates a plain object from a GroupMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupMember
         * @static
         * @param {server.GroupMember} message GroupMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "MEMBER" : 0;
                object.name = "";
                object.avatarId = "";
                object.result = "";
                object.reason = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupMember.Action[message.action] : message.action;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.GroupMember.Type[message.type] : message.type;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            return object;
        };

        /**
         * Converts this GroupMember to JSON.
         * @function toJSON
         * @memberof server.GroupMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupMember.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} REMOVE=1 REMOVE value
         * @property {number} PROMOTE=2 PROMOTE value
         * @property {number} DEMOTE=3 DEMOTE value
         * @property {number} LEAVE=4 LEAVE value
         * @property {number} JOIN=5 JOIN value
         */
        GroupMember.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "REMOVE"] = 1;
            values[valuesById[2] = "PROMOTE"] = 2;
            values[valuesById[3] = "DEMOTE"] = 3;
            values[valuesById[4] = "LEAVE"] = 4;
            values[valuesById[5] = "JOIN"] = 5;
            return values;
        })();

        /**
         * Type enum.
         * @name server.GroupMember.Type
         * @enum {number}
         * @property {number} MEMBER=0 MEMBER value
         * @property {number} ADMIN=1 ADMIN value
         */
        GroupMember.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MEMBER"] = 0;
            values[valuesById[1] = "ADMIN"] = 1;
            return values;
        })();

        return GroupMember;
    })();

    server.GroupStanza = (function() {

        /**
         * Properties of a GroupStanza.
         * @memberof server
         * @interface IGroupStanza
         * @property {server.GroupStanza.Action|null} [action] GroupStanza action
         * @property {string|null} [gid] GroupStanza gid
         * @property {string|null} [name] GroupStanza name
         * @property {string|null} [avatarId] GroupStanza avatarId
         * @property {number|Long|null} [senderUid] GroupStanza senderUid
         * @property {string|null} [senderName] GroupStanza senderName
         * @property {Array.<server.IGroupMember>|null} [members] GroupStanza members
         * @property {string|null} [background] GroupStanza background
         * @property {Uint8Array|null} [audienceHash] GroupStanza audienceHash
         * @property {string|null} [description] GroupStanza description
         * @property {server.IHistoryResend|null} [historyResend] GroupStanza historyResend
         */

        /**
         * Constructs a new GroupStanza.
         * @memberof server
         * @classdesc Represents a GroupStanza.
         * @implements IGroupStanza
         * @constructor
         * @param {server.IGroupStanza=} [properties] Properties to set
         */
        function GroupStanza(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupStanza action.
         * @member {server.GroupStanza.Action} action
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.action = 0;

        /**
         * GroupStanza gid.
         * @member {string} gid
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.gid = "";

        /**
         * GroupStanza name.
         * @member {string} name
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.name = "";

        /**
         * GroupStanza avatarId.
         * @member {string} avatarId
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.avatarId = "";

        /**
         * GroupStanza senderUid.
         * @member {number|Long} senderUid
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.senderUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupStanza senderName.
         * @member {string} senderName
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.senderName = "";

        /**
         * GroupStanza members.
         * @member {Array.<server.IGroupMember>} members
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.members = $util.emptyArray;

        /**
         * GroupStanza background.
         * @member {string} background
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.background = "";

        /**
         * GroupStanza audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.audienceHash = $util.newBuffer([]);

        /**
         * GroupStanza description.
         * @member {string} description
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.description = "";

        /**
         * GroupStanza historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.GroupStanza
         * @instance
         */
        GroupStanza.prototype.historyResend = null;

        /**
         * Creates a new GroupStanza instance using the specified properties.
         * @function create
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza=} [properties] Properties to set
         * @returns {server.GroupStanza} GroupStanza instance
         */
        GroupStanza.create = function create(properties) {
            return new GroupStanza(properties);
        };

        /**
         * Encodes the specified GroupStanza message. Does not implicitly {@link server.GroupStanza.verify|verify} messages.
         * @function encode
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza} message GroupStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarId);
            if (message.senderUid != null && Object.hasOwnProperty.call(message, "senderUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.senderUid);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderName);
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.server.GroupMember.encode(message.members[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.background);
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.audienceHash);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.description);
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupStanza message, length delimited. Does not implicitly {@link server.GroupStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupStanza
         * @static
         * @param {server.IGroupStanza} message GroupStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupStanza} GroupStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.avatarId = reader.string();
                    break;
                case 5:
                    message.senderUid = reader.int64();
                    break;
                case 6:
                    message.senderName = reader.string();
                    break;
                case 7:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.server.GroupMember.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.background = reader.string();
                    break;
                case 9:
                    message.audienceHash = reader.bytes();
                    break;
                case 10:
                    message.description = reader.string();
                    break;
                case 11:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupStanza} GroupStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupStanza message.
         * @function verify
         * @memberof server.GroupStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (!$util.isInteger(message.senderUid) && !(message.senderUid && $util.isInteger(message.senderUid.low) && $util.isInteger(message.senderUid.high)))
                    return "senderUid: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.server.GroupMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            if (message.background != null && message.hasOwnProperty("background"))
                if (!$util.isString(message.background))
                    return "background: string expected";
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                var error = $root.server.HistoryResend.verify(message.historyResend);
                if (error)
                    return "historyResend." + error;
            }
            return null;
        };

        /**
         * Creates a GroupStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupStanza} GroupStanza
         */
        GroupStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupStanza)
                return object;
            var message = new $root.server.GroupStanza();
            switch (object.action) {
            case "SET":
            case 0:
                message.action = 0;
                break;
            case "GET":
            case 1:
                message.action = 1;
                break;
            case "CREATE":
            case 2:
                message.action = 2;
                break;
            case "DELETE":
            case 3:
                message.action = 3;
                break;
            case "LEAVE":
            case 4:
                message.action = 4;
                break;
            case "CHANGE_AVATAR":
            case 5:
                message.action = 5;
                break;
            case "CHANGE_NAME":
            case 6:
                message.action = 6;
                break;
            case "MODIFY_ADMINS":
            case 7:
                message.action = 7;
                break;
            case "MODIFY_MEMBERS":
            case 8:
                message.action = 8;
                break;
            case "AUTO_PROMOTE_ADMINS":
            case 9:
                message.action = 9;
                break;
            case "SET_NAME":
            case 10:
                message.action = 10;
                break;
            case "JOIN":
            case 11:
                message.action = 11;
                break;
            case "PREVIEW":
            case 12:
                message.action = 12;
                break;
            case "SET_BACKGROUND":
            case 13:
                message.action = 13;
                break;
            case "GET_MEMBER_IDENTITY_KEYS":
            case 14:
                message.action = 14;
                break;
            case "CHANGE_DESCRIPTION":
            case 15:
                message.action = 15;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.senderUid != null)
                if ($util.Long)
                    (message.senderUid = $util.Long.fromValue(object.senderUid)).unsigned = false;
                else if (typeof object.senderUid === "string")
                    message.senderUid = parseInt(object.senderUid, 10);
                else if (typeof object.senderUid === "number")
                    message.senderUid = object.senderUid;
                else if (typeof object.senderUid === "object")
                    message.senderUid = new $util.LongBits(object.senderUid.low >>> 0, object.senderUid.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".server.GroupStanza.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".server.GroupStanza.members: object expected");
                    message.members[i] = $root.server.GroupMember.fromObject(object.members[i]);
                }
            }
            if (object.background != null)
                message.background = String(object.background);
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.description != null)
                message.description = String(object.description);
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.GroupStanza.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupStanza
         * @static
         * @param {server.GroupStanza} message GroupStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (options.defaults) {
                object.action = options.enums === String ? "SET" : 0;
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderUid = options.longs === String ? "0" : 0;
                object.senderName = "";
                object.background = "";
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.description = "";
                object.historyResend = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupStanza.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (typeof message.senderUid === "number")
                    object.senderUid = options.longs === String ? String(message.senderUid) : message.senderUid;
                else
                    object.senderUid = options.longs === String ? $util.Long.prototype.toString.call(message.senderUid) : options.longs === Number ? new $util.LongBits(message.senderUid.low >>> 0, message.senderUid.high >>> 0).toNumber() : message.senderUid;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.server.GroupMember.toObject(message.members[j], options);
            }
            if (message.background != null && message.hasOwnProperty("background"))
                object.background = message.background;
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.historyResend != null && message.hasOwnProperty("historyResend"))
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
            return object;
        };

        /**
         * Converts this GroupStanza to JSON.
         * @function toJSON
         * @memberof server.GroupStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupStanza.Action
         * @enum {number}
         * @property {number} SET=0 SET value
         * @property {number} GET=1 GET value
         * @property {number} CREATE=2 CREATE value
         * @property {number} DELETE=3 DELETE value
         * @property {number} LEAVE=4 LEAVE value
         * @property {number} CHANGE_AVATAR=5 CHANGE_AVATAR value
         * @property {number} CHANGE_NAME=6 CHANGE_NAME value
         * @property {number} MODIFY_ADMINS=7 MODIFY_ADMINS value
         * @property {number} MODIFY_MEMBERS=8 MODIFY_MEMBERS value
         * @property {number} AUTO_PROMOTE_ADMINS=9 AUTO_PROMOTE_ADMINS value
         * @property {number} SET_NAME=10 SET_NAME value
         * @property {number} JOIN=11 JOIN value
         * @property {number} PREVIEW=12 PREVIEW value
         * @property {number} SET_BACKGROUND=13 SET_BACKGROUND value
         * @property {number} GET_MEMBER_IDENTITY_KEYS=14 GET_MEMBER_IDENTITY_KEYS value
         * @property {number} CHANGE_DESCRIPTION=15 CHANGE_DESCRIPTION value
         */
        GroupStanza.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SET"] = 0;
            values[valuesById[1] = "GET"] = 1;
            values[valuesById[2] = "CREATE"] = 2;
            values[valuesById[3] = "DELETE"] = 3;
            values[valuesById[4] = "LEAVE"] = 4;
            values[valuesById[5] = "CHANGE_AVATAR"] = 5;
            values[valuesById[6] = "CHANGE_NAME"] = 6;
            values[valuesById[7] = "MODIFY_ADMINS"] = 7;
            values[valuesById[8] = "MODIFY_MEMBERS"] = 8;
            values[valuesById[9] = "AUTO_PROMOTE_ADMINS"] = 9;
            values[valuesById[10] = "SET_NAME"] = 10;
            values[valuesById[11] = "JOIN"] = 11;
            values[valuesById[12] = "PREVIEW"] = 12;
            values[valuesById[13] = "SET_BACKGROUND"] = 13;
            values[valuesById[14] = "GET_MEMBER_IDENTITY_KEYS"] = 14;
            values[valuesById[15] = "CHANGE_DESCRIPTION"] = 15;
            return values;
        })();

        return GroupStanza;
    })();

    server.GroupChat = (function() {

        /**
         * Properties of a GroupChat.
         * @memberof server
         * @interface IGroupChat
         * @property {string|null} [gid] GroupChat gid
         * @property {string|null} [name] GroupChat name
         * @property {string|null} [avatarId] GroupChat avatarId
         * @property {number|Long|null} [senderUid] GroupChat senderUid
         * @property {string|null} [senderName] GroupChat senderName
         * @property {number|Long|null} [timestamp] GroupChat timestamp
         * @property {Uint8Array|null} [payload] GroupChat payload
         */

        /**
         * Constructs a new GroupChat.
         * @memberof server
         * @classdesc Represents a GroupChat.
         * @implements IGroupChat
         * @constructor
         * @param {server.IGroupChat=} [properties] Properties to set
         */
        function GroupChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChat gid.
         * @member {string} gid
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.gid = "";

        /**
         * GroupChat name.
         * @member {string} name
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.name = "";

        /**
         * GroupChat avatarId.
         * @member {string} avatarId
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.avatarId = "";

        /**
         * GroupChat senderUid.
         * @member {number|Long} senderUid
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.senderUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupChat senderName.
         * @member {string} senderName
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.senderName = "";

        /**
         * GroupChat timestamp.
         * @member {number|Long} timestamp
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupChat payload.
         * @member {Uint8Array} payload
         * @memberof server.GroupChat
         * @instance
         */
        GroupChat.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new GroupChat instance using the specified properties.
         * @function create
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat=} [properties] Properties to set
         * @returns {server.GroupChat} GroupChat instance
         */
        GroupChat.create = function create(properties) {
            return new GroupChat(properties);
        };

        /**
         * Encodes the specified GroupChat message. Does not implicitly {@link server.GroupChat.verify|verify} messages.
         * @function encode
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat} message GroupChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarId);
            if (message.senderUid != null && Object.hasOwnProperty.call(message, "senderUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.senderUid);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.senderName);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified GroupChat message, length delimited. Does not implicitly {@link server.GroupChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupChat
         * @static
         * @param {server.IGroupChat} message GroupChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChat message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupChat} GroupChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.avatarId = reader.string();
                    break;
                case 4:
                    message.senderUid = reader.int64();
                    break;
                case 5:
                    message.senderName = reader.string();
                    break;
                case 6:
                    message.timestamp = reader.int64();
                    break;
                case 7:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupChat} GroupChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupChat message.
         * @function verify
         * @memberof server.GroupChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (!$util.isInteger(message.senderUid) && !(message.senderUid && $util.isInteger(message.senderUid.low) && $util.isInteger(message.senderUid.high)))
                    return "senderUid: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a GroupChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupChat} GroupChat
         */
        GroupChat.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupChat)
                return object;
            var message = new $root.server.GroupChat();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            if (object.senderUid != null)
                if ($util.Long)
                    (message.senderUid = $util.Long.fromValue(object.senderUid)).unsigned = false;
                else if (typeof object.senderUid === "string")
                    message.senderUid = parseInt(object.senderUid, 10);
                else if (typeof object.senderUid === "number")
                    message.senderUid = object.senderUid;
                else if (typeof object.senderUid === "object")
                    message.senderUid = new $util.LongBits(object.senderUid.low >>> 0, object.senderUid.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a GroupChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupChat
         * @static
         * @param {server.GroupChat} message GroupChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.name = "";
                object.avatarId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.senderUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.senderUid = options.longs === String ? "0" : 0;
                object.senderName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                if (typeof message.senderUid === "number")
                    object.senderUid = options.longs === String ? String(message.senderUid) : message.senderUid;
                else
                    object.senderUid = options.longs === String ? $util.Long.prototype.toString.call(message.senderUid) : options.longs === Number ? new $util.LongBits(message.senderUid.low >>> 0, message.senderUid.high >>> 0).toNumber() : message.senderUid;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this GroupChat to JSON.
         * @function toJSON
         * @memberof server.GroupChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupChat;
    })();

    server.GroupsStanza = (function() {

        /**
         * Properties of a GroupsStanza.
         * @memberof server
         * @interface IGroupsStanza
         * @property {server.GroupsStanza.Action|null} [action] GroupsStanza action
         * @property {Array.<server.IGroupStanza>|null} [groupStanzas] GroupsStanza groupStanzas
         */

        /**
         * Constructs a new GroupsStanza.
         * @memberof server
         * @classdesc Represents a GroupsStanza.
         * @implements IGroupsStanza
         * @constructor
         * @param {server.IGroupsStanza=} [properties] Properties to set
         */
        function GroupsStanza(properties) {
            this.groupStanzas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupsStanza action.
         * @member {server.GroupsStanza.Action} action
         * @memberof server.GroupsStanza
         * @instance
         */
        GroupsStanza.prototype.action = 0;

        /**
         * GroupsStanza groupStanzas.
         * @member {Array.<server.IGroupStanza>} groupStanzas
         * @memberof server.GroupsStanza
         * @instance
         */
        GroupsStanza.prototype.groupStanzas = $util.emptyArray;

        /**
         * Creates a new GroupsStanza instance using the specified properties.
         * @function create
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza=} [properties] Properties to set
         * @returns {server.GroupsStanza} GroupsStanza instance
         */
        GroupsStanza.create = function create(properties) {
            return new GroupsStanza(properties);
        };

        /**
         * Encodes the specified GroupsStanza message. Does not implicitly {@link server.GroupsStanza.verify|verify} messages.
         * @function encode
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza} message GroupsStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupsStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.groupStanzas != null && message.groupStanzas.length)
                for (var i = 0; i < message.groupStanzas.length; ++i)
                    $root.server.GroupStanza.encode(message.groupStanzas[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupsStanza message, length delimited. Does not implicitly {@link server.GroupsStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupsStanza
         * @static
         * @param {server.IGroupsStanza} message GroupsStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupsStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupsStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupsStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupsStanza} GroupsStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupsStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupsStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    if (!(message.groupStanzas && message.groupStanzas.length))
                        message.groupStanzas = [];
                    message.groupStanzas.push($root.server.GroupStanza.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupsStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupsStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupsStanza} GroupsStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupsStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupsStanza message.
         * @function verify
         * @memberof server.GroupsStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupsStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                    break;
                }
            if (message.groupStanzas != null && message.hasOwnProperty("groupStanzas")) {
                if (!Array.isArray(message.groupStanzas))
                    return "groupStanzas: array expected";
                for (var i = 0; i < message.groupStanzas.length; ++i) {
                    var error = $root.server.GroupStanza.verify(message.groupStanzas[i]);
                    if (error)
                        return "groupStanzas." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GroupsStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupsStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupsStanza} GroupsStanza
         */
        GroupsStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupsStanza)
                return object;
            var message = new $root.server.GroupsStanza();
            switch (object.action) {
            case "GET":
            case 0:
                message.action = 0;
                break;
            }
            if (object.groupStanzas) {
                if (!Array.isArray(object.groupStanzas))
                    throw TypeError(".server.GroupsStanza.groupStanzas: array expected");
                message.groupStanzas = [];
                for (var i = 0; i < object.groupStanzas.length; ++i) {
                    if (typeof object.groupStanzas[i] !== "object")
                        throw TypeError(".server.GroupsStanza.groupStanzas: object expected");
                    message.groupStanzas[i] = $root.server.GroupStanza.fromObject(object.groupStanzas[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupsStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupsStanza
         * @static
         * @param {server.GroupsStanza} message GroupsStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupsStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groupStanzas = [];
            if (options.defaults)
                object.action = options.enums === String ? "GET" : 0;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupsStanza.Action[message.action] : message.action;
            if (message.groupStanzas && message.groupStanzas.length) {
                object.groupStanzas = [];
                for (var j = 0; j < message.groupStanzas.length; ++j)
                    object.groupStanzas[j] = $root.server.GroupStanza.toObject(message.groupStanzas[j], options);
            }
            return object;
        };

        /**
         * Converts this GroupsStanza to JSON.
         * @function toJSON
         * @memberof server.GroupsStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupsStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupsStanza.Action
         * @enum {number}
         * @property {number} GET=0 GET value
         */
        GroupsStanza.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            return values;
        })();

        return GroupsStanza;
    })();

    server.GroupInviteLink = (function() {

        /**
         * Properties of a GroupInviteLink.
         * @memberof server
         * @interface IGroupInviteLink
         * @property {server.GroupInviteLink.Action|null} [action] GroupInviteLink action
         * @property {string|null} [gid] GroupInviteLink gid
         * @property {string|null} [link] GroupInviteLink link
         * @property {string|null} [result] GroupInviteLink result
         * @property {string|null} [reason] GroupInviteLink reason
         * @property {server.IGroupStanza|null} [group] GroupInviteLink group
         */

        /**
         * Constructs a new GroupInviteLink.
         * @memberof server
         * @classdesc Represents a GroupInviteLink.
         * @implements IGroupInviteLink
         * @constructor
         * @param {server.IGroupInviteLink=} [properties] Properties to set
         */
        function GroupInviteLink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInviteLink action.
         * @member {server.GroupInviteLink.Action} action
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.action = 0;

        /**
         * GroupInviteLink gid.
         * @member {string} gid
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.gid = "";

        /**
         * GroupInviteLink link.
         * @member {string} link
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.link = "";

        /**
         * GroupInviteLink result.
         * @member {string} result
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.result = "";

        /**
         * GroupInviteLink reason.
         * @member {string} reason
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.reason = "";

        /**
         * GroupInviteLink group.
         * @member {server.IGroupStanza|null|undefined} group
         * @memberof server.GroupInviteLink
         * @instance
         */
        GroupInviteLink.prototype.group = null;

        /**
         * Creates a new GroupInviteLink instance using the specified properties.
         * @function create
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink=} [properties] Properties to set
         * @returns {server.GroupInviteLink} GroupInviteLink instance
         */
        GroupInviteLink.create = function create(properties) {
            return new GroupInviteLink(properties);
        };

        /**
         * Encodes the specified GroupInviteLink message. Does not implicitly {@link server.GroupInviteLink.verify|verify} messages.
         * @function encode
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            if (message.link != null && Object.hasOwnProperty.call(message, "link"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.link);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.reason);
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                $root.server.GroupStanza.encode(message.group, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupInviteLink message, length delimited. Does not implicitly {@link server.GroupInviteLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.IGroupInviteLink} message GroupInviteLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupInviteLink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                case 3:
                    message.link = reader.string();
                    break;
                case 4:
                    message.result = reader.string();
                    break;
                case 5:
                    message.reason = reader.string();
                    break;
                case 6:
                    message.group = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInviteLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupInviteLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupInviteLink} GroupInviteLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInviteLink message.
         * @function verify
         * @memberof server.GroupInviteLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInviteLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.link != null && message.hasOwnProperty("link"))
                if (!$util.isString(message.link))
                    return "link: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.group != null && message.hasOwnProperty("group")) {
                var error = $root.server.GroupStanza.verify(message.group);
                if (error)
                    return "group." + error;
            }
            return null;
        };

        /**
         * Creates a GroupInviteLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupInviteLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupInviteLink} GroupInviteLink
         */
        GroupInviteLink.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupInviteLink)
                return object;
            var message = new $root.server.GroupInviteLink();
            switch (object.action) {
            case "UNKNOWN":
            case 0:
                message.action = 0;
                break;
            case "GET":
            case 1:
                message.action = 1;
                break;
            case "RESET":
            case 2:
                message.action = 2;
                break;
            case "JOIN":
            case 3:
                message.action = 3;
                break;
            case "PREVIEW":
            case 4:
                message.action = 4;
                break;
            }
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.link != null)
                message.link = String(object.link);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".server.GroupInviteLink.group: object expected");
                message.group = $root.server.GroupStanza.fromObject(object.group);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInviteLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupInviteLink
         * @static
         * @param {server.GroupInviteLink} message GroupInviteLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInviteLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "UNKNOWN" : 0;
                object.gid = "";
                object.link = "";
                object.result = "";
                object.reason = "";
                object.group = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.GroupInviteLink.Action[message.action] : message.action;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.link != null && message.hasOwnProperty("link"))
                object.link = message.link;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.server.GroupStanza.toObject(message.group, options);
            return object;
        };

        /**
         * Converts this GroupInviteLink to JSON.
         * @function toJSON
         * @memberof server.GroupInviteLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInviteLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.GroupInviteLink.Action
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} GET=1 GET value
         * @property {number} RESET=2 RESET value
         * @property {number} JOIN=3 JOIN value
         * @property {number} PREVIEW=4 PREVIEW value
         */
        GroupInviteLink.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "GET"] = 1;
            values[valuesById[2] = "RESET"] = 2;
            values[valuesById[3] = "JOIN"] = 3;
            values[valuesById[4] = "PREVIEW"] = 4;
            return values;
        })();

        return GroupInviteLink;
    })();

    server.AuthRequest = (function() {

        /**
         * Properties of an AuthRequest.
         * @memberof server
         * @interface IAuthRequest
         * @property {number|Long|null} [uid] AuthRequest uid
         * @property {string|null} [pwd] AuthRequest pwd
         * @property {server.IClientMode|null} [clientMode] AuthRequest clientMode
         * @property {server.IClientVersion|null} [clientVersion] AuthRequest clientVersion
         * @property {string|null} [resource] AuthRequest resource
         * @property {server.IDeviceInfo|null} [deviceInfo] AuthRequest deviceInfo
         */

        /**
         * Constructs a new AuthRequest.
         * @memberof server
         * @classdesc Represents an AuthRequest.
         * @implements IAuthRequest
         * @constructor
         * @param {server.IAuthRequest=} [properties] Properties to set
         */
        function AuthRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRequest uid.
         * @member {number|Long} uid
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AuthRequest pwd.
         * @member {string} pwd
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.pwd = "";

        /**
         * AuthRequest clientMode.
         * @member {server.IClientMode|null|undefined} clientMode
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientMode = null;

        /**
         * AuthRequest clientVersion.
         * @member {server.IClientVersion|null|undefined} clientVersion
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientVersion = null;

        /**
         * AuthRequest resource.
         * @member {string} resource
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.resource = "";

        /**
         * AuthRequest deviceInfo.
         * @member {server.IDeviceInfo|null|undefined} deviceInfo
         * @memberof server.AuthRequest
         * @instance
         */
        AuthRequest.prototype.deviceInfo = null;

        /**
         * Creates a new AuthRequest instance using the specified properties.
         * @function create
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest=} [properties] Properties to set
         * @returns {server.AuthRequest} AuthRequest instance
         */
        AuthRequest.create = function create(properties) {
            return new AuthRequest(properties);
        };

        /**
         * Encodes the specified AuthRequest message. Does not implicitly {@link server.AuthRequest.verify|verify} messages.
         * @function encode
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.pwd != null && Object.hasOwnProperty.call(message, "pwd"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwd);
            if (message.clientMode != null && Object.hasOwnProperty.call(message, "clientMode"))
                $root.server.ClientMode.encode(message.clientMode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
                $root.server.ClientVersion.encode(message.clientVersion, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.resource);
            if (message.deviceInfo != null && Object.hasOwnProperty.call(message, "deviceInfo"))
                $root.server.DeviceInfo.encode(message.deviceInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AuthRequest message, length delimited. Does not implicitly {@link server.AuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AuthRequest
         * @static
         * @param {server.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AuthRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.pwd = reader.string();
                    break;
                case 3:
                    message.clientMode = $root.server.ClientMode.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clientVersion = $root.server.ClientVersion.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.resource = reader.string();
                    break;
                case 6:
                    message.deviceInfo = $root.server.DeviceInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRequest message.
         * @function verify
         * @memberof server.AuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                if (!$util.isString(message.pwd))
                    return "pwd: string expected";
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                var error = $root.server.ClientMode.verify(message.clientMode);
                if (error)
                    return "clientMode." + error;
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                var error = $root.server.ClientVersion.verify(message.clientVersion);
                if (error)
                    return "clientVersion." + error;
            }
            if (message.resource != null && message.hasOwnProperty("resource"))
                if (!$util.isString(message.resource))
                    return "resource: string expected";
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo")) {
                var error = $root.server.DeviceInfo.verify(message.deviceInfo);
                if (error)
                    return "deviceInfo." + error;
            }
            return null;
        };

        /**
         * Creates an AuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AuthRequest} AuthRequest
         */
        AuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AuthRequest)
                return object;
            var message = new $root.server.AuthRequest();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.pwd != null)
                message.pwd = String(object.pwd);
            if (object.clientMode != null) {
                if (typeof object.clientMode !== "object")
                    throw TypeError(".server.AuthRequest.clientMode: object expected");
                message.clientMode = $root.server.ClientMode.fromObject(object.clientMode);
            }
            if (object.clientVersion != null) {
                if (typeof object.clientVersion !== "object")
                    throw TypeError(".server.AuthRequest.clientVersion: object expected");
                message.clientVersion = $root.server.ClientVersion.fromObject(object.clientVersion);
            }
            if (object.resource != null)
                message.resource = String(object.resource);
            if (object.deviceInfo != null) {
                if (typeof object.deviceInfo !== "object")
                    throw TypeError(".server.AuthRequest.deviceInfo: object expected");
                message.deviceInfo = $root.server.DeviceInfo.fromObject(object.deviceInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an AuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AuthRequest
         * @static
         * @param {server.AuthRequest} message AuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.pwd = "";
                object.clientMode = null;
                object.clientVersion = null;
                object.resource = "";
                object.deviceInfo = null;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.pwd != null && message.hasOwnProperty("pwd"))
                object.pwd = message.pwd;
            if (message.clientMode != null && message.hasOwnProperty("clientMode"))
                object.clientMode = $root.server.ClientMode.toObject(message.clientMode, options);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = $root.server.ClientVersion.toObject(message.clientVersion, options);
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = message.resource;
            if (message.deviceInfo != null && message.hasOwnProperty("deviceInfo"))
                object.deviceInfo = $root.server.DeviceInfo.toObject(message.deviceInfo, options);
            return object;
        };

        /**
         * Converts this AuthRequest to JSON.
         * @function toJSON
         * @memberof server.AuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthRequest;
    })();

    server.AuthResult = (function() {

        /**
         * Properties of an AuthResult.
         * @memberof server
         * @interface IAuthResult
         * @property {string|null} [resultString] AuthResult resultString
         * @property {string|null} [reasonString] AuthResult reasonString
         * @property {Uint8Array|null} [propsHash] AuthResult propsHash
         * @property {number|Long|null} [versionTtl] AuthResult versionTtl
         * @property {server.AuthResult.Result|null} [result] AuthResult result
         * @property {server.AuthResult.Reason|null} [reason] AuthResult reason
         */

        /**
         * Constructs a new AuthResult.
         * @memberof server
         * @classdesc Represents an AuthResult.
         * @implements IAuthResult
         * @constructor
         * @param {server.IAuthResult=} [properties] Properties to set
         */
        function AuthResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthResult resultString.
         * @member {string} resultString
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.resultString = "";

        /**
         * AuthResult reasonString.
         * @member {string} reasonString
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.reasonString = "";

        /**
         * AuthResult propsHash.
         * @member {Uint8Array} propsHash
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.propsHash = $util.newBuffer([]);

        /**
         * AuthResult versionTtl.
         * @member {number|Long} versionTtl
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.versionTtl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AuthResult result.
         * @member {server.AuthResult.Result} result
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.result = 0;

        /**
         * AuthResult reason.
         * @member {server.AuthResult.Reason} reason
         * @memberof server.AuthResult
         * @instance
         */
        AuthResult.prototype.reason = 0;

        /**
         * Creates a new AuthResult instance using the specified properties.
         * @function create
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult=} [properties] Properties to set
         * @returns {server.AuthResult} AuthResult instance
         */
        AuthResult.create = function create(properties) {
            return new AuthResult(properties);
        };

        /**
         * Encodes the specified AuthResult message. Does not implicitly {@link server.AuthResult.verify|verify} messages.
         * @function encode
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult} message AuthResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultString != null && Object.hasOwnProperty.call(message, "resultString"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.resultString);
            if (message.reasonString != null && Object.hasOwnProperty.call(message, "reasonString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reasonString);
            if (message.propsHash != null && Object.hasOwnProperty.call(message, "propsHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.propsHash);
            if (message.versionTtl != null && Object.hasOwnProperty.call(message, "versionTtl"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.versionTtl);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified AuthResult message, length delimited. Does not implicitly {@link server.AuthResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AuthResult
         * @static
         * @param {server.IAuthResult} message AuthResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.AuthResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AuthResult} AuthResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AuthResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resultString = reader.string();
                    break;
                case 2:
                    message.reasonString = reader.string();
                    break;
                case 3:
                    message.propsHash = reader.bytes();
                    break;
                case 4:
                    message.versionTtl = reader.int64();
                    break;
                case 5:
                    message.result = reader.int32();
                    break;
                case 6:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AuthResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AuthResult} AuthResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthResult message.
         * @function verify
         * @memberof server.AuthResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultString != null && message.hasOwnProperty("resultString"))
                if (!$util.isString(message.resultString))
                    return "resultString: string expected";
            if (message.reasonString != null && message.hasOwnProperty("reasonString"))
                if (!$util.isString(message.reasonString))
                    return "reasonString: string expected";
            if (message.propsHash != null && message.hasOwnProperty("propsHash"))
                if (!(message.propsHash && typeof message.propsHash.length === "number" || $util.isString(message.propsHash)))
                    return "propsHash: buffer expected";
            if (message.versionTtl != null && message.hasOwnProperty("versionTtl"))
                if (!$util.isInteger(message.versionTtl) && !(message.versionTtl && $util.isInteger(message.versionTtl.low) && $util.isInteger(message.versionTtl.high)))
                    return "versionTtl: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates an AuthResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AuthResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AuthResult} AuthResult
         */
        AuthResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AuthResult)
                return object;
            var message = new $root.server.AuthResult();
            if (object.resultString != null)
                message.resultString = String(object.resultString);
            if (object.reasonString != null)
                message.reasonString = String(object.reasonString);
            if (object.propsHash != null)
                if (typeof object.propsHash === "string")
                    $util.base64.decode(object.propsHash, message.propsHash = $util.newBuffer($util.base64.length(object.propsHash)), 0);
                else if (object.propsHash.length)
                    message.propsHash = object.propsHash;
            if (object.versionTtl != null)
                if ($util.Long)
                    (message.versionTtl = $util.Long.fromValue(object.versionTtl)).unsigned = false;
                else if (typeof object.versionTtl === "string")
                    message.versionTtl = parseInt(object.versionTtl, 10);
                else if (typeof object.versionTtl === "number")
                    message.versionTtl = object.versionTtl;
                else if (typeof object.versionTtl === "object")
                    message.versionTtl = new $util.LongBits(object.versionTtl.low >>> 0, object.versionTtl.high >>> 0).toNumber();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "OK":
            case 1:
                message.reason = 1;
                break;
            case "SPUB_MISMATCH":
            case 2:
                message.reason = 2;
                break;
            case "INVALID_CLIENT_VERSION":
            case 3:
                message.reason = 3;
                break;
            case "INVALID_RESOURCE":
            case 4:
                message.reason = 4;
                break;
            case "ACCOUNT_DELETED":
            case 5:
                message.reason = 5;
                break;
            case "INVALID_UID_OR_PASSWORD":
            case 6:
                message.reason = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AuthResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AuthResult
         * @static
         * @param {server.AuthResult} message AuthResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.resultString = "";
                object.reasonString = "";
                if (options.bytes === String)
                    object.propsHash = "";
                else {
                    object.propsHash = [];
                    if (options.bytes !== Array)
                        object.propsHash = $util.newBuffer(object.propsHash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.versionTtl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.versionTtl = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "UNKNOWN" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.resultString != null && message.hasOwnProperty("resultString"))
                object.resultString = message.resultString;
            if (message.reasonString != null && message.hasOwnProperty("reasonString"))
                object.reasonString = message.reasonString;
            if (message.propsHash != null && message.hasOwnProperty("propsHash"))
                object.propsHash = options.bytes === String ? $util.base64.encode(message.propsHash, 0, message.propsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.propsHash) : message.propsHash;
            if (message.versionTtl != null && message.hasOwnProperty("versionTtl"))
                if (typeof message.versionTtl === "number")
                    object.versionTtl = options.longs === String ? String(message.versionTtl) : message.versionTtl;
                else
                    object.versionTtl = options.longs === String ? $util.Long.prototype.toString.call(message.versionTtl) : options.longs === Number ? new $util.LongBits(message.versionTtl.low >>> 0, message.versionTtl.high >>> 0).toNumber() : message.versionTtl;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.AuthResult.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.AuthResult.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this AuthResult to JSON.
         * @function toJSON
         * @memberof server.AuthResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.AuthResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        AuthResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.AuthResult.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} OK=1 OK value
         * @property {number} SPUB_MISMATCH=2 SPUB_MISMATCH value
         * @property {number} INVALID_CLIENT_VERSION=3 INVALID_CLIENT_VERSION value
         * @property {number} INVALID_RESOURCE=4 INVALID_RESOURCE value
         * @property {number} ACCOUNT_DELETED=5 ACCOUNT_DELETED value
         * @property {number} INVALID_UID_OR_PASSWORD=6 INVALID_UID_OR_PASSWORD value
         */
        AuthResult.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "SPUB_MISMATCH"] = 2;
            values[valuesById[3] = "INVALID_CLIENT_VERSION"] = 3;
            values[valuesById[4] = "INVALID_RESOURCE"] = 4;
            values[valuesById[5] = "ACCOUNT_DELETED"] = 5;
            values[valuesById[6] = "INVALID_UID_OR_PASSWORD"] = 6;
            return values;
        })();

        return AuthResult;
    })();

    server.Invite = (function() {

        /**
         * Properties of an Invite.
         * @memberof server
         * @interface IInvite
         * @property {string|null} [phone] Invite phone
         * @property {string|null} [result] Invite result
         * @property {string|null} [reason] Invite reason
         */

        /**
         * Constructs a new Invite.
         * @memberof server
         * @classdesc Represents an Invite.
         * @implements IInvite
         * @constructor
         * @param {server.IInvite=} [properties] Properties to set
         */
        function Invite(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Invite phone.
         * @member {string} phone
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.phone = "";

        /**
         * Invite result.
         * @member {string} result
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.result = "";

        /**
         * Invite reason.
         * @member {string} reason
         * @memberof server.Invite
         * @instance
         */
        Invite.prototype.reason = "";

        /**
         * Creates a new Invite instance using the specified properties.
         * @function create
         * @memberof server.Invite
         * @static
         * @param {server.IInvite=} [properties] Properties to set
         * @returns {server.Invite} Invite instance
         */
        Invite.create = function create(properties) {
            return new Invite(properties);
        };

        /**
         * Encodes the specified Invite message. Does not implicitly {@link server.Invite.verify|verify} messages.
         * @function encode
         * @memberof server.Invite
         * @static
         * @param {server.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified Invite message, length delimited. Does not implicitly {@link server.Invite.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Invite
         * @static
         * @param {server.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invite message from the specified reader or buffer.
         * @function decode
         * @memberof server.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Invite();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.result = reader.string();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invite message.
         * @function verify
         * @memberof server.Invite
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invite.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates an Invite message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Invite
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Invite} Invite
         */
        Invite.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Invite)
                return object;
            var message = new $root.server.Invite();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.result != null)
                message.result = String(object.result);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from an Invite message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Invite
         * @static
         * @param {server.Invite} message Invite
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Invite.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.result = "";
                object.reason = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this Invite to JSON.
         * @function toJSON
         * @memberof server.Invite
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Invite.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Invite;
    })();

    server.InvitesRequest = (function() {

        /**
         * Properties of an InvitesRequest.
         * @memberof server
         * @interface IInvitesRequest
         * @property {Array.<server.IInvite>|null} [invites] InvitesRequest invites
         */

        /**
         * Constructs a new InvitesRequest.
         * @memberof server
         * @classdesc Represents an InvitesRequest.
         * @implements IInvitesRequest
         * @constructor
         * @param {server.IInvitesRequest=} [properties] Properties to set
         */
        function InvitesRequest(properties) {
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvitesRequest invites.
         * @member {Array.<server.IInvite>} invites
         * @memberof server.InvitesRequest
         * @instance
         */
        InvitesRequest.prototype.invites = $util.emptyArray;

        /**
         * Creates a new InvitesRequest instance using the specified properties.
         * @function create
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest=} [properties] Properties to set
         * @returns {server.InvitesRequest} InvitesRequest instance
         */
        InvitesRequest.create = function create(properties) {
            return new InvitesRequest(properties);
        };

        /**
         * Encodes the specified InvitesRequest message. Does not implicitly {@link server.InvitesRequest.verify|verify} messages.
         * @function encode
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest} message InvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    $root.server.Invite.encode(message.invites[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InvitesRequest message, length delimited. Does not implicitly {@link server.InvitesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InvitesRequest
         * @static
         * @param {server.IInvitesRequest} message InvitesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvitesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.InvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InvitesRequest} InvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InvitesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invites && message.invites.length))
                        message.invites = [];
                    message.invites.push($root.server.Invite.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvitesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InvitesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InvitesRequest} InvitesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvitesRequest message.
         * @function verify
         * @memberof server.InvitesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvitesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i) {
                    var error = $root.server.Invite.verify(message.invites[i]);
                    if (error)
                        return "invites." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InvitesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InvitesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InvitesRequest} InvitesRequest
         */
        InvitesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InvitesRequest)
                return object;
            var message = new $root.server.InvitesRequest();
            if (object.invites) {
                if (!Array.isArray(object.invites))
                    throw TypeError(".server.InvitesRequest.invites: array expected");
                message.invites = [];
                for (var i = 0; i < object.invites.length; ++i) {
                    if (typeof object.invites[i] !== "object")
                        throw TypeError(".server.InvitesRequest.invites: object expected");
                    message.invites[i] = $root.server.Invite.fromObject(object.invites[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InvitesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InvitesRequest
         * @static
         * @param {server.InvitesRequest} message InvitesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvitesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invites = [];
            if (message.invites && message.invites.length) {
                object.invites = [];
                for (var j = 0; j < message.invites.length; ++j)
                    object.invites[j] = $root.server.Invite.toObject(message.invites[j], options);
            }
            return object;
        };

        /**
         * Converts this InvitesRequest to JSON.
         * @function toJSON
         * @memberof server.InvitesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvitesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvitesRequest;
    })();

    server.InvitesResponse = (function() {

        /**
         * Properties of an InvitesResponse.
         * @memberof server
         * @interface IInvitesResponse
         * @property {number|null} [invitesLeft] InvitesResponse invitesLeft
         * @property {number|Long|null} [timeUntilRefresh] InvitesResponse timeUntilRefresh
         * @property {Array.<server.IInvite>|null} [invites] InvitesResponse invites
         */

        /**
         * Constructs a new InvitesResponse.
         * @memberof server
         * @classdesc Represents an InvitesResponse.
         * @implements IInvitesResponse
         * @constructor
         * @param {server.IInvitesResponse=} [properties] Properties to set
         */
        function InvitesResponse(properties) {
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InvitesResponse invitesLeft.
         * @member {number} invitesLeft
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.invitesLeft = 0;

        /**
         * InvitesResponse timeUntilRefresh.
         * @member {number|Long} timeUntilRefresh
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.timeUntilRefresh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InvitesResponse invites.
         * @member {Array.<server.IInvite>} invites
         * @memberof server.InvitesResponse
         * @instance
         */
        InvitesResponse.prototype.invites = $util.emptyArray;

        /**
         * Creates a new InvitesResponse instance using the specified properties.
         * @function create
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse=} [properties] Properties to set
         * @returns {server.InvitesResponse} InvitesResponse instance
         */
        InvitesResponse.create = function create(properties) {
            return new InvitesResponse(properties);
        };

        /**
         * Encodes the specified InvitesResponse message. Does not implicitly {@link server.InvitesResponse.verify|verify} messages.
         * @function encode
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse} message InvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invitesLeft != null && Object.hasOwnProperty.call(message, "invitesLeft"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.invitesLeft);
            if (message.timeUntilRefresh != null && Object.hasOwnProperty.call(message, "timeUntilRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeUntilRefresh);
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    $root.server.Invite.encode(message.invites[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InvitesResponse message, length delimited. Does not implicitly {@link server.InvitesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InvitesResponse
         * @static
         * @param {server.IInvitesResponse} message InvitesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvitesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvitesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.InvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InvitesResponse} InvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InvitesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.invitesLeft = reader.int32();
                    break;
                case 2:
                    message.timeUntilRefresh = reader.int64();
                    break;
                case 3:
                    if (!(message.invites && message.invites.length))
                        message.invites = [];
                    message.invites.push($root.server.Invite.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvitesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InvitesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InvitesResponse} InvitesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvitesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvitesResponse message.
         * @function verify
         * @memberof server.InvitesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvitesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invitesLeft != null && message.hasOwnProperty("invitesLeft"))
                if (!$util.isInteger(message.invitesLeft))
                    return "invitesLeft: integer expected";
            if (message.timeUntilRefresh != null && message.hasOwnProperty("timeUntilRefresh"))
                if (!$util.isInteger(message.timeUntilRefresh) && !(message.timeUntilRefresh && $util.isInteger(message.timeUntilRefresh.low) && $util.isInteger(message.timeUntilRefresh.high)))
                    return "timeUntilRefresh: integer|Long expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i) {
                    var error = $root.server.Invite.verify(message.invites[i]);
                    if (error)
                        return "invites." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InvitesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InvitesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InvitesResponse} InvitesResponse
         */
        InvitesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InvitesResponse)
                return object;
            var message = new $root.server.InvitesResponse();
            if (object.invitesLeft != null)
                message.invitesLeft = object.invitesLeft | 0;
            if (object.timeUntilRefresh != null)
                if ($util.Long)
                    (message.timeUntilRefresh = $util.Long.fromValue(object.timeUntilRefresh)).unsigned = false;
                else if (typeof object.timeUntilRefresh === "string")
                    message.timeUntilRefresh = parseInt(object.timeUntilRefresh, 10);
                else if (typeof object.timeUntilRefresh === "number")
                    message.timeUntilRefresh = object.timeUntilRefresh;
                else if (typeof object.timeUntilRefresh === "object")
                    message.timeUntilRefresh = new $util.LongBits(object.timeUntilRefresh.low >>> 0, object.timeUntilRefresh.high >>> 0).toNumber();
            if (object.invites) {
                if (!Array.isArray(object.invites))
                    throw TypeError(".server.InvitesResponse.invites: array expected");
                message.invites = [];
                for (var i = 0; i < object.invites.length; ++i) {
                    if (typeof object.invites[i] !== "object")
                        throw TypeError(".server.InvitesResponse.invites: object expected");
                    message.invites[i] = $root.server.Invite.fromObject(object.invites[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InvitesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InvitesResponse
         * @static
         * @param {server.InvitesResponse} message InvitesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvitesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.invites = [];
            if (options.defaults) {
                object.invitesLeft = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeUntilRefresh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeUntilRefresh = options.longs === String ? "0" : 0;
            }
            if (message.invitesLeft != null && message.hasOwnProperty("invitesLeft"))
                object.invitesLeft = message.invitesLeft;
            if (message.timeUntilRefresh != null && message.hasOwnProperty("timeUntilRefresh"))
                if (typeof message.timeUntilRefresh === "number")
                    object.timeUntilRefresh = options.longs === String ? String(message.timeUntilRefresh) : message.timeUntilRefresh;
                else
                    object.timeUntilRefresh = options.longs === String ? $util.Long.prototype.toString.call(message.timeUntilRefresh) : options.longs === Number ? new $util.LongBits(message.timeUntilRefresh.low >>> 0, message.timeUntilRefresh.high >>> 0).toNumber() : message.timeUntilRefresh;
            if (message.invites && message.invites.length) {
                object.invites = [];
                for (var j = 0; j < message.invites.length; ++j)
                    object.invites[j] = $root.server.Invite.toObject(message.invites[j], options);
            }
            return object;
        };

        /**
         * Converts this InvitesResponse to JSON.
         * @function toJSON
         * @memberof server.InvitesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvitesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvitesResponse;
    })();

    server.MediaUrl = (function() {

        /**
         * Properties of a MediaUrl.
         * @memberof server
         * @interface IMediaUrl
         * @property {string|null} [get] MediaUrl get
         * @property {string|null} [put] MediaUrl put
         * @property {string|null} [patch] MediaUrl patch
         */

        /**
         * Constructs a new MediaUrl.
         * @memberof server
         * @classdesc Represents a MediaUrl.
         * @implements IMediaUrl
         * @constructor
         * @param {server.IMediaUrl=} [properties] Properties to set
         */
        function MediaUrl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaUrl get.
         * @member {string} get
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.get = "";

        /**
         * MediaUrl put.
         * @member {string} put
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.put = "";

        /**
         * MediaUrl patch.
         * @member {string} patch
         * @memberof server.MediaUrl
         * @instance
         */
        MediaUrl.prototype.patch = "";

        /**
         * Creates a new MediaUrl instance using the specified properties.
         * @function create
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl=} [properties] Properties to set
         * @returns {server.MediaUrl} MediaUrl instance
         */
        MediaUrl.create = function create(properties) {
            return new MediaUrl(properties);
        };

        /**
         * Encodes the specified MediaUrl message. Does not implicitly {@link server.MediaUrl.verify|verify} messages.
         * @function encode
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl} message MediaUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUrl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.get);
            if (message.put != null && Object.hasOwnProperty.call(message, "put"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.put);
            if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.patch);
            return writer;
        };

        /**
         * Encodes the specified MediaUrl message, length delimited. Does not implicitly {@link server.MediaUrl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaUrl
         * @static
         * @param {server.IMediaUrl} message MediaUrl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUrl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaUrl message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaUrl} MediaUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUrl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaUrl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.get = reader.string();
                    break;
                case 2:
                    message.put = reader.string();
                    break;
                case 3:
                    message.patch = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaUrl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaUrl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaUrl} MediaUrl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUrl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaUrl message.
         * @function verify
         * @memberof server.MediaUrl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaUrl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.get != null && message.hasOwnProperty("get"))
                if (!$util.isString(message.get))
                    return "get: string expected";
            if (message.put != null && message.hasOwnProperty("put"))
                if (!$util.isString(message.put))
                    return "put: string expected";
            if (message.patch != null && message.hasOwnProperty("patch"))
                if (!$util.isString(message.patch))
                    return "patch: string expected";
            return null;
        };

        /**
         * Creates a MediaUrl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaUrl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaUrl} MediaUrl
         */
        MediaUrl.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaUrl)
                return object;
            var message = new $root.server.MediaUrl();
            if (object.get != null)
                message.get = String(object.get);
            if (object.put != null)
                message.put = String(object.put);
            if (object.patch != null)
                message.patch = String(object.patch);
            return message;
        };

        /**
         * Creates a plain object from a MediaUrl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaUrl
         * @static
         * @param {server.MediaUrl} message MediaUrl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaUrl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.get = "";
                object.put = "";
                object.patch = "";
            }
            if (message.get != null && message.hasOwnProperty("get"))
                object.get = message.get;
            if (message.put != null && message.hasOwnProperty("put"))
                object.put = message.put;
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = message.patch;
            return object;
        };

        /**
         * Converts this MediaUrl to JSON.
         * @function toJSON
         * @memberof server.MediaUrl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaUrl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaUrl;
    })();

    server.UploadMedia = (function() {

        /**
         * Properties of an UploadMedia.
         * @memberof server
         * @interface IUploadMedia
         * @property {number|Long|null} [size] UploadMedia size
         * @property {server.IMediaUrl|null} [url] UploadMedia url
         * @property {string|null} [downloadUrl] UploadMedia downloadUrl
         * @property {server.UploadMedia.Type|null} [type] UploadMedia type
         */

        /**
         * Constructs a new UploadMedia.
         * @memberof server
         * @classdesc Represents an UploadMedia.
         * @implements IUploadMedia
         * @constructor
         * @param {server.IUploadMedia=} [properties] Properties to set
         */
        function UploadMedia(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UploadMedia size.
         * @member {number|Long} size
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UploadMedia url.
         * @member {server.IMediaUrl|null|undefined} url
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.url = null;

        /**
         * UploadMedia downloadUrl.
         * @member {string} downloadUrl
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.downloadUrl = "";

        /**
         * UploadMedia type.
         * @member {server.UploadMedia.Type} type
         * @memberof server.UploadMedia
         * @instance
         */
        UploadMedia.prototype.type = 0;

        /**
         * Creates a new UploadMedia instance using the specified properties.
         * @function create
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia=} [properties] Properties to set
         * @returns {server.UploadMedia} UploadMedia instance
         */
        UploadMedia.create = function create(properties) {
            return new UploadMedia(properties);
        };

        /**
         * Encodes the specified UploadMedia message. Does not implicitly {@link server.UploadMedia.verify|verify} messages.
         * @function encode
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia} message UploadMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadMedia.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.size);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                $root.server.MediaUrl.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.downloadUrl);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified UploadMedia message, length delimited. Does not implicitly {@link server.UploadMedia.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UploadMedia
         * @static
         * @param {server.IUploadMedia} message UploadMedia message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UploadMedia.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UploadMedia message from the specified reader or buffer.
         * @function decode
         * @memberof server.UploadMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UploadMedia} UploadMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadMedia.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UploadMedia();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.size = reader.int64();
                    break;
                case 2:
                    message.url = $root.server.MediaUrl.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.downloadUrl = reader.string();
                    break;
                case 4:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UploadMedia message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UploadMedia
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UploadMedia} UploadMedia
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UploadMedia.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UploadMedia message.
         * @function verify
         * @memberof server.UploadMedia
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UploadMedia.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            if (message.url != null && message.hasOwnProperty("url")) {
                var error = $root.server.MediaUrl.verify(message.url);
                if (error)
                    return "url." + error;
            }
            if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
                if (!$util.isString(message.downloadUrl))
                    return "downloadUrl: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an UploadMedia message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UploadMedia
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UploadMedia} UploadMedia
         */
        UploadMedia.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UploadMedia)
                return object;
            var message = new $root.server.UploadMedia();
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
            if (object.url != null) {
                if (typeof object.url !== "object")
                    throw TypeError(".server.UploadMedia.url: object expected");
                message.url = $root.server.MediaUrl.fromObject(object.url);
            }
            if (object.downloadUrl != null)
                message.downloadUrl = String(object.downloadUrl);
            switch (object.type) {
            case "DEFAULT":
            case 0:
                message.type = 0;
                break;
            case "RESUMABLE":
            case 1:
                message.type = 1;
                break;
            case "DIRECT":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an UploadMedia message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UploadMedia
         * @static
         * @param {server.UploadMedia} message UploadMedia
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UploadMedia.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
                object.url = null;
                object.downloadUrl = "";
                object.type = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = $root.server.MediaUrl.toObject(message.url, options);
            if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
                object.downloadUrl = message.downloadUrl;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.UploadMedia.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this UploadMedia to JSON.
         * @function toJSON
         * @memberof server.UploadMedia
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UploadMedia.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.UploadMedia.Type
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} RESUMABLE=1 RESUMABLE value
         * @property {number} DIRECT=2 DIRECT value
         */
        UploadMedia.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "RESUMABLE"] = 1;
            values[valuesById[2] = "DIRECT"] = 2;
            return values;
        })();

        return UploadMedia;
    })();

    server.ChatStanza = (function() {

        /**
         * Properties of a ChatStanza.
         * @memberof server
         * @interface IChatStanza
         * @property {number|Long|null} [timestamp] ChatStanza timestamp
         * @property {Uint8Array|null} [payload] ChatStanza payload
         * @property {Uint8Array|null} [encPayload] ChatStanza encPayload
         * @property {Uint8Array|null} [publicKey] ChatStanza publicKey
         * @property {number|Long|null} [oneTimePreKeyId] ChatStanza oneTimePreKeyId
         * @property {string|null} [senderName] ChatStanza senderName
         * @property {string|null} [senderPhone] ChatStanza senderPhone
         * @property {server.IMediaCounters|null} [mediaCounters] ChatStanza mediaCounters
         * @property {string|null} [senderLogInfo] ChatStanza senderLogInfo
         * @property {string|null} [senderClientVersion] ChatStanza senderClientVersion
         */

        /**
         * Constructs a new ChatStanza.
         * @memberof server
         * @classdesc Represents a ChatStanza.
         * @implements IChatStanza
         * @constructor
         * @param {server.IChatStanza=} [properties] Properties to set
         */
        function ChatStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatStanza timestamp.
         * @member {number|Long} timestamp
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChatStanza payload.
         * @member {Uint8Array} payload
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.payload = $util.newBuffer([]);

        /**
         * ChatStanza encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.encPayload = $util.newBuffer([]);

        /**
         * ChatStanza publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.publicKey = $util.newBuffer([]);

        /**
         * ChatStanza oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChatStanza senderName.
         * @member {string} senderName
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderName = "";

        /**
         * ChatStanza senderPhone.
         * @member {string} senderPhone
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderPhone = "";

        /**
         * ChatStanza mediaCounters.
         * @member {server.IMediaCounters|null|undefined} mediaCounters
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.mediaCounters = null;

        /**
         * ChatStanza senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderLogInfo = "";

        /**
         * ChatStanza senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.ChatStanza
         * @instance
         */
        ChatStanza.prototype.senderClientVersion = "";

        /**
         * Creates a new ChatStanza instance using the specified properties.
         * @function create
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza=} [properties] Properties to set
         * @returns {server.ChatStanza} ChatStanza instance
         */
        ChatStanza.create = function create(properties) {
            return new ChatStanza(properties);
        };

        /**
         * Encodes the specified ChatStanza message. Does not implicitly {@link server.ChatStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza} message ChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.oneTimePreKeyId);
            if (message.senderName != null && Object.hasOwnProperty.call(message, "senderName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderName);
            if (message.senderPhone != null && Object.hasOwnProperty.call(message, "senderPhone"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.senderPhone);
            if (message.mediaCounters != null && Object.hasOwnProperty.call(message, "mediaCounters"))
                $root.server.MediaCounters.encode(message.mediaCounters, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified ChatStanza message, length delimited. Does not implicitly {@link server.ChatStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatStanza
         * @static
         * @param {server.IChatStanza} message ChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatStanza} ChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.encPayload = reader.bytes();
                    break;
                case 4:
                    message.publicKey = reader.bytes();
                    break;
                case 5:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 6:
                    message.senderName = reader.string();
                    break;
                case 7:
                    message.senderPhone = reader.string();
                    break;
                case 8:
                    message.mediaCounters = $root.server.MediaCounters.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatStanza} ChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatStanza message.
         * @function verify
         * @memberof server.ChatStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                if (!$util.isString(message.senderName))
                    return "senderName: string expected";
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                if (!$util.isString(message.senderPhone))
                    return "senderPhone: string expected";
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters")) {
                var error = $root.server.MediaCounters.verify(message.mediaCounters);
                if (error)
                    return "mediaCounters." + error;
            }
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a ChatStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatStanza} ChatStanza
         */
        ChatStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatStanza)
                return object;
            var message = new $root.server.ChatStanza();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.senderName != null)
                message.senderName = String(object.senderName);
            if (object.senderPhone != null)
                message.senderPhone = String(object.senderPhone);
            if (object.mediaCounters != null) {
                if (typeof object.mediaCounters !== "object")
                    throw TypeError(".server.ChatStanza.mediaCounters: object expected");
                message.mediaCounters = $root.server.MediaCounters.fromObject(object.mediaCounters);
            }
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a ChatStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatStanza
         * @static
         * @param {server.ChatStanza} message ChatStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                object.senderName = "";
                object.senderPhone = "";
                object.mediaCounters = null;
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.senderName != null && message.hasOwnProperty("senderName"))
                object.senderName = message.senderName;
            if (message.senderPhone != null && message.hasOwnProperty("senderPhone"))
                object.senderPhone = message.senderPhone;
            if (message.mediaCounters != null && message.hasOwnProperty("mediaCounters"))
                object.mediaCounters = $root.server.MediaCounters.toObject(message.mediaCounters, options);
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this ChatStanza to JSON.
         * @function toJSON
         * @memberof server.ChatStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatStanza;
    })();

    server.SilentChatStanza = (function() {

        /**
         * Properties of a SilentChatStanza.
         * @memberof server
         * @interface ISilentChatStanza
         * @property {server.IChatStanza|null} [chatStanza] SilentChatStanza chatStanza
         */

        /**
         * Constructs a new SilentChatStanza.
         * @memberof server
         * @classdesc Represents a SilentChatStanza.
         * @implements ISilentChatStanza
         * @constructor
         * @param {server.ISilentChatStanza=} [properties] Properties to set
         */
        function SilentChatStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SilentChatStanza chatStanza.
         * @member {server.IChatStanza|null|undefined} chatStanza
         * @memberof server.SilentChatStanza
         * @instance
         */
        SilentChatStanza.prototype.chatStanza = null;

        /**
         * Creates a new SilentChatStanza instance using the specified properties.
         * @function create
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza=} [properties] Properties to set
         * @returns {server.SilentChatStanza} SilentChatStanza instance
         */
        SilentChatStanza.create = function create(properties) {
            return new SilentChatStanza(properties);
        };

        /**
         * Encodes the specified SilentChatStanza message. Does not implicitly {@link server.SilentChatStanza.verify|verify} messages.
         * @function encode
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza} message SilentChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SilentChatStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatStanza != null && Object.hasOwnProperty.call(message, "chatStanza"))
                $root.server.ChatStanza.encode(message.chatStanza, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SilentChatStanza message, length delimited. Does not implicitly {@link server.SilentChatStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.ISilentChatStanza} message SilentChatStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SilentChatStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SilentChatStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.SilentChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SilentChatStanza} SilentChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SilentChatStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SilentChatStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chatStanza = $root.server.ChatStanza.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SilentChatStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SilentChatStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SilentChatStanza} SilentChatStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SilentChatStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SilentChatStanza message.
         * @function verify
         * @memberof server.SilentChatStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SilentChatStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                var error = $root.server.ChatStanza.verify(message.chatStanza);
                if (error)
                    return "chatStanza." + error;
            }
            return null;
        };

        /**
         * Creates a SilentChatStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SilentChatStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SilentChatStanza} SilentChatStanza
         */
        SilentChatStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SilentChatStanza)
                return object;
            var message = new $root.server.SilentChatStanza();
            if (object.chatStanza != null) {
                if (typeof object.chatStanza !== "object")
                    throw TypeError(".server.SilentChatStanza.chatStanza: object expected");
                message.chatStanza = $root.server.ChatStanza.fromObject(object.chatStanza);
            }
            return message;
        };

        /**
         * Creates a plain object from a SilentChatStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SilentChatStanza
         * @static
         * @param {server.SilentChatStanza} message SilentChatStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SilentChatStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.chatStanza = null;
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza"))
                object.chatStanza = $root.server.ChatStanza.toObject(message.chatStanza, options);
            return object;
        };

        /**
         * Converts this SilentChatStanza to JSON.
         * @function toJSON
         * @memberof server.SilentChatStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SilentChatStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SilentChatStanza;
    })();

    server.Ping = (function() {

        /**
         * Properties of a Ping.
         * @memberof server
         * @interface IPing
         */

        /**
         * Constructs a new Ping.
         * @memberof server
         * @classdesc Represents a Ping.
         * @implements IPing
         * @constructor
         * @param {server.IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof server.Ping
         * @static
         * @param {server.IPing=} [properties] Properties to set
         * @returns {server.Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };

        /**
         * Encodes the specified Ping message. Does not implicitly {@link server.Ping.verify|verify} messages.
         * @function encode
         * @memberof server.Ping
         * @static
         * @param {server.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link server.Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Ping
         * @static
         * @param {server.IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof server.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof server.Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Ping)
                return object;
            return new $root.server.Ping();
        };

        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Ping
         * @static
         * @param {server.Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof server.Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ping;
    })();

    server.ErrorStanza = (function() {

        /**
         * Properties of an ErrorStanza.
         * @memberof server
         * @interface IErrorStanza
         * @property {string|null} [reason] ErrorStanza reason
         */

        /**
         * Constructs a new ErrorStanza.
         * @memberof server
         * @classdesc Represents an ErrorStanza.
         * @implements IErrorStanza
         * @constructor
         * @param {server.IErrorStanza=} [properties] Properties to set
         */
        function ErrorStanza(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ErrorStanza reason.
         * @member {string} reason
         * @memberof server.ErrorStanza
         * @instance
         */
        ErrorStanza.prototype.reason = "";

        /**
         * Creates a new ErrorStanza instance using the specified properties.
         * @function create
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza=} [properties] Properties to set
         * @returns {server.ErrorStanza} ErrorStanza instance
         */
        ErrorStanza.create = function create(properties) {
            return new ErrorStanza(properties);
        };

        /**
         * Encodes the specified ErrorStanza message. Does not implicitly {@link server.ErrorStanza.verify|verify} messages.
         * @function encode
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza} message ErrorStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorStanza.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ErrorStanza message, length delimited. Does not implicitly {@link server.ErrorStanza.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ErrorStanza
         * @static
         * @param {server.IErrorStanza} message ErrorStanza message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorStanza.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ErrorStanza message from the specified reader or buffer.
         * @function decode
         * @memberof server.ErrorStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ErrorStanza} ErrorStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorStanza.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ErrorStanza();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ErrorStanza message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ErrorStanza
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ErrorStanza} ErrorStanza
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorStanza.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ErrorStanza message.
         * @function verify
         * @memberof server.ErrorStanza
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ErrorStanza.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates an ErrorStanza message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ErrorStanza
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ErrorStanza} ErrorStanza
         */
        ErrorStanza.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ErrorStanza)
                return object;
            var message = new $root.server.ErrorStanza();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from an ErrorStanza message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ErrorStanza
         * @static
         * @param {server.ErrorStanza} message ErrorStanza
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ErrorStanza.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ErrorStanza to JSON.
         * @function toJSON
         * @memberof server.ErrorStanza
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ErrorStanza.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ErrorStanza;
    })();

    server.Name = (function() {

        /**
         * Properties of a Name.
         * @memberof server
         * @interface IName
         * @property {number|Long|null} [uid] Name uid
         * @property {string|null} [name] Name name
         */

        /**
         * Constructs a new Name.
         * @memberof server
         * @classdesc Represents a Name.
         * @implements IName
         * @constructor
         * @param {server.IName=} [properties] Properties to set
         */
        function Name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Name uid.
         * @member {number|Long} uid
         * @memberof server.Name
         * @instance
         */
        Name.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Name name.
         * @member {string} name
         * @memberof server.Name
         * @instance
         */
        Name.prototype.name = "";

        /**
         * Creates a new Name instance using the specified properties.
         * @function create
         * @memberof server.Name
         * @static
         * @param {server.IName=} [properties] Properties to set
         * @returns {server.Name} Name instance
         */
        Name.create = function create(properties) {
            return new Name(properties);
        };

        /**
         * Encodes the specified Name message. Does not implicitly {@link server.Name.verify|verify} messages.
         * @function encode
         * @memberof server.Name
         * @static
         * @param {server.IName} message Name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Name message, length delimited. Does not implicitly {@link server.Name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Name
         * @static
         * @param {server.IName} message Name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Name message from the specified reader or buffer.
         * @function decode
         * @memberof server.Name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Name} Name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Name} Name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Name message.
         * @function verify
         * @memberof server.Name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Name} Name
         */
        Name.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Name)
                return object;
            var message = new $root.server.Name();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Name
         * @static
         * @param {server.Name} message Name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Name.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Name to JSON.
         * @function toJSON
         * @memberof server.Name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Name;
    })();

    server.EndOfQueue = (function() {

        /**
         * Properties of an EndOfQueue.
         * @memberof server
         * @interface IEndOfQueue
         * @property {boolean|null} [trimmed] EndOfQueue trimmed
         */

        /**
         * Constructs a new EndOfQueue.
         * @memberof server
         * @classdesc Represents an EndOfQueue.
         * @implements IEndOfQueue
         * @constructor
         * @param {server.IEndOfQueue=} [properties] Properties to set
         */
        function EndOfQueue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EndOfQueue trimmed.
         * @member {boolean} trimmed
         * @memberof server.EndOfQueue
         * @instance
         */
        EndOfQueue.prototype.trimmed = false;

        /**
         * Creates a new EndOfQueue instance using the specified properties.
         * @function create
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue=} [properties] Properties to set
         * @returns {server.EndOfQueue} EndOfQueue instance
         */
        EndOfQueue.create = function create(properties) {
            return new EndOfQueue(properties);
        };

        /**
         * Encodes the specified EndOfQueue message. Does not implicitly {@link server.EndOfQueue.verify|verify} messages.
         * @function encode
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue} message EndOfQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndOfQueue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trimmed != null && Object.hasOwnProperty.call(message, "trimmed"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.trimmed);
            return writer;
        };

        /**
         * Encodes the specified EndOfQueue message, length delimited. Does not implicitly {@link server.EndOfQueue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EndOfQueue
         * @static
         * @param {server.IEndOfQueue} message EndOfQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndOfQueue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EndOfQueue message from the specified reader or buffer.
         * @function decode
         * @memberof server.EndOfQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EndOfQueue} EndOfQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndOfQueue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EndOfQueue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trimmed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EndOfQueue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EndOfQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EndOfQueue} EndOfQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndOfQueue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EndOfQueue message.
         * @function verify
         * @memberof server.EndOfQueue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EndOfQueue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trimmed != null && message.hasOwnProperty("trimmed"))
                if (typeof message.trimmed !== "boolean")
                    return "trimmed: boolean expected";
            return null;
        };

        /**
         * Creates an EndOfQueue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EndOfQueue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EndOfQueue} EndOfQueue
         */
        EndOfQueue.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EndOfQueue)
                return object;
            var message = new $root.server.EndOfQueue();
            if (object.trimmed != null)
                message.trimmed = Boolean(object.trimmed);
            return message;
        };

        /**
         * Creates a plain object from an EndOfQueue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EndOfQueue
         * @static
         * @param {server.EndOfQueue} message EndOfQueue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EndOfQueue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.trimmed = false;
            if (message.trimmed != null && message.hasOwnProperty("trimmed"))
                object.trimmed = message.trimmed;
            return object;
        };

        /**
         * Converts this EndOfQueue to JSON.
         * @function toJSON
         * @memberof server.EndOfQueue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EndOfQueue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EndOfQueue;
    })();

    server.HistoryResend = (function() {

        /**
         * Properties of a HistoryResend.
         * @memberof server
         * @interface IHistoryResend
         * @property {string|null} [gid] HistoryResend gid
         * @property {string|null} [id] HistoryResend id
         * @property {Uint8Array|null} [payload] HistoryResend payload
         * @property {Uint8Array|null} [encPayload] HistoryResend encPayload
         * @property {Array.<server.ISenderStateBundle>|null} [senderStateBundles] HistoryResend senderStateBundles
         * @property {server.ISenderStateWithKeyInfo|null} [senderState] HistoryResend senderState
         * @property {Uint8Array|null} [audienceHash] HistoryResend audienceHash
         * @property {string|null} [senderLogInfo] HistoryResend senderLogInfo
         * @property {string|null} [senderClientVersion] HistoryResend senderClientVersion
         */

        /**
         * Constructs a new HistoryResend.
         * @memberof server
         * @classdesc Represents a HistoryResend.
         * @implements IHistoryResend
         * @constructor
         * @param {server.IHistoryResend=} [properties] Properties to set
         */
        function HistoryResend(properties) {
            this.senderStateBundles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistoryResend gid.
         * @member {string} gid
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.gid = "";

        /**
         * HistoryResend id.
         * @member {string} id
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.id = "";

        /**
         * HistoryResend payload.
         * @member {Uint8Array} payload
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.payload = $util.newBuffer([]);

        /**
         * HistoryResend encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.encPayload = $util.newBuffer([]);

        /**
         * HistoryResend senderStateBundles.
         * @member {Array.<server.ISenderStateBundle>} senderStateBundles
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderStateBundles = $util.emptyArray;

        /**
         * HistoryResend senderState.
         * @member {server.ISenderStateWithKeyInfo|null|undefined} senderState
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderState = null;

        /**
         * HistoryResend audienceHash.
         * @member {Uint8Array} audienceHash
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.audienceHash = $util.newBuffer([]);

        /**
         * HistoryResend senderLogInfo.
         * @member {string} senderLogInfo
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderLogInfo = "";

        /**
         * HistoryResend senderClientVersion.
         * @member {string} senderClientVersion
         * @memberof server.HistoryResend
         * @instance
         */
        HistoryResend.prototype.senderClientVersion = "";

        /**
         * Creates a new HistoryResend instance using the specified properties.
         * @function create
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend=} [properties] Properties to set
         * @returns {server.HistoryResend} HistoryResend instance
         */
        HistoryResend.create = function create(properties) {
            return new HistoryResend(properties);
        };

        /**
         * Encodes the specified HistoryResend message. Does not implicitly {@link server.HistoryResend.verify|verify} messages.
         * @function encode
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend} message HistoryResend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryResend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encPayload);
            if (message.senderStateBundles != null && message.senderStateBundles.length)
                for (var i = 0; i < message.senderStateBundles.length; ++i)
                    $root.server.SenderStateBundle.encode(message.senderStateBundles[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.senderState != null && Object.hasOwnProperty.call(message, "senderState"))
                $root.server.SenderStateWithKeyInfo.encode(message.senderState, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.audienceHash != null && Object.hasOwnProperty.call(message, "audienceHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.audienceHash);
            if (message.senderLogInfo != null && Object.hasOwnProperty.call(message, "senderLogInfo"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.senderLogInfo);
            if (message.senderClientVersion != null && Object.hasOwnProperty.call(message, "senderClientVersion"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.senderClientVersion);
            return writer;
        };

        /**
         * Encodes the specified HistoryResend message, length delimited. Does not implicitly {@link server.HistoryResend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HistoryResend
         * @static
         * @param {server.IHistoryResend} message HistoryResend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryResend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistoryResend message from the specified reader or buffer.
         * @function decode
         * @memberof server.HistoryResend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HistoryResend} HistoryResend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryResend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HistoryResend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    message.encPayload = reader.bytes();
                    break;
                case 6:
                    if (!(message.senderStateBundles && message.senderStateBundles.length))
                        message.senderStateBundles = [];
                    message.senderStateBundles.push($root.server.SenderStateBundle.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.senderState = $root.server.SenderStateWithKeyInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.audienceHash = reader.bytes();
                    break;
                case 16:
                    message.senderLogInfo = reader.string();
                    break;
                case 17:
                    message.senderClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HistoryResend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HistoryResend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HistoryResend} HistoryResend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryResend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistoryResend message.
         * @function verify
         * @memberof server.HistoryResend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistoryResend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.senderStateBundles != null && message.hasOwnProperty("senderStateBundles")) {
                if (!Array.isArray(message.senderStateBundles))
                    return "senderStateBundles: array expected";
                for (var i = 0; i < message.senderStateBundles.length; ++i) {
                    var error = $root.server.SenderStateBundle.verify(message.senderStateBundles[i]);
                    if (error)
                        return "senderStateBundles." + error;
                }
            }
            if (message.senderState != null && message.hasOwnProperty("senderState")) {
                var error = $root.server.SenderStateWithKeyInfo.verify(message.senderState);
                if (error)
                    return "senderState." + error;
            }
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                if (!(message.audienceHash && typeof message.audienceHash.length === "number" || $util.isString(message.audienceHash)))
                    return "audienceHash: buffer expected";
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                if (!$util.isString(message.senderLogInfo))
                    return "senderLogInfo: string expected";
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                if (!$util.isString(message.senderClientVersion))
                    return "senderClientVersion: string expected";
            return null;
        };

        /**
         * Creates a HistoryResend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HistoryResend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HistoryResend} HistoryResend
         */
        HistoryResend.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HistoryResend)
                return object;
            var message = new $root.server.HistoryResend();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.senderStateBundles) {
                if (!Array.isArray(object.senderStateBundles))
                    throw TypeError(".server.HistoryResend.senderStateBundles: array expected");
                message.senderStateBundles = [];
                for (var i = 0; i < object.senderStateBundles.length; ++i) {
                    if (typeof object.senderStateBundles[i] !== "object")
                        throw TypeError(".server.HistoryResend.senderStateBundles: object expected");
                    message.senderStateBundles[i] = $root.server.SenderStateBundle.fromObject(object.senderStateBundles[i]);
                }
            }
            if (object.senderState != null) {
                if (typeof object.senderState !== "object")
                    throw TypeError(".server.HistoryResend.senderState: object expected");
                message.senderState = $root.server.SenderStateWithKeyInfo.fromObject(object.senderState);
            }
            if (object.audienceHash != null)
                if (typeof object.audienceHash === "string")
                    $util.base64.decode(object.audienceHash, message.audienceHash = $util.newBuffer($util.base64.length(object.audienceHash)), 0);
                else if (object.audienceHash.length)
                    message.audienceHash = object.audienceHash;
            if (object.senderLogInfo != null)
                message.senderLogInfo = String(object.senderLogInfo);
            if (object.senderClientVersion != null)
                message.senderClientVersion = String(object.senderClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a HistoryResend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HistoryResend
         * @static
         * @param {server.HistoryResend} message HistoryResend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistoryResend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderStateBundles = [];
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                object.senderState = null;
                if (options.bytes === String)
                    object.audienceHash = "";
                else {
                    object.audienceHash = [];
                    if (options.bytes !== Array)
                        object.audienceHash = $util.newBuffer(object.audienceHash);
                }
                object.senderLogInfo = "";
                object.senderClientVersion = "";
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.senderStateBundles && message.senderStateBundles.length) {
                object.senderStateBundles = [];
                for (var j = 0; j < message.senderStateBundles.length; ++j)
                    object.senderStateBundles[j] = $root.server.SenderStateBundle.toObject(message.senderStateBundles[j], options);
            }
            if (message.senderState != null && message.hasOwnProperty("senderState"))
                object.senderState = $root.server.SenderStateWithKeyInfo.toObject(message.senderState, options);
            if (message.audienceHash != null && message.hasOwnProperty("audienceHash"))
                object.audienceHash = options.bytes === String ? $util.base64.encode(message.audienceHash, 0, message.audienceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.audienceHash) : message.audienceHash;
            if (message.senderLogInfo != null && message.hasOwnProperty("senderLogInfo"))
                object.senderLogInfo = message.senderLogInfo;
            if (message.senderClientVersion != null && message.hasOwnProperty("senderClientVersion"))
                object.senderClientVersion = message.senderClientVersion;
            return object;
        };

        /**
         * Converts this HistoryResend to JSON.
         * @function toJSON
         * @memberof server.HistoryResend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistoryResend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistoryResend;
    })();

    /**
     * CallType enum.
     * @name server.CallType
     * @enum {number}
     * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
     * @property {number} AUDIO=1 AUDIO value
     * @property {number} VIDEO=2 VIDEO value
     */
    server.CallType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
        values[valuesById[1] = "AUDIO"] = 1;
        values[valuesById[2] = "VIDEO"] = 2;
        return values;
    })();

    server.StunServer = (function() {

        /**
         * Properties of a StunServer.
         * @memberof server
         * @interface IStunServer
         * @property {string|null} [host] StunServer host
         * @property {number|null} [port] StunServer port
         */

        /**
         * Constructs a new StunServer.
         * @memberof server
         * @classdesc Represents a StunServer.
         * @implements IStunServer
         * @constructor
         * @param {server.IStunServer=} [properties] Properties to set
         */
        function StunServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StunServer host.
         * @member {string} host
         * @memberof server.StunServer
         * @instance
         */
        StunServer.prototype.host = "";

        /**
         * StunServer port.
         * @member {number} port
         * @memberof server.StunServer
         * @instance
         */
        StunServer.prototype.port = 0;

        /**
         * Creates a new StunServer instance using the specified properties.
         * @function create
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer=} [properties] Properties to set
         * @returns {server.StunServer} StunServer instance
         */
        StunServer.create = function create(properties) {
            return new StunServer(properties);
        };

        /**
         * Encodes the specified StunServer message. Does not implicitly {@link server.StunServer.verify|verify} messages.
         * @function encode
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer} message StunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StunServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            return writer;
        };

        /**
         * Encodes the specified StunServer message, length delimited. Does not implicitly {@link server.StunServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StunServer
         * @static
         * @param {server.IStunServer} message StunServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StunServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StunServer message from the specified reader or buffer.
         * @function decode
         * @memberof server.StunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StunServer} StunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StunServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StunServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StunServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StunServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StunServer} StunServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StunServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StunServer message.
         * @function verify
         * @memberof server.StunServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StunServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            return null;
        };

        /**
         * Creates a StunServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StunServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StunServer} StunServer
         */
        StunServer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StunServer)
                return object;
            var message = new $root.server.StunServer();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a StunServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StunServer
         * @static
         * @param {server.StunServer} message StunServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StunServer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this StunServer to JSON.
         * @function toJSON
         * @memberof server.StunServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StunServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StunServer;
    })();

    server.TurnServer = (function() {

        /**
         * Properties of a TurnServer.
         * @memberof server
         * @interface ITurnServer
         * @property {string|null} [host] TurnServer host
         * @property {number|null} [port] TurnServer port
         * @property {string|null} [username] TurnServer username
         * @property {string|null} [password] TurnServer password
         */

        /**
         * Constructs a new TurnServer.
         * @memberof server
         * @classdesc Represents a TurnServer.
         * @implements ITurnServer
         * @constructor
         * @param {server.ITurnServer=} [properties] Properties to set
         */
        function TurnServer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TurnServer host.
         * @member {string} host
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.host = "";

        /**
         * TurnServer port.
         * @member {number} port
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.port = 0;

        /**
         * TurnServer username.
         * @member {string} username
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.username = "";

        /**
         * TurnServer password.
         * @member {string} password
         * @memberof server.TurnServer
         * @instance
         */
        TurnServer.prototype.password = "";

        /**
         * Creates a new TurnServer instance using the specified properties.
         * @function create
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer=} [properties] Properties to set
         * @returns {server.TurnServer} TurnServer instance
         */
        TurnServer.create = function create(properties) {
            return new TurnServer(properties);
        };

        /**
         * Encodes the specified TurnServer message. Does not implicitly {@link server.TurnServer.verify|verify} messages.
         * @function encode
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer} message TurnServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnServer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified TurnServer message, length delimited. Does not implicitly {@link server.TurnServer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TurnServer
         * @static
         * @param {server.ITurnServer} message TurnServer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnServer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TurnServer message from the specified reader or buffer.
         * @function decode
         * @memberof server.TurnServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TurnServer} TurnServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnServer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TurnServer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.uint32();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TurnServer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TurnServer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TurnServer} TurnServer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnServer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TurnServer message.
         * @function verify
         * @memberof server.TurnServer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TurnServer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a TurnServer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TurnServer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TurnServer} TurnServer
         */
        TurnServer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TurnServer)
                return object;
            var message = new $root.server.TurnServer();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a TurnServer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TurnServer
         * @static
         * @param {server.TurnServer} message TurnServer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TurnServer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.username = "";
                object.password = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this TurnServer to JSON.
         * @function toJSON
         * @memberof server.TurnServer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TurnServer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TurnServer;
    })();

    server.GetCallServers = (function() {

        /**
         * Properties of a GetCallServers.
         * @memberof server
         * @interface IGetCallServers
         * @property {string|null} [callId] GetCallServers callId
         * @property {number|Long|null} [peerUid] GetCallServers peerUid
         * @property {server.CallType|null} [callType] GetCallServers callType
         */

        /**
         * Constructs a new GetCallServers.
         * @memberof server
         * @classdesc Represents a GetCallServers.
         * @implements IGetCallServers
         * @constructor
         * @param {server.IGetCallServers=} [properties] Properties to set
         */
        function GetCallServers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCallServers callId.
         * @member {string} callId
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.callId = "";

        /**
         * GetCallServers peerUid.
         * @member {number|Long} peerUid
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetCallServers callType.
         * @member {server.CallType} callType
         * @memberof server.GetCallServers
         * @instance
         */
        GetCallServers.prototype.callType = 0;

        /**
         * Creates a new GetCallServers instance using the specified properties.
         * @function create
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers=} [properties] Properties to set
         * @returns {server.GetCallServers} GetCallServers instance
         */
        GetCallServers.create = function create(properties) {
            return new GetCallServers(properties);
        };

        /**
         * Encodes the specified GetCallServers message. Does not implicitly {@link server.GetCallServers.verify|verify} messages.
         * @function encode
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers} message GetCallServers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.peerUid);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callType);
            return writer;
        };

        /**
         * Encodes the specified GetCallServers message, length delimited. Does not implicitly {@link server.GetCallServers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GetCallServers
         * @static
         * @param {server.IGetCallServers} message GetCallServers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCallServers message from the specified reader or buffer.
         * @function decode
         * @memberof server.GetCallServers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GetCallServers} GetCallServers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GetCallServers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.int64();
                    break;
                case 3:
                    message.callType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCallServers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GetCallServers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GetCallServers} GetCallServers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCallServers message.
         * @function verify
         * @memberof server.GetCallServers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCallServers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetCallServers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GetCallServers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GetCallServers} GetCallServers
         */
        GetCallServers.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GetCallServers)
                return object;
            var message = new $root.server.GetCallServers();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = false;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber();
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCallServers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GetCallServers
         * @static
         * @param {server.GetCallServers} message GetCallServers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCallServers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber() : message.peerUid;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            return object;
        };

        /**
         * Converts this GetCallServers to JSON.
         * @function toJSON
         * @memberof server.GetCallServers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCallServers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCallServers;
    })();

    server.GetCallServersResult = (function() {

        /**
         * Properties of a GetCallServersResult.
         * @memberof server
         * @interface IGetCallServersResult
         * @property {server.GetCallServersResult.Result|null} [result] GetCallServersResult result
         * @property {Array.<server.IStunServer>|null} [stunServers] GetCallServersResult stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] GetCallServersResult turnServers
         * @property {server.ICallConfig|null} [callConfig] GetCallServersResult callConfig
         */

        /**
         * Constructs a new GetCallServersResult.
         * @memberof server
         * @classdesc Represents a GetCallServersResult.
         * @implements IGetCallServersResult
         * @constructor
         * @param {server.IGetCallServersResult=} [properties] Properties to set
         */
        function GetCallServersResult(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCallServersResult result.
         * @member {server.GetCallServersResult.Result} result
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.result = 0;

        /**
         * GetCallServersResult stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.stunServers = $util.emptyArray;

        /**
         * GetCallServersResult turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.turnServers = $util.emptyArray;

        /**
         * GetCallServersResult callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.GetCallServersResult
         * @instance
         */
        GetCallServersResult.prototype.callConfig = null;

        /**
         * Creates a new GetCallServersResult instance using the specified properties.
         * @function create
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult=} [properties] Properties to set
         * @returns {server.GetCallServersResult} GetCallServersResult instance
         */
        GetCallServersResult.create = function create(properties) {
            return new GetCallServersResult(properties);
        };

        /**
         * Encodes the specified GetCallServersResult message. Does not implicitly {@link server.GetCallServersResult.verify|verify} messages.
         * @function encode
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult} message GetCallServersResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServersResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetCallServersResult message, length delimited. Does not implicitly {@link server.GetCallServersResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.IGetCallServersResult} message GetCallServersResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCallServersResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCallServersResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.GetCallServersResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GetCallServersResult} GetCallServersResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServersResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GetCallServersResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCallServersResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GetCallServersResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GetCallServersResult} GetCallServersResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCallServersResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCallServersResult message.
         * @function verify
         * @memberof server.GetCallServersResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCallServersResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            return null;
        };

        /**
         * Creates a GetCallServersResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GetCallServersResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GetCallServersResult} GetCallServersResult
         */
        GetCallServersResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GetCallServersResult)
                return object;
            var message = new $root.server.GetCallServersResult();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.GetCallServersResult.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.GetCallServersResult.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.GetCallServersResult.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.GetCallServersResult.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.GetCallServersResult.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCallServersResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GetCallServersResult
         * @static
         * @param {server.GetCallServersResult} message GetCallServersResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCallServersResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN" : 0;
                object.callConfig = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.GetCallServersResult.Result[message.result] : message.result;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            return object;
        };

        /**
         * Converts this GetCallServersResult to JSON.
         * @function toJSON
         * @memberof server.GetCallServersResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCallServersResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.GetCallServersResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        GetCallServersResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        return GetCallServersResult;
    })();

    server.CallCapabilities = (function() {

        /**
         * Properties of a CallCapabilities.
         * @memberof server
         * @interface ICallCapabilities
         * @property {boolean|null} [preAnswer] CallCapabilities preAnswer
         * @property {boolean|null} [sdpRestart] CallCapabilities sdpRestart
         */

        /**
         * Constructs a new CallCapabilities.
         * @memberof server
         * @classdesc Represents a CallCapabilities.
         * @implements ICallCapabilities
         * @constructor
         * @param {server.ICallCapabilities=} [properties] Properties to set
         */
        function CallCapabilities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallCapabilities preAnswer.
         * @member {boolean} preAnswer
         * @memberof server.CallCapabilities
         * @instance
         */
        CallCapabilities.prototype.preAnswer = false;

        /**
         * CallCapabilities sdpRestart.
         * @member {boolean} sdpRestart
         * @memberof server.CallCapabilities
         * @instance
         */
        CallCapabilities.prototype.sdpRestart = false;

        /**
         * Creates a new CallCapabilities instance using the specified properties.
         * @function create
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities=} [properties] Properties to set
         * @returns {server.CallCapabilities} CallCapabilities instance
         */
        CallCapabilities.create = function create(properties) {
            return new CallCapabilities(properties);
        };

        /**
         * Encodes the specified CallCapabilities message. Does not implicitly {@link server.CallCapabilities.verify|verify} messages.
         * @function encode
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities} message CallCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallCapabilities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.preAnswer != null && Object.hasOwnProperty.call(message, "preAnswer"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.preAnswer);
            if (message.sdpRestart != null && Object.hasOwnProperty.call(message, "sdpRestart"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.sdpRestart);
            return writer;
        };

        /**
         * Encodes the specified CallCapabilities message, length delimited. Does not implicitly {@link server.CallCapabilities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallCapabilities
         * @static
         * @param {server.ICallCapabilities} message CallCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallCapabilities message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallCapabilities} CallCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallCapabilities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallCapabilities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.preAnswer = reader.bool();
                    break;
                case 2:
                    message.sdpRestart = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallCapabilities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallCapabilities} CallCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallCapabilities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallCapabilities message.
         * @function verify
         * @memberof server.CallCapabilities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallCapabilities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.preAnswer != null && message.hasOwnProperty("preAnswer"))
                if (typeof message.preAnswer !== "boolean")
                    return "preAnswer: boolean expected";
            if (message.sdpRestart != null && message.hasOwnProperty("sdpRestart"))
                if (typeof message.sdpRestart !== "boolean")
                    return "sdpRestart: boolean expected";
            return null;
        };

        /**
         * Creates a CallCapabilities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallCapabilities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallCapabilities} CallCapabilities
         */
        CallCapabilities.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallCapabilities)
                return object;
            var message = new $root.server.CallCapabilities();
            if (object.preAnswer != null)
                message.preAnswer = Boolean(object.preAnswer);
            if (object.sdpRestart != null)
                message.sdpRestart = Boolean(object.sdpRestart);
            return message;
        };

        /**
         * Creates a plain object from a CallCapabilities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallCapabilities
         * @static
         * @param {server.CallCapabilities} message CallCapabilities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallCapabilities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.preAnswer = false;
                object.sdpRestart = false;
            }
            if (message.preAnswer != null && message.hasOwnProperty("preAnswer"))
                object.preAnswer = message.preAnswer;
            if (message.sdpRestart != null && message.hasOwnProperty("sdpRestart"))
                object.sdpRestart = message.sdpRestart;
            return object;
        };

        /**
         * Converts this CallCapabilities to JSON.
         * @function toJSON
         * @memberof server.CallCapabilities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallCapabilities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallCapabilities;
    })();

    server.StartCall = (function() {

        /**
         * Properties of a StartCall.
         * @memberof server
         * @interface IStartCall
         * @property {string|null} [callId] StartCall callId
         * @property {number|Long|null} [peerUid] StartCall peerUid
         * @property {server.CallType|null} [callType] StartCall callType
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] StartCall webrtcOffer
         * @property {number|null} [rerequestCount] StartCall rerequestCount
         * @property {server.ICallCapabilities|null} [callCapabilities] StartCall callCapabilities
         */

        /**
         * Constructs a new StartCall.
         * @memberof server
         * @classdesc Represents a StartCall.
         * @implements IStartCall
         * @constructor
         * @param {server.IStartCall=} [properties] Properties to set
         */
        function StartCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartCall callId.
         * @member {string} callId
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callId = "";

        /**
         * StartCall peerUid.
         * @member {number|Long} peerUid
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StartCall callType.
         * @member {server.CallType} callType
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callType = 0;

        /**
         * StartCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.webrtcOffer = null;

        /**
         * StartCall rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.rerequestCount = 0;

        /**
         * StartCall callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.StartCall
         * @instance
         */
        StartCall.prototype.callCapabilities = null;

        /**
         * Creates a new StartCall instance using the specified properties.
         * @function create
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall=} [properties] Properties to set
         * @returns {server.StartCall} StartCall instance
         */
        StartCall.create = function create(properties) {
            return new StartCall(properties);
        };

        /**
         * Encodes the specified StartCall message. Does not implicitly {@link server.StartCall.verify|verify} messages.
         * @function encode
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall} message StartCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.peerUid);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callType);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rerequestCount);
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StartCall message, length delimited. Does not implicitly {@link server.StartCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StartCall
         * @static
         * @param {server.IStartCall} message StartCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.StartCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StartCall} StartCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StartCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.int64();
                    break;
                case 3:
                    message.callType = reader.int32();
                    break;
                case 4:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.rerequestCount = reader.int32();
                    break;
                case 6:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StartCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StartCall} StartCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCall message.
         * @function verify
         * @memberof server.StartCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates a StartCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StartCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StartCall} StartCall
         */
        StartCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StartCall)
                return object;
            var message = new $root.server.StartCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = false;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber();
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.StartCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount | 0;
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.StartCall.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from a StartCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StartCall
         * @static
         * @param {server.StartCall} message StartCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.webrtcOffer = null;
                object.rerequestCount = 0;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber() : message.peerUid;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this StartCall to JSON.
         * @function toJSON
         * @memberof server.StartCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartCall;
    })();

    server.StartCallResult = (function() {

        /**
         * Properties of a StartCallResult.
         * @memberof server
         * @interface IStartCallResult
         * @property {server.StartCallResult.Result|null} [result] StartCallResult result
         * @property {Array.<server.IStunServer>|null} [stunServers] StartCallResult stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] StartCallResult turnServers
         * @property {number|Long|null} [timestampMs] StartCallResult timestampMs
         */

        /**
         * Constructs a new StartCallResult.
         * @memberof server
         * @classdesc Represents a StartCallResult.
         * @implements IStartCallResult
         * @constructor
         * @param {server.IStartCallResult=} [properties] Properties to set
         */
        function StartCallResult(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartCallResult result.
         * @member {server.StartCallResult.Result} result
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.result = 0;

        /**
         * StartCallResult stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.stunServers = $util.emptyArray;

        /**
         * StartCallResult turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.turnServers = $util.emptyArray;

        /**
         * StartCallResult timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.StartCallResult
         * @instance
         */
        StartCallResult.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StartCallResult instance using the specified properties.
         * @function create
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult=} [properties] Properties to set
         * @returns {server.StartCallResult} StartCallResult instance
         */
        StartCallResult.create = function create(properties) {
            return new StartCallResult(properties);
        };

        /**
         * Encodes the specified StartCallResult message. Does not implicitly {@link server.StartCallResult.verify|verify} messages.
         * @function encode
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult} message StartCallResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCallResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified StartCallResult message, length delimited. Does not implicitly {@link server.StartCallResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.StartCallResult
         * @static
         * @param {server.IStartCallResult} message StartCallResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCallResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCallResult message from the specified reader or buffer.
         * @function decode
         * @memberof server.StartCallResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.StartCallResult} StartCallResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCallResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.StartCallResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCallResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.StartCallResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.StartCallResult} StartCallResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCallResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCallResult message.
         * @function verify
         * @memberof server.StartCallResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCallResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a StartCallResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.StartCallResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.StartCallResult} StartCallResult
         */
        StartCallResult.fromObject = function fromObject(object) {
            if (object instanceof $root.server.StartCallResult)
                return object;
            var message = new $root.server.StartCallResult();
            switch (object.result) {
            case "UNKNOWN":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.StartCallResult.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.StartCallResult.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.StartCallResult.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.StartCallResult.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StartCallResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.StartCallResult
         * @static
         * @param {server.StartCallResult} message StartCallResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCallResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.StartCallResult.Result[message.result] : message.result;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this StartCallResult to JSON.
         * @function toJSON
         * @memberof server.StartCallResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCallResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.StartCallResult.Result
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        StartCallResult.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        return StartCallResult;
    })();

    server.WebRtcSessionDescription = (function() {

        /**
         * Properties of a WebRtcSessionDescription.
         * @memberof server
         * @interface IWebRtcSessionDescription
         * @property {Uint8Array|null} [encPayload] WebRtcSessionDescription encPayload
         * @property {Uint8Array|null} [publicKey] WebRtcSessionDescription publicKey
         * @property {number|null} [oneTimePreKeyId] WebRtcSessionDescription oneTimePreKeyId
         */

        /**
         * Constructs a new WebRtcSessionDescription.
         * @memberof server
         * @classdesc Represents a WebRtcSessionDescription.
         * @implements IWebRtcSessionDescription
         * @constructor
         * @param {server.IWebRtcSessionDescription=} [properties] Properties to set
         */
        function WebRtcSessionDescription(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebRtcSessionDescription encPayload.
         * @member {Uint8Array} encPayload
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.encPayload = $util.newBuffer([]);

        /**
         * WebRtcSessionDescription publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.publicKey = $util.newBuffer([]);

        /**
         * WebRtcSessionDescription oneTimePreKeyId.
         * @member {number} oneTimePreKeyId
         * @memberof server.WebRtcSessionDescription
         * @instance
         */
        WebRtcSessionDescription.prototype.oneTimePreKeyId = 0;

        /**
         * Creates a new WebRtcSessionDescription instance using the specified properties.
         * @function create
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription=} [properties] Properties to set
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription instance
         */
        WebRtcSessionDescription.create = function create(properties) {
            return new WebRtcSessionDescription(properties);
        };

        /**
         * Encodes the specified WebRtcSessionDescription message. Does not implicitly {@link server.WebRtcSessionDescription.verify|verify} messages.
         * @function encode
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription} message WebRtcSessionDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebRtcSessionDescription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encPayload != null && Object.hasOwnProperty.call(message, "encPayload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encPayload);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.oneTimePreKeyId);
            return writer;
        };

        /**
         * Encodes the specified WebRtcSessionDescription message, length delimited. Does not implicitly {@link server.WebRtcSessionDescription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.IWebRtcSessionDescription} message WebRtcSessionDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebRtcSessionDescription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebRtcSessionDescription message from the specified reader or buffer.
         * @function decode
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebRtcSessionDescription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WebRtcSessionDescription();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encPayload = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.oneTimePreKeyId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebRtcSessionDescription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebRtcSessionDescription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebRtcSessionDescription message.
         * @function verify
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebRtcSessionDescription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                if (!(message.encPayload && typeof message.encPayload.length === "number" || $util.isString(message.encPayload)))
                    return "encPayload: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId))
                    return "oneTimePreKeyId: integer expected";
            return null;
        };

        /**
         * Creates a WebRtcSessionDescription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WebRtcSessionDescription} WebRtcSessionDescription
         */
        WebRtcSessionDescription.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WebRtcSessionDescription)
                return object;
            var message = new $root.server.WebRtcSessionDescription();
            if (object.encPayload != null)
                if (typeof object.encPayload === "string")
                    $util.base64.decode(object.encPayload, message.encPayload = $util.newBuffer($util.base64.length(object.encPayload)), 0);
                else if (object.encPayload.length)
                    message.encPayload = object.encPayload;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.oneTimePreKeyId != null)
                message.oneTimePreKeyId = object.oneTimePreKeyId | 0;
            return message;
        };

        /**
         * Creates a plain object from a WebRtcSessionDescription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WebRtcSessionDescription
         * @static
         * @param {server.WebRtcSessionDescription} message WebRtcSessionDescription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebRtcSessionDescription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encPayload = "";
                else {
                    object.encPayload = [];
                    if (options.bytes !== Array)
                        object.encPayload = $util.newBuffer(object.encPayload);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.oneTimePreKeyId = 0;
            }
            if (message.encPayload != null && message.hasOwnProperty("encPayload"))
                object.encPayload = options.bytes === String ? $util.base64.encode(message.encPayload, 0, message.encPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encPayload) : message.encPayload;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                object.oneTimePreKeyId = message.oneTimePreKeyId;
            return object;
        };

        /**
         * Converts this WebRtcSessionDescription to JSON.
         * @function toJSON
         * @memberof server.WebRtcSessionDescription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebRtcSessionDescription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebRtcSessionDescription;
    })();

    server.IncomingCallPush = (function() {

        /**
         * Properties of an IncomingCallPush.
         * @memberof server
         * @interface IIncomingCallPush
         * @property {string|null} [callId] IncomingCallPush callId
         * @property {server.CallType|null} [callType] IncomingCallPush callType
         * @property {Array.<server.IStunServer>|null} [stunServers] IncomingCallPush stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] IncomingCallPush turnServers
         * @property {number|Long|null} [timestampMs] IncomingCallPush timestampMs
         * @property {server.ICallConfig|null} [callConfig] IncomingCallPush callConfig
         * @property {server.ICallCapabilities|null} [callCapabilities] IncomingCallPush callCapabilities
         */

        /**
         * Constructs a new IncomingCallPush.
         * @memberof server
         * @classdesc Represents an IncomingCallPush.
         * @implements IIncomingCallPush
         * @constructor
         * @param {server.IIncomingCallPush=} [properties] Properties to set
         */
        function IncomingCallPush(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingCallPush callId.
         * @member {string} callId
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callId = "";

        /**
         * IncomingCallPush callType.
         * @member {server.CallType} callType
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callType = 0;

        /**
         * IncomingCallPush stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.stunServers = $util.emptyArray;

        /**
         * IncomingCallPush turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.turnServers = $util.emptyArray;

        /**
         * IncomingCallPush timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCallPush callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callConfig = null;

        /**
         * IncomingCallPush callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.IncomingCallPush
         * @instance
         */
        IncomingCallPush.prototype.callCapabilities = null;

        /**
         * Creates a new IncomingCallPush instance using the specified properties.
         * @function create
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush=} [properties] Properties to set
         * @returns {server.IncomingCallPush} IncomingCallPush instance
         */
        IncomingCallPush.create = function create(properties) {
            return new IncomingCallPush(properties);
        };

        /**
         * Encodes the specified IncomingCallPush message. Does not implicitly {@link server.IncomingCallPush.verify|verify} messages.
         * @function encode
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush} message IncomingCallPush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCallPush.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.callType);
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestampMs);
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IncomingCallPush message, length delimited. Does not implicitly {@link server.IncomingCallPush.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IIncomingCallPush} message IncomingCallPush message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCallPush.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncomingCallPush message from the specified reader or buffer.
         * @function decode
         * @memberof server.IncomingCallPush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IncomingCallPush} IncomingCallPush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCallPush.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IncomingCallPush();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.callType = reader.int32();
                    break;
                case 3:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.timestampMs = reader.int64();
                    break;
                case 6:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IncomingCallPush message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IncomingCallPush
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IncomingCallPush} IncomingCallPush
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCallPush.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncomingCallPush message.
         * @function verify
         * @memberof server.IncomingCallPush
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncomingCallPush.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates an IncomingCallPush message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IncomingCallPush
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IncomingCallPush} IncomingCallPush
         */
        IncomingCallPush.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IncomingCallPush)
                return object;
            var message = new $root.server.IncomingCallPush();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.IncomingCallPush.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.IncomingCallPush.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.IncomingCallPush.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.IncomingCallPush.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.IncomingCallPush.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.IncomingCallPush.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from an IncomingCallPush message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IncomingCallPush
         * @static
         * @param {server.IncomingCallPush} message IncomingCallPush
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncomingCallPush.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.callId = "";
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.callConfig = null;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this IncomingCallPush to JSON.
         * @function toJSON
         * @memberof server.IncomingCallPush
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncomingCallPush.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IncomingCallPush;
    })();

    server.IncomingCall = (function() {

        /**
         * Properties of an IncomingCall.
         * @memberof server
         * @interface IIncomingCall
         * @property {string|null} [callId] IncomingCall callId
         * @property {server.CallType|null} [callType] IncomingCall callType
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] IncomingCall webrtcOffer
         * @property {Array.<server.IStunServer>|null} [stunServers] IncomingCall stunServers
         * @property {Array.<server.ITurnServer>|null} [turnServers] IncomingCall turnServers
         * @property {number|Long|null} [timestampMs] IncomingCall timestampMs
         * @property {number|Long|null} [serverSentTsMs] IncomingCall serverSentTsMs
         * @property {server.ICallConfig|null} [callConfig] IncomingCall callConfig
         * @property {server.ICallCapabilities|null} [callCapabilities] IncomingCall callCapabilities
         */

        /**
         * Constructs a new IncomingCall.
         * @memberof server
         * @classdesc Represents an IncomingCall.
         * @implements IIncomingCall
         * @constructor
         * @param {server.IIncomingCall=} [properties] Properties to set
         */
        function IncomingCall(properties) {
            this.stunServers = [];
            this.turnServers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingCall callId.
         * @member {string} callId
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callId = "";

        /**
         * IncomingCall callType.
         * @member {server.CallType} callType
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callType = 0;

        /**
         * IncomingCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.webrtcOffer = null;

        /**
         * IncomingCall stunServers.
         * @member {Array.<server.IStunServer>} stunServers
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.stunServers = $util.emptyArray;

        /**
         * IncomingCall turnServers.
         * @member {Array.<server.ITurnServer>} turnServers
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.turnServers = $util.emptyArray;

        /**
         * IncomingCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCall serverSentTsMs.
         * @member {number|Long} serverSentTsMs
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.serverSentTsMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IncomingCall callConfig.
         * @member {server.ICallConfig|null|undefined} callConfig
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callConfig = null;

        /**
         * IncomingCall callCapabilities.
         * @member {server.ICallCapabilities|null|undefined} callCapabilities
         * @memberof server.IncomingCall
         * @instance
         */
        IncomingCall.prototype.callCapabilities = null;

        /**
         * Creates a new IncomingCall instance using the specified properties.
         * @function create
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall=} [properties] Properties to set
         * @returns {server.IncomingCall} IncomingCall instance
         */
        IncomingCall.create = function create(properties) {
            return new IncomingCall(properties);
        };

        /**
         * Encodes the specified IncomingCall message. Does not implicitly {@link server.IncomingCall.verify|verify} messages.
         * @function encode
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall} message IncomingCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.callType != null && Object.hasOwnProperty.call(message, "callType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.callType);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stunServers != null && message.stunServers.length)
                for (var i = 0; i < message.stunServers.length; ++i)
                    $root.server.StunServer.encode(message.stunServers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.turnServers != null && message.turnServers.length)
                for (var i = 0; i < message.turnServers.length; ++i)
                    $root.server.TurnServer.encode(message.turnServers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestampMs);
            if (message.serverSentTsMs != null && Object.hasOwnProperty.call(message, "serverSentTsMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.serverSentTsMs);
            if (message.callConfig != null && Object.hasOwnProperty.call(message, "callConfig"))
                $root.server.CallConfig.encode(message.callConfig, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.callCapabilities != null && Object.hasOwnProperty.call(message, "callCapabilities"))
                $root.server.CallCapabilities.encode(message.callCapabilities, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IncomingCall message, length delimited. Does not implicitly {@link server.IncomingCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IncomingCall
         * @static
         * @param {server.IIncomingCall} message IncomingCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncomingCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.IncomingCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IncomingCall} IncomingCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IncomingCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.callType = reader.int32();
                    break;
                case 3:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.stunServers && message.stunServers.length))
                        message.stunServers = [];
                    message.stunServers.push($root.server.StunServer.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.turnServers && message.turnServers.length))
                        message.turnServers = [];
                    message.turnServers.push($root.server.TurnServer.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timestampMs = reader.int64();
                    break;
                case 7:
                    message.serverSentTsMs = reader.int64();
                    break;
                case 8:
                    message.callConfig = $root.server.CallConfig.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.callCapabilities = $root.server.CallCapabilities.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IncomingCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IncomingCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IncomingCall} IncomingCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncomingCall message.
         * @function verify
         * @memberof server.IncomingCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncomingCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.callType != null && message.hasOwnProperty("callType"))
                switch (message.callType) {
                default:
                    return "callType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            if (message.stunServers != null && message.hasOwnProperty("stunServers")) {
                if (!Array.isArray(message.stunServers))
                    return "stunServers: array expected";
                for (var i = 0; i < message.stunServers.length; ++i) {
                    var error = $root.server.StunServer.verify(message.stunServers[i]);
                    if (error)
                        return "stunServers." + error;
                }
            }
            if (message.turnServers != null && message.hasOwnProperty("turnServers")) {
                if (!Array.isArray(message.turnServers))
                    return "turnServers: array expected";
                for (var i = 0; i < message.turnServers.length; ++i) {
                    var error = $root.server.TurnServer.verify(message.turnServers[i]);
                    if (error)
                        return "turnServers." + error;
                }
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.serverSentTsMs != null && message.hasOwnProperty("serverSentTsMs"))
                if (!$util.isInteger(message.serverSentTsMs) && !(message.serverSentTsMs && $util.isInteger(message.serverSentTsMs.low) && $util.isInteger(message.serverSentTsMs.high)))
                    return "serverSentTsMs: integer|Long expected";
            if (message.callConfig != null && message.hasOwnProperty("callConfig")) {
                var error = $root.server.CallConfig.verify(message.callConfig);
                if (error)
                    return "callConfig." + error;
            }
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities")) {
                var error = $root.server.CallCapabilities.verify(message.callCapabilities);
                if (error)
                    return "callCapabilities." + error;
            }
            return null;
        };

        /**
         * Creates an IncomingCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IncomingCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IncomingCall} IncomingCall
         */
        IncomingCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IncomingCall)
                return object;
            var message = new $root.server.IncomingCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.callType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.callType = 0;
                break;
            case "AUDIO":
            case 1:
                message.callType = 1;
                break;
            case "VIDEO":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.IncomingCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            if (object.stunServers) {
                if (!Array.isArray(object.stunServers))
                    throw TypeError(".server.IncomingCall.stunServers: array expected");
                message.stunServers = [];
                for (var i = 0; i < object.stunServers.length; ++i) {
                    if (typeof object.stunServers[i] !== "object")
                        throw TypeError(".server.IncomingCall.stunServers: object expected");
                    message.stunServers[i] = $root.server.StunServer.fromObject(object.stunServers[i]);
                }
            }
            if (object.turnServers) {
                if (!Array.isArray(object.turnServers))
                    throw TypeError(".server.IncomingCall.turnServers: array expected");
                message.turnServers = [];
                for (var i = 0; i < object.turnServers.length; ++i) {
                    if (typeof object.turnServers[i] !== "object")
                        throw TypeError(".server.IncomingCall.turnServers: object expected");
                    message.turnServers[i] = $root.server.TurnServer.fromObject(object.turnServers[i]);
                }
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.serverSentTsMs != null)
                if ($util.Long)
                    (message.serverSentTsMs = $util.Long.fromValue(object.serverSentTsMs)).unsigned = false;
                else if (typeof object.serverSentTsMs === "string")
                    message.serverSentTsMs = parseInt(object.serverSentTsMs, 10);
                else if (typeof object.serverSentTsMs === "number")
                    message.serverSentTsMs = object.serverSentTsMs;
                else if (typeof object.serverSentTsMs === "object")
                    message.serverSentTsMs = new $util.LongBits(object.serverSentTsMs.low >>> 0, object.serverSentTsMs.high >>> 0).toNumber();
            if (object.callConfig != null) {
                if (typeof object.callConfig !== "object")
                    throw TypeError(".server.IncomingCall.callConfig: object expected");
                message.callConfig = $root.server.CallConfig.fromObject(object.callConfig);
            }
            if (object.callCapabilities != null) {
                if (typeof object.callCapabilities !== "object")
                    throw TypeError(".server.IncomingCall.callCapabilities: object expected");
                message.callCapabilities = $root.server.CallCapabilities.fromObject(object.callCapabilities);
            }
            return message;
        };

        /**
         * Creates a plain object from an IncomingCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IncomingCall
         * @static
         * @param {server.IncomingCall} message IncomingCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncomingCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.stunServers = [];
                object.turnServers = [];
            }
            if (options.defaults) {
                object.callId = "";
                object.callType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.webrtcOffer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.serverSentTsMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serverSentTsMs = options.longs === String ? "0" : 0;
                object.callConfig = null;
                object.callCapabilities = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.callType != null && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.server.CallType[message.callType] : message.callType;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            if (message.stunServers && message.stunServers.length) {
                object.stunServers = [];
                for (var j = 0; j < message.stunServers.length; ++j)
                    object.stunServers[j] = $root.server.StunServer.toObject(message.stunServers[j], options);
            }
            if (message.turnServers && message.turnServers.length) {
                object.turnServers = [];
                for (var j = 0; j < message.turnServers.length; ++j)
                    object.turnServers[j] = $root.server.TurnServer.toObject(message.turnServers[j], options);
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.serverSentTsMs != null && message.hasOwnProperty("serverSentTsMs"))
                if (typeof message.serverSentTsMs === "number")
                    object.serverSentTsMs = options.longs === String ? String(message.serverSentTsMs) : message.serverSentTsMs;
                else
                    object.serverSentTsMs = options.longs === String ? $util.Long.prototype.toString.call(message.serverSentTsMs) : options.longs === Number ? new $util.LongBits(message.serverSentTsMs.low >>> 0, message.serverSentTsMs.high >>> 0).toNumber() : message.serverSentTsMs;
            if (message.callConfig != null && message.hasOwnProperty("callConfig"))
                object.callConfig = $root.server.CallConfig.toObject(message.callConfig, options);
            if (message.callCapabilities != null && message.hasOwnProperty("callCapabilities"))
                object.callCapabilities = $root.server.CallCapabilities.toObject(message.callCapabilities, options);
            return object;
        };

        /**
         * Converts this IncomingCall to JSON.
         * @function toJSON
         * @memberof server.IncomingCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncomingCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IncomingCall;
    })();

    server.IceCandidate = (function() {

        /**
         * Properties of an IceCandidate.
         * @memberof server
         * @interface IIceCandidate
         * @property {string|null} [callId] IceCandidate callId
         * @property {string|null} [sdpMediaId] IceCandidate sdpMediaId
         * @property {number|null} [sdpMediaLineIndex] IceCandidate sdpMediaLineIndex
         * @property {string|null} [sdp] IceCandidate sdp
         */

        /**
         * Constructs a new IceCandidate.
         * @memberof server
         * @classdesc Represents an IceCandidate.
         * @implements IIceCandidate
         * @constructor
         * @param {server.IIceCandidate=} [properties] Properties to set
         */
        function IceCandidate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceCandidate callId.
         * @member {string} callId
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.callId = "";

        /**
         * IceCandidate sdpMediaId.
         * @member {string} sdpMediaId
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdpMediaId = "";

        /**
         * IceCandidate sdpMediaLineIndex.
         * @member {number} sdpMediaLineIndex
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdpMediaLineIndex = 0;

        /**
         * IceCandidate sdp.
         * @member {string} sdp
         * @memberof server.IceCandidate
         * @instance
         */
        IceCandidate.prototype.sdp = "";

        /**
         * Creates a new IceCandidate instance using the specified properties.
         * @function create
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate=} [properties] Properties to set
         * @returns {server.IceCandidate} IceCandidate instance
         */
        IceCandidate.create = function create(properties) {
            return new IceCandidate(properties);
        };

        /**
         * Encodes the specified IceCandidate message. Does not implicitly {@link server.IceCandidate.verify|verify} messages.
         * @function encode
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.sdpMediaId != null && Object.hasOwnProperty.call(message, "sdpMediaId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sdpMediaId);
            if (message.sdpMediaLineIndex != null && Object.hasOwnProperty.call(message, "sdpMediaLineIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sdpMediaLineIndex);
            if (message.sdp != null && Object.hasOwnProperty.call(message, "sdp"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sdp);
            return writer;
        };

        /**
         * Encodes the specified IceCandidate message, length delimited. Does not implicitly {@link server.IceCandidate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceCandidate
         * @static
         * @param {server.IIceCandidate} message IceCandidate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceCandidate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceCandidate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.sdpMediaId = reader.string();
                    break;
                case 3:
                    message.sdpMediaLineIndex = reader.int32();
                    break;
                case 4:
                    message.sdp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceCandidate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceCandidate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceCandidate} IceCandidate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceCandidate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceCandidate message.
         * @function verify
         * @memberof server.IceCandidate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceCandidate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.sdpMediaId != null && message.hasOwnProperty("sdpMediaId"))
                if (!$util.isString(message.sdpMediaId))
                    return "sdpMediaId: string expected";
            if (message.sdpMediaLineIndex != null && message.hasOwnProperty("sdpMediaLineIndex"))
                if (!$util.isInteger(message.sdpMediaLineIndex))
                    return "sdpMediaLineIndex: integer expected";
            if (message.sdp != null && message.hasOwnProperty("sdp"))
                if (!$util.isString(message.sdp))
                    return "sdp: string expected";
            return null;
        };

        /**
         * Creates an IceCandidate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceCandidate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceCandidate} IceCandidate
         */
        IceCandidate.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceCandidate)
                return object;
            var message = new $root.server.IceCandidate();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.sdpMediaId != null)
                message.sdpMediaId = String(object.sdpMediaId);
            if (object.sdpMediaLineIndex != null)
                message.sdpMediaLineIndex = object.sdpMediaLineIndex | 0;
            if (object.sdp != null)
                message.sdp = String(object.sdp);
            return message;
        };

        /**
         * Creates a plain object from an IceCandidate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceCandidate
         * @static
         * @param {server.IceCandidate} message IceCandidate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceCandidate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.sdpMediaId = "";
                object.sdpMediaLineIndex = 0;
                object.sdp = "";
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.sdpMediaId != null && message.hasOwnProperty("sdpMediaId"))
                object.sdpMediaId = message.sdpMediaId;
            if (message.sdpMediaLineIndex != null && message.hasOwnProperty("sdpMediaLineIndex"))
                object.sdpMediaLineIndex = message.sdpMediaLineIndex;
            if (message.sdp != null && message.hasOwnProperty("sdp"))
                object.sdp = message.sdp;
            return object;
        };

        /**
         * Converts this IceCandidate to JSON.
         * @function toJSON
         * @memberof server.IceCandidate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceCandidate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceCandidate;
    })();

    server.CallRinging = (function() {

        /**
         * Properties of a CallRinging.
         * @memberof server
         * @interface ICallRinging
         * @property {string|null} [callId] CallRinging callId
         * @property {number|Long|null} [timestampMs] CallRinging timestampMs
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] CallRinging webrtcAnswer
         */

        /**
         * Constructs a new CallRinging.
         * @memberof server
         * @classdesc Represents a CallRinging.
         * @implements ICallRinging
         * @constructor
         * @param {server.ICallRinging=} [properties] Properties to set
         */
        function CallRinging(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallRinging callId.
         * @member {string} callId
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.callId = "";

        /**
         * CallRinging timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CallRinging webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.CallRinging
         * @instance
         */
        CallRinging.prototype.webrtcAnswer = null;

        /**
         * Creates a new CallRinging instance using the specified properties.
         * @function create
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging=} [properties] Properties to set
         * @returns {server.CallRinging} CallRinging instance
         */
        CallRinging.create = function create(properties) {
            return new CallRinging(properties);
        };

        /**
         * Encodes the specified CallRinging message. Does not implicitly {@link server.CallRinging.verify|verify} messages.
         * @function encode
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging} message CallRinging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallRinging.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestampMs);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CallRinging message, length delimited. Does not implicitly {@link server.CallRinging.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallRinging
         * @static
         * @param {server.ICallRinging} message CallRinging message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallRinging.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallRinging message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallRinging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallRinging} CallRinging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallRinging.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallRinging();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.timestampMs = reader.int64();
                    break;
                case 3:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallRinging message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallRinging
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallRinging} CallRinging
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallRinging.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallRinging message.
         * @function verify
         * @memberof server.CallRinging
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallRinging.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            return null;
        };

        /**
         * Creates a CallRinging message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallRinging
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallRinging} CallRinging
         */
        CallRinging.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallRinging)
                return object;
            var message = new $root.server.CallRinging();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.CallRinging.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallRinging message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallRinging
         * @static
         * @param {server.CallRinging} message CallRinging
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallRinging.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.webrtcAnswer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            return object;
        };

        /**
         * Converts this CallRinging to JSON.
         * @function toJSON
         * @memberof server.CallRinging
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallRinging.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallRinging;
    })();

    server.PreAnswerCall = (function() {

        /**
         * Properties of a PreAnswerCall.
         * @memberof server
         * @interface IPreAnswerCall
         * @property {string|null} [callId] PreAnswerCall callId
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] PreAnswerCall webrtcAnswer
         * @property {number|Long|null} [timestampMs] PreAnswerCall timestampMs
         */

        /**
         * Constructs a new PreAnswerCall.
         * @memberof server
         * @classdesc Represents a PreAnswerCall.
         * @implements IPreAnswerCall
         * @constructor
         * @param {server.IPreAnswerCall=} [properties] Properties to set
         */
        function PreAnswerCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreAnswerCall callId.
         * @member {string} callId
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.callId = "";

        /**
         * PreAnswerCall webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.webrtcAnswer = null;

        /**
         * PreAnswerCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.PreAnswerCall
         * @instance
         */
        PreAnswerCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PreAnswerCall instance using the specified properties.
         * @function create
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall=} [properties] Properties to set
         * @returns {server.PreAnswerCall} PreAnswerCall instance
         */
        PreAnswerCall.create = function create(properties) {
            return new PreAnswerCall(properties);
        };

        /**
         * Encodes the specified PreAnswerCall message. Does not implicitly {@link server.PreAnswerCall.verify|verify} messages.
         * @function encode
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall} message PreAnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAnswerCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified PreAnswerCall message, length delimited. Does not implicitly {@link server.PreAnswerCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.IPreAnswerCall} message PreAnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreAnswerCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreAnswerCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.PreAnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PreAnswerCall} PreAnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAnswerCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PreAnswerCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreAnswerCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PreAnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PreAnswerCall} PreAnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreAnswerCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreAnswerCall message.
         * @function verify
         * @memberof server.PreAnswerCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreAnswerCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a PreAnswerCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PreAnswerCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PreAnswerCall} PreAnswerCall
         */
        PreAnswerCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PreAnswerCall)
                return object;
            var message = new $root.server.PreAnswerCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.PreAnswerCall.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PreAnswerCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PreAnswerCall
         * @static
         * @param {server.PreAnswerCall} message PreAnswerCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreAnswerCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.webrtcAnswer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this PreAnswerCall to JSON.
         * @function toJSON
         * @memberof server.PreAnswerCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreAnswerCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreAnswerCall;
    })();

    server.AnswerCall = (function() {

        /**
         * Properties of an AnswerCall.
         * @memberof server
         * @interface IAnswerCall
         * @property {string|null} [callId] AnswerCall callId
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] AnswerCall webrtcAnswer
         * @property {number|Long|null} [timestampMs] AnswerCall timestampMs
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] AnswerCall webrtcOffer
         */

        /**
         * Constructs a new AnswerCall.
         * @memberof server
         * @classdesc Represents an AnswerCall.
         * @implements IAnswerCall
         * @constructor
         * @param {server.IAnswerCall=} [properties] Properties to set
         */
        function AnswerCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnswerCall callId.
         * @member {string} callId
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.callId = "";

        /**
         * AnswerCall webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.webrtcAnswer = null;

        /**
         * AnswerCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnswerCall webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.AnswerCall
         * @instance
         */
        AnswerCall.prototype.webrtcOffer = null;

        /**
         * Creates a new AnswerCall instance using the specified properties.
         * @function create
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall=} [properties] Properties to set
         * @returns {server.AnswerCall} AnswerCall instance
         */
        AnswerCall.create = function create(properties) {
            return new AnswerCall(properties);
        };

        /**
         * Encodes the specified AnswerCall message. Does not implicitly {@link server.AnswerCall.verify|verify} messages.
         * @function encode
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall} message AnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnswerCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AnswerCall message, length delimited. Does not implicitly {@link server.AnswerCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.AnswerCall
         * @static
         * @param {server.IAnswerCall} message AnswerCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnswerCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnswerCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.AnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.AnswerCall} AnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnswerCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.AnswerCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                case 4:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnswerCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.AnswerCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.AnswerCall} AnswerCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnswerCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnswerCall message.
         * @function verify
         * @memberof server.AnswerCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnswerCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            return null;
        };

        /**
         * Creates an AnswerCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.AnswerCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.AnswerCall} AnswerCall
         */
        AnswerCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.AnswerCall)
                return object;
            var message = new $root.server.AnswerCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.AnswerCall.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.AnswerCall.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            return message;
        };

        /**
         * Creates a plain object from an AnswerCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.AnswerCall
         * @static
         * @param {server.AnswerCall} message AnswerCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnswerCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.webrtcAnswer = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.webrtcOffer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            return object;
        };

        /**
         * Converts this AnswerCall to JSON.
         * @function toJSON
         * @memberof server.AnswerCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnswerCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnswerCall;
    })();

    server.CallSdp = (function() {

        /**
         * Properties of a CallSdp.
         * @memberof server
         * @interface ICallSdp
         * @property {string|null} [callId] CallSdp callId
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] CallSdp webrtcOffer
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] CallSdp webrtcAnswer
         */

        /**
         * Constructs a new CallSdp.
         * @memberof server
         * @classdesc Represents a CallSdp.
         * @implements ICallSdp
         * @constructor
         * @param {server.ICallSdp=} [properties] Properties to set
         */
        function CallSdp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallSdp callId.
         * @member {string} callId
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.callId = "";

        /**
         * CallSdp webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.webrtcOffer = null;

        /**
         * CallSdp webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.CallSdp
         * @instance
         */
        CallSdp.prototype.webrtcAnswer = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * CallSdp sdp.
         * @member {"webrtcOffer"|"webrtcAnswer"|undefined} sdp
         * @memberof server.CallSdp
         * @instance
         */
        Object.defineProperty(CallSdp.prototype, "sdp", {
            get: $util.oneOfGetter($oneOfFields = ["webrtcOffer", "webrtcAnswer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CallSdp instance using the specified properties.
         * @function create
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp=} [properties] Properties to set
         * @returns {server.CallSdp} CallSdp instance
         */
        CallSdp.create = function create(properties) {
            return new CallSdp(properties);
        };

        /**
         * Encodes the specified CallSdp message. Does not implicitly {@link server.CallSdp.verify|verify} messages.
         * @function encode
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp} message CallSdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallSdp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CallSdp message, length delimited. Does not implicitly {@link server.CallSdp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallSdp
         * @static
         * @param {server.ICallSdp} message CallSdp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallSdp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallSdp message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallSdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallSdp} CallSdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallSdp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallSdp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallSdp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallSdp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallSdp} CallSdp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallSdp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallSdp message.
         * @function verify
         * @memberof server.CallSdp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallSdp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                properties.sdp = 1;
                {
                    var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                    if (error)
                        return "webrtcOffer." + error;
                }
            }
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                if (properties.sdp === 1)
                    return "sdp: multiple values";
                properties.sdp = 1;
                {
                    var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                    if (error)
                        return "webrtcAnswer." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CallSdp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallSdp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallSdp} CallSdp
         */
        CallSdp.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallSdp)
                return object;
            var message = new $root.server.CallSdp();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.CallSdp.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.CallSdp.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallSdp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallSdp
         * @static
         * @param {server.CallSdp} message CallSdp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallSdp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.callId = "";
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
                if (options.oneofs)
                    object.sdp = "webrtcOffer";
            }
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
                if (options.oneofs)
                    object.sdp = "webrtcAnswer";
            }
            return object;
        };

        /**
         * Converts this CallSdp to JSON.
         * @function toJSON
         * @memberof server.CallSdp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallSdp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallSdp;
    })();

    server.EndCall = (function() {

        /**
         * Properties of an EndCall.
         * @memberof server
         * @interface IEndCall
         * @property {string|null} [callId] EndCall callId
         * @property {server.EndCall.Reason|null} [reason] EndCall reason
         * @property {number|Long|null} [timestampMs] EndCall timestampMs
         */

        /**
         * Constructs a new EndCall.
         * @memberof server
         * @classdesc Represents an EndCall.
         * @implements IEndCall
         * @constructor
         * @param {server.IEndCall=} [properties] Properties to set
         */
        function EndCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EndCall callId.
         * @member {string} callId
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.callId = "";

        /**
         * EndCall reason.
         * @member {server.EndCall.Reason} reason
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.reason = 0;

        /**
         * EndCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.EndCall
         * @instance
         */
        EndCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EndCall instance using the specified properties.
         * @function create
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall=} [properties] Properties to set
         * @returns {server.EndCall} EndCall instance
         */
        EndCall.create = function create(properties) {
            return new EndCall(properties);
        };

        /**
         * Encodes the specified EndCall message. Does not implicitly {@link server.EndCall.verify|verify} messages.
         * @function encode
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall} message EndCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified EndCall message, length delimited. Does not implicitly {@link server.EndCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EndCall
         * @static
         * @param {server.IEndCall} message EndCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EndCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.EndCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EndCall} EndCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EndCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EndCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EndCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EndCall} EndCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EndCall message.
         * @function verify
         * @memberof server.EndCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EndCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates an EndCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EndCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EndCall} EndCall
         */
        EndCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EndCall)
                return object;
            var message = new $root.server.EndCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.reason) {
            case "UNKNOWN":
            case 0:
                message.reason = 0;
                break;
            case "REJECT":
            case 1:
                message.reason = 1;
                break;
            case "BUSY":
            case 2:
                message.reason = 2;
                break;
            case "TIMEOUT":
            case 3:
                message.reason = 3;
                break;
            case "CALL_END":
            case 4:
                message.reason = 4;
                break;
            case "CANCEL":
            case 5:
                message.reason = 5;
                break;
            case "DECRYPTION_FAILED":
            case 6:
                message.reason = 6;
                break;
            case "ENCRYPTION_FAILED":
            case 7:
                message.reason = 7;
                break;
            case "SYSTEM_ERROR":
            case 8:
                message.reason = 8;
                break;
            case "VIDEO_UNSUPPORTED":
            case 9:
                message.reason = 9;
                break;
            case "CONNECTION_ERROR":
            case 10:
                message.reason = 10;
                break;
            }
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EndCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EndCall
         * @static
         * @param {server.EndCall} message EndCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EndCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.reason = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.EndCall.Reason[message.reason] : message.reason;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this EndCall to JSON.
         * @function toJSON
         * @memberof server.EndCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EndCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.EndCall.Reason
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REJECT=1 REJECT value
         * @property {number} BUSY=2 BUSY value
         * @property {number} TIMEOUT=3 TIMEOUT value
         * @property {number} CALL_END=4 CALL_END value
         * @property {number} CANCEL=5 CANCEL value
         * @property {number} DECRYPTION_FAILED=6 DECRYPTION_FAILED value
         * @property {number} ENCRYPTION_FAILED=7 ENCRYPTION_FAILED value
         * @property {number} SYSTEM_ERROR=8 SYSTEM_ERROR value
         * @property {number} VIDEO_UNSUPPORTED=9 VIDEO_UNSUPPORTED value
         * @property {number} CONNECTION_ERROR=10 CONNECTION_ERROR value
         */
        EndCall.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REJECT"] = 1;
            values[valuesById[2] = "BUSY"] = 2;
            values[valuesById[3] = "TIMEOUT"] = 3;
            values[valuesById[4] = "CALL_END"] = 4;
            values[valuesById[5] = "CANCEL"] = 5;
            values[valuesById[6] = "DECRYPTION_FAILED"] = 6;
            values[valuesById[7] = "ENCRYPTION_FAILED"] = 7;
            values[valuesById[8] = "SYSTEM_ERROR"] = 8;
            values[valuesById[9] = "VIDEO_UNSUPPORTED"] = 9;
            values[valuesById[10] = "CONNECTION_ERROR"] = 10;
            return values;
        })();

        return EndCall;
    })();

    server.IceRestartOffer = (function() {

        /**
         * Properties of an IceRestartOffer.
         * @memberof server
         * @interface IIceRestartOffer
         * @property {string|null} [callId] IceRestartOffer callId
         * @property {number|null} [idx] IceRestartOffer idx
         * @property {server.IWebRtcSessionDescription|null} [webrtcOffer] IceRestartOffer webrtcOffer
         */

        /**
         * Constructs a new IceRestartOffer.
         * @memberof server
         * @classdesc Represents an IceRestartOffer.
         * @implements IIceRestartOffer
         * @constructor
         * @param {server.IIceRestartOffer=} [properties] Properties to set
         */
        function IceRestartOffer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceRestartOffer callId.
         * @member {string} callId
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.callId = "";

        /**
         * IceRestartOffer idx.
         * @member {number} idx
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.idx = 0;

        /**
         * IceRestartOffer webrtcOffer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcOffer
         * @memberof server.IceRestartOffer
         * @instance
         */
        IceRestartOffer.prototype.webrtcOffer = null;

        /**
         * Creates a new IceRestartOffer instance using the specified properties.
         * @function create
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer=} [properties] Properties to set
         * @returns {server.IceRestartOffer} IceRestartOffer instance
         */
        IceRestartOffer.create = function create(properties) {
            return new IceRestartOffer(properties);
        };

        /**
         * Encodes the specified IceRestartOffer message. Does not implicitly {@link server.IceRestartOffer.verify|verify} messages.
         * @function encode
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer} message IceRestartOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.idx);
            if (message.webrtcOffer != null && Object.hasOwnProperty.call(message, "webrtcOffer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcOffer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IceRestartOffer message, length delimited. Does not implicitly {@link server.IceRestartOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IIceRestartOffer} message IceRestartOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceRestartOffer message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceRestartOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceRestartOffer} IceRestartOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceRestartOffer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.idx = reader.int32();
                    break;
                case 3:
                    message.webrtcOffer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceRestartOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceRestartOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceRestartOffer} IceRestartOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceRestartOffer message.
         * @function verify
         * @memberof server.IceRestartOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceRestartOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcOffer);
                if (error)
                    return "webrtcOffer." + error;
            }
            return null;
        };

        /**
         * Creates an IceRestartOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceRestartOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceRestartOffer} IceRestartOffer
         */
        IceRestartOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceRestartOffer)
                return object;
            var message = new $root.server.IceRestartOffer();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.webrtcOffer != null) {
                if (typeof object.webrtcOffer !== "object")
                    throw TypeError(".server.IceRestartOffer.webrtcOffer: object expected");
                message.webrtcOffer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcOffer);
            }
            return message;
        };

        /**
         * Creates a plain object from an IceRestartOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceRestartOffer
         * @static
         * @param {server.IceRestartOffer} message IceRestartOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceRestartOffer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.idx = 0;
                object.webrtcOffer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.webrtcOffer != null && message.hasOwnProperty("webrtcOffer"))
                object.webrtcOffer = $root.server.WebRtcSessionDescription.toObject(message.webrtcOffer, options);
            return object;
        };

        /**
         * Converts this IceRestartOffer to JSON.
         * @function toJSON
         * @memberof server.IceRestartOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceRestartOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceRestartOffer;
    })();

    server.IceRestartAnswer = (function() {

        /**
         * Properties of an IceRestartAnswer.
         * @memberof server
         * @interface IIceRestartAnswer
         * @property {string|null} [callId] IceRestartAnswer callId
         * @property {number|null} [idx] IceRestartAnswer idx
         * @property {server.IWebRtcSessionDescription|null} [webrtcAnswer] IceRestartAnswer webrtcAnswer
         */

        /**
         * Constructs a new IceRestartAnswer.
         * @memberof server
         * @classdesc Represents an IceRestartAnswer.
         * @implements IIceRestartAnswer
         * @constructor
         * @param {server.IIceRestartAnswer=} [properties] Properties to set
         */
        function IceRestartAnswer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IceRestartAnswer callId.
         * @member {string} callId
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.callId = "";

        /**
         * IceRestartAnswer idx.
         * @member {number} idx
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.idx = 0;

        /**
         * IceRestartAnswer webrtcAnswer.
         * @member {server.IWebRtcSessionDescription|null|undefined} webrtcAnswer
         * @memberof server.IceRestartAnswer
         * @instance
         */
        IceRestartAnswer.prototype.webrtcAnswer = null;

        /**
         * Creates a new IceRestartAnswer instance using the specified properties.
         * @function create
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer=} [properties] Properties to set
         * @returns {server.IceRestartAnswer} IceRestartAnswer instance
         */
        IceRestartAnswer.create = function create(properties) {
            return new IceRestartAnswer(properties);
        };

        /**
         * Encodes the specified IceRestartAnswer message. Does not implicitly {@link server.IceRestartAnswer.verify|verify} messages.
         * @function encode
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer} message IceRestartAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartAnswer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.idx);
            if (message.webrtcAnswer != null && Object.hasOwnProperty.call(message, "webrtcAnswer"))
                $root.server.WebRtcSessionDescription.encode(message.webrtcAnswer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IceRestartAnswer message, length delimited. Does not implicitly {@link server.IceRestartAnswer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IIceRestartAnswer} message IceRestartAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IceRestartAnswer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IceRestartAnswer message from the specified reader or buffer.
         * @function decode
         * @memberof server.IceRestartAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartAnswer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IceRestartAnswer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.idx = reader.int32();
                    break;
                case 3:
                    message.webrtcAnswer = $root.server.WebRtcSessionDescription.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IceRestartAnswer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IceRestartAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IceRestartAnswer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IceRestartAnswer message.
         * @function verify
         * @memberof server.IceRestartAnswer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IceRestartAnswer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer")) {
                var error = $root.server.WebRtcSessionDescription.verify(message.webrtcAnswer);
                if (error)
                    return "webrtcAnswer." + error;
            }
            return null;
        };

        /**
         * Creates an IceRestartAnswer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IceRestartAnswer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IceRestartAnswer} IceRestartAnswer
         */
        IceRestartAnswer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IceRestartAnswer)
                return object;
            var message = new $root.server.IceRestartAnswer();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.webrtcAnswer != null) {
                if (typeof object.webrtcAnswer !== "object")
                    throw TypeError(".server.IceRestartAnswer.webrtcAnswer: object expected");
                message.webrtcAnswer = $root.server.WebRtcSessionDescription.fromObject(object.webrtcAnswer);
            }
            return message;
        };

        /**
         * Creates a plain object from an IceRestartAnswer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IceRestartAnswer
         * @static
         * @param {server.IceRestartAnswer} message IceRestartAnswer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IceRestartAnswer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.idx = 0;
                object.webrtcAnswer = null;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.webrtcAnswer != null && message.hasOwnProperty("webrtcAnswer"))
                object.webrtcAnswer = $root.server.WebRtcSessionDescription.toObject(message.webrtcAnswer, options);
            return object;
        };

        /**
         * Converts this IceRestartAnswer to JSON.
         * @function toJSON
         * @memberof server.IceRestartAnswer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IceRestartAnswer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IceRestartAnswer;
    })();

    server.HoldCall = (function() {

        /**
         * Properties of a HoldCall.
         * @memberof server
         * @interface IHoldCall
         * @property {string|null} [callId] HoldCall callId
         * @property {boolean|null} [hold] HoldCall hold
         * @property {number|Long|null} [timestampMs] HoldCall timestampMs
         */

        /**
         * Constructs a new HoldCall.
         * @memberof server
         * @classdesc Represents a HoldCall.
         * @implements IHoldCall
         * @constructor
         * @param {server.IHoldCall=} [properties] Properties to set
         */
        function HoldCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HoldCall callId.
         * @member {string} callId
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.callId = "";

        /**
         * HoldCall hold.
         * @member {boolean} hold
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.hold = false;

        /**
         * HoldCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.HoldCall
         * @instance
         */
        HoldCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new HoldCall instance using the specified properties.
         * @function create
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall=} [properties] Properties to set
         * @returns {server.HoldCall} HoldCall instance
         */
        HoldCall.create = function create(properties) {
            return new HoldCall(properties);
        };

        /**
         * Encodes the specified HoldCall message. Does not implicitly {@link server.HoldCall.verify|verify} messages.
         * @function encode
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall} message HoldCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HoldCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.hold != null && Object.hasOwnProperty.call(message, "hold"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hold);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified HoldCall message, length delimited. Does not implicitly {@link server.HoldCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HoldCall
         * @static
         * @param {server.IHoldCall} message HoldCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HoldCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HoldCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.HoldCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HoldCall} HoldCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HoldCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HoldCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.hold = reader.bool();
                    break;
                case 3:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HoldCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HoldCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HoldCall} HoldCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HoldCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HoldCall message.
         * @function verify
         * @memberof server.HoldCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HoldCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.hold != null && message.hasOwnProperty("hold"))
                if (typeof message.hold !== "boolean")
                    return "hold: boolean expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a HoldCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HoldCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HoldCall} HoldCall
         */
        HoldCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HoldCall)
                return object;
            var message = new $root.server.HoldCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.hold != null)
                message.hold = Boolean(object.hold);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a HoldCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HoldCall
         * @static
         * @param {server.HoldCall} message HoldCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HoldCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.hold = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.hold != null && message.hasOwnProperty("hold"))
                object.hold = message.hold;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this HoldCall to JSON.
         * @function toJSON
         * @memberof server.HoldCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HoldCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HoldCall;
    })();

    server.MuteCall = (function() {

        /**
         * Properties of a MuteCall.
         * @memberof server
         * @interface IMuteCall
         * @property {string|null} [callId] MuteCall callId
         * @property {server.MuteCall.MediaType|null} [mediaType] MuteCall mediaType
         * @property {boolean|null} [muted] MuteCall muted
         * @property {number|Long|null} [timestampMs] MuteCall timestampMs
         */

        /**
         * Constructs a new MuteCall.
         * @memberof server
         * @classdesc Represents a MuteCall.
         * @implements IMuteCall
         * @constructor
         * @param {server.IMuteCall=} [properties] Properties to set
         */
        function MuteCall(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MuteCall callId.
         * @member {string} callId
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.callId = "";

        /**
         * MuteCall mediaType.
         * @member {server.MuteCall.MediaType} mediaType
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.mediaType = 0;

        /**
         * MuteCall muted.
         * @member {boolean} muted
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.muted = false;

        /**
         * MuteCall timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.MuteCall
         * @instance
         */
        MuteCall.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MuteCall instance using the specified properties.
         * @function create
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall=} [properties] Properties to set
         * @returns {server.MuteCall} MuteCall instance
         */
        MuteCall.create = function create(properties) {
            return new MuteCall(properties);
        };

        /**
         * Encodes the specified MuteCall message. Does not implicitly {@link server.MuteCall.verify|verify} messages.
         * @function encode
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall} message MuteCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MuteCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaType);
            if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.muted);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestampMs);
            return writer;
        };

        /**
         * Encodes the specified MuteCall message, length delimited. Does not implicitly {@link server.MuteCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MuteCall
         * @static
         * @param {server.IMuteCall} message MuteCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MuteCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MuteCall message from the specified reader or buffer.
         * @function decode
         * @memberof server.MuteCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MuteCall} MuteCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MuteCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MuteCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.mediaType = reader.int32();
                    break;
                case 3:
                    message.muted = reader.bool();
                    break;
                case 4:
                    message.timestampMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MuteCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MuteCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MuteCall} MuteCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MuteCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MuteCall message.
         * @function verify
         * @memberof server.MuteCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MuteCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.muted != null && message.hasOwnProperty("muted"))
                if (typeof message.muted !== "boolean")
                    return "muted: boolean expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            return null;
        };

        /**
         * Creates a MuteCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MuteCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MuteCall} MuteCall
         */
        MuteCall.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MuteCall)
                return object;
            var message = new $root.server.MuteCall();
            if (object.callId != null)
                message.callId = String(object.callId);
            switch (object.mediaType) {
            case "AUDIO":
            case 0:
                message.mediaType = 0;
                break;
            case "VIDEO":
            case 1:
                message.mediaType = 1;
                break;
            }
            if (object.muted != null)
                message.muted = Boolean(object.muted);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a MuteCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MuteCall
         * @static
         * @param {server.MuteCall} message MuteCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MuteCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                object.mediaType = options.enums === String ? "AUDIO" : 0;
                object.muted = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.server.MuteCall.MediaType[message.mediaType] : message.mediaType;
            if (message.muted != null && message.hasOwnProperty("muted"))
                object.muted = message.muted;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
            return object;
        };

        /**
         * Converts this MuteCall to JSON.
         * @function toJSON
         * @memberof server.MuteCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MuteCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * MediaType enum.
         * @name server.MuteCall.MediaType
         * @enum {number}
         * @property {number} AUDIO=0 AUDIO value
         * @property {number} VIDEO=1 VIDEO value
         */
        MuteCall.MediaType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AUDIO"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            return values;
        })();

        return MuteCall;
    })();

    server.CallConfig = (function() {

        /**
         * Properties of a CallConfig.
         * @memberof server
         * @interface ICallConfig
         * @property {number|null} [audioBitrateMax] CallConfig audioBitrateMax
         * @property {number|null} [videoBitrateMax] CallConfig videoBitrateMax
         * @property {number|null} [audioCodec] CallConfig audioCodec
         * @property {number|null} [videoCodec] CallConfig videoCodec
         * @property {number|null} [videoWidth] CallConfig videoWidth
         * @property {number|null} [videoHeight] CallConfig videoHeight
         * @property {number|null} [videoFps] CallConfig videoFps
         * @property {number|null} [audioJitterBufferMaxPackets] CallConfig audioJitterBufferMaxPackets
         * @property {boolean|null} [audioJitterBufferFastAccelerate] CallConfig audioJitterBufferFastAccelerate
         * @property {server.CallConfig.IceTransportPolicy|null} [iceTransportPolicy] CallConfig iceTransportPolicy
         * @property {number|null} [iceRestartDelayMs] CallConfig iceRestartDelayMs
         */

        /**
         * Constructs a new CallConfig.
         * @memberof server
         * @classdesc Represents a CallConfig.
         * @implements ICallConfig
         * @constructor
         * @param {server.ICallConfig=} [properties] Properties to set
         */
        function CallConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallConfig audioBitrateMax.
         * @member {number} audioBitrateMax
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioBitrateMax = 0;

        /**
         * CallConfig videoBitrateMax.
         * @member {number} videoBitrateMax
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoBitrateMax = 0;

        /**
         * CallConfig audioCodec.
         * @member {number} audioCodec
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioCodec = 0;

        /**
         * CallConfig videoCodec.
         * @member {number} videoCodec
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoCodec = 0;

        /**
         * CallConfig videoWidth.
         * @member {number} videoWidth
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoWidth = 0;

        /**
         * CallConfig videoHeight.
         * @member {number} videoHeight
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoHeight = 0;

        /**
         * CallConfig videoFps.
         * @member {number} videoFps
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.videoFps = 0;

        /**
         * CallConfig audioJitterBufferMaxPackets.
         * @member {number} audioJitterBufferMaxPackets
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioJitterBufferMaxPackets = 0;

        /**
         * CallConfig audioJitterBufferFastAccelerate.
         * @member {boolean} audioJitterBufferFastAccelerate
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.audioJitterBufferFastAccelerate = false;

        /**
         * CallConfig iceTransportPolicy.
         * @member {server.CallConfig.IceTransportPolicy} iceTransportPolicy
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceTransportPolicy = 0;

        /**
         * CallConfig iceRestartDelayMs.
         * @member {number} iceRestartDelayMs
         * @memberof server.CallConfig
         * @instance
         */
        CallConfig.prototype.iceRestartDelayMs = 0;

        /**
         * Creates a new CallConfig instance using the specified properties.
         * @function create
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig=} [properties] Properties to set
         * @returns {server.CallConfig} CallConfig instance
         */
        CallConfig.create = function create(properties) {
            return new CallConfig(properties);
        };

        /**
         * Encodes the specified CallConfig message. Does not implicitly {@link server.CallConfig.verify|verify} messages.
         * @function encode
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig} message CallConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audioBitrateMax != null && Object.hasOwnProperty.call(message, "audioBitrateMax"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.audioBitrateMax);
            if (message.videoBitrateMax != null && Object.hasOwnProperty.call(message, "videoBitrateMax"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.videoBitrateMax);
            if (message.audioCodec != null && Object.hasOwnProperty.call(message, "audioCodec"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.audioCodec);
            if (message.videoCodec != null && Object.hasOwnProperty.call(message, "videoCodec"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.videoCodec);
            if (message.videoWidth != null && Object.hasOwnProperty.call(message, "videoWidth"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.videoWidth);
            if (message.videoHeight != null && Object.hasOwnProperty.call(message, "videoHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.videoHeight);
            if (message.videoFps != null && Object.hasOwnProperty.call(message, "videoFps"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.videoFps);
            if (message.audioJitterBufferMaxPackets != null && Object.hasOwnProperty.call(message, "audioJitterBufferMaxPackets"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.audioJitterBufferMaxPackets);
            if (message.audioJitterBufferFastAccelerate != null && Object.hasOwnProperty.call(message, "audioJitterBufferFastAccelerate"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.audioJitterBufferFastAccelerate);
            if (message.iceTransportPolicy != null && Object.hasOwnProperty.call(message, "iceTransportPolicy"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.iceTransportPolicy);
            if (message.iceRestartDelayMs != null && Object.hasOwnProperty.call(message, "iceRestartDelayMs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.iceRestartDelayMs);
            return writer;
        };

        /**
         * Encodes the specified CallConfig message, length delimited. Does not implicitly {@link server.CallConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.CallConfig
         * @static
         * @param {server.ICallConfig} message CallConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallConfig message from the specified reader or buffer.
         * @function decode
         * @memberof server.CallConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.CallConfig} CallConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.CallConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audioBitrateMax = reader.int32();
                    break;
                case 2:
                    message.videoBitrateMax = reader.int32();
                    break;
                case 3:
                    message.audioCodec = reader.int32();
                    break;
                case 4:
                    message.videoCodec = reader.int32();
                    break;
                case 5:
                    message.videoWidth = reader.int32();
                    break;
                case 6:
                    message.videoHeight = reader.int32();
                    break;
                case 7:
                    message.videoFps = reader.int32();
                    break;
                case 8:
                    message.audioJitterBufferMaxPackets = reader.int32();
                    break;
                case 9:
                    message.audioJitterBufferFastAccelerate = reader.bool();
                    break;
                case 10:
                    message.iceTransportPolicy = reader.int32();
                    break;
                case 11:
                    message.iceRestartDelayMs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.CallConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.CallConfig} CallConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallConfig message.
         * @function verify
         * @memberof server.CallConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audioBitrateMax != null && message.hasOwnProperty("audioBitrateMax"))
                if (!$util.isInteger(message.audioBitrateMax))
                    return "audioBitrateMax: integer expected";
            if (message.videoBitrateMax != null && message.hasOwnProperty("videoBitrateMax"))
                if (!$util.isInteger(message.videoBitrateMax))
                    return "videoBitrateMax: integer expected";
            if (message.audioCodec != null && message.hasOwnProperty("audioCodec"))
                if (!$util.isInteger(message.audioCodec))
                    return "audioCodec: integer expected";
            if (message.videoCodec != null && message.hasOwnProperty("videoCodec"))
                if (!$util.isInteger(message.videoCodec))
                    return "videoCodec: integer expected";
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                if (!$util.isInteger(message.videoWidth))
                    return "videoWidth: integer expected";
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                if (!$util.isInteger(message.videoHeight))
                    return "videoHeight: integer expected";
            if (message.videoFps != null && message.hasOwnProperty("videoFps"))
                if (!$util.isInteger(message.videoFps))
                    return "videoFps: integer expected";
            if (message.audioJitterBufferMaxPackets != null && message.hasOwnProperty("audioJitterBufferMaxPackets"))
                if (!$util.isInteger(message.audioJitterBufferMaxPackets))
                    return "audioJitterBufferMaxPackets: integer expected";
            if (message.audioJitterBufferFastAccelerate != null && message.hasOwnProperty("audioJitterBufferFastAccelerate"))
                if (typeof message.audioJitterBufferFastAccelerate !== "boolean")
                    return "audioJitterBufferFastAccelerate: boolean expected";
            if (message.iceTransportPolicy != null && message.hasOwnProperty("iceTransportPolicy"))
                switch (message.iceTransportPolicy) {
                default:
                    return "iceTransportPolicy: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.iceRestartDelayMs != null && message.hasOwnProperty("iceRestartDelayMs"))
                if (!$util.isInteger(message.iceRestartDelayMs))
                    return "iceRestartDelayMs: integer expected";
            return null;
        };

        /**
         * Creates a CallConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.CallConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.CallConfig} CallConfig
         */
        CallConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.server.CallConfig)
                return object;
            var message = new $root.server.CallConfig();
            if (object.audioBitrateMax != null)
                message.audioBitrateMax = object.audioBitrateMax | 0;
            if (object.videoBitrateMax != null)
                message.videoBitrateMax = object.videoBitrateMax | 0;
            if (object.audioCodec != null)
                message.audioCodec = object.audioCodec | 0;
            if (object.videoCodec != null)
                message.videoCodec = object.videoCodec | 0;
            if (object.videoWidth != null)
                message.videoWidth = object.videoWidth | 0;
            if (object.videoHeight != null)
                message.videoHeight = object.videoHeight | 0;
            if (object.videoFps != null)
                message.videoFps = object.videoFps | 0;
            if (object.audioJitterBufferMaxPackets != null)
                message.audioJitterBufferMaxPackets = object.audioJitterBufferMaxPackets | 0;
            if (object.audioJitterBufferFastAccelerate != null)
                message.audioJitterBufferFastAccelerate = Boolean(object.audioJitterBufferFastAccelerate);
            switch (object.iceTransportPolicy) {
            case "ALL":
            case 0:
                message.iceTransportPolicy = 0;
                break;
            case "RELAY":
            case 1:
                message.iceTransportPolicy = 1;
                break;
            }
            if (object.iceRestartDelayMs != null)
                message.iceRestartDelayMs = object.iceRestartDelayMs | 0;
            return message;
        };

        /**
         * Creates a plain object from a CallConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.CallConfig
         * @static
         * @param {server.CallConfig} message CallConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audioBitrateMax = 0;
                object.videoBitrateMax = 0;
                object.audioCodec = 0;
                object.videoCodec = 0;
                object.videoWidth = 0;
                object.videoHeight = 0;
                object.videoFps = 0;
                object.audioJitterBufferMaxPackets = 0;
                object.audioJitterBufferFastAccelerate = false;
                object.iceTransportPolicy = options.enums === String ? "ALL" : 0;
                object.iceRestartDelayMs = 0;
            }
            if (message.audioBitrateMax != null && message.hasOwnProperty("audioBitrateMax"))
                object.audioBitrateMax = message.audioBitrateMax;
            if (message.videoBitrateMax != null && message.hasOwnProperty("videoBitrateMax"))
                object.videoBitrateMax = message.videoBitrateMax;
            if (message.audioCodec != null && message.hasOwnProperty("audioCodec"))
                object.audioCodec = message.audioCodec;
            if (message.videoCodec != null && message.hasOwnProperty("videoCodec"))
                object.videoCodec = message.videoCodec;
            if (message.videoWidth != null && message.hasOwnProperty("videoWidth"))
                object.videoWidth = message.videoWidth;
            if (message.videoHeight != null && message.hasOwnProperty("videoHeight"))
                object.videoHeight = message.videoHeight;
            if (message.videoFps != null && message.hasOwnProperty("videoFps"))
                object.videoFps = message.videoFps;
            if (message.audioJitterBufferMaxPackets != null && message.hasOwnProperty("audioJitterBufferMaxPackets"))
                object.audioJitterBufferMaxPackets = message.audioJitterBufferMaxPackets;
            if (message.audioJitterBufferFastAccelerate != null && message.hasOwnProperty("audioJitterBufferFastAccelerate"))
                object.audioJitterBufferFastAccelerate = message.audioJitterBufferFastAccelerate;
            if (message.iceTransportPolicy != null && message.hasOwnProperty("iceTransportPolicy"))
                object.iceTransportPolicy = options.enums === String ? $root.server.CallConfig.IceTransportPolicy[message.iceTransportPolicy] : message.iceTransportPolicy;
            if (message.iceRestartDelayMs != null && message.hasOwnProperty("iceRestartDelayMs"))
                object.iceRestartDelayMs = message.iceRestartDelayMs;
            return object;
        };

        /**
         * Converts this CallConfig to JSON.
         * @function toJSON
         * @memberof server.CallConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * IceTransportPolicy enum.
         * @name server.CallConfig.IceTransportPolicy
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} RELAY=1 RELAY value
         */
        CallConfig.IceTransportPolicy = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "RELAY"] = 1;
            return values;
        })();

        return CallConfig;
    })();

    server.OgTagInfo = (function() {

        /**
         * Properties of an OgTagInfo.
         * @memberof server
         * @interface IOgTagInfo
         * @property {string|null} [title] OgTagInfo title
         * @property {string|null} [description] OgTagInfo description
         * @property {string|null} [thumbnailUrl] OgTagInfo thumbnailUrl
         * @property {number|null} [thumbnailWidth] OgTagInfo thumbnailWidth
         * @property {number|null} [thumbnailHeight] OgTagInfo thumbnailHeight
         */

        /**
         * Constructs a new OgTagInfo.
         * @memberof server
         * @classdesc Represents an OgTagInfo.
         * @implements IOgTagInfo
         * @constructor
         * @param {server.IOgTagInfo=} [properties] Properties to set
         */
        function OgTagInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OgTagInfo title.
         * @member {string} title
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.title = "";

        /**
         * OgTagInfo description.
         * @member {string} description
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.description = "";

        /**
         * OgTagInfo thumbnailUrl.
         * @member {string} thumbnailUrl
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailUrl = "";

        /**
         * OgTagInfo thumbnailWidth.
         * @member {number} thumbnailWidth
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailWidth = 0;

        /**
         * OgTagInfo thumbnailHeight.
         * @member {number} thumbnailHeight
         * @memberof server.OgTagInfo
         * @instance
         */
        OgTagInfo.prototype.thumbnailHeight = 0;

        /**
         * Creates a new OgTagInfo instance using the specified properties.
         * @function create
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo=} [properties] Properties to set
         * @returns {server.OgTagInfo} OgTagInfo instance
         */
        OgTagInfo.create = function create(properties) {
            return new OgTagInfo(properties);
        };

        /**
         * Encodes the specified OgTagInfo message. Does not implicitly {@link server.OgTagInfo.verify|verify} messages.
         * @function encode
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo} message OgTagInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OgTagInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
            if (message.thumbnailUrl != null && Object.hasOwnProperty.call(message, "thumbnailUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.thumbnailUrl);
            if (message.thumbnailWidth != null && Object.hasOwnProperty.call(message, "thumbnailWidth"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.thumbnailWidth);
            if (message.thumbnailHeight != null && Object.hasOwnProperty.call(message, "thumbnailHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.thumbnailHeight);
            return writer;
        };

        /**
         * Encodes the specified OgTagInfo message, length delimited. Does not implicitly {@link server.OgTagInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OgTagInfo
         * @static
         * @param {server.IOgTagInfo} message OgTagInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OgTagInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OgTagInfo message from the specified reader or buffer.
         * @function decode
         * @memberof server.OgTagInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OgTagInfo} OgTagInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OgTagInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OgTagInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.thumbnailUrl = reader.string();
                    break;
                case 4:
                    message.thumbnailWidth = reader.int32();
                    break;
                case 5:
                    message.thumbnailHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OgTagInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OgTagInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OgTagInfo} OgTagInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OgTagInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OgTagInfo message.
         * @function verify
         * @memberof server.OgTagInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OgTagInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                if (!$util.isString(message.thumbnailUrl))
                    return "thumbnailUrl: string expected";
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                if (!$util.isInteger(message.thumbnailWidth))
                    return "thumbnailWidth: integer expected";
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                if (!$util.isInteger(message.thumbnailHeight))
                    return "thumbnailHeight: integer expected";
            return null;
        };

        /**
         * Creates an OgTagInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OgTagInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OgTagInfo} OgTagInfo
         */
        OgTagInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OgTagInfo)
                return object;
            var message = new $root.server.OgTagInfo();
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.thumbnailUrl != null)
                message.thumbnailUrl = String(object.thumbnailUrl);
            if (object.thumbnailWidth != null)
                message.thumbnailWidth = object.thumbnailWidth | 0;
            if (object.thumbnailHeight != null)
                message.thumbnailHeight = object.thumbnailHeight | 0;
            return message;
        };

        /**
         * Creates a plain object from an OgTagInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OgTagInfo
         * @static
         * @param {server.OgTagInfo} message OgTagInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OgTagInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.title = "";
                object.description = "";
                object.thumbnailUrl = "";
                object.thumbnailWidth = 0;
                object.thumbnailHeight = 0;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.thumbnailUrl != null && message.hasOwnProperty("thumbnailUrl"))
                object.thumbnailUrl = message.thumbnailUrl;
            if (message.thumbnailWidth != null && message.hasOwnProperty("thumbnailWidth"))
                object.thumbnailWidth = message.thumbnailWidth;
            if (message.thumbnailHeight != null && message.hasOwnProperty("thumbnailHeight"))
                object.thumbnailHeight = message.thumbnailHeight;
            return object;
        };

        /**
         * Converts this OgTagInfo to JSON.
         * @function toJSON
         * @memberof server.OgTagInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OgTagInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OgTagInfo;
    })();

    server.ExternalSharePost = (function() {

        /**
         * Properties of an ExternalSharePost.
         * @memberof server
         * @interface IExternalSharePost
         * @property {server.ExternalSharePost.Action|null} [action] ExternalSharePost action
         * @property {string|null} [blobId] ExternalSharePost blobId
         * @property {Uint8Array|null} [blob] ExternalSharePost blob
         * @property {number|Long|null} [expiresInSeconds] ExternalSharePost expiresInSeconds
         * @property {server.IOgTagInfo|null} [ogTagInfo] ExternalSharePost ogTagInfo
         */

        /**
         * Constructs a new ExternalSharePost.
         * @memberof server
         * @classdesc Represents an ExternalSharePost.
         * @implements IExternalSharePost
         * @constructor
         * @param {server.IExternalSharePost=} [properties] Properties to set
         */
        function ExternalSharePost(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalSharePost action.
         * @member {server.ExternalSharePost.Action} action
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.action = 0;

        /**
         * ExternalSharePost blobId.
         * @member {string} blobId
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.blobId = "";

        /**
         * ExternalSharePost blob.
         * @member {Uint8Array} blob
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.blob = $util.newBuffer([]);

        /**
         * ExternalSharePost expiresInSeconds.
         * @member {number|Long} expiresInSeconds
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.expiresInSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExternalSharePost ogTagInfo.
         * @member {server.IOgTagInfo|null|undefined} ogTagInfo
         * @memberof server.ExternalSharePost
         * @instance
         */
        ExternalSharePost.prototype.ogTagInfo = null;

        /**
         * Creates a new ExternalSharePost instance using the specified properties.
         * @function create
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost=} [properties] Properties to set
         * @returns {server.ExternalSharePost} ExternalSharePost instance
         */
        ExternalSharePost.create = function create(properties) {
            return new ExternalSharePost(properties);
        };

        /**
         * Encodes the specified ExternalSharePost message. Does not implicitly {@link server.ExternalSharePost.verify|verify} messages.
         * @function encode
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost} message ExternalSharePost message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePost.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.blobId != null && Object.hasOwnProperty.call(message, "blobId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blobId);
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.blob);
            if (message.expiresInSeconds != null && Object.hasOwnProperty.call(message, "expiresInSeconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expiresInSeconds);
            if (message.ogTagInfo != null && Object.hasOwnProperty.call(message, "ogTagInfo"))
                $root.server.OgTagInfo.encode(message.ogTagInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExternalSharePost message, length delimited. Does not implicitly {@link server.ExternalSharePost.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.IExternalSharePost} message ExternalSharePost message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePost.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalSharePost message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExternalSharePost
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExternalSharePost} ExternalSharePost
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePost.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExternalSharePost();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.blobId = reader.string();
                    break;
                case 3:
                    message.blob = reader.bytes();
                    break;
                case 4:
                    message.expiresInSeconds = reader.int64();
                    break;
                case 5:
                    message.ogTagInfo = $root.server.OgTagInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalSharePost message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExternalSharePost
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExternalSharePost} ExternalSharePost
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePost.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalSharePost message.
         * @function verify
         * @memberof server.ExternalSharePost
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalSharePost.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.blobId != null && message.hasOwnProperty("blobId"))
                if (!$util.isString(message.blobId))
                    return "blobId: string expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (!$util.isInteger(message.expiresInSeconds) && !(message.expiresInSeconds && $util.isInteger(message.expiresInSeconds.low) && $util.isInteger(message.expiresInSeconds.high)))
                    return "expiresInSeconds: integer|Long expected";
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo")) {
                var error = $root.server.OgTagInfo.verify(message.ogTagInfo);
                if (error)
                    return "ogTagInfo." + error;
            }
            return null;
        };

        /**
         * Creates an ExternalSharePost message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExternalSharePost
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExternalSharePost} ExternalSharePost
         */
        ExternalSharePost.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExternalSharePost)
                return object;
            var message = new $root.server.ExternalSharePost();
            switch (object.action) {
            case "STORE":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            case "GET":
            case 2:
                message.action = 2;
                break;
            }
            if (object.blobId != null)
                message.blobId = String(object.blobId);
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            if (object.expiresInSeconds != null)
                if ($util.Long)
                    (message.expiresInSeconds = $util.Long.fromValue(object.expiresInSeconds)).unsigned = false;
                else if (typeof object.expiresInSeconds === "string")
                    message.expiresInSeconds = parseInt(object.expiresInSeconds, 10);
                else if (typeof object.expiresInSeconds === "number")
                    message.expiresInSeconds = object.expiresInSeconds;
                else if (typeof object.expiresInSeconds === "object")
                    message.expiresInSeconds = new $util.LongBits(object.expiresInSeconds.low >>> 0, object.expiresInSeconds.high >>> 0).toNumber();
            if (object.ogTagInfo != null) {
                if (typeof object.ogTagInfo !== "object")
                    throw TypeError(".server.ExternalSharePost.ogTagInfo: object expected");
                message.ogTagInfo = $root.server.OgTagInfo.fromObject(object.ogTagInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExternalSharePost message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExternalSharePost
         * @static
         * @param {server.ExternalSharePost} message ExternalSharePost
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalSharePost.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "STORE" : 0;
                object.blobId = "";
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiresInSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiresInSeconds = options.longs === String ? "0" : 0;
                object.ogTagInfo = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.ExternalSharePost.Action[message.action] : message.action;
            if (message.blobId != null && message.hasOwnProperty("blobId"))
                object.blobId = message.blobId;
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            if (message.expiresInSeconds != null && message.hasOwnProperty("expiresInSeconds"))
                if (typeof message.expiresInSeconds === "number")
                    object.expiresInSeconds = options.longs === String ? String(message.expiresInSeconds) : message.expiresInSeconds;
                else
                    object.expiresInSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.expiresInSeconds) : options.longs === Number ? new $util.LongBits(message.expiresInSeconds.low >>> 0, message.expiresInSeconds.high >>> 0).toNumber() : message.expiresInSeconds;
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo"))
                object.ogTagInfo = $root.server.OgTagInfo.toObject(message.ogTagInfo, options);
            return object;
        };

        /**
         * Converts this ExternalSharePost to JSON.
         * @function toJSON
         * @memberof server.ExternalSharePost
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalSharePost.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.ExternalSharePost.Action
         * @enum {number}
         * @property {number} STORE=0 STORE value
         * @property {number} DELETE=1 DELETE value
         * @property {number} GET=2 GET value
         */
        ExternalSharePost.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STORE"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            values[valuesById[2] = "GET"] = 2;
            return values;
        })();

        return ExternalSharePost;
    })();

    server.ExternalSharePostContainer = (function() {

        /**
         * Properties of an ExternalSharePostContainer.
         * @memberof server
         * @interface IExternalSharePostContainer
         * @property {number|Long|null} [uid] ExternalSharePostContainer uid
         * @property {Uint8Array|null} [blob] ExternalSharePostContainer blob
         * @property {server.IOgTagInfo|null} [ogTagInfo] ExternalSharePostContainer ogTagInfo
         * @property {string|null} [name] ExternalSharePostContainer name
         * @property {string|null} [avatarId] ExternalSharePostContainer avatarId
         */

        /**
         * Constructs a new ExternalSharePostContainer.
         * @memberof server
         * @classdesc Represents an ExternalSharePostContainer.
         * @implements IExternalSharePostContainer
         * @constructor
         * @param {server.IExternalSharePostContainer=} [properties] Properties to set
         */
        function ExternalSharePostContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalSharePostContainer uid.
         * @member {number|Long} uid
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExternalSharePostContainer blob.
         * @member {Uint8Array} blob
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.blob = $util.newBuffer([]);

        /**
         * ExternalSharePostContainer ogTagInfo.
         * @member {server.IOgTagInfo|null|undefined} ogTagInfo
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.ogTagInfo = null;

        /**
         * ExternalSharePostContainer name.
         * @member {string} name
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.name = "";

        /**
         * ExternalSharePostContainer avatarId.
         * @member {string} avatarId
         * @memberof server.ExternalSharePostContainer
         * @instance
         */
        ExternalSharePostContainer.prototype.avatarId = "";

        /**
         * Creates a new ExternalSharePostContainer instance using the specified properties.
         * @function create
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer=} [properties] Properties to set
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer instance
         */
        ExternalSharePostContainer.create = function create(properties) {
            return new ExternalSharePostContainer(properties);
        };

        /**
         * Encodes the specified ExternalSharePostContainer message. Does not implicitly {@link server.ExternalSharePostContainer.verify|verify} messages.
         * @function encode
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer} message ExternalSharePostContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePostContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.blob != null && Object.hasOwnProperty.call(message, "blob"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blob);
            if (message.ogTagInfo != null && Object.hasOwnProperty.call(message, "ogTagInfo"))
                $root.server.OgTagInfo.encode(message.ogTagInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatarId);
            return writer;
        };

        /**
         * Encodes the specified ExternalSharePostContainer message, length delimited. Does not implicitly {@link server.ExternalSharePostContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.IExternalSharePostContainer} message ExternalSharePostContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalSharePostContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalSharePostContainer message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePostContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExternalSharePostContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.blob = reader.bytes();
                    break;
                case 3:
                    message.ogTagInfo = $root.server.OgTagInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.avatarId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalSharePostContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalSharePostContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalSharePostContainer message.
         * @function verify
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalSharePostContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.blob != null && message.hasOwnProperty("blob"))
                if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                    return "blob: buffer expected";
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo")) {
                var error = $root.server.OgTagInfo.verify(message.ogTagInfo);
                if (error)
                    return "ogTagInfo." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isString(message.avatarId))
                    return "avatarId: string expected";
            return null;
        };

        /**
         * Creates an ExternalSharePostContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExternalSharePostContainer} ExternalSharePostContainer
         */
        ExternalSharePostContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExternalSharePostContainer)
                return object;
            var message = new $root.server.ExternalSharePostContainer();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.blob != null)
                if (typeof object.blob === "string")
                    $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                else if (object.blob.length)
                    message.blob = object.blob;
            if (object.ogTagInfo != null) {
                if (typeof object.ogTagInfo !== "object")
                    throw TypeError(".server.ExternalSharePostContainer.ogTagInfo: object expected");
                message.ogTagInfo = $root.server.OgTagInfo.fromObject(object.ogTagInfo);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.avatarId != null)
                message.avatarId = String(object.avatarId);
            return message;
        };

        /**
         * Creates a plain object from an ExternalSharePostContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExternalSharePostContainer
         * @static
         * @param {server.ExternalSharePostContainer} message ExternalSharePostContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalSharePostContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.blob = "";
                else {
                    object.blob = [];
                    if (options.bytes !== Array)
                        object.blob = $util.newBuffer(object.blob);
                }
                object.ogTagInfo = null;
                object.name = "";
                object.avatarId = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.blob != null && message.hasOwnProperty("blob"))
                object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
            if (message.ogTagInfo != null && message.hasOwnProperty("ogTagInfo"))
                object.ogTagInfo = $root.server.OgTagInfo.toObject(message.ogTagInfo, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            return object;
        };

        /**
         * Converts this ExternalSharePostContainer to JSON.
         * @function toJSON
         * @memberof server.ExternalSharePostContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalSharePostContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExternalSharePostContainer;
    })();

    server.Iq = (function() {

        /**
         * Properties of an Iq.
         * @memberof server
         * @interface IIq
         * @property {string|null} [id] Iq id
         * @property {server.Iq.Type|null} [type] Iq type
         * @property {server.IUploadMedia|null} [uploadMedia] Iq uploadMedia
         * @property {server.IContactList|null} [contactList] Iq contactList
         * @property {server.IUploadAvatar|null} [uploadAvatar] Iq uploadAvatar
         * @property {server.IAvatar|null} [avatar] Iq avatar
         * @property {server.IAvatars|null} [avatars] Iq avatars
         * @property {server.IClientMode|null} [clientMode] Iq clientMode
         * @property {server.IClientVersion|null} [clientVersion] Iq clientVersion
         * @property {server.IPushRegister|null} [pushRegister] Iq pushRegister
         * @property {server.IWhisperKeys|null} [whisperKeys] Iq whisperKeys
         * @property {server.IPing|null} [ping] Iq ping
         * @property {server.IFeedItem|null} [feedItem] Iq feedItem
         * @property {server.IPrivacyList|null} [privacyList] Iq privacyList
         * @property {server.IPrivacyLists|null} [privacyLists] Iq privacyLists
         * @property {server.IGroupStanza|null} [groupStanza] Iq groupStanza
         * @property {server.IGroupsStanza|null} [groupsStanza] Iq groupsStanza
         * @property {server.IClientLog|null} [clientLog] Iq clientLog
         * @property {server.IName|null} [name] Iq name
         * @property {server.IErrorStanza|null} [errorStanza] Iq errorStanza
         * @property {server.IProps|null} [props] Iq props
         * @property {server.IInvitesRequest|null} [invitesRequest] Iq invitesRequest
         * @property {server.IInvitesResponse|null} [invitesResponse] Iq invitesResponse
         * @property {server.INotificationPrefs|null} [notificationPrefs] Iq notificationPrefs
         * @property {server.IGroupFeedItem|null} [groupFeedItem] Iq groupFeedItem
         * @property {server.IUploadGroupAvatar|null} [groupAvatar] Iq groupAvatar
         * @property {server.IDeleteAccount|null} [deleteAccount] Iq deleteAccount
         * @property {server.IGroupInviteLink|null} [groupInviteLink] Iq groupInviteLink
         * @property {server.IHistoryResend|null} [historyResend] Iq historyResend
         * @property {server.IExportData|null} [exportData] Iq exportData
         * @property {server.IContactSyncError|null} [contactSyncError] Iq contactSyncError
         * @property {server.IClientOtpRequest|null} [clientOtpRequest] Iq clientOtpRequest
         * @property {server.IClientOtpResponse|null} [clientOtpResponse] Iq clientOtpResponse
         * @property {server.IWhisperKeysCollection|null} [whisperKeysCollection] Iq whisperKeysCollection
         * @property {server.IGetCallServers|null} [getCallServers] Iq getCallServers
         * @property {server.IGetCallServersResult|null} [getCallServersResult] Iq getCallServersResult
         * @property {server.IStartCall|null} [startCall] Iq startCall
         * @property {server.IStartCallResult|null} [startCallResult] Iq startCallResult
         * @property {server.ITruncWhisperKeysCollection|null} [truncWhisperKeysCollection] Iq truncWhisperKeysCollection
         * @property {server.IExternalSharePost|null} [externalSharePost] Iq externalSharePost
         * @property {server.IExternalSharePostContainer|null} [externalSharePostContainer] Iq externalSharePostContainer
         */

        /**
         * Constructs a new Iq.
         * @memberof server
         * @classdesc Represents an Iq.
         * @implements IIq
         * @constructor
         * @param {server.IIq=} [properties] Properties to set
         */
        function Iq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Iq id.
         * @member {string} id
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.id = "";

        /**
         * Iq type.
         * @member {server.Iq.Type} type
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.type = 0;

        /**
         * Iq uploadMedia.
         * @member {server.IUploadMedia|null|undefined} uploadMedia
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.uploadMedia = null;

        /**
         * Iq contactList.
         * @member {server.IContactList|null|undefined} contactList
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.contactList = null;

        /**
         * Iq uploadAvatar.
         * @member {server.IUploadAvatar|null|undefined} uploadAvatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.uploadAvatar = null;

        /**
         * Iq avatar.
         * @member {server.IAvatar|null|undefined} avatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.avatar = null;

        /**
         * Iq avatars.
         * @member {server.IAvatars|null|undefined} avatars
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.avatars = null;

        /**
         * Iq clientMode.
         * @member {server.IClientMode|null|undefined} clientMode
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientMode = null;

        /**
         * Iq clientVersion.
         * @member {server.IClientVersion|null|undefined} clientVersion
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientVersion = null;

        /**
         * Iq pushRegister.
         * @member {server.IPushRegister|null|undefined} pushRegister
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.pushRegister = null;

        /**
         * Iq whisperKeys.
         * @member {server.IWhisperKeys|null|undefined} whisperKeys
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.whisperKeys = null;

        /**
         * Iq ping.
         * @member {server.IPing|null|undefined} ping
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.ping = null;

        /**
         * Iq feedItem.
         * @member {server.IFeedItem|null|undefined} feedItem
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.feedItem = null;

        /**
         * Iq privacyList.
         * @member {server.IPrivacyList|null|undefined} privacyList
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.privacyList = null;

        /**
         * Iq privacyLists.
         * @member {server.IPrivacyLists|null|undefined} privacyLists
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.privacyLists = null;

        /**
         * Iq groupStanza.
         * @member {server.IGroupStanza|null|undefined} groupStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupStanza = null;

        /**
         * Iq groupsStanza.
         * @member {server.IGroupsStanza|null|undefined} groupsStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupsStanza = null;

        /**
         * Iq clientLog.
         * @member {server.IClientLog|null|undefined} clientLog
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientLog = null;

        /**
         * Iq name.
         * @member {server.IName|null|undefined} name
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.name = null;

        /**
         * Iq errorStanza.
         * @member {server.IErrorStanza|null|undefined} errorStanza
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.errorStanza = null;

        /**
         * Iq props.
         * @member {server.IProps|null|undefined} props
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.props = null;

        /**
         * Iq invitesRequest.
         * @member {server.IInvitesRequest|null|undefined} invitesRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.invitesRequest = null;

        /**
         * Iq invitesResponse.
         * @member {server.IInvitesResponse|null|undefined} invitesResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.invitesResponse = null;

        /**
         * Iq notificationPrefs.
         * @member {server.INotificationPrefs|null|undefined} notificationPrefs
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.notificationPrefs = null;

        /**
         * Iq groupFeedItem.
         * @member {server.IGroupFeedItem|null|undefined} groupFeedItem
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupFeedItem = null;

        /**
         * Iq groupAvatar.
         * @member {server.IUploadGroupAvatar|null|undefined} groupAvatar
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupAvatar = null;

        /**
         * Iq deleteAccount.
         * @member {server.IDeleteAccount|null|undefined} deleteAccount
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.deleteAccount = null;

        /**
         * Iq groupInviteLink.
         * @member {server.IGroupInviteLink|null|undefined} groupInviteLink
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.groupInviteLink = null;

        /**
         * Iq historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.historyResend = null;

        /**
         * Iq exportData.
         * @member {server.IExportData|null|undefined} exportData
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.exportData = null;

        /**
         * Iq contactSyncError.
         * @member {server.IContactSyncError|null|undefined} contactSyncError
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.contactSyncError = null;

        /**
         * Iq clientOtpRequest.
         * @member {server.IClientOtpRequest|null|undefined} clientOtpRequest
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientOtpRequest = null;

        /**
         * Iq clientOtpResponse.
         * @member {server.IClientOtpResponse|null|undefined} clientOtpResponse
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.clientOtpResponse = null;

        /**
         * Iq whisperKeysCollection.
         * @member {server.IWhisperKeysCollection|null|undefined} whisperKeysCollection
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.whisperKeysCollection = null;

        /**
         * Iq getCallServers.
         * @member {server.IGetCallServers|null|undefined} getCallServers
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.getCallServers = null;

        /**
         * Iq getCallServersResult.
         * @member {server.IGetCallServersResult|null|undefined} getCallServersResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.getCallServersResult = null;

        /**
         * Iq startCall.
         * @member {server.IStartCall|null|undefined} startCall
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.startCall = null;

        /**
         * Iq startCallResult.
         * @member {server.IStartCallResult|null|undefined} startCallResult
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.startCallResult = null;

        /**
         * Iq truncWhisperKeysCollection.
         * @member {server.ITruncWhisperKeysCollection|null|undefined} truncWhisperKeysCollection
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.truncWhisperKeysCollection = null;

        /**
         * Iq externalSharePost.
         * @member {server.IExternalSharePost|null|undefined} externalSharePost
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.externalSharePost = null;

        /**
         * Iq externalSharePostContainer.
         * @member {server.IExternalSharePostContainer|null|undefined} externalSharePostContainer
         * @memberof server.Iq
         * @instance
         */
        Iq.prototype.externalSharePostContainer = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Iq payload.
         * @member {"uploadMedia"|"contactList"|"uploadAvatar"|"avatar"|"avatars"|"clientMode"|"clientVersion"|"pushRegister"|"whisperKeys"|"ping"|"feedItem"|"privacyList"|"privacyLists"|"groupStanza"|"groupsStanza"|"clientLog"|"name"|"errorStanza"|"props"|"invitesRequest"|"invitesResponse"|"notificationPrefs"|"groupFeedItem"|"groupAvatar"|"deleteAccount"|"groupInviteLink"|"historyResend"|"exportData"|"contactSyncError"|"clientOtpRequest"|"clientOtpResponse"|"whisperKeysCollection"|"getCallServers"|"getCallServersResult"|"startCall"|"startCallResult"|"truncWhisperKeysCollection"|"externalSharePost"|"externalSharePostContainer"|undefined} payload
         * @memberof server.Iq
         * @instance
         */
        Object.defineProperty(Iq.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["uploadMedia", "contactList", "uploadAvatar", "avatar", "avatars", "clientMode", "clientVersion", "pushRegister", "whisperKeys", "ping", "feedItem", "privacyList", "privacyLists", "groupStanza", "groupsStanza", "clientLog", "name", "errorStanza", "props", "invitesRequest", "invitesResponse", "notificationPrefs", "groupFeedItem", "groupAvatar", "deleteAccount", "groupInviteLink", "historyResend", "exportData", "contactSyncError", "clientOtpRequest", "clientOtpResponse", "whisperKeysCollection", "getCallServers", "getCallServersResult", "startCall", "startCallResult", "truncWhisperKeysCollection", "externalSharePost", "externalSharePostContainer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Iq instance using the specified properties.
         * @function create
         * @memberof server.Iq
         * @static
         * @param {server.IIq=} [properties] Properties to set
         * @returns {server.Iq} Iq instance
         */
        Iq.create = function create(properties) {
            return new Iq(properties);
        };

        /**
         * Encodes the specified Iq message. Does not implicitly {@link server.Iq.verify|verify} messages.
         * @function encode
         * @memberof server.Iq
         * @static
         * @param {server.IIq} message Iq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Iq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.uploadMedia != null && Object.hasOwnProperty.call(message, "uploadMedia"))
                $root.server.UploadMedia.encode(message.uploadMedia, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.contactList != null && Object.hasOwnProperty.call(message, "contactList"))
                $root.server.ContactList.encode(message.contactList, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.uploadAvatar != null && Object.hasOwnProperty.call(message, "uploadAvatar"))
                $root.server.UploadAvatar.encode(message.uploadAvatar, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.server.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.avatars != null && Object.hasOwnProperty.call(message, "avatars"))
                $root.server.Avatars.encode(message.avatars, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.clientMode != null && Object.hasOwnProperty.call(message, "clientMode"))
                $root.server.ClientMode.encode(message.clientMode, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
                $root.server.ClientVersion.encode(message.clientVersion, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.pushRegister != null && Object.hasOwnProperty.call(message, "pushRegister"))
                $root.server.PushRegister.encode(message.pushRegister, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.whisperKeys != null && Object.hasOwnProperty.call(message, "whisperKeys"))
                $root.server.WhisperKeys.encode(message.whisperKeys, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.server.Ping.encode(message.ping, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.feedItem != null && Object.hasOwnProperty.call(message, "feedItem"))
                $root.server.FeedItem.encode(message.feedItem, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.privacyList != null && Object.hasOwnProperty.call(message, "privacyList"))
                $root.server.PrivacyList.encode(message.privacyList, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.privacyLists != null && Object.hasOwnProperty.call(message, "privacyLists"))
                $root.server.PrivacyLists.encode(message.privacyLists, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.groupStanza != null && Object.hasOwnProperty.call(message, "groupStanza"))
                $root.server.GroupStanza.encode(message.groupStanza, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.groupsStanza != null && Object.hasOwnProperty.call(message, "groupsStanza"))
                $root.server.GroupsStanza.encode(message.groupsStanza, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.clientLog != null && Object.hasOwnProperty.call(message, "clientLog"))
                $root.server.ClientLog.encode(message.clientLog, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.server.Name.encode(message.name, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.errorStanza != null && Object.hasOwnProperty.call(message, "errorStanza"))
                $root.server.ErrorStanza.encode(message.errorStanza, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.props != null && Object.hasOwnProperty.call(message, "props"))
                $root.server.Props.encode(message.props, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.invitesRequest != null && Object.hasOwnProperty.call(message, "invitesRequest"))
                $root.server.InvitesRequest.encode(message.invitesRequest, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.invitesResponse != null && Object.hasOwnProperty.call(message, "invitesResponse"))
                $root.server.InvitesResponse.encode(message.invitesResponse, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.notificationPrefs != null && Object.hasOwnProperty.call(message, "notificationPrefs"))
                $root.server.NotificationPrefs.encode(message.notificationPrefs, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.groupFeedItem != null && Object.hasOwnProperty.call(message, "groupFeedItem"))
                $root.server.GroupFeedItem.encode(message.groupFeedItem, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.groupAvatar != null && Object.hasOwnProperty.call(message, "groupAvatar"))
                $root.server.UploadGroupAvatar.encode(message.groupAvatar, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.deleteAccount != null && Object.hasOwnProperty.call(message, "deleteAccount"))
                $root.server.DeleteAccount.encode(message.deleteAccount, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.groupInviteLink != null && Object.hasOwnProperty.call(message, "groupInviteLink"))
                $root.server.GroupInviteLink.encode(message.groupInviteLink, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.exportData != null && Object.hasOwnProperty.call(message, "exportData"))
                $root.server.ExportData.encode(message.exportData, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.contactSyncError != null && Object.hasOwnProperty.call(message, "contactSyncError"))
                $root.server.ContactSyncError.encode(message.contactSyncError, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.clientOtpRequest != null && Object.hasOwnProperty.call(message, "clientOtpRequest"))
                $root.server.ClientOtpRequest.encode(message.clientOtpRequest, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.clientOtpResponse != null && Object.hasOwnProperty.call(message, "clientOtpResponse"))
                $root.server.ClientOtpResponse.encode(message.clientOtpResponse, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.whisperKeysCollection != null && Object.hasOwnProperty.call(message, "whisperKeysCollection"))
                $root.server.WhisperKeysCollection.encode(message.whisperKeysCollection, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.getCallServers != null && Object.hasOwnProperty.call(message, "getCallServers"))
                $root.server.GetCallServers.encode(message.getCallServers, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.getCallServersResult != null && Object.hasOwnProperty.call(message, "getCallServersResult"))
                $root.server.GetCallServersResult.encode(message.getCallServersResult, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.startCall != null && Object.hasOwnProperty.call(message, "startCall"))
                $root.server.StartCall.encode(message.startCall, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.startCallResult != null && Object.hasOwnProperty.call(message, "startCallResult"))
                $root.server.StartCallResult.encode(message.startCallResult, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.truncWhisperKeysCollection != null && Object.hasOwnProperty.call(message, "truncWhisperKeysCollection"))
                $root.server.TruncWhisperKeysCollection.encode(message.truncWhisperKeysCollection, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.externalSharePost != null && Object.hasOwnProperty.call(message, "externalSharePost"))
                $root.server.ExternalSharePost.encode(message.externalSharePost, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.externalSharePostContainer != null && Object.hasOwnProperty.call(message, "externalSharePostContainer"))
                $root.server.ExternalSharePostContainer.encode(message.externalSharePostContainer, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Iq message, length delimited. Does not implicitly {@link server.Iq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Iq
         * @static
         * @param {server.IIq} message Iq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Iq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Iq message from the specified reader or buffer.
         * @function decode
         * @memberof server.Iq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Iq} Iq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Iq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Iq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.uploadMedia = $root.server.UploadMedia.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.contactList = $root.server.ContactList.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.uploadAvatar = $root.server.UploadAvatar.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.avatar = $root.server.Avatar.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.avatars = $root.server.Avatars.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.clientMode = $root.server.ClientMode.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.clientVersion = $root.server.ClientVersion.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.pushRegister = $root.server.PushRegister.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.whisperKeys = $root.server.WhisperKeys.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.ping = $root.server.Ping.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.feedItem = $root.server.FeedItem.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.privacyList = $root.server.PrivacyList.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.privacyLists = $root.server.PrivacyLists.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.groupStanza = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.groupsStanza = $root.server.GroupsStanza.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.clientLog = $root.server.ClientLog.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.name = $root.server.Name.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.errorStanza = $root.server.ErrorStanza.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.props = $root.server.Props.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.invitesRequest = $root.server.InvitesRequest.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.invitesResponse = $root.server.InvitesResponse.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.notificationPrefs = $root.server.NotificationPrefs.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.groupFeedItem = $root.server.GroupFeedItem.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.groupAvatar = $root.server.UploadGroupAvatar.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.deleteAccount = $root.server.DeleteAccount.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.groupInviteLink = $root.server.GroupInviteLink.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.exportData = $root.server.ExportData.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.contactSyncError = $root.server.ContactSyncError.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.clientOtpRequest = $root.server.ClientOtpRequest.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.clientOtpResponse = $root.server.ClientOtpResponse.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.whisperKeysCollection = $root.server.WhisperKeysCollection.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.getCallServers = $root.server.GetCallServers.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.getCallServersResult = $root.server.GetCallServersResult.decode(reader, reader.uint32());
                    break;
                case 40:
                    message.startCall = $root.server.StartCall.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.startCallResult = $root.server.StartCallResult.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.externalSharePost = $root.server.ExternalSharePost.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.externalSharePostContainer = $root.server.ExternalSharePostContainer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Iq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Iq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Iq} Iq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Iq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Iq message.
         * @function verify
         * @memberof server.Iq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Iq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.uploadMedia != null && message.hasOwnProperty("uploadMedia")) {
                properties.payload = 1;
                {
                    var error = $root.server.UploadMedia.verify(message.uploadMedia);
                    if (error)
                        return "uploadMedia." + error;
                }
            }
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactList.verify(message.contactList);
                    if (error)
                        return "contactList." + error;
                }
            }
            if (message.uploadAvatar != null && message.hasOwnProperty("uploadAvatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UploadAvatar.verify(message.uploadAvatar);
                    if (error)
                        return "uploadAvatar." + error;
                }
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
            }
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatars.verify(message.avatars);
                    if (error)
                        return "avatars." + error;
                }
            }
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientMode.verify(message.clientMode);
                    if (error)
                        return "clientMode." + error;
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientVersion.verify(message.clientVersion);
                    if (error)
                        return "clientVersion." + error;
                }
            }
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PushRegister.verify(message.pushRegister);
                    if (error)
                        return "pushRegister." + error;
                }
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeys.verify(message.whisperKeys);
                    if (error)
                        return "whisperKeys." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Ping.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItem.verify(message.feedItem);
                    if (error)
                        return "feedItem." + error;
                }
            }
            if (message.privacyList != null && message.hasOwnProperty("privacyList")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PrivacyList.verify(message.privacyList);
                    if (error)
                        return "privacyList." + error;
                }
            }
            if (message.privacyLists != null && message.hasOwnProperty("privacyLists")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PrivacyLists.verify(message.privacyLists);
                    if (error)
                        return "privacyLists." + error;
                }
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupStanza.verify(message.groupStanza);
                    if (error)
                        return "groupStanza." + error;
                }
            }
            if (message.groupsStanza != null && message.hasOwnProperty("groupsStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupsStanza.verify(message.groupsStanza);
                    if (error)
                        return "groupsStanza." + error;
                }
            }
            if (message.clientLog != null && message.hasOwnProperty("clientLog")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientLog.verify(message.clientLog);
                    if (error)
                        return "clientLog." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Name.verify(message.name);
                    if (error)
                        return "name." + error;
                }
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ErrorStanza.verify(message.errorStanza);
                    if (error)
                        return "errorStanza." + error;
                }
            }
            if (message.props != null && message.hasOwnProperty("props")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Props.verify(message.props);
                    if (error)
                        return "props." + error;
                }
            }
            if (message.invitesRequest != null && message.hasOwnProperty("invitesRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InvitesRequest.verify(message.invitesRequest);
                    if (error)
                        return "invitesRequest." + error;
                }
            }
            if (message.invitesResponse != null && message.hasOwnProperty("invitesResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InvitesResponse.verify(message.invitesResponse);
                    if (error)
                        return "invitesResponse." + error;
                }
            }
            if (message.notificationPrefs != null && message.hasOwnProperty("notificationPrefs")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.NotificationPrefs.verify(message.notificationPrefs);
                    if (error)
                        return "notificationPrefs." + error;
                }
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItem.verify(message.groupFeedItem);
                    if (error)
                        return "groupFeedItem." + error;
                }
            }
            if (message.groupAvatar != null && message.hasOwnProperty("groupAvatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.UploadGroupAvatar.verify(message.groupAvatar);
                    if (error)
                        return "groupAvatar." + error;
                }
            }
            if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.DeleteAccount.verify(message.deleteAccount);
                    if (error)
                        return "deleteAccount." + error;
                }
            }
            if (message.groupInviteLink != null && message.hasOwnProperty("groupInviteLink")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupInviteLink.verify(message.groupInviteLink);
                    if (error)
                        return "groupInviteLink." + error;
                }
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HistoryResend.verify(message.historyResend);
                    if (error)
                        return "historyResend." + error;
                }
            }
            if (message.exportData != null && message.hasOwnProperty("exportData")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExportData.verify(message.exportData);
                    if (error)
                        return "exportData." + error;
                }
            }
            if (message.contactSyncError != null && message.hasOwnProperty("contactSyncError")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactSyncError.verify(message.contactSyncError);
                    if (error)
                        return "contactSyncError." + error;
                }
            }
            if (message.clientOtpRequest != null && message.hasOwnProperty("clientOtpRequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientOtpRequest.verify(message.clientOtpRequest);
                    if (error)
                        return "clientOtpRequest." + error;
                }
            }
            if (message.clientOtpResponse != null && message.hasOwnProperty("clientOtpResponse")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ClientOtpResponse.verify(message.clientOtpResponse);
                    if (error)
                        return "clientOtpResponse." + error;
                }
            }
            if (message.whisperKeysCollection != null && message.hasOwnProperty("whisperKeysCollection")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeysCollection.verify(message.whisperKeysCollection);
                    if (error)
                        return "whisperKeysCollection." + error;
                }
            }
            if (message.getCallServers != null && message.hasOwnProperty("getCallServers")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GetCallServers.verify(message.getCallServers);
                    if (error)
                        return "getCallServers." + error;
                }
            }
            if (message.getCallServersResult != null && message.hasOwnProperty("getCallServersResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GetCallServersResult.verify(message.getCallServersResult);
                    if (error)
                        return "getCallServersResult." + error;
                }
            }
            if (message.startCall != null && message.hasOwnProperty("startCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.StartCall.verify(message.startCall);
                    if (error)
                        return "startCall." + error;
                }
            }
            if (message.startCallResult != null && message.hasOwnProperty("startCallResult")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.StartCallResult.verify(message.startCallResult);
                    if (error)
                        return "startCallResult." + error;
                }
            }
            if (message.truncWhisperKeysCollection != null && message.hasOwnProperty("truncWhisperKeysCollection")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.TruncWhisperKeysCollection.verify(message.truncWhisperKeysCollection);
                    if (error)
                        return "truncWhisperKeysCollection." + error;
                }
            }
            if (message.externalSharePost != null && message.hasOwnProperty("externalSharePost")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExternalSharePost.verify(message.externalSharePost);
                    if (error)
                        return "externalSharePost." + error;
                }
            }
            if (message.externalSharePostContainer != null && message.hasOwnProperty("externalSharePostContainer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ExternalSharePostContainer.verify(message.externalSharePostContainer);
                    if (error)
                        return "externalSharePostContainer." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Iq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Iq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Iq} Iq
         */
        Iq.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Iq)
                return object;
            var message = new $root.server.Iq();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "GET":
            case 0:
                message.type = 0;
                break;
            case "SET":
            case 1:
                message.type = 1;
                break;
            case "RESULT":
            case 2:
                message.type = 2;
                break;
            case "ERROR":
            case 3:
                message.type = 3;
                break;
            }
            if (object.uploadMedia != null) {
                if (typeof object.uploadMedia !== "object")
                    throw TypeError(".server.Iq.uploadMedia: object expected");
                message.uploadMedia = $root.server.UploadMedia.fromObject(object.uploadMedia);
            }
            if (object.contactList != null) {
                if (typeof object.contactList !== "object")
                    throw TypeError(".server.Iq.contactList: object expected");
                message.contactList = $root.server.ContactList.fromObject(object.contactList);
            }
            if (object.uploadAvatar != null) {
                if (typeof object.uploadAvatar !== "object")
                    throw TypeError(".server.Iq.uploadAvatar: object expected");
                message.uploadAvatar = $root.server.UploadAvatar.fromObject(object.uploadAvatar);
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".server.Iq.avatar: object expected");
                message.avatar = $root.server.Avatar.fromObject(object.avatar);
            }
            if (object.avatars != null) {
                if (typeof object.avatars !== "object")
                    throw TypeError(".server.Iq.avatars: object expected");
                message.avatars = $root.server.Avatars.fromObject(object.avatars);
            }
            if (object.clientMode != null) {
                if (typeof object.clientMode !== "object")
                    throw TypeError(".server.Iq.clientMode: object expected");
                message.clientMode = $root.server.ClientMode.fromObject(object.clientMode);
            }
            if (object.clientVersion != null) {
                if (typeof object.clientVersion !== "object")
                    throw TypeError(".server.Iq.clientVersion: object expected");
                message.clientVersion = $root.server.ClientVersion.fromObject(object.clientVersion);
            }
            if (object.pushRegister != null) {
                if (typeof object.pushRegister !== "object")
                    throw TypeError(".server.Iq.pushRegister: object expected");
                message.pushRegister = $root.server.PushRegister.fromObject(object.pushRegister);
            }
            if (object.whisperKeys != null) {
                if (typeof object.whisperKeys !== "object")
                    throw TypeError(".server.Iq.whisperKeys: object expected");
                message.whisperKeys = $root.server.WhisperKeys.fromObject(object.whisperKeys);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".server.Iq.ping: object expected");
                message.ping = $root.server.Ping.fromObject(object.ping);
            }
            if (object.feedItem != null) {
                if (typeof object.feedItem !== "object")
                    throw TypeError(".server.Iq.feedItem: object expected");
                message.feedItem = $root.server.FeedItem.fromObject(object.feedItem);
            }
            if (object.privacyList != null) {
                if (typeof object.privacyList !== "object")
                    throw TypeError(".server.Iq.privacyList: object expected");
                message.privacyList = $root.server.PrivacyList.fromObject(object.privacyList);
            }
            if (object.privacyLists != null) {
                if (typeof object.privacyLists !== "object")
                    throw TypeError(".server.Iq.privacyLists: object expected");
                message.privacyLists = $root.server.PrivacyLists.fromObject(object.privacyLists);
            }
            if (object.groupStanza != null) {
                if (typeof object.groupStanza !== "object")
                    throw TypeError(".server.Iq.groupStanza: object expected");
                message.groupStanza = $root.server.GroupStanza.fromObject(object.groupStanza);
            }
            if (object.groupsStanza != null) {
                if (typeof object.groupsStanza !== "object")
                    throw TypeError(".server.Iq.groupsStanza: object expected");
                message.groupsStanza = $root.server.GroupsStanza.fromObject(object.groupsStanza);
            }
            if (object.clientLog != null) {
                if (typeof object.clientLog !== "object")
                    throw TypeError(".server.Iq.clientLog: object expected");
                message.clientLog = $root.server.ClientLog.fromObject(object.clientLog);
            }
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".server.Iq.name: object expected");
                message.name = $root.server.Name.fromObject(object.name);
            }
            if (object.errorStanza != null) {
                if (typeof object.errorStanza !== "object")
                    throw TypeError(".server.Iq.errorStanza: object expected");
                message.errorStanza = $root.server.ErrorStanza.fromObject(object.errorStanza);
            }
            if (object.props != null) {
                if (typeof object.props !== "object")
                    throw TypeError(".server.Iq.props: object expected");
                message.props = $root.server.Props.fromObject(object.props);
            }
            if (object.invitesRequest != null) {
                if (typeof object.invitesRequest !== "object")
                    throw TypeError(".server.Iq.invitesRequest: object expected");
                message.invitesRequest = $root.server.InvitesRequest.fromObject(object.invitesRequest);
            }
            if (object.invitesResponse != null) {
                if (typeof object.invitesResponse !== "object")
                    throw TypeError(".server.Iq.invitesResponse: object expected");
                message.invitesResponse = $root.server.InvitesResponse.fromObject(object.invitesResponse);
            }
            if (object.notificationPrefs != null) {
                if (typeof object.notificationPrefs !== "object")
                    throw TypeError(".server.Iq.notificationPrefs: object expected");
                message.notificationPrefs = $root.server.NotificationPrefs.fromObject(object.notificationPrefs);
            }
            if (object.groupFeedItem != null) {
                if (typeof object.groupFeedItem !== "object")
                    throw TypeError(".server.Iq.groupFeedItem: object expected");
                message.groupFeedItem = $root.server.GroupFeedItem.fromObject(object.groupFeedItem);
            }
            if (object.groupAvatar != null) {
                if (typeof object.groupAvatar !== "object")
                    throw TypeError(".server.Iq.groupAvatar: object expected");
                message.groupAvatar = $root.server.UploadGroupAvatar.fromObject(object.groupAvatar);
            }
            if (object.deleteAccount != null) {
                if (typeof object.deleteAccount !== "object")
                    throw TypeError(".server.Iq.deleteAccount: object expected");
                message.deleteAccount = $root.server.DeleteAccount.fromObject(object.deleteAccount);
            }
            if (object.groupInviteLink != null) {
                if (typeof object.groupInviteLink !== "object")
                    throw TypeError(".server.Iq.groupInviteLink: object expected");
                message.groupInviteLink = $root.server.GroupInviteLink.fromObject(object.groupInviteLink);
            }
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.Iq.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            if (object.exportData != null) {
                if (typeof object.exportData !== "object")
                    throw TypeError(".server.Iq.exportData: object expected");
                message.exportData = $root.server.ExportData.fromObject(object.exportData);
            }
            if (object.contactSyncError != null) {
                if (typeof object.contactSyncError !== "object")
                    throw TypeError(".server.Iq.contactSyncError: object expected");
                message.contactSyncError = $root.server.ContactSyncError.fromObject(object.contactSyncError);
            }
            if (object.clientOtpRequest != null) {
                if (typeof object.clientOtpRequest !== "object")
                    throw TypeError(".server.Iq.clientOtpRequest: object expected");
                message.clientOtpRequest = $root.server.ClientOtpRequest.fromObject(object.clientOtpRequest);
            }
            if (object.clientOtpResponse != null) {
                if (typeof object.clientOtpResponse !== "object")
                    throw TypeError(".server.Iq.clientOtpResponse: object expected");
                message.clientOtpResponse = $root.server.ClientOtpResponse.fromObject(object.clientOtpResponse);
            }
            if (object.whisperKeysCollection != null) {
                if (typeof object.whisperKeysCollection !== "object")
                    throw TypeError(".server.Iq.whisperKeysCollection: object expected");
                message.whisperKeysCollection = $root.server.WhisperKeysCollection.fromObject(object.whisperKeysCollection);
            }
            if (object.getCallServers != null) {
                if (typeof object.getCallServers !== "object")
                    throw TypeError(".server.Iq.getCallServers: object expected");
                message.getCallServers = $root.server.GetCallServers.fromObject(object.getCallServers);
            }
            if (object.getCallServersResult != null) {
                if (typeof object.getCallServersResult !== "object")
                    throw TypeError(".server.Iq.getCallServersResult: object expected");
                message.getCallServersResult = $root.server.GetCallServersResult.fromObject(object.getCallServersResult);
            }
            if (object.startCall != null) {
                if (typeof object.startCall !== "object")
                    throw TypeError(".server.Iq.startCall: object expected");
                message.startCall = $root.server.StartCall.fromObject(object.startCall);
            }
            if (object.startCallResult != null) {
                if (typeof object.startCallResult !== "object")
                    throw TypeError(".server.Iq.startCallResult: object expected");
                message.startCallResult = $root.server.StartCallResult.fromObject(object.startCallResult);
            }
            if (object.truncWhisperKeysCollection != null) {
                if (typeof object.truncWhisperKeysCollection !== "object")
                    throw TypeError(".server.Iq.truncWhisperKeysCollection: object expected");
                message.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.fromObject(object.truncWhisperKeysCollection);
            }
            if (object.externalSharePost != null) {
                if (typeof object.externalSharePost !== "object")
                    throw TypeError(".server.Iq.externalSharePost: object expected");
                message.externalSharePost = $root.server.ExternalSharePost.fromObject(object.externalSharePost);
            }
            if (object.externalSharePostContainer != null) {
                if (typeof object.externalSharePostContainer !== "object")
                    throw TypeError(".server.Iq.externalSharePostContainer: object expected");
                message.externalSharePostContainer = $root.server.ExternalSharePostContainer.fromObject(object.externalSharePostContainer);
            }
            return message;
        };

        /**
         * Creates a plain object from an Iq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Iq
         * @static
         * @param {server.Iq} message Iq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Iq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "GET" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Iq.Type[message.type] : message.type;
            if (message.uploadMedia != null && message.hasOwnProperty("uploadMedia")) {
                object.uploadMedia = $root.server.UploadMedia.toObject(message.uploadMedia, options);
                if (options.oneofs)
                    object.payload = "uploadMedia";
            }
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                object.contactList = $root.server.ContactList.toObject(message.contactList, options);
                if (options.oneofs)
                    object.payload = "contactList";
            }
            if (message.uploadAvatar != null && message.hasOwnProperty("uploadAvatar")) {
                object.uploadAvatar = $root.server.UploadAvatar.toObject(message.uploadAvatar, options);
                if (options.oneofs)
                    object.payload = "uploadAvatar";
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                object.avatar = $root.server.Avatar.toObject(message.avatar, options);
                if (options.oneofs)
                    object.payload = "avatar";
            }
            if (message.avatars != null && message.hasOwnProperty("avatars")) {
                object.avatars = $root.server.Avatars.toObject(message.avatars, options);
                if (options.oneofs)
                    object.payload = "avatars";
            }
            if (message.clientMode != null && message.hasOwnProperty("clientMode")) {
                object.clientMode = $root.server.ClientMode.toObject(message.clientMode, options);
                if (options.oneofs)
                    object.payload = "clientMode";
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
                object.clientVersion = $root.server.ClientVersion.toObject(message.clientVersion, options);
                if (options.oneofs)
                    object.payload = "clientVersion";
            }
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                object.pushRegister = $root.server.PushRegister.toObject(message.pushRegister, options);
                if (options.oneofs)
                    object.payload = "pushRegister";
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                object.whisperKeys = $root.server.WhisperKeys.toObject(message.whisperKeys, options);
                if (options.oneofs)
                    object.payload = "whisperKeys";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.server.Ping.toObject(message.ping, options);
                if (options.oneofs)
                    object.payload = "ping";
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                object.feedItem = $root.server.FeedItem.toObject(message.feedItem, options);
                if (options.oneofs)
                    object.payload = "feedItem";
            }
            if (message.privacyList != null && message.hasOwnProperty("privacyList")) {
                object.privacyList = $root.server.PrivacyList.toObject(message.privacyList, options);
                if (options.oneofs)
                    object.payload = "privacyList";
            }
            if (message.privacyLists != null && message.hasOwnProperty("privacyLists")) {
                object.privacyLists = $root.server.PrivacyLists.toObject(message.privacyLists, options);
                if (options.oneofs)
                    object.payload = "privacyLists";
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                object.groupStanza = $root.server.GroupStanza.toObject(message.groupStanza, options);
                if (options.oneofs)
                    object.payload = "groupStanza";
            }
            if (message.groupsStanza != null && message.hasOwnProperty("groupsStanza")) {
                object.groupsStanza = $root.server.GroupsStanza.toObject(message.groupsStanza, options);
                if (options.oneofs)
                    object.payload = "groupsStanza";
            }
            if (message.clientLog != null && message.hasOwnProperty("clientLog")) {
                object.clientLog = $root.server.ClientLog.toObject(message.clientLog, options);
                if (options.oneofs)
                    object.payload = "clientLog";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = $root.server.Name.toObject(message.name, options);
                if (options.oneofs)
                    object.payload = "name";
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                object.errorStanza = $root.server.ErrorStanza.toObject(message.errorStanza, options);
                if (options.oneofs)
                    object.payload = "errorStanza";
            }
            if (message.props != null && message.hasOwnProperty("props")) {
                object.props = $root.server.Props.toObject(message.props, options);
                if (options.oneofs)
                    object.payload = "props";
            }
            if (message.invitesRequest != null && message.hasOwnProperty("invitesRequest")) {
                object.invitesRequest = $root.server.InvitesRequest.toObject(message.invitesRequest, options);
                if (options.oneofs)
                    object.payload = "invitesRequest";
            }
            if (message.invitesResponse != null && message.hasOwnProperty("invitesResponse")) {
                object.invitesResponse = $root.server.InvitesResponse.toObject(message.invitesResponse, options);
                if (options.oneofs)
                    object.payload = "invitesResponse";
            }
            if (message.notificationPrefs != null && message.hasOwnProperty("notificationPrefs")) {
                object.notificationPrefs = $root.server.NotificationPrefs.toObject(message.notificationPrefs, options);
                if (options.oneofs)
                    object.payload = "notificationPrefs";
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                object.groupFeedItem = $root.server.GroupFeedItem.toObject(message.groupFeedItem, options);
                if (options.oneofs)
                    object.payload = "groupFeedItem";
            }
            if (message.groupAvatar != null && message.hasOwnProperty("groupAvatar")) {
                object.groupAvatar = $root.server.UploadGroupAvatar.toObject(message.groupAvatar, options);
                if (options.oneofs)
                    object.payload = "groupAvatar";
            }
            if (message.deleteAccount != null && message.hasOwnProperty("deleteAccount")) {
                object.deleteAccount = $root.server.DeleteAccount.toObject(message.deleteAccount, options);
                if (options.oneofs)
                    object.payload = "deleteAccount";
            }
            if (message.groupInviteLink != null && message.hasOwnProperty("groupInviteLink")) {
                object.groupInviteLink = $root.server.GroupInviteLink.toObject(message.groupInviteLink, options);
                if (options.oneofs)
                    object.payload = "groupInviteLink";
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
                if (options.oneofs)
                    object.payload = "historyResend";
            }
            if (message.exportData != null && message.hasOwnProperty("exportData")) {
                object.exportData = $root.server.ExportData.toObject(message.exportData, options);
                if (options.oneofs)
                    object.payload = "exportData";
            }
            if (message.contactSyncError != null && message.hasOwnProperty("contactSyncError")) {
                object.contactSyncError = $root.server.ContactSyncError.toObject(message.contactSyncError, options);
                if (options.oneofs)
                    object.payload = "contactSyncError";
            }
            if (message.clientOtpRequest != null && message.hasOwnProperty("clientOtpRequest")) {
                object.clientOtpRequest = $root.server.ClientOtpRequest.toObject(message.clientOtpRequest, options);
                if (options.oneofs)
                    object.payload = "clientOtpRequest";
            }
            if (message.clientOtpResponse != null && message.hasOwnProperty("clientOtpResponse")) {
                object.clientOtpResponse = $root.server.ClientOtpResponse.toObject(message.clientOtpResponse, options);
                if (options.oneofs)
                    object.payload = "clientOtpResponse";
            }
            if (message.whisperKeysCollection != null && message.hasOwnProperty("whisperKeysCollection")) {
                object.whisperKeysCollection = $root.server.WhisperKeysCollection.toObject(message.whisperKeysCollection, options);
                if (options.oneofs)
                    object.payload = "whisperKeysCollection";
            }
            if (message.getCallServers != null && message.hasOwnProperty("getCallServers")) {
                object.getCallServers = $root.server.GetCallServers.toObject(message.getCallServers, options);
                if (options.oneofs)
                    object.payload = "getCallServers";
            }
            if (message.getCallServersResult != null && message.hasOwnProperty("getCallServersResult")) {
                object.getCallServersResult = $root.server.GetCallServersResult.toObject(message.getCallServersResult, options);
                if (options.oneofs)
                    object.payload = "getCallServersResult";
            }
            if (message.startCall != null && message.hasOwnProperty("startCall")) {
                object.startCall = $root.server.StartCall.toObject(message.startCall, options);
                if (options.oneofs)
                    object.payload = "startCall";
            }
            if (message.startCallResult != null && message.hasOwnProperty("startCallResult")) {
                object.startCallResult = $root.server.StartCallResult.toObject(message.startCallResult, options);
                if (options.oneofs)
                    object.payload = "startCallResult";
            }
            if (message.truncWhisperKeysCollection != null && message.hasOwnProperty("truncWhisperKeysCollection")) {
                object.truncWhisperKeysCollection = $root.server.TruncWhisperKeysCollection.toObject(message.truncWhisperKeysCollection, options);
                if (options.oneofs)
                    object.payload = "truncWhisperKeysCollection";
            }
            if (message.externalSharePost != null && message.hasOwnProperty("externalSharePost")) {
                object.externalSharePost = $root.server.ExternalSharePost.toObject(message.externalSharePost, options);
                if (options.oneofs)
                    object.payload = "externalSharePost";
            }
            if (message.externalSharePostContainer != null && message.hasOwnProperty("externalSharePostContainer")) {
                object.externalSharePostContainer = $root.server.ExternalSharePostContainer.toObject(message.externalSharePostContainer, options);
                if (options.oneofs)
                    object.payload = "externalSharePostContainer";
            }
            return object;
        };

        /**
         * Converts this Iq to JSON.
         * @function toJSON
         * @memberof server.Iq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Iq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Iq.Type
         * @enum {number}
         * @property {number} GET=0 GET value
         * @property {number} SET=1 SET value
         * @property {number} RESULT=2 RESULT value
         * @property {number} ERROR=3 ERROR value
         */
        Iq.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GET"] = 0;
            values[valuesById[1] = "SET"] = 1;
            values[valuesById[2] = "RESULT"] = 2;
            values[valuesById[3] = "ERROR"] = 3;
            return values;
        })();

        return Iq;
    })();

    server.Msg = (function() {

        /**
         * Properties of a Msg.
         * @memberof server
         * @interface IMsg
         * @property {string|null} [id] Msg id
         * @property {server.Msg.Type|null} [type] Msg type
         * @property {number|Long|null} [toUid] Msg toUid
         * @property {number|Long|null} [fromUid] Msg fromUid
         * @property {server.IContactList|null} [contactList] Msg contactList
         * @property {server.IAvatar|null} [avatar] Msg avatar
         * @property {server.IWhisperKeys|null} [whisperKeys] Msg whisperKeys
         * @property {server.ISeenReceipt|null} [seenReceipt] Msg seenReceipt
         * @property {server.IDeliveryReceipt|null} [deliveryReceipt] Msg deliveryReceipt
         * @property {server.IChatStanza|null} [chatStanza] Msg chatStanza
         * @property {server.IFeedItem|null} [feedItem] Msg feedItem
         * @property {server.IFeedItems|null} [feedItems] Msg feedItems
         * @property {server.IContactHash|null} [contactHash] Msg contactHash
         * @property {server.IGroupStanza|null} [groupStanza] Msg groupStanza
         * @property {server.IGroupChat|null} [groupChat] Msg groupChat
         * @property {server.IName|null} [name] Msg name
         * @property {server.IErrorStanza|null} [errorStanza] Msg errorStanza
         * @property {server.IGroupChatRetract|null} [groupchatRetract] Msg groupchatRetract
         * @property {server.IChatRetract|null} [chatRetract] Msg chatRetract
         * @property {server.IGroupFeedItem|null} [groupFeedItem] Msg groupFeedItem
         * @property {server.IRerequest|null} [rerequest] Msg rerequest
         * @property {server.ISilentChatStanza|null} [silentChatStanza] Msg silentChatStanza
         * @property {server.IGroupFeedItems|null} [groupFeedItems] Msg groupFeedItems
         * @property {server.IEndOfQueue|null} [endOfQueue] Msg endOfQueue
         * @property {server.IInviteeNotice|null} [inviteeNotice] Msg inviteeNotice
         * @property {server.IGroupFeedRerequest|null} [groupFeedRerequest] Msg groupFeedRerequest
         * @property {server.IHistoryResend|null} [historyResend] Msg historyResend
         * @property {server.IPlayedReceipt|null} [playedReceipt] Msg playedReceipt
         * @property {server.IRequestLogs|null} [requestLogs] Msg requestLogs
         * @property {server.IWakeUp|null} [wakeup] Msg wakeup
         * @property {server.IHomeFeedRerequest|null} [homeFeedRerequest] Msg homeFeedRerequest
         * @property {server.IIncomingCall|null} [incomingCall] Msg incomingCall
         * @property {server.ICallRinging|null} [callRinging] Msg callRinging
         * @property {server.IAnswerCall|null} [answerCall] Msg answerCall
         * @property {server.IEndCall|null} [endCall] Msg endCall
         * @property {server.IIceCandidate|null} [iceCandidate] Msg iceCandidate
         * @property {server.IMarketingAlert|null} [marketingAlert] Msg marketingAlert
         * @property {server.IIceRestartOffer|null} [iceRestartOffer] Msg iceRestartOffer
         * @property {server.IIceRestartAnswer|null} [iceRestartAnswer] Msg iceRestartAnswer
         * @property {server.IGroupFeedHistory|null} [groupFeedHistory] Msg groupFeedHistory
         * @property {server.IPreAnswerCall|null} [preAnswerCall] Msg preAnswerCall
         * @property {server.IHoldCall|null} [holdCall] Msg holdCall
         * @property {server.IMuteCall|null} [muteCall] Msg muteCall
         * @property {server.IIncomingCallPush|null} [incomingCallPush] Msg incomingCallPush
         * @property {server.ICallSdp|null} [callSdp] Msg callSdp
         * @property {number|null} [retryCount] Msg retryCount
         * @property {number|null} [rerequestCount] Msg rerequestCount
         */

        /**
         * Constructs a new Msg.
         * @memberof server
         * @classdesc Represents a Msg.
         * @implements IMsg
         * @constructor
         * @param {server.IMsg=} [properties] Properties to set
         */
        function Msg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Msg id.
         * @member {string} id
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.id = "";

        /**
         * Msg type.
         * @member {server.Msg.Type} type
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.type = 0;

        /**
         * Msg toUid.
         * @member {number|Long} toUid
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.toUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Msg fromUid.
         * @member {number|Long} fromUid
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Msg contactList.
         * @member {server.IContactList|null|undefined} contactList
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.contactList = null;

        /**
         * Msg avatar.
         * @member {server.IAvatar|null|undefined} avatar
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.avatar = null;

        /**
         * Msg whisperKeys.
         * @member {server.IWhisperKeys|null|undefined} whisperKeys
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.whisperKeys = null;

        /**
         * Msg seenReceipt.
         * @member {server.ISeenReceipt|null|undefined} seenReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.seenReceipt = null;

        /**
         * Msg deliveryReceipt.
         * @member {server.IDeliveryReceipt|null|undefined} deliveryReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.deliveryReceipt = null;

        /**
         * Msg chatStanza.
         * @member {server.IChatStanza|null|undefined} chatStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.chatStanza = null;

        /**
         * Msg feedItem.
         * @member {server.IFeedItem|null|undefined} feedItem
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.feedItem = null;

        /**
         * Msg feedItems.
         * @member {server.IFeedItems|null|undefined} feedItems
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.feedItems = null;

        /**
         * Msg contactHash.
         * @member {server.IContactHash|null|undefined} contactHash
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.contactHash = null;

        /**
         * Msg groupStanza.
         * @member {server.IGroupStanza|null|undefined} groupStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupStanza = null;

        /**
         * Msg groupChat.
         * @member {server.IGroupChat|null|undefined} groupChat
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupChat = null;

        /**
         * Msg name.
         * @member {server.IName|null|undefined} name
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.name = null;

        /**
         * Msg errorStanza.
         * @member {server.IErrorStanza|null|undefined} errorStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.errorStanza = null;

        /**
         * Msg groupchatRetract.
         * @member {server.IGroupChatRetract|null|undefined} groupchatRetract
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupchatRetract = null;

        /**
         * Msg chatRetract.
         * @member {server.IChatRetract|null|undefined} chatRetract
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.chatRetract = null;

        /**
         * Msg groupFeedItem.
         * @member {server.IGroupFeedItem|null|undefined} groupFeedItem
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedItem = null;

        /**
         * Msg rerequest.
         * @member {server.IRerequest|null|undefined} rerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.rerequest = null;

        /**
         * Msg silentChatStanza.
         * @member {server.ISilentChatStanza|null|undefined} silentChatStanza
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.silentChatStanza = null;

        /**
         * Msg groupFeedItems.
         * @member {server.IGroupFeedItems|null|undefined} groupFeedItems
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedItems = null;

        /**
         * Msg endOfQueue.
         * @member {server.IEndOfQueue|null|undefined} endOfQueue
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.endOfQueue = null;

        /**
         * Msg inviteeNotice.
         * @member {server.IInviteeNotice|null|undefined} inviteeNotice
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.inviteeNotice = null;

        /**
         * Msg groupFeedRerequest.
         * @member {server.IGroupFeedRerequest|null|undefined} groupFeedRerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedRerequest = null;

        /**
         * Msg historyResend.
         * @member {server.IHistoryResend|null|undefined} historyResend
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.historyResend = null;

        /**
         * Msg playedReceipt.
         * @member {server.IPlayedReceipt|null|undefined} playedReceipt
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.playedReceipt = null;

        /**
         * Msg requestLogs.
         * @member {server.IRequestLogs|null|undefined} requestLogs
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.requestLogs = null;

        /**
         * Msg wakeup.
         * @member {server.IWakeUp|null|undefined} wakeup
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.wakeup = null;

        /**
         * Msg homeFeedRerequest.
         * @member {server.IHomeFeedRerequest|null|undefined} homeFeedRerequest
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.homeFeedRerequest = null;

        /**
         * Msg incomingCall.
         * @member {server.IIncomingCall|null|undefined} incomingCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.incomingCall = null;

        /**
         * Msg callRinging.
         * @member {server.ICallRinging|null|undefined} callRinging
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.callRinging = null;

        /**
         * Msg answerCall.
         * @member {server.IAnswerCall|null|undefined} answerCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.answerCall = null;

        /**
         * Msg endCall.
         * @member {server.IEndCall|null|undefined} endCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.endCall = null;

        /**
         * Msg iceCandidate.
         * @member {server.IIceCandidate|null|undefined} iceCandidate
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceCandidate = null;

        /**
         * Msg marketingAlert.
         * @member {server.IMarketingAlert|null|undefined} marketingAlert
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.marketingAlert = null;

        /**
         * Msg iceRestartOffer.
         * @member {server.IIceRestartOffer|null|undefined} iceRestartOffer
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceRestartOffer = null;

        /**
         * Msg iceRestartAnswer.
         * @member {server.IIceRestartAnswer|null|undefined} iceRestartAnswer
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.iceRestartAnswer = null;

        /**
         * Msg groupFeedHistory.
         * @member {server.IGroupFeedHistory|null|undefined} groupFeedHistory
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.groupFeedHistory = null;

        /**
         * Msg preAnswerCall.
         * @member {server.IPreAnswerCall|null|undefined} preAnswerCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.preAnswerCall = null;

        /**
         * Msg holdCall.
         * @member {server.IHoldCall|null|undefined} holdCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.holdCall = null;

        /**
         * Msg muteCall.
         * @member {server.IMuteCall|null|undefined} muteCall
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.muteCall = null;

        /**
         * Msg incomingCallPush.
         * @member {server.IIncomingCallPush|null|undefined} incomingCallPush
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.incomingCallPush = null;

        /**
         * Msg callSdp.
         * @member {server.ICallSdp|null|undefined} callSdp
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.callSdp = null;

        /**
         * Msg retryCount.
         * @member {number} retryCount
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.retryCount = 0;

        /**
         * Msg rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.Msg
         * @instance
         */
        Msg.prototype.rerequestCount = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Msg payload.
         * @member {"contactList"|"avatar"|"whisperKeys"|"seenReceipt"|"deliveryReceipt"|"chatStanza"|"feedItem"|"feedItems"|"contactHash"|"groupStanza"|"groupChat"|"name"|"errorStanza"|"groupchatRetract"|"chatRetract"|"groupFeedItem"|"rerequest"|"silentChatStanza"|"groupFeedItems"|"endOfQueue"|"inviteeNotice"|"groupFeedRerequest"|"historyResend"|"playedReceipt"|"requestLogs"|"wakeup"|"homeFeedRerequest"|"incomingCall"|"callRinging"|"answerCall"|"endCall"|"iceCandidate"|"marketingAlert"|"iceRestartOffer"|"iceRestartAnswer"|"groupFeedHistory"|"preAnswerCall"|"holdCall"|"muteCall"|"incomingCallPush"|"callSdp"|undefined} payload
         * @memberof server.Msg
         * @instance
         */
        Object.defineProperty(Msg.prototype, "payload", {
            get: $util.oneOfGetter($oneOfFields = ["contactList", "avatar", "whisperKeys", "seenReceipt", "deliveryReceipt", "chatStanza", "feedItem", "feedItems", "contactHash", "groupStanza", "groupChat", "name", "errorStanza", "groupchatRetract", "chatRetract", "groupFeedItem", "rerequest", "silentChatStanza", "groupFeedItems", "endOfQueue", "inviteeNotice", "groupFeedRerequest", "historyResend", "playedReceipt", "requestLogs", "wakeup", "homeFeedRerequest", "incomingCall", "callRinging", "answerCall", "endCall", "iceCandidate", "marketingAlert", "iceRestartOffer", "iceRestartAnswer", "groupFeedHistory", "preAnswerCall", "holdCall", "muteCall", "incomingCallPush", "callSdp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Msg instance using the specified properties.
         * @function create
         * @memberof server.Msg
         * @static
         * @param {server.IMsg=} [properties] Properties to set
         * @returns {server.Msg} Msg instance
         */
        Msg.create = function create(properties) {
            return new Msg(properties);
        };

        /**
         * Encodes the specified Msg message. Does not implicitly {@link server.Msg.verify|verify} messages.
         * @function encode
         * @memberof server.Msg
         * @static
         * @param {server.IMsg} message Msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Msg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.toUid);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromUid);
            if (message.contactList != null && Object.hasOwnProperty.call(message, "contactList"))
                $root.server.ContactList.encode(message.contactList, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                $root.server.Avatar.encode(message.avatar, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.whisperKeys != null && Object.hasOwnProperty.call(message, "whisperKeys"))
                $root.server.WhisperKeys.encode(message.whisperKeys, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.seenReceipt != null && Object.hasOwnProperty.call(message, "seenReceipt"))
                $root.server.SeenReceipt.encode(message.seenReceipt, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.deliveryReceipt != null && Object.hasOwnProperty.call(message, "deliveryReceipt"))
                $root.server.DeliveryReceipt.encode(message.deliveryReceipt, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.chatStanza != null && Object.hasOwnProperty.call(message, "chatStanza"))
                $root.server.ChatStanza.encode(message.chatStanza, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.feedItem != null && Object.hasOwnProperty.call(message, "feedItem"))
                $root.server.FeedItem.encode(message.feedItem, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.feedItems != null && Object.hasOwnProperty.call(message, "feedItems"))
                $root.server.FeedItems.encode(message.feedItems, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.contactHash != null && Object.hasOwnProperty.call(message, "contactHash"))
                $root.server.ContactHash.encode(message.contactHash, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.groupStanza != null && Object.hasOwnProperty.call(message, "groupStanza"))
                $root.server.GroupStanza.encode(message.groupStanza, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.groupChat != null && Object.hasOwnProperty.call(message, "groupChat"))
                $root.server.GroupChat.encode(message.groupChat, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                $root.server.Name.encode(message.name, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.errorStanza != null && Object.hasOwnProperty.call(message, "errorStanza"))
                $root.server.ErrorStanza.encode(message.errorStanza, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.groupchatRetract != null && Object.hasOwnProperty.call(message, "groupchatRetract"))
                $root.server.GroupChatRetract.encode(message.groupchatRetract, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.chatRetract != null && Object.hasOwnProperty.call(message, "chatRetract"))
                $root.server.ChatRetract.encode(message.chatRetract, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.groupFeedItem != null && Object.hasOwnProperty.call(message, "groupFeedItem"))
                $root.server.GroupFeedItem.encode(message.groupFeedItem, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.retryCount);
            if (message.rerequest != null && Object.hasOwnProperty.call(message, "rerequest"))
                $root.server.Rerequest.encode(message.rerequest, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.silentChatStanza != null && Object.hasOwnProperty.call(message, "silentChatStanza"))
                $root.server.SilentChatStanza.encode(message.silentChatStanza, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.groupFeedItems != null && Object.hasOwnProperty.call(message, "groupFeedItems"))
                $root.server.GroupFeedItems.encode(message.groupFeedItems, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.rerequestCount);
            if (message.endOfQueue != null && Object.hasOwnProperty.call(message, "endOfQueue"))
                $root.server.EndOfQueue.encode(message.endOfQueue, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.inviteeNotice != null && Object.hasOwnProperty.call(message, "inviteeNotice"))
                $root.server.InviteeNotice.encode(message.inviteeNotice, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.groupFeedRerequest != null && Object.hasOwnProperty.call(message, "groupFeedRerequest"))
                $root.server.GroupFeedRerequest.encode(message.groupFeedRerequest, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.historyResend != null && Object.hasOwnProperty.call(message, "historyResend"))
                $root.server.HistoryResend.encode(message.historyResend, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.playedReceipt != null && Object.hasOwnProperty.call(message, "playedReceipt"))
                $root.server.PlayedReceipt.encode(message.playedReceipt, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.requestLogs != null && Object.hasOwnProperty.call(message, "requestLogs"))
                $root.server.RequestLogs.encode(message.requestLogs, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.wakeup != null && Object.hasOwnProperty.call(message, "wakeup"))
                $root.server.WakeUp.encode(message.wakeup, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.homeFeedRerequest != null && Object.hasOwnProperty.call(message, "homeFeedRerequest"))
                $root.server.HomeFeedRerequest.encode(message.homeFeedRerequest, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.incomingCall != null && Object.hasOwnProperty.call(message, "incomingCall"))
                $root.server.IncomingCall.encode(message.incomingCall, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.callRinging != null && Object.hasOwnProperty.call(message, "callRinging"))
                $root.server.CallRinging.encode(message.callRinging, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.answerCall != null && Object.hasOwnProperty.call(message, "answerCall"))
                $root.server.AnswerCall.encode(message.answerCall, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.endCall != null && Object.hasOwnProperty.call(message, "endCall"))
                $root.server.EndCall.encode(message.endCall, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.iceCandidate != null && Object.hasOwnProperty.call(message, "iceCandidate"))
                $root.server.IceCandidate.encode(message.iceCandidate, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.marketingAlert != null && Object.hasOwnProperty.call(message, "marketingAlert"))
                $root.server.MarketingAlert.encode(message.marketingAlert, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.iceRestartOffer != null && Object.hasOwnProperty.call(message, "iceRestartOffer"))
                $root.server.IceRestartOffer.encode(message.iceRestartOffer, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.iceRestartAnswer != null && Object.hasOwnProperty.call(message, "iceRestartAnswer"))
                $root.server.IceRestartAnswer.encode(message.iceRestartAnswer, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.groupFeedHistory != null && Object.hasOwnProperty.call(message, "groupFeedHistory"))
                $root.server.GroupFeedHistory.encode(message.groupFeedHistory, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.preAnswerCall != null && Object.hasOwnProperty.call(message, "preAnswerCall"))
                $root.server.PreAnswerCall.encode(message.preAnswerCall, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.holdCall != null && Object.hasOwnProperty.call(message, "holdCall"))
                $root.server.HoldCall.encode(message.holdCall, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.muteCall != null && Object.hasOwnProperty.call(message, "muteCall"))
                $root.server.MuteCall.encode(message.muteCall, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.incomingCallPush != null && Object.hasOwnProperty.call(message, "incomingCallPush"))
                $root.server.IncomingCallPush.encode(message.incomingCallPush, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.callSdp != null && Object.hasOwnProperty.call(message, "callSdp"))
                $root.server.CallSdp.encode(message.callSdp, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Msg message, length delimited. Does not implicitly {@link server.Msg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Msg
         * @static
         * @param {server.IMsg} message Msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Msg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Msg message from the specified reader or buffer.
         * @function decode
         * @memberof server.Msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Msg} Msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Msg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Msg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.toUid = reader.int64();
                    break;
                case 4:
                    message.fromUid = reader.int64();
                    break;
                case 5:
                    message.contactList = $root.server.ContactList.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.avatar = $root.server.Avatar.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.whisperKeys = $root.server.WhisperKeys.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.seenReceipt = $root.server.SeenReceipt.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.deliveryReceipt = $root.server.DeliveryReceipt.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.chatStanza = $root.server.ChatStanza.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.feedItem = $root.server.FeedItem.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.feedItems = $root.server.FeedItems.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.contactHash = $root.server.ContactHash.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.groupStanza = $root.server.GroupStanza.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.groupChat = $root.server.GroupChat.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.name = $root.server.Name.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.errorStanza = $root.server.ErrorStanza.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.groupchatRetract = $root.server.GroupChatRetract.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.chatRetract = $root.server.ChatRetract.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.groupFeedItem = $root.server.GroupFeedItem.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.rerequest = $root.server.Rerequest.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.silentChatStanza = $root.server.SilentChatStanza.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.groupFeedItems = $root.server.GroupFeedItems.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.endOfQueue = $root.server.EndOfQueue.decode(reader, reader.uint32());
                    break;
                case 27:
                    message.inviteeNotice = $root.server.InviteeNotice.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.groupFeedRerequest = $root.server.GroupFeedRerequest.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.historyResend = $root.server.HistoryResend.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.playedReceipt = $root.server.PlayedReceipt.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.requestLogs = $root.server.RequestLogs.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.wakeup = $root.server.WakeUp.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.homeFeedRerequest = $root.server.HomeFeedRerequest.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.incomingCall = $root.server.IncomingCall.decode(reader, reader.uint32());
                    break;
                case 35:
                    message.callRinging = $root.server.CallRinging.decode(reader, reader.uint32());
                    break;
                case 36:
                    message.answerCall = $root.server.AnswerCall.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.endCall = $root.server.EndCall.decode(reader, reader.uint32());
                    break;
                case 38:
                    message.iceCandidate = $root.server.IceCandidate.decode(reader, reader.uint32());
                    break;
                case 39:
                    message.marketingAlert = $root.server.MarketingAlert.decode(reader, reader.uint32());
                    break;
                case 40:
                    message.iceRestartOffer = $root.server.IceRestartOffer.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.iceRestartAnswer = $root.server.IceRestartAnswer.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.groupFeedHistory = $root.server.GroupFeedHistory.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.preAnswerCall = $root.server.PreAnswerCall.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.holdCall = $root.server.HoldCall.decode(reader, reader.uint32());
                    break;
                case 45:
                    message.muteCall = $root.server.MuteCall.decode(reader, reader.uint32());
                    break;
                case 46:
                    message.incomingCallPush = $root.server.IncomingCallPush.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.callSdp = $root.server.CallSdp.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.retryCount = reader.int32();
                    break;
                case 25:
                    message.rerequestCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Msg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Msg} Msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Msg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Msg message.
         * @function verify
         * @memberof server.Msg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Msg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (!$util.isInteger(message.toUid) && !(message.toUid && $util.isInteger(message.toUid.low) && $util.isInteger(message.toUid.high)))
                    return "toUid: integer|Long expected";
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                properties.payload = 1;
                {
                    var error = $root.server.ContactList.verify(message.contactList);
                    if (error)
                        return "contactList." + error;
                }
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WhisperKeys.verify(message.whisperKeys);
                    if (error)
                        return "whisperKeys." + error;
                }
            }
            if (message.seenReceipt != null && message.hasOwnProperty("seenReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SeenReceipt.verify(message.seenReceipt);
                    if (error)
                        return "seenReceipt." + error;
                }
            }
            if (message.deliveryReceipt != null && message.hasOwnProperty("deliveryReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.DeliveryReceipt.verify(message.deliveryReceipt);
                    if (error)
                        return "deliveryReceipt." + error;
                }
            }
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ChatStanza.verify(message.chatStanza);
                    if (error)
                        return "chatStanza." + error;
                }
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItem.verify(message.feedItem);
                    if (error)
                        return "feedItem." + error;
                }
            }
            if (message.feedItems != null && message.hasOwnProperty("feedItems")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.FeedItems.verify(message.feedItems);
                    if (error)
                        return "feedItems." + error;
                }
            }
            if (message.contactHash != null && message.hasOwnProperty("contactHash")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ContactHash.verify(message.contactHash);
                    if (error)
                        return "contactHash." + error;
                }
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupStanza.verify(message.groupStanza);
                    if (error)
                        return "groupStanza." + error;
                }
            }
            if (message.groupChat != null && message.hasOwnProperty("groupChat")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupChat.verify(message.groupChat);
                    if (error)
                        return "groupChat." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Name.verify(message.name);
                    if (error)
                        return "name." + error;
                }
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ErrorStanza.verify(message.errorStanza);
                    if (error)
                        return "errorStanza." + error;
                }
            }
            if (message.groupchatRetract != null && message.hasOwnProperty("groupchatRetract")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupChatRetract.verify(message.groupchatRetract);
                    if (error)
                        return "groupchatRetract." + error;
                }
            }
            if (message.chatRetract != null && message.hasOwnProperty("chatRetract")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.ChatRetract.verify(message.chatRetract);
                    if (error)
                        return "chatRetract." + error;
                }
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItem.verify(message.groupFeedItem);
                    if (error)
                        return "groupFeedItem." + error;
                }
            }
            if (message.rerequest != null && message.hasOwnProperty("rerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.Rerequest.verify(message.rerequest);
                    if (error)
                        return "rerequest." + error;
                }
            }
            if (message.silentChatStanza != null && message.hasOwnProperty("silentChatStanza")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.SilentChatStanza.verify(message.silentChatStanza);
                    if (error)
                        return "silentChatStanza." + error;
                }
            }
            if (message.groupFeedItems != null && message.hasOwnProperty("groupFeedItems")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedItems.verify(message.groupFeedItems);
                    if (error)
                        return "groupFeedItems." + error;
                }
            }
            if (message.endOfQueue != null && message.hasOwnProperty("endOfQueue")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.EndOfQueue.verify(message.endOfQueue);
                    if (error)
                        return "endOfQueue." + error;
                }
            }
            if (message.inviteeNotice != null && message.hasOwnProperty("inviteeNotice")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.InviteeNotice.verify(message.inviteeNotice);
                    if (error)
                        return "inviteeNotice." + error;
                }
            }
            if (message.groupFeedRerequest != null && message.hasOwnProperty("groupFeedRerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedRerequest.verify(message.groupFeedRerequest);
                    if (error)
                        return "groupFeedRerequest." + error;
                }
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HistoryResend.verify(message.historyResend);
                    if (error)
                        return "historyResend." + error;
                }
            }
            if (message.playedReceipt != null && message.hasOwnProperty("playedReceipt")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PlayedReceipt.verify(message.playedReceipt);
                    if (error)
                        return "playedReceipt." + error;
                }
            }
            if (message.requestLogs != null && message.hasOwnProperty("requestLogs")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.RequestLogs.verify(message.requestLogs);
                    if (error)
                        return "requestLogs." + error;
                }
            }
            if (message.wakeup != null && message.hasOwnProperty("wakeup")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.WakeUp.verify(message.wakeup);
                    if (error)
                        return "wakeup." + error;
                }
            }
            if (message.homeFeedRerequest != null && message.hasOwnProperty("homeFeedRerequest")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HomeFeedRerequest.verify(message.homeFeedRerequest);
                    if (error)
                        return "homeFeedRerequest." + error;
                }
            }
            if (message.incomingCall != null && message.hasOwnProperty("incomingCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IncomingCall.verify(message.incomingCall);
                    if (error)
                        return "incomingCall." + error;
                }
            }
            if (message.callRinging != null && message.hasOwnProperty("callRinging")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.CallRinging.verify(message.callRinging);
                    if (error)
                        return "callRinging." + error;
                }
            }
            if (message.answerCall != null && message.hasOwnProperty("answerCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.AnswerCall.verify(message.answerCall);
                    if (error)
                        return "answerCall." + error;
                }
            }
            if (message.endCall != null && message.hasOwnProperty("endCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.EndCall.verify(message.endCall);
                    if (error)
                        return "endCall." + error;
                }
            }
            if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceCandidate.verify(message.iceCandidate);
                    if (error)
                        return "iceCandidate." + error;
                }
            }
            if (message.marketingAlert != null && message.hasOwnProperty("marketingAlert")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.MarketingAlert.verify(message.marketingAlert);
                    if (error)
                        return "marketingAlert." + error;
                }
            }
            if (message.iceRestartOffer != null && message.hasOwnProperty("iceRestartOffer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceRestartOffer.verify(message.iceRestartOffer);
                    if (error)
                        return "iceRestartOffer." + error;
                }
            }
            if (message.iceRestartAnswer != null && message.hasOwnProperty("iceRestartAnswer")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IceRestartAnswer.verify(message.iceRestartAnswer);
                    if (error)
                        return "iceRestartAnswer." + error;
                }
            }
            if (message.groupFeedHistory != null && message.hasOwnProperty("groupFeedHistory")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.GroupFeedHistory.verify(message.groupFeedHistory);
                    if (error)
                        return "groupFeedHistory." + error;
                }
            }
            if (message.preAnswerCall != null && message.hasOwnProperty("preAnswerCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.PreAnswerCall.verify(message.preAnswerCall);
                    if (error)
                        return "preAnswerCall." + error;
                }
            }
            if (message.holdCall != null && message.hasOwnProperty("holdCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.HoldCall.verify(message.holdCall);
                    if (error)
                        return "holdCall." + error;
                }
            }
            if (message.muteCall != null && message.hasOwnProperty("muteCall")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.MuteCall.verify(message.muteCall);
                    if (error)
                        return "muteCall." + error;
                }
            }
            if (message.incomingCallPush != null && message.hasOwnProperty("incomingCallPush")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.IncomingCallPush.verify(message.incomingCallPush);
                    if (error)
                        return "incomingCallPush." + error;
                }
            }
            if (message.callSdp != null && message.hasOwnProperty("callSdp")) {
                if (properties.payload === 1)
                    return "payload: multiple values";
                properties.payload = 1;
                {
                    var error = $root.server.CallSdp.verify(message.callSdp);
                    if (error)
                        return "callSdp." + error;
                }
            }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            return null;
        };

        /**
         * Creates a Msg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Msg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Msg} Msg
         */
        Msg.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Msg)
                return object;
            var message = new $root.server.Msg();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "NORMAL":
            case 0:
                message.type = 0;
                break;
            case "ERROR":
            case 1:
                message.type = 1;
                break;
            case "GROUPCHAT":
            case 2:
                message.type = 2;
                break;
            case "HEADLINE":
            case 3:
                message.type = 3;
                break;
            case "CHAT":
            case 4:
                message.type = 4;
                break;
            case "CALL":
            case 5:
                message.type = 5;
                break;
            }
            if (object.toUid != null)
                if ($util.Long)
                    (message.toUid = $util.Long.fromValue(object.toUid)).unsigned = false;
                else if (typeof object.toUid === "string")
                    message.toUid = parseInt(object.toUid, 10);
                else if (typeof object.toUid === "number")
                    message.toUid = object.toUid;
                else if (typeof object.toUid === "object")
                    message.toUid = new $util.LongBits(object.toUid.low >>> 0, object.toUid.high >>> 0).toNumber();
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            if (object.contactList != null) {
                if (typeof object.contactList !== "object")
                    throw TypeError(".server.Msg.contactList: object expected");
                message.contactList = $root.server.ContactList.fromObject(object.contactList);
            }
            if (object.avatar != null) {
                if (typeof object.avatar !== "object")
                    throw TypeError(".server.Msg.avatar: object expected");
                message.avatar = $root.server.Avatar.fromObject(object.avatar);
            }
            if (object.whisperKeys != null) {
                if (typeof object.whisperKeys !== "object")
                    throw TypeError(".server.Msg.whisperKeys: object expected");
                message.whisperKeys = $root.server.WhisperKeys.fromObject(object.whisperKeys);
            }
            if (object.seenReceipt != null) {
                if (typeof object.seenReceipt !== "object")
                    throw TypeError(".server.Msg.seenReceipt: object expected");
                message.seenReceipt = $root.server.SeenReceipt.fromObject(object.seenReceipt);
            }
            if (object.deliveryReceipt != null) {
                if (typeof object.deliveryReceipt !== "object")
                    throw TypeError(".server.Msg.deliveryReceipt: object expected");
                message.deliveryReceipt = $root.server.DeliveryReceipt.fromObject(object.deliveryReceipt);
            }
            if (object.chatStanza != null) {
                if (typeof object.chatStanza !== "object")
                    throw TypeError(".server.Msg.chatStanza: object expected");
                message.chatStanza = $root.server.ChatStanza.fromObject(object.chatStanza);
            }
            if (object.feedItem != null) {
                if (typeof object.feedItem !== "object")
                    throw TypeError(".server.Msg.feedItem: object expected");
                message.feedItem = $root.server.FeedItem.fromObject(object.feedItem);
            }
            if (object.feedItems != null) {
                if (typeof object.feedItems !== "object")
                    throw TypeError(".server.Msg.feedItems: object expected");
                message.feedItems = $root.server.FeedItems.fromObject(object.feedItems);
            }
            if (object.contactHash != null) {
                if (typeof object.contactHash !== "object")
                    throw TypeError(".server.Msg.contactHash: object expected");
                message.contactHash = $root.server.ContactHash.fromObject(object.contactHash);
            }
            if (object.groupStanza != null) {
                if (typeof object.groupStanza !== "object")
                    throw TypeError(".server.Msg.groupStanza: object expected");
                message.groupStanza = $root.server.GroupStanza.fromObject(object.groupStanza);
            }
            if (object.groupChat != null) {
                if (typeof object.groupChat !== "object")
                    throw TypeError(".server.Msg.groupChat: object expected");
                message.groupChat = $root.server.GroupChat.fromObject(object.groupChat);
            }
            if (object.name != null) {
                if (typeof object.name !== "object")
                    throw TypeError(".server.Msg.name: object expected");
                message.name = $root.server.Name.fromObject(object.name);
            }
            if (object.errorStanza != null) {
                if (typeof object.errorStanza !== "object")
                    throw TypeError(".server.Msg.errorStanza: object expected");
                message.errorStanza = $root.server.ErrorStanza.fromObject(object.errorStanza);
            }
            if (object.groupchatRetract != null) {
                if (typeof object.groupchatRetract !== "object")
                    throw TypeError(".server.Msg.groupchatRetract: object expected");
                message.groupchatRetract = $root.server.GroupChatRetract.fromObject(object.groupchatRetract);
            }
            if (object.chatRetract != null) {
                if (typeof object.chatRetract !== "object")
                    throw TypeError(".server.Msg.chatRetract: object expected");
                message.chatRetract = $root.server.ChatRetract.fromObject(object.chatRetract);
            }
            if (object.groupFeedItem != null) {
                if (typeof object.groupFeedItem !== "object")
                    throw TypeError(".server.Msg.groupFeedItem: object expected");
                message.groupFeedItem = $root.server.GroupFeedItem.fromObject(object.groupFeedItem);
            }
            if (object.rerequest != null) {
                if (typeof object.rerequest !== "object")
                    throw TypeError(".server.Msg.rerequest: object expected");
                message.rerequest = $root.server.Rerequest.fromObject(object.rerequest);
            }
            if (object.silentChatStanza != null) {
                if (typeof object.silentChatStanza !== "object")
                    throw TypeError(".server.Msg.silentChatStanza: object expected");
                message.silentChatStanza = $root.server.SilentChatStanza.fromObject(object.silentChatStanza);
            }
            if (object.groupFeedItems != null) {
                if (typeof object.groupFeedItems !== "object")
                    throw TypeError(".server.Msg.groupFeedItems: object expected");
                message.groupFeedItems = $root.server.GroupFeedItems.fromObject(object.groupFeedItems);
            }
            if (object.endOfQueue != null) {
                if (typeof object.endOfQueue !== "object")
                    throw TypeError(".server.Msg.endOfQueue: object expected");
                message.endOfQueue = $root.server.EndOfQueue.fromObject(object.endOfQueue);
            }
            if (object.inviteeNotice != null) {
                if (typeof object.inviteeNotice !== "object")
                    throw TypeError(".server.Msg.inviteeNotice: object expected");
                message.inviteeNotice = $root.server.InviteeNotice.fromObject(object.inviteeNotice);
            }
            if (object.groupFeedRerequest != null) {
                if (typeof object.groupFeedRerequest !== "object")
                    throw TypeError(".server.Msg.groupFeedRerequest: object expected");
                message.groupFeedRerequest = $root.server.GroupFeedRerequest.fromObject(object.groupFeedRerequest);
            }
            if (object.historyResend != null) {
                if (typeof object.historyResend !== "object")
                    throw TypeError(".server.Msg.historyResend: object expected");
                message.historyResend = $root.server.HistoryResend.fromObject(object.historyResend);
            }
            if (object.playedReceipt != null) {
                if (typeof object.playedReceipt !== "object")
                    throw TypeError(".server.Msg.playedReceipt: object expected");
                message.playedReceipt = $root.server.PlayedReceipt.fromObject(object.playedReceipt);
            }
            if (object.requestLogs != null) {
                if (typeof object.requestLogs !== "object")
                    throw TypeError(".server.Msg.requestLogs: object expected");
                message.requestLogs = $root.server.RequestLogs.fromObject(object.requestLogs);
            }
            if (object.wakeup != null) {
                if (typeof object.wakeup !== "object")
                    throw TypeError(".server.Msg.wakeup: object expected");
                message.wakeup = $root.server.WakeUp.fromObject(object.wakeup);
            }
            if (object.homeFeedRerequest != null) {
                if (typeof object.homeFeedRerequest !== "object")
                    throw TypeError(".server.Msg.homeFeedRerequest: object expected");
                message.homeFeedRerequest = $root.server.HomeFeedRerequest.fromObject(object.homeFeedRerequest);
            }
            if (object.incomingCall != null) {
                if (typeof object.incomingCall !== "object")
                    throw TypeError(".server.Msg.incomingCall: object expected");
                message.incomingCall = $root.server.IncomingCall.fromObject(object.incomingCall);
            }
            if (object.callRinging != null) {
                if (typeof object.callRinging !== "object")
                    throw TypeError(".server.Msg.callRinging: object expected");
                message.callRinging = $root.server.CallRinging.fromObject(object.callRinging);
            }
            if (object.answerCall != null) {
                if (typeof object.answerCall !== "object")
                    throw TypeError(".server.Msg.answerCall: object expected");
                message.answerCall = $root.server.AnswerCall.fromObject(object.answerCall);
            }
            if (object.endCall != null) {
                if (typeof object.endCall !== "object")
                    throw TypeError(".server.Msg.endCall: object expected");
                message.endCall = $root.server.EndCall.fromObject(object.endCall);
            }
            if (object.iceCandidate != null) {
                if (typeof object.iceCandidate !== "object")
                    throw TypeError(".server.Msg.iceCandidate: object expected");
                message.iceCandidate = $root.server.IceCandidate.fromObject(object.iceCandidate);
            }
            if (object.marketingAlert != null) {
                if (typeof object.marketingAlert !== "object")
                    throw TypeError(".server.Msg.marketingAlert: object expected");
                message.marketingAlert = $root.server.MarketingAlert.fromObject(object.marketingAlert);
            }
            if (object.iceRestartOffer != null) {
                if (typeof object.iceRestartOffer !== "object")
                    throw TypeError(".server.Msg.iceRestartOffer: object expected");
                message.iceRestartOffer = $root.server.IceRestartOffer.fromObject(object.iceRestartOffer);
            }
            if (object.iceRestartAnswer != null) {
                if (typeof object.iceRestartAnswer !== "object")
                    throw TypeError(".server.Msg.iceRestartAnswer: object expected");
                message.iceRestartAnswer = $root.server.IceRestartAnswer.fromObject(object.iceRestartAnswer);
            }
            if (object.groupFeedHistory != null) {
                if (typeof object.groupFeedHistory !== "object")
                    throw TypeError(".server.Msg.groupFeedHistory: object expected");
                message.groupFeedHistory = $root.server.GroupFeedHistory.fromObject(object.groupFeedHistory);
            }
            if (object.preAnswerCall != null) {
                if (typeof object.preAnswerCall !== "object")
                    throw TypeError(".server.Msg.preAnswerCall: object expected");
                message.preAnswerCall = $root.server.PreAnswerCall.fromObject(object.preAnswerCall);
            }
            if (object.holdCall != null) {
                if (typeof object.holdCall !== "object")
                    throw TypeError(".server.Msg.holdCall: object expected");
                message.holdCall = $root.server.HoldCall.fromObject(object.holdCall);
            }
            if (object.muteCall != null) {
                if (typeof object.muteCall !== "object")
                    throw TypeError(".server.Msg.muteCall: object expected");
                message.muteCall = $root.server.MuteCall.fromObject(object.muteCall);
            }
            if (object.incomingCallPush != null) {
                if (typeof object.incomingCallPush !== "object")
                    throw TypeError(".server.Msg.incomingCallPush: object expected");
                message.incomingCallPush = $root.server.IncomingCallPush.fromObject(object.incomingCallPush);
            }
            if (object.callSdp != null) {
                if (typeof object.callSdp !== "object")
                    throw TypeError(".server.Msg.callSdp: object expected");
                message.callSdp = $root.server.CallSdp.fromObject(object.callSdp);
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount | 0;
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount | 0;
            return message;
        };

        /**
         * Creates a plain object from a Msg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Msg
         * @static
         * @param {server.Msg} message Msg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Msg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "NORMAL" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.toUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toUid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
                object.retryCount = 0;
                object.rerequestCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Msg.Type[message.type] : message.type;
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (typeof message.toUid === "number")
                    object.toUid = options.longs === String ? String(message.toUid) : message.toUid;
                else
                    object.toUid = options.longs === String ? $util.Long.prototype.toString.call(message.toUid) : options.longs === Number ? new $util.LongBits(message.toUid.low >>> 0, message.toUid.high >>> 0).toNumber() : message.toUid;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            if (message.contactList != null && message.hasOwnProperty("contactList")) {
                object.contactList = $root.server.ContactList.toObject(message.contactList, options);
                if (options.oneofs)
                    object.payload = "contactList";
            }
            if (message.avatar != null && message.hasOwnProperty("avatar")) {
                object.avatar = $root.server.Avatar.toObject(message.avatar, options);
                if (options.oneofs)
                    object.payload = "avatar";
            }
            if (message.whisperKeys != null && message.hasOwnProperty("whisperKeys")) {
                object.whisperKeys = $root.server.WhisperKeys.toObject(message.whisperKeys, options);
                if (options.oneofs)
                    object.payload = "whisperKeys";
            }
            if (message.seenReceipt != null && message.hasOwnProperty("seenReceipt")) {
                object.seenReceipt = $root.server.SeenReceipt.toObject(message.seenReceipt, options);
                if (options.oneofs)
                    object.payload = "seenReceipt";
            }
            if (message.deliveryReceipt != null && message.hasOwnProperty("deliveryReceipt")) {
                object.deliveryReceipt = $root.server.DeliveryReceipt.toObject(message.deliveryReceipt, options);
                if (options.oneofs)
                    object.payload = "deliveryReceipt";
            }
            if (message.chatStanza != null && message.hasOwnProperty("chatStanza")) {
                object.chatStanza = $root.server.ChatStanza.toObject(message.chatStanza, options);
                if (options.oneofs)
                    object.payload = "chatStanza";
            }
            if (message.feedItem != null && message.hasOwnProperty("feedItem")) {
                object.feedItem = $root.server.FeedItem.toObject(message.feedItem, options);
                if (options.oneofs)
                    object.payload = "feedItem";
            }
            if (message.feedItems != null && message.hasOwnProperty("feedItems")) {
                object.feedItems = $root.server.FeedItems.toObject(message.feedItems, options);
                if (options.oneofs)
                    object.payload = "feedItems";
            }
            if (message.contactHash != null && message.hasOwnProperty("contactHash")) {
                object.contactHash = $root.server.ContactHash.toObject(message.contactHash, options);
                if (options.oneofs)
                    object.payload = "contactHash";
            }
            if (message.groupStanza != null && message.hasOwnProperty("groupStanza")) {
                object.groupStanza = $root.server.GroupStanza.toObject(message.groupStanza, options);
                if (options.oneofs)
                    object.payload = "groupStanza";
            }
            if (message.groupChat != null && message.hasOwnProperty("groupChat")) {
                object.groupChat = $root.server.GroupChat.toObject(message.groupChat, options);
                if (options.oneofs)
                    object.payload = "groupChat";
            }
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = $root.server.Name.toObject(message.name, options);
                if (options.oneofs)
                    object.payload = "name";
            }
            if (message.errorStanza != null && message.hasOwnProperty("errorStanza")) {
                object.errorStanza = $root.server.ErrorStanza.toObject(message.errorStanza, options);
                if (options.oneofs)
                    object.payload = "errorStanza";
            }
            if (message.groupchatRetract != null && message.hasOwnProperty("groupchatRetract")) {
                object.groupchatRetract = $root.server.GroupChatRetract.toObject(message.groupchatRetract, options);
                if (options.oneofs)
                    object.payload = "groupchatRetract";
            }
            if (message.chatRetract != null && message.hasOwnProperty("chatRetract")) {
                object.chatRetract = $root.server.ChatRetract.toObject(message.chatRetract, options);
                if (options.oneofs)
                    object.payload = "chatRetract";
            }
            if (message.groupFeedItem != null && message.hasOwnProperty("groupFeedItem")) {
                object.groupFeedItem = $root.server.GroupFeedItem.toObject(message.groupFeedItem, options);
                if (options.oneofs)
                    object.payload = "groupFeedItem";
            }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            if (message.rerequest != null && message.hasOwnProperty("rerequest")) {
                object.rerequest = $root.server.Rerequest.toObject(message.rerequest, options);
                if (options.oneofs)
                    object.payload = "rerequest";
            }
            if (message.silentChatStanza != null && message.hasOwnProperty("silentChatStanza")) {
                object.silentChatStanza = $root.server.SilentChatStanza.toObject(message.silentChatStanza, options);
                if (options.oneofs)
                    object.payload = "silentChatStanza";
            }
            if (message.groupFeedItems != null && message.hasOwnProperty("groupFeedItems")) {
                object.groupFeedItems = $root.server.GroupFeedItems.toObject(message.groupFeedItems, options);
                if (options.oneofs)
                    object.payload = "groupFeedItems";
            }
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.endOfQueue != null && message.hasOwnProperty("endOfQueue")) {
                object.endOfQueue = $root.server.EndOfQueue.toObject(message.endOfQueue, options);
                if (options.oneofs)
                    object.payload = "endOfQueue";
            }
            if (message.inviteeNotice != null && message.hasOwnProperty("inviteeNotice")) {
                object.inviteeNotice = $root.server.InviteeNotice.toObject(message.inviteeNotice, options);
                if (options.oneofs)
                    object.payload = "inviteeNotice";
            }
            if (message.groupFeedRerequest != null && message.hasOwnProperty("groupFeedRerequest")) {
                object.groupFeedRerequest = $root.server.GroupFeedRerequest.toObject(message.groupFeedRerequest, options);
                if (options.oneofs)
                    object.payload = "groupFeedRerequest";
            }
            if (message.historyResend != null && message.hasOwnProperty("historyResend")) {
                object.historyResend = $root.server.HistoryResend.toObject(message.historyResend, options);
                if (options.oneofs)
                    object.payload = "historyResend";
            }
            if (message.playedReceipt != null && message.hasOwnProperty("playedReceipt")) {
                object.playedReceipt = $root.server.PlayedReceipt.toObject(message.playedReceipt, options);
                if (options.oneofs)
                    object.payload = "playedReceipt";
            }
            if (message.requestLogs != null && message.hasOwnProperty("requestLogs")) {
                object.requestLogs = $root.server.RequestLogs.toObject(message.requestLogs, options);
                if (options.oneofs)
                    object.payload = "requestLogs";
            }
            if (message.wakeup != null && message.hasOwnProperty("wakeup")) {
                object.wakeup = $root.server.WakeUp.toObject(message.wakeup, options);
                if (options.oneofs)
                    object.payload = "wakeup";
            }
            if (message.homeFeedRerequest != null && message.hasOwnProperty("homeFeedRerequest")) {
                object.homeFeedRerequest = $root.server.HomeFeedRerequest.toObject(message.homeFeedRerequest, options);
                if (options.oneofs)
                    object.payload = "homeFeedRerequest";
            }
            if (message.incomingCall != null && message.hasOwnProperty("incomingCall")) {
                object.incomingCall = $root.server.IncomingCall.toObject(message.incomingCall, options);
                if (options.oneofs)
                    object.payload = "incomingCall";
            }
            if (message.callRinging != null && message.hasOwnProperty("callRinging")) {
                object.callRinging = $root.server.CallRinging.toObject(message.callRinging, options);
                if (options.oneofs)
                    object.payload = "callRinging";
            }
            if (message.answerCall != null && message.hasOwnProperty("answerCall")) {
                object.answerCall = $root.server.AnswerCall.toObject(message.answerCall, options);
                if (options.oneofs)
                    object.payload = "answerCall";
            }
            if (message.endCall != null && message.hasOwnProperty("endCall")) {
                object.endCall = $root.server.EndCall.toObject(message.endCall, options);
                if (options.oneofs)
                    object.payload = "endCall";
            }
            if (message.iceCandidate != null && message.hasOwnProperty("iceCandidate")) {
                object.iceCandidate = $root.server.IceCandidate.toObject(message.iceCandidate, options);
                if (options.oneofs)
                    object.payload = "iceCandidate";
            }
            if (message.marketingAlert != null && message.hasOwnProperty("marketingAlert")) {
                object.marketingAlert = $root.server.MarketingAlert.toObject(message.marketingAlert, options);
                if (options.oneofs)
                    object.payload = "marketingAlert";
            }
            if (message.iceRestartOffer != null && message.hasOwnProperty("iceRestartOffer")) {
                object.iceRestartOffer = $root.server.IceRestartOffer.toObject(message.iceRestartOffer, options);
                if (options.oneofs)
                    object.payload = "iceRestartOffer";
            }
            if (message.iceRestartAnswer != null && message.hasOwnProperty("iceRestartAnswer")) {
                object.iceRestartAnswer = $root.server.IceRestartAnswer.toObject(message.iceRestartAnswer, options);
                if (options.oneofs)
                    object.payload = "iceRestartAnswer";
            }
            if (message.groupFeedHistory != null && message.hasOwnProperty("groupFeedHistory")) {
                object.groupFeedHistory = $root.server.GroupFeedHistory.toObject(message.groupFeedHistory, options);
                if (options.oneofs)
                    object.payload = "groupFeedHistory";
            }
            if (message.preAnswerCall != null && message.hasOwnProperty("preAnswerCall")) {
                object.preAnswerCall = $root.server.PreAnswerCall.toObject(message.preAnswerCall, options);
                if (options.oneofs)
                    object.payload = "preAnswerCall";
            }
            if (message.holdCall != null && message.hasOwnProperty("holdCall")) {
                object.holdCall = $root.server.HoldCall.toObject(message.holdCall, options);
                if (options.oneofs)
                    object.payload = "holdCall";
            }
            if (message.muteCall != null && message.hasOwnProperty("muteCall")) {
                object.muteCall = $root.server.MuteCall.toObject(message.muteCall, options);
                if (options.oneofs)
                    object.payload = "muteCall";
            }
            if (message.incomingCallPush != null && message.hasOwnProperty("incomingCallPush")) {
                object.incomingCallPush = $root.server.IncomingCallPush.toObject(message.incomingCallPush, options);
                if (options.oneofs)
                    object.payload = "incomingCallPush";
            }
            if (message.callSdp != null && message.hasOwnProperty("callSdp")) {
                object.callSdp = $root.server.CallSdp.toObject(message.callSdp, options);
                if (options.oneofs)
                    object.payload = "callSdp";
            }
            return object;
        };

        /**
         * Converts this Msg to JSON.
         * @function toJSON
         * @memberof server.Msg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Msg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Msg.Type
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} ERROR=1 ERROR value
         * @property {number} GROUPCHAT=2 GROUPCHAT value
         * @property {number} HEADLINE=3 HEADLINE value
         * @property {number} CHAT=4 CHAT value
         * @property {number} CALL=5 CALL value
         */
        Msg.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "ERROR"] = 1;
            values[valuesById[2] = "GROUPCHAT"] = 2;
            values[valuesById[3] = "HEADLINE"] = 3;
            values[valuesById[4] = "CHAT"] = 4;
            values[valuesById[5] = "CALL"] = 5;
            return values;
        })();

        return Msg;
    })();

    server.Presence = (function() {

        /**
         * Properties of a Presence.
         * @memberof server
         * @interface IPresence
         * @property {string|null} [id] Presence id
         * @property {server.Presence.Type|null} [type] Presence type
         * @property {number|Long|null} [uid] Presence uid
         * @property {number|Long|null} [lastSeen] Presence lastSeen
         * @property {number|Long|null} [toUid] Presence toUid
         * @property {number|Long|null} [fromUid] Presence fromUid
         */

        /**
         * Constructs a new Presence.
         * @memberof server
         * @classdesc Represents a Presence.
         * @implements IPresence
         * @constructor
         * @param {server.IPresence=} [properties] Properties to set
         */
        function Presence(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Presence id.
         * @member {string} id
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.id = "";

        /**
         * Presence type.
         * @member {server.Presence.Type} type
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.type = 0;

        /**
         * Presence uid.
         * @member {number|Long} uid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence lastSeen.
         * @member {number|Long} lastSeen
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.lastSeen = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence toUid.
         * @member {number|Long} toUid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.toUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Presence fromUid.
         * @member {number|Long} fromUid
         * @memberof server.Presence
         * @instance
         */
        Presence.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Presence instance using the specified properties.
         * @function create
         * @memberof server.Presence
         * @static
         * @param {server.IPresence=} [properties] Properties to set
         * @returns {server.Presence} Presence instance
         */
        Presence.create = function create(properties) {
            return new Presence(properties);
        };

        /**
         * Encodes the specified Presence message. Does not implicitly {@link server.Presence.verify|verify} messages.
         * @function encode
         * @memberof server.Presence
         * @static
         * @param {server.IPresence} message Presence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presence.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            if (message.lastSeen != null && Object.hasOwnProperty.call(message, "lastSeen"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastSeen);
            if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.toUid);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.fromUid);
            return writer;
        };

        /**
         * Encodes the specified Presence message, length delimited. Does not implicitly {@link server.Presence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Presence
         * @static
         * @param {server.IPresence} message Presence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presence.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Presence message from the specified reader or buffer.
         * @function decode
         * @memberof server.Presence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Presence} Presence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presence.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Presence();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.uid = reader.int64();
                    break;
                case 4:
                    message.lastSeen = reader.int64();
                    break;
                case 5:
                    message.toUid = reader.int64();
                    break;
                case 6:
                    message.fromUid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Presence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Presence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Presence} Presence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presence.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Presence message.
         * @function verify
         * @memberof server.Presence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Presence.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
                if (!$util.isInteger(message.lastSeen) && !(message.lastSeen && $util.isInteger(message.lastSeen.low) && $util.isInteger(message.lastSeen.high)))
                    return "lastSeen: integer|Long expected";
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (!$util.isInteger(message.toUid) && !(message.toUid && $util.isInteger(message.toUid.low) && $util.isInteger(message.toUid.high)))
                    return "toUid: integer|Long expected";
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            return null;
        };

        /**
         * Creates a Presence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Presence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Presence} Presence
         */
        Presence.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Presence)
                return object;
            var message = new $root.server.Presence();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "AVAILABLE":
            case 0:
                message.type = 0;
                break;
            case "AWAY":
            case 1:
                message.type = 1;
                break;
            case "SUBSCRIBE":
            case 2:
                message.type = 2;
                break;
            case "UNSUBSCRIBE":
            case 3:
                message.type = 3;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lastSeen != null)
                if ($util.Long)
                    (message.lastSeen = $util.Long.fromValue(object.lastSeen)).unsigned = false;
                else if (typeof object.lastSeen === "string")
                    message.lastSeen = parseInt(object.lastSeen, 10);
                else if (typeof object.lastSeen === "number")
                    message.lastSeen = object.lastSeen;
                else if (typeof object.lastSeen === "object")
                    message.lastSeen = new $util.LongBits(object.lastSeen.low >>> 0, object.lastSeen.high >>> 0).toNumber();
            if (object.toUid != null)
                if ($util.Long)
                    (message.toUid = $util.Long.fromValue(object.toUid)).unsigned = false;
                else if (typeof object.toUid === "string")
                    message.toUid = parseInt(object.toUid, 10);
                else if (typeof object.toUid === "number")
                    message.toUid = object.toUid;
                else if (typeof object.toUid === "object")
                    message.toUid = new $util.LongBits(object.toUid.low >>> 0, object.toUid.high >>> 0).toNumber();
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Presence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Presence
         * @static
         * @param {server.Presence} message Presence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Presence.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "AVAILABLE" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSeen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastSeen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.toUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toUid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Presence.Type[message.type] : message.type;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
                if (typeof message.lastSeen === "number")
                    object.lastSeen = options.longs === String ? String(message.lastSeen) : message.lastSeen;
                else
                    object.lastSeen = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeen) : options.longs === Number ? new $util.LongBits(message.lastSeen.low >>> 0, message.lastSeen.high >>> 0).toNumber() : message.lastSeen;
            if (message.toUid != null && message.hasOwnProperty("toUid"))
                if (typeof message.toUid === "number")
                    object.toUid = options.longs === String ? String(message.toUid) : message.toUid;
                else
                    object.toUid = options.longs === String ? $util.Long.prototype.toString.call(message.toUid) : options.longs === Number ? new $util.LongBits(message.toUid.low >>> 0, message.toUid.high >>> 0).toNumber() : message.toUid;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            return object;
        };

        /**
         * Converts this Presence to JSON.
         * @function toJSON
         * @memberof server.Presence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Presence.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Presence.Type
         * @enum {number}
         * @property {number} AVAILABLE=0 AVAILABLE value
         * @property {number} AWAY=1 AWAY value
         * @property {number} SUBSCRIBE=2 SUBSCRIBE value
         * @property {number} UNSUBSCRIBE=3 UNSUBSCRIBE value
         */
        Presence.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AVAILABLE"] = 0;
            values[valuesById[1] = "AWAY"] = 1;
            values[valuesById[2] = "SUBSCRIBE"] = 2;
            values[valuesById[3] = "UNSUBSCRIBE"] = 3;
            return values;
        })();

        return Presence;
    })();

    server.ChatState = (function() {

        /**
         * Properties of a ChatState.
         * @memberof server
         * @interface IChatState
         * @property {server.ChatState.Type|null} [type] ChatState type
         * @property {string|null} [threadId] ChatState threadId
         * @property {server.ChatState.ThreadType|null} [threadType] ChatState threadType
         * @property {number|Long|null} [fromUid] ChatState fromUid
         */

        /**
         * Constructs a new ChatState.
         * @memberof server
         * @classdesc Represents a ChatState.
         * @implements IChatState
         * @constructor
         * @param {server.IChatState=} [properties] Properties to set
         */
        function ChatState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatState type.
         * @member {server.ChatState.Type} type
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.type = 0;

        /**
         * ChatState threadId.
         * @member {string} threadId
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.threadId = "";

        /**
         * ChatState threadType.
         * @member {server.ChatState.ThreadType} threadType
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.threadType = 0;

        /**
         * ChatState fromUid.
         * @member {number|Long} fromUid
         * @memberof server.ChatState
         * @instance
         */
        ChatState.prototype.fromUid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChatState instance using the specified properties.
         * @function create
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState=} [properties] Properties to set
         * @returns {server.ChatState} ChatState instance
         */
        ChatState.create = function create(properties) {
            return new ChatState(properties);
        };

        /**
         * Encodes the specified ChatState message. Does not implicitly {@link server.ChatState.verify|verify} messages.
         * @function encode
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState} message ChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.threadType != null && Object.hasOwnProperty.call(message, "threadType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.threadType);
            if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromUid);
            return writer;
        };

        /**
         * Encodes the specified ChatState message, length delimited. Does not implicitly {@link server.ChatState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatState
         * @static
         * @param {server.IChatState} message ChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatState message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatState} ChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.threadType = reader.int32();
                    break;
                case 4:
                    message.fromUid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatState} ChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatState message.
         * @function verify
         * @memberof server.ChatState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                switch (message.threadType) {
                default:
                    return "threadType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (!$util.isInteger(message.fromUid) && !(message.fromUid && $util.isInteger(message.fromUid.low) && $util.isInteger(message.fromUid.high)))
                    return "fromUid: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChatState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatState} ChatState
         */
        ChatState.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatState)
                return object;
            var message = new $root.server.ChatState();
            switch (object.type) {
            case "AVAILABLE":
            case 0:
                message.type = 0;
                break;
            case "TYPING":
            case 1:
                message.type = 1;
                break;
            }
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            switch (object.threadType) {
            case "CHAT":
            case 0:
                message.threadType = 0;
                break;
            case "GROUP_CHAT":
            case 1:
                message.threadType = 1;
                break;
            }
            if (object.fromUid != null)
                if ($util.Long)
                    (message.fromUid = $util.Long.fromValue(object.fromUid)).unsigned = false;
                else if (typeof object.fromUid === "string")
                    message.fromUid = parseInt(object.fromUid, 10);
                else if (typeof object.fromUid === "number")
                    message.fromUid = object.fromUid;
                else if (typeof object.fromUid === "object")
                    message.fromUid = new $util.LongBits(object.fromUid.low >>> 0, object.fromUid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChatState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatState
         * @static
         * @param {server.ChatState} message ChatState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "AVAILABLE" : 0;
                object.threadId = "";
                object.threadType = options.enums === String ? "CHAT" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fromUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromUid = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.ChatState.Type[message.type] : message.type;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.threadType != null && message.hasOwnProperty("threadType"))
                object.threadType = options.enums === String ? $root.server.ChatState.ThreadType[message.threadType] : message.threadType;
            if (message.fromUid != null && message.hasOwnProperty("fromUid"))
                if (typeof message.fromUid === "number")
                    object.fromUid = options.longs === String ? String(message.fromUid) : message.fromUid;
                else
                    object.fromUid = options.longs === String ? $util.Long.prototype.toString.call(message.fromUid) : options.longs === Number ? new $util.LongBits(message.fromUid.low >>> 0, message.fromUid.high >>> 0).toNumber() : message.fromUid;
            return object;
        };

        /**
         * Converts this ChatState to JSON.
         * @function toJSON
         * @memberof server.ChatState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.ChatState.Type
         * @enum {number}
         * @property {number} AVAILABLE=0 AVAILABLE value
         * @property {number} TYPING=1 TYPING value
         */
        ChatState.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AVAILABLE"] = 0;
            values[valuesById[1] = "TYPING"] = 1;
            return values;
        })();

        /**
         * ThreadType enum.
         * @name server.ChatState.ThreadType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} GROUP_CHAT=1 GROUP_CHAT value
         */
        ChatState.ThreadType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "GROUP_CHAT"] = 1;
            return values;
        })();

        return ChatState;
    })();

    server.Ack = (function() {

        /**
         * Properties of an Ack.
         * @memberof server
         * @interface IAck
         * @property {string|null} [id] Ack id
         * @property {number|Long|null} [timestamp] Ack timestamp
         */

        /**
         * Constructs a new Ack.
         * @memberof server
         * @classdesc Represents an Ack.
         * @implements IAck
         * @constructor
         * @param {server.IAck=} [properties] Properties to set
         */
        function Ack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ack id.
         * @member {string} id
         * @memberof server.Ack
         * @instance
         */
        Ack.prototype.id = "";

        /**
         * Ack timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Ack
         * @instance
         */
        Ack.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Ack instance using the specified properties.
         * @function create
         * @memberof server.Ack
         * @static
         * @param {server.IAck=} [properties] Properties to set
         * @returns {server.Ack} Ack instance
         */
        Ack.create = function create(properties) {
            return new Ack(properties);
        };

        /**
         * Encodes the specified Ack message. Does not implicitly {@link server.Ack.verify|verify} messages.
         * @function encode
         * @memberof server.Ack
         * @static
         * @param {server.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Ack message, length delimited. Does not implicitly {@link server.Ack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Ack
         * @static
         * @param {server.IAck} message Ack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Ack message from the specified reader or buffer.
         * @function decode
         * @memberof server.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Ack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Ack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Ack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Ack} Ack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Ack message.
         * @function verify
         * @memberof server.Ack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an Ack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Ack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Ack} Ack
         */
        Ack.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Ack)
                return object;
            var message = new $root.server.Ack();
            if (object.id != null)
                message.id = String(object.id);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Ack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Ack
         * @static
         * @param {server.Ack} message Ack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Ack to JSON.
         * @function toJSON
         * @memberof server.Ack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ack;
    })();

    server.HaError = (function() {

        /**
         * Properties of a HaError.
         * @memberof server
         * @interface IHaError
         * @property {string|null} [reason] HaError reason
         */

        /**
         * Constructs a new HaError.
         * @memberof server
         * @classdesc Represents a HaError.
         * @implements IHaError
         * @constructor
         * @param {server.IHaError=} [properties] Properties to set
         */
        function HaError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HaError reason.
         * @member {string} reason
         * @memberof server.HaError
         * @instance
         */
        HaError.prototype.reason = "";

        /**
         * Creates a new HaError instance using the specified properties.
         * @function create
         * @memberof server.HaError
         * @static
         * @param {server.IHaError=} [properties] Properties to set
         * @returns {server.HaError} HaError instance
         */
        HaError.create = function create(properties) {
            return new HaError(properties);
        };

        /**
         * Encodes the specified HaError message. Does not implicitly {@link server.HaError.verify|verify} messages.
         * @function encode
         * @memberof server.HaError
         * @static
         * @param {server.IHaError} message HaError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HaError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified HaError message, length delimited. Does not implicitly {@link server.HaError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HaError
         * @static
         * @param {server.IHaError} message HaError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HaError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HaError message from the specified reader or buffer.
         * @function decode
         * @memberof server.HaError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HaError} HaError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HaError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HaError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HaError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HaError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HaError} HaError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HaError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HaError message.
         * @function verify
         * @memberof server.HaError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HaError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a HaError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HaError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HaError} HaError
         */
        HaError.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HaError)
                return object;
            var message = new $root.server.HaError();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a HaError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HaError
         * @static
         * @param {server.HaError} message HaError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HaError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this HaError to JSON.
         * @function toJSON
         * @memberof server.HaError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HaError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HaError;
    })();

    server.Packet = (function() {

        /**
         * Properties of a Packet.
         * @memberof server
         * @interface IPacket
         * @property {server.IMsg|null} [msg] Packet msg
         * @property {server.IIq|null} [iq] Packet iq
         * @property {server.IAck|null} [ack] Packet ack
         * @property {server.IPresence|null} [presence] Packet presence
         * @property {server.IHaError|null} [haError] Packet haError
         * @property {server.IChatState|null} [chatState] Packet chatState
         */

        /**
         * Constructs a new Packet.
         * @memberof server
         * @classdesc Represents a Packet.
         * @implements IPacket
         * @constructor
         * @param {server.IPacket=} [properties] Properties to set
         */
        function Packet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Packet msg.
         * @member {server.IMsg|null|undefined} msg
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.msg = null;

        /**
         * Packet iq.
         * @member {server.IIq|null|undefined} iq
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.iq = null;

        /**
         * Packet ack.
         * @member {server.IAck|null|undefined} ack
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.ack = null;

        /**
         * Packet presence.
         * @member {server.IPresence|null|undefined} presence
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.presence = null;

        /**
         * Packet haError.
         * @member {server.IHaError|null|undefined} haError
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.haError = null;

        /**
         * Packet chatState.
         * @member {server.IChatState|null|undefined} chatState
         * @memberof server.Packet
         * @instance
         */
        Packet.prototype.chatState = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Packet stanza.
         * @member {"msg"|"iq"|"ack"|"presence"|"haError"|"chatState"|undefined} stanza
         * @memberof server.Packet
         * @instance
         */
        Object.defineProperty(Packet.prototype, "stanza", {
            get: $util.oneOfGetter($oneOfFields = ["msg", "iq", "ack", "presence", "haError", "chatState"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Packet instance using the specified properties.
         * @function create
         * @memberof server.Packet
         * @static
         * @param {server.IPacket=} [properties] Properties to set
         * @returns {server.Packet} Packet instance
         */
        Packet.create = function create(properties) {
            return new Packet(properties);
        };

        /**
         * Encodes the specified Packet message. Does not implicitly {@link server.Packet.verify|verify} messages.
         * @function encode
         * @memberof server.Packet
         * @static
         * @param {server.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                $root.server.Msg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.iq != null && Object.hasOwnProperty.call(message, "iq"))
                $root.server.Iq.encode(message.iq, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                $root.server.Ack.encode(message.ack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.presence != null && Object.hasOwnProperty.call(message, "presence"))
                $root.server.Presence.encode(message.presence, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.haError != null && Object.hasOwnProperty.call(message, "haError"))
                $root.server.HaError.encode(message.haError, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.chatState != null && Object.hasOwnProperty.call(message, "chatState"))
                $root.server.ChatState.encode(message.chatState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Packet message, length delimited. Does not implicitly {@link server.Packet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Packet
         * @static
         * @param {server.IPacket} message Packet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Packet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Packet message from the specified reader or buffer.
         * @function decode
         * @memberof server.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Packet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = $root.server.Msg.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.iq = $root.server.Iq.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.ack = $root.server.Ack.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.presence = $root.server.Presence.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.haError = $root.server.HaError.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.chatState = $root.server.ChatState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Packet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Packet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Packet} Packet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Packet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Packet message.
         * @function verify
         * @memberof server.Packet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Packet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.msg != null && message.hasOwnProperty("msg")) {
                properties.stanza = 1;
                {
                    var error = $root.server.Msg.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
            }
            if (message.iq != null && message.hasOwnProperty("iq")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Iq.verify(message.iq);
                    if (error)
                        return "iq." + error;
                }
            }
            if (message.ack != null && message.hasOwnProperty("ack")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Ack.verify(message.ack);
                    if (error)
                        return "ack." + error;
                }
            }
            if (message.presence != null && message.hasOwnProperty("presence")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.Presence.verify(message.presence);
                    if (error)
                        return "presence." + error;
                }
            }
            if (message.haError != null && message.hasOwnProperty("haError")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.HaError.verify(message.haError);
                    if (error)
                        return "haError." + error;
                }
            }
            if (message.chatState != null && message.hasOwnProperty("chatState")) {
                if (properties.stanza === 1)
                    return "stanza: multiple values";
                properties.stanza = 1;
                {
                    var error = $root.server.ChatState.verify(message.chatState);
                    if (error)
                        return "chatState." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Packet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Packet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Packet} Packet
         */
        Packet.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Packet)
                return object;
            var message = new $root.server.Packet();
            if (object.msg != null) {
                if (typeof object.msg !== "object")
                    throw TypeError(".server.Packet.msg: object expected");
                message.msg = $root.server.Msg.fromObject(object.msg);
            }
            if (object.iq != null) {
                if (typeof object.iq !== "object")
                    throw TypeError(".server.Packet.iq: object expected");
                message.iq = $root.server.Iq.fromObject(object.iq);
            }
            if (object.ack != null) {
                if (typeof object.ack !== "object")
                    throw TypeError(".server.Packet.ack: object expected");
                message.ack = $root.server.Ack.fromObject(object.ack);
            }
            if (object.presence != null) {
                if (typeof object.presence !== "object")
                    throw TypeError(".server.Packet.presence: object expected");
                message.presence = $root.server.Presence.fromObject(object.presence);
            }
            if (object.haError != null) {
                if (typeof object.haError !== "object")
                    throw TypeError(".server.Packet.haError: object expected");
                message.haError = $root.server.HaError.fromObject(object.haError);
            }
            if (object.chatState != null) {
                if (typeof object.chatState !== "object")
                    throw TypeError(".server.Packet.chatState: object expected");
                message.chatState = $root.server.ChatState.fromObject(object.chatState);
            }
            return message;
        };

        /**
         * Creates a plain object from a Packet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Packet
         * @static
         * @param {server.Packet} message Packet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Packet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.msg != null && message.hasOwnProperty("msg")) {
                object.msg = $root.server.Msg.toObject(message.msg, options);
                if (options.oneofs)
                    object.stanza = "msg";
            }
            if (message.iq != null && message.hasOwnProperty("iq")) {
                object.iq = $root.server.Iq.toObject(message.iq, options);
                if (options.oneofs)
                    object.stanza = "iq";
            }
            if (message.ack != null && message.hasOwnProperty("ack")) {
                object.ack = $root.server.Ack.toObject(message.ack, options);
                if (options.oneofs)
                    object.stanza = "ack";
            }
            if (message.presence != null && message.hasOwnProperty("presence")) {
                object.presence = $root.server.Presence.toObject(message.presence, options);
                if (options.oneofs)
                    object.stanza = "presence";
            }
            if (message.haError != null && message.hasOwnProperty("haError")) {
                object.haError = $root.server.HaError.toObject(message.haError, options);
                if (options.oneofs)
                    object.stanza = "haError";
            }
            if (message.chatState != null && message.hasOwnProperty("chatState")) {
                object.chatState = $root.server.ChatState.toObject(message.chatState, options);
                if (options.oneofs)
                    object.stanza = "chatState";
            }
            return object;
        };

        /**
         * Converts this Packet to JSON.
         * @function toJSON
         * @memberof server.Packet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Packet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Packet;
    })();

    server.UidElement = (function() {

        /**
         * Properties of an UidElement.
         * @memberof server
         * @interface IUidElement
         * @property {server.UidElement.Action|null} [action] UidElement action
         * @property {number|Long|null} [uid] UidElement uid
         */

        /**
         * Constructs a new UidElement.
         * @memberof server
         * @classdesc Represents an UidElement.
         * @implements IUidElement
         * @constructor
         * @param {server.IUidElement=} [properties] Properties to set
         */
        function UidElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UidElement action.
         * @member {server.UidElement.Action} action
         * @memberof server.UidElement
         * @instance
         */
        UidElement.prototype.action = 0;

        /**
         * UidElement uid.
         * @member {number|Long} uid
         * @memberof server.UidElement
         * @instance
         */
        UidElement.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UidElement instance using the specified properties.
         * @function create
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement=} [properties] Properties to set
         * @returns {server.UidElement} UidElement instance
         */
        UidElement.create = function create(properties) {
            return new UidElement(properties);
        };

        /**
         * Encodes the specified UidElement message. Does not implicitly {@link server.UidElement.verify|verify} messages.
         * @function encode
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement} message UidElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            return writer;
        };

        /**
         * Encodes the specified UidElement message, length delimited. Does not implicitly {@link server.UidElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.UidElement
         * @static
         * @param {server.IUidElement} message UidElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UidElement message from the specified reader or buffer.
         * @function decode
         * @memberof server.UidElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.UidElement} UidElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.UidElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UidElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.UidElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.UidElement} UidElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UidElement message.
         * @function verify
         * @memberof server.UidElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UidElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };

        /**
         * Creates an UidElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.UidElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.UidElement} UidElement
         */
        UidElement.fromObject = function fromObject(object) {
            if (object instanceof $root.server.UidElement)
                return object;
            var message = new $root.server.UidElement();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UidElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.UidElement
         * @static
         * @param {server.UidElement} message UidElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UidElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.UidElement.Action[message.action] : message.action;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };

        /**
         * Converts this UidElement to JSON.
         * @function toJSON
         * @memberof server.UidElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UidElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.UidElement.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        UidElement.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return UidElement;
    })();

    server.PhoneElement = (function() {

        /**
         * Properties of a PhoneElement.
         * @memberof server
         * @interface IPhoneElement
         * @property {server.PhoneElement.Action|null} [action] PhoneElement action
         * @property {string|null} [phone] PhoneElement phone
         */

        /**
         * Constructs a new PhoneElement.
         * @memberof server
         * @classdesc Represents a PhoneElement.
         * @implements IPhoneElement
         * @constructor
         * @param {server.IPhoneElement=} [properties] Properties to set
         */
        function PhoneElement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PhoneElement action.
         * @member {server.PhoneElement.Action} action
         * @memberof server.PhoneElement
         * @instance
         */
        PhoneElement.prototype.action = 0;

        /**
         * PhoneElement phone.
         * @member {string} phone
         * @memberof server.PhoneElement
         * @instance
         */
        PhoneElement.prototype.phone = "";

        /**
         * Creates a new PhoneElement instance using the specified properties.
         * @function create
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement=} [properties] Properties to set
         * @returns {server.PhoneElement} PhoneElement instance
         */
        PhoneElement.create = function create(properties) {
            return new PhoneElement(properties);
        };

        /**
         * Encodes the specified PhoneElement message. Does not implicitly {@link server.PhoneElement.verify|verify} messages.
         * @function encode
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement} message PhoneElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhoneElement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);
            return writer;
        };

        /**
         * Encodes the specified PhoneElement message, length delimited. Does not implicitly {@link server.PhoneElement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PhoneElement
         * @static
         * @param {server.IPhoneElement} message PhoneElement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PhoneElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PhoneElement message from the specified reader or buffer.
         * @function decode
         * @memberof server.PhoneElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PhoneElement} PhoneElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhoneElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PhoneElement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.int32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PhoneElement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PhoneElement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PhoneElement} PhoneElement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PhoneElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PhoneElement message.
         * @function verify
         * @memberof server.PhoneElement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PhoneElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            return null;
        };

        /**
         * Creates a PhoneElement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PhoneElement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PhoneElement} PhoneElement
         */
        PhoneElement.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PhoneElement)
                return object;
            var message = new $root.server.PhoneElement();
            switch (object.action) {
            case "ADD":
            case 0:
                message.action = 0;
                break;
            case "DELETE":
            case 1:
                message.action = 1;
                break;
            }
            if (object.phone != null)
                message.phone = String(object.phone);
            return message;
        };

        /**
         * Creates a plain object from a PhoneElement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PhoneElement
         * @static
         * @param {server.PhoneElement} message PhoneElement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PhoneElement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "ADD" : 0;
                object.phone = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.PhoneElement.Action[message.action] : message.action;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            return object;
        };

        /**
         * Converts this PhoneElement to JSON.
         * @function toJSON
         * @memberof server.PhoneElement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PhoneElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.PhoneElement.Action
         * @enum {number}
         * @property {number} ADD=0 ADD value
         * @property {number} DELETE=1 DELETE value
         */
        PhoneElement.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD"] = 0;
            values[valuesById[1] = "DELETE"] = 1;
            return values;
        })();

        return PhoneElement;
    })();

    server.PrivacyList = (function() {

        /**
         * Properties of a PrivacyList.
         * @memberof server
         * @interface IPrivacyList
         * @property {server.PrivacyList.Type|null} [type] PrivacyList type
         * @property {Array.<server.IUidElement>|null} [uidElements] PrivacyList uidElements
         * @property {Uint8Array|null} [hash] PrivacyList hash
         * @property {Array.<server.IPhoneElement>|null} [phoneElements] PrivacyList phoneElements
         * @property {boolean|null} [usingPhones] PrivacyList usingPhones
         */

        /**
         * Constructs a new PrivacyList.
         * @memberof server
         * @classdesc Represents a PrivacyList.
         * @implements IPrivacyList
         * @constructor
         * @param {server.IPrivacyList=} [properties] Properties to set
         */
        function PrivacyList(properties) {
            this.uidElements = [];
            this.phoneElements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivacyList type.
         * @member {server.PrivacyList.Type} type
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.type = 0;

        /**
         * PrivacyList uidElements.
         * @member {Array.<server.IUidElement>} uidElements
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.uidElements = $util.emptyArray;

        /**
         * PrivacyList hash.
         * @member {Uint8Array} hash
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.hash = $util.newBuffer([]);

        /**
         * PrivacyList phoneElements.
         * @member {Array.<server.IPhoneElement>} phoneElements
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.phoneElements = $util.emptyArray;

        /**
         * PrivacyList usingPhones.
         * @member {boolean} usingPhones
         * @memberof server.PrivacyList
         * @instance
         */
        PrivacyList.prototype.usingPhones = false;

        /**
         * Creates a new PrivacyList instance using the specified properties.
         * @function create
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList=} [properties] Properties to set
         * @returns {server.PrivacyList} PrivacyList instance
         */
        PrivacyList.create = function create(properties) {
            return new PrivacyList(properties);
        };

        /**
         * Encodes the specified PrivacyList message. Does not implicitly {@link server.PrivacyList.verify|verify} messages.
         * @function encode
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList} message PrivacyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.uidElements != null && message.uidElements.length)
                for (var i = 0; i < message.uidElements.length; ++i)
                    $root.server.UidElement.encode(message.uidElements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hash);
            if (message.phoneElements != null && message.phoneElements.length)
                for (var i = 0; i < message.phoneElements.length; ++i)
                    $root.server.PhoneElement.encode(message.phoneElements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.usingPhones != null && Object.hasOwnProperty.call(message, "usingPhones"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.usingPhones);
            return writer;
        };

        /**
         * Encodes the specified PrivacyList message, length delimited. Does not implicitly {@link server.PrivacyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PrivacyList
         * @static
         * @param {server.IPrivacyList} message PrivacyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivacyList message from the specified reader or buffer.
         * @function decode
         * @memberof server.PrivacyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PrivacyList} PrivacyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PrivacyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.uidElements && message.uidElements.length))
                        message.uidElements = [];
                    message.uidElements.push($root.server.UidElement.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.hash = reader.bytes();
                    break;
                case 4:
                    if (!(message.phoneElements && message.phoneElements.length))
                        message.phoneElements = [];
                    message.phoneElements.push($root.server.PhoneElement.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.usingPhones = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivacyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PrivacyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PrivacyList} PrivacyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivacyList message.
         * @function verify
         * @memberof server.PrivacyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivacyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.uidElements != null && message.hasOwnProperty("uidElements")) {
                if (!Array.isArray(message.uidElements))
                    return "uidElements: array expected";
                for (var i = 0; i < message.uidElements.length; ++i) {
                    var error = $root.server.UidElement.verify(message.uidElements[i]);
                    if (error)
                        return "uidElements." + error;
                }
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.phoneElements != null && message.hasOwnProperty("phoneElements")) {
                if (!Array.isArray(message.phoneElements))
                    return "phoneElements: array expected";
                for (var i = 0; i < message.phoneElements.length; ++i) {
                    var error = $root.server.PhoneElement.verify(message.phoneElements[i]);
                    if (error)
                        return "phoneElements." + error;
                }
            }
            if (message.usingPhones != null && message.hasOwnProperty("usingPhones"))
                if (typeof message.usingPhones !== "boolean")
                    return "usingPhones: boolean expected";
            return null;
        };

        /**
         * Creates a PrivacyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PrivacyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PrivacyList} PrivacyList
         */
        PrivacyList.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PrivacyList)
                return object;
            var message = new $root.server.PrivacyList();
            switch (object.type) {
            case "ALL":
            case 0:
                message.type = 0;
                break;
            case "BLOCK":
            case 1:
                message.type = 1;
                break;
            case "EXCEPT":
            case 2:
                message.type = 2;
                break;
            case "MUTE":
            case 3:
                message.type = 3;
                break;
            case "ONLY":
            case 4:
                message.type = 4;
                break;
            }
            if (object.uidElements) {
                if (!Array.isArray(object.uidElements))
                    throw TypeError(".server.PrivacyList.uidElements: array expected");
                message.uidElements = [];
                for (var i = 0; i < object.uidElements.length; ++i) {
                    if (typeof object.uidElements[i] !== "object")
                        throw TypeError(".server.PrivacyList.uidElements: object expected");
                    message.uidElements[i] = $root.server.UidElement.fromObject(object.uidElements[i]);
                }
            }
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.phoneElements) {
                if (!Array.isArray(object.phoneElements))
                    throw TypeError(".server.PrivacyList.phoneElements: array expected");
                message.phoneElements = [];
                for (var i = 0; i < object.phoneElements.length; ++i) {
                    if (typeof object.phoneElements[i] !== "object")
                        throw TypeError(".server.PrivacyList.phoneElements: object expected");
                    message.phoneElements[i] = $root.server.PhoneElement.fromObject(object.phoneElements[i]);
                }
            }
            if (object.usingPhones != null)
                message.usingPhones = Boolean(object.usingPhones);
            return message;
        };

        /**
         * Creates a plain object from a PrivacyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PrivacyList
         * @static
         * @param {server.PrivacyList} message PrivacyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivacyList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.uidElements = [];
                object.phoneElements = [];
            }
            if (options.defaults) {
                object.type = options.enums === String ? "ALL" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                object.usingPhones = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.PrivacyList.Type[message.type] : message.type;
            if (message.uidElements && message.uidElements.length) {
                object.uidElements = [];
                for (var j = 0; j < message.uidElements.length; ++j)
                    object.uidElements[j] = $root.server.UidElement.toObject(message.uidElements[j], options);
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.phoneElements && message.phoneElements.length) {
                object.phoneElements = [];
                for (var j = 0; j < message.phoneElements.length; ++j)
                    object.phoneElements[j] = $root.server.PhoneElement.toObject(message.phoneElements[j], options);
            }
            if (message.usingPhones != null && message.hasOwnProperty("usingPhones"))
                object.usingPhones = message.usingPhones;
            return object;
        };

        /**
         * Converts this PrivacyList to JSON.
         * @function toJSON
         * @memberof server.PrivacyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivacyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.PrivacyList.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} BLOCK=1 BLOCK value
         * @property {number} EXCEPT=2 EXCEPT value
         * @property {number} MUTE=3 MUTE value
         * @property {number} ONLY=4 ONLY value
         */
        PrivacyList.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            values[valuesById[2] = "EXCEPT"] = 2;
            values[valuesById[3] = "MUTE"] = 3;
            values[valuesById[4] = "ONLY"] = 4;
            return values;
        })();

        return PrivacyList;
    })();

    server.PrivacyLists = (function() {

        /**
         * Properties of a PrivacyLists.
         * @memberof server
         * @interface IPrivacyLists
         * @property {server.PrivacyLists.Type|null} [activeType] PrivacyLists activeType
         * @property {Array.<server.IPrivacyList>|null} [lists] PrivacyLists lists
         */

        /**
         * Constructs a new PrivacyLists.
         * @memberof server
         * @classdesc Represents a PrivacyLists.
         * @implements IPrivacyLists
         * @constructor
         * @param {server.IPrivacyLists=} [properties] Properties to set
         */
        function PrivacyLists(properties) {
            this.lists = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivacyLists activeType.
         * @member {server.PrivacyLists.Type} activeType
         * @memberof server.PrivacyLists
         * @instance
         */
        PrivacyLists.prototype.activeType = 0;

        /**
         * PrivacyLists lists.
         * @member {Array.<server.IPrivacyList>} lists
         * @memberof server.PrivacyLists
         * @instance
         */
        PrivacyLists.prototype.lists = $util.emptyArray;

        /**
         * Creates a new PrivacyLists instance using the specified properties.
         * @function create
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists=} [properties] Properties to set
         * @returns {server.PrivacyLists} PrivacyLists instance
         */
        PrivacyLists.create = function create(properties) {
            return new PrivacyLists(properties);
        };

        /**
         * Encodes the specified PrivacyLists message. Does not implicitly {@link server.PrivacyLists.verify|verify} messages.
         * @function encode
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists} message PrivacyLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyLists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeType != null && Object.hasOwnProperty.call(message, "activeType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activeType);
            if (message.lists != null && message.lists.length)
                for (var i = 0; i < message.lists.length; ++i)
                    $root.server.PrivacyList.encode(message.lists[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PrivacyLists message, length delimited. Does not implicitly {@link server.PrivacyLists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PrivacyLists
         * @static
         * @param {server.IPrivacyLists} message PrivacyLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivacyLists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivacyLists message from the specified reader or buffer.
         * @function decode
         * @memberof server.PrivacyLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PrivacyLists} PrivacyLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyLists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PrivacyLists();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeType = reader.int32();
                    break;
                case 2:
                    if (!(message.lists && message.lists.length))
                        message.lists = [];
                    message.lists.push($root.server.PrivacyList.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivacyLists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PrivacyLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PrivacyLists} PrivacyLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivacyLists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivacyLists message.
         * @function verify
         * @memberof server.PrivacyLists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivacyLists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeType != null && message.hasOwnProperty("activeType"))
                switch (message.activeType) {
                default:
                    return "activeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.lists != null && message.hasOwnProperty("lists")) {
                if (!Array.isArray(message.lists))
                    return "lists: array expected";
                for (var i = 0; i < message.lists.length; ++i) {
                    var error = $root.server.PrivacyList.verify(message.lists[i]);
                    if (error)
                        return "lists." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PrivacyLists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PrivacyLists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PrivacyLists} PrivacyLists
         */
        PrivacyLists.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PrivacyLists)
                return object;
            var message = new $root.server.PrivacyLists();
            switch (object.activeType) {
            case "ALL":
            case 0:
                message.activeType = 0;
                break;
            case "BLOCK":
            case 1:
                message.activeType = 1;
                break;
            case "EXCEPT":
            case 2:
                message.activeType = 2;
                break;
            case "ONLY":
            case 3:
                message.activeType = 3;
                break;
            }
            if (object.lists) {
                if (!Array.isArray(object.lists))
                    throw TypeError(".server.PrivacyLists.lists: array expected");
                message.lists = [];
                for (var i = 0; i < object.lists.length; ++i) {
                    if (typeof object.lists[i] !== "object")
                        throw TypeError(".server.PrivacyLists.lists: object expected");
                    message.lists[i] = $root.server.PrivacyList.fromObject(object.lists[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PrivacyLists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PrivacyLists
         * @static
         * @param {server.PrivacyLists} message PrivacyLists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivacyLists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lists = [];
            if (options.defaults)
                object.activeType = options.enums === String ? "ALL" : 0;
            if (message.activeType != null && message.hasOwnProperty("activeType"))
                object.activeType = options.enums === String ? $root.server.PrivacyLists.Type[message.activeType] : message.activeType;
            if (message.lists && message.lists.length) {
                object.lists = [];
                for (var j = 0; j < message.lists.length; ++j)
                    object.lists[j] = $root.server.PrivacyList.toObject(message.lists[j], options);
            }
            return object;
        };

        /**
         * Converts this PrivacyLists to JSON.
         * @function toJSON
         * @memberof server.PrivacyLists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivacyLists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.PrivacyLists.Type
         * @enum {number}
         * @property {number} ALL=0 ALL value
         * @property {number} BLOCK=1 BLOCK value
         * @property {number} EXCEPT=2 EXCEPT value
         * @property {number} ONLY=3 ONLY value
         */
        PrivacyLists.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALL"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            values[valuesById[2] = "EXCEPT"] = 2;
            values[valuesById[3] = "ONLY"] = 3;
            return values;
        })();

        return PrivacyLists;
    })();

    server.PushToken = (function() {

        /**
         * Properties of a PushToken.
         * @memberof server
         * @interface IPushToken
         * @property {server.PushToken.TokenType|null} [tokenType] PushToken tokenType
         * @property {string|null} [token] PushToken token
         */

        /**
         * Constructs a new PushToken.
         * @memberof server
         * @classdesc Represents a PushToken.
         * @implements IPushToken
         * @constructor
         * @param {server.IPushToken=} [properties] Properties to set
         */
        function PushToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushToken tokenType.
         * @member {server.PushToken.TokenType} tokenType
         * @memberof server.PushToken
         * @instance
         */
        PushToken.prototype.tokenType = 0;

        /**
         * PushToken token.
         * @member {string} token
         * @memberof server.PushToken
         * @instance
         */
        PushToken.prototype.token = "";

        /**
         * Creates a new PushToken instance using the specified properties.
         * @function create
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken=} [properties] Properties to set
         * @returns {server.PushToken} PushToken instance
         */
        PushToken.create = function create(properties) {
            return new PushToken(properties);
        };

        /**
         * Encodes the specified PushToken message. Does not implicitly {@link server.PushToken.verify|verify} messages.
         * @function encode
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken} message PushToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenType != null && Object.hasOwnProperty.call(message, "tokenType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tokenType);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            return writer;
        };

        /**
         * Encodes the specified PushToken message, length delimited. Does not implicitly {@link server.PushToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushToken
         * @static
         * @param {server.IPushToken} message PushToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushToken message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushToken} PushToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tokenType = reader.int32();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushToken} PushToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushToken message.
         * @function verify
         * @memberof server.PushToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                switch (message.tokenType) {
                default:
                    return "tokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!$util.isString(message.token))
                    return "token: string expected";
            return null;
        };

        /**
         * Creates a PushToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushToken} PushToken
         */
        PushToken.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushToken)
                return object;
            var message = new $root.server.PushToken();
            switch (object.tokenType) {
            case "ANDROID":
            case 0:
                message.tokenType = 0;
                break;
            case "IOS":
            case 1:
                message.tokenType = 1;
                break;
            case "IOS_DEV":
            case 2:
                message.tokenType = 2;
                break;
            case "IOS_APPCLIP":
            case 3:
                message.tokenType = 3;
                break;
            case "IOS_VOIP":
            case 4:
                message.tokenType = 4;
                break;
            }
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };

        /**
         * Creates a plain object from a PushToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushToken
         * @static
         * @param {server.PushToken} message PushToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tokenType = options.enums === String ? "ANDROID" : 0;
                object.token = "";
            }
            if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                object.tokenType = options.enums === String ? $root.server.PushToken.TokenType[message.tokenType] : message.tokenType;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };

        /**
         * Converts this PushToken to JSON.
         * @function toJSON
         * @memberof server.PushToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * TokenType enum.
         * @name server.PushToken.TokenType
         * @enum {number}
         * @property {number} ANDROID=0 ANDROID value
         * @property {number} IOS=1 IOS value
         * @property {number} IOS_DEV=2 IOS_DEV value
         * @property {number} IOS_APPCLIP=3 IOS_APPCLIP value
         * @property {number} IOS_VOIP=4 IOS_VOIP value
         */
        PushToken.TokenType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ANDROID"] = 0;
            values[valuesById[1] = "IOS"] = 1;
            values[valuesById[2] = "IOS_DEV"] = 2;
            values[valuesById[3] = "IOS_APPCLIP"] = 3;
            values[valuesById[4] = "IOS_VOIP"] = 4;
            return values;
        })();

        return PushToken;
    })();

    server.PushRegister = (function() {

        /**
         * Properties of a PushRegister.
         * @memberof server
         * @interface IPushRegister
         * @property {server.IPushToken|null} [pushToken] PushRegister pushToken
         * @property {string|null} [langId] PushRegister langId
         */

        /**
         * Constructs a new PushRegister.
         * @memberof server
         * @classdesc Represents a PushRegister.
         * @implements IPushRegister
         * @constructor
         * @param {server.IPushRegister=} [properties] Properties to set
         */
        function PushRegister(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRegister pushToken.
         * @member {server.IPushToken|null|undefined} pushToken
         * @memberof server.PushRegister
         * @instance
         */
        PushRegister.prototype.pushToken = null;

        /**
         * PushRegister langId.
         * @member {string} langId
         * @memberof server.PushRegister
         * @instance
         */
        PushRegister.prototype.langId = "";

        /**
         * Creates a new PushRegister instance using the specified properties.
         * @function create
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister=} [properties] Properties to set
         * @returns {server.PushRegister} PushRegister instance
         */
        PushRegister.create = function create(properties) {
            return new PushRegister(properties);
        };

        /**
         * Encodes the specified PushRegister message. Does not implicitly {@link server.PushRegister.verify|verify} messages.
         * @function encode
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister} message PushRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRegister.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pushToken != null && Object.hasOwnProperty.call(message, "pushToken"))
                $root.server.PushToken.encode(message.pushToken, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.langId != null && Object.hasOwnProperty.call(message, "langId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.langId);
            return writer;
        };

        /**
         * Encodes the specified PushRegister message, length delimited. Does not implicitly {@link server.PushRegister.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushRegister
         * @static
         * @param {server.IPushRegister} message PushRegister message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRegister.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushRegister message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushRegister} PushRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRegister.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushRegister();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pushToken = $root.server.PushToken.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.langId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushRegister message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushRegister
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushRegister} PushRegister
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRegister.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushRegister message.
         * @function verify
         * @memberof server.PushRegister
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushRegister.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pushToken != null && message.hasOwnProperty("pushToken")) {
                var error = $root.server.PushToken.verify(message.pushToken);
                if (error)
                    return "pushToken." + error;
            }
            if (message.langId != null && message.hasOwnProperty("langId"))
                if (!$util.isString(message.langId))
                    return "langId: string expected";
            return null;
        };

        /**
         * Creates a PushRegister message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushRegister
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushRegister} PushRegister
         */
        PushRegister.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushRegister)
                return object;
            var message = new $root.server.PushRegister();
            if (object.pushToken != null) {
                if (typeof object.pushToken !== "object")
                    throw TypeError(".server.PushRegister.pushToken: object expected");
                message.pushToken = $root.server.PushToken.fromObject(object.pushToken);
            }
            if (object.langId != null)
                message.langId = String(object.langId);
            return message;
        };

        /**
         * Creates a plain object from a PushRegister message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushRegister
         * @static
         * @param {server.PushRegister} message PushRegister
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushRegister.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pushToken = null;
                object.langId = "";
            }
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                object.pushToken = $root.server.PushToken.toObject(message.pushToken, options);
            if (message.langId != null && message.hasOwnProperty("langId"))
                object.langId = message.langId;
            return object;
        };

        /**
         * Converts this PushRegister to JSON.
         * @function toJSON
         * @memberof server.PushRegister
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushRegister.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushRegister;
    })();

    server.PushPref = (function() {

        /**
         * Properties of a PushPref.
         * @memberof server
         * @interface IPushPref
         * @property {server.PushPref.Name|null} [name] PushPref name
         * @property {boolean|null} [value] PushPref value
         */

        /**
         * Constructs a new PushPref.
         * @memberof server
         * @classdesc Represents a PushPref.
         * @implements IPushPref
         * @constructor
         * @param {server.IPushPref=} [properties] Properties to set
         */
        function PushPref(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushPref name.
         * @member {server.PushPref.Name} name
         * @memberof server.PushPref
         * @instance
         */
        PushPref.prototype.name = 0;

        /**
         * PushPref value.
         * @member {boolean} value
         * @memberof server.PushPref
         * @instance
         */
        PushPref.prototype.value = false;

        /**
         * Creates a new PushPref instance using the specified properties.
         * @function create
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref=} [properties] Properties to set
         * @returns {server.PushPref} PushPref instance
         */
        PushPref.create = function create(properties) {
            return new PushPref(properties);
        };

        /**
         * Encodes the specified PushPref message. Does not implicitly {@link server.PushPref.verify|verify} messages.
         * @function encode
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref} message PushPref message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushPref.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
            return writer;
        };

        /**
         * Encodes the specified PushPref message, length delimited. Does not implicitly {@link server.PushPref.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushPref
         * @static
         * @param {server.IPushPref} message PushPref message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushPref.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushPref message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushPref
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushPref} PushPref
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushPref.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushPref();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.int32();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushPref message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushPref
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushPref} PushPref
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushPref.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushPref message.
         * @function verify
         * @memberof server.PushPref
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushPref.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                switch (message.name) {
                default:
                    return "name: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "boolean")
                    return "value: boolean expected";
            return null;
        };

        /**
         * Creates a PushPref message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushPref
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushPref} PushPref
         */
        PushPref.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushPref)
                return object;
            var message = new $root.server.PushPref();
            switch (object.name) {
            case "POST":
            case 0:
                message.name = 0;
                break;
            case "COMMENT":
            case 1:
                message.name = 1;
                break;
            }
            if (object.value != null)
                message.value = Boolean(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PushPref message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushPref
         * @static
         * @param {server.PushPref} message PushPref
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushPref.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = options.enums === String ? "POST" : 0;
                object.value = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.enums === String ? $root.server.PushPref.Name[message.name] : message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PushPref to JSON.
         * @function toJSON
         * @memberof server.PushPref
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushPref.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Name enum.
         * @name server.PushPref.Name
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} COMMENT=1 COMMENT value
         */
        PushPref.Name = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "COMMENT"] = 1;
            return values;
        })();

        return PushPref;
    })();

    server.NotificationPrefs = (function() {

        /**
         * Properties of a NotificationPrefs.
         * @memberof server
         * @interface INotificationPrefs
         * @property {Array.<server.IPushPref>|null} [pushPrefs] NotificationPrefs pushPrefs
         */

        /**
         * Constructs a new NotificationPrefs.
         * @memberof server
         * @classdesc Represents a NotificationPrefs.
         * @implements INotificationPrefs
         * @constructor
         * @param {server.INotificationPrefs=} [properties] Properties to set
         */
        function NotificationPrefs(properties) {
            this.pushPrefs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationPrefs pushPrefs.
         * @member {Array.<server.IPushPref>} pushPrefs
         * @memberof server.NotificationPrefs
         * @instance
         */
        NotificationPrefs.prototype.pushPrefs = $util.emptyArray;

        /**
         * Creates a new NotificationPrefs instance using the specified properties.
         * @function create
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs=} [properties] Properties to set
         * @returns {server.NotificationPrefs} NotificationPrefs instance
         */
        NotificationPrefs.create = function create(properties) {
            return new NotificationPrefs(properties);
        };

        /**
         * Encodes the specified NotificationPrefs message. Does not implicitly {@link server.NotificationPrefs.verify|verify} messages.
         * @function encode
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs} message NotificationPrefs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationPrefs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pushPrefs != null && message.pushPrefs.length)
                for (var i = 0; i < message.pushPrefs.length; ++i)
                    $root.server.PushPref.encode(message.pushPrefs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NotificationPrefs message, length delimited. Does not implicitly {@link server.NotificationPrefs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.INotificationPrefs} message NotificationPrefs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationPrefs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotificationPrefs message from the specified reader or buffer.
         * @function decode
         * @memberof server.NotificationPrefs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.NotificationPrefs} NotificationPrefs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationPrefs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.NotificationPrefs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.pushPrefs && message.pushPrefs.length))
                        message.pushPrefs = [];
                    message.pushPrefs.push($root.server.PushPref.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotificationPrefs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.NotificationPrefs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.NotificationPrefs} NotificationPrefs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationPrefs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotificationPrefs message.
         * @function verify
         * @memberof server.NotificationPrefs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotificationPrefs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pushPrefs != null && message.hasOwnProperty("pushPrefs")) {
                if (!Array.isArray(message.pushPrefs))
                    return "pushPrefs: array expected";
                for (var i = 0; i < message.pushPrefs.length; ++i) {
                    var error = $root.server.PushPref.verify(message.pushPrefs[i]);
                    if (error)
                        return "pushPrefs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NotificationPrefs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.NotificationPrefs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.NotificationPrefs} NotificationPrefs
         */
        NotificationPrefs.fromObject = function fromObject(object) {
            if (object instanceof $root.server.NotificationPrefs)
                return object;
            var message = new $root.server.NotificationPrefs();
            if (object.pushPrefs) {
                if (!Array.isArray(object.pushPrefs))
                    throw TypeError(".server.NotificationPrefs.pushPrefs: array expected");
                message.pushPrefs = [];
                for (var i = 0; i < object.pushPrefs.length; ++i) {
                    if (typeof object.pushPrefs[i] !== "object")
                        throw TypeError(".server.NotificationPrefs.pushPrefs: object expected");
                    message.pushPrefs[i] = $root.server.PushPref.fromObject(object.pushPrefs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NotificationPrefs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.NotificationPrefs
         * @static
         * @param {server.NotificationPrefs} message NotificationPrefs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotificationPrefs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pushPrefs = [];
            if (message.pushPrefs && message.pushPrefs.length) {
                object.pushPrefs = [];
                for (var j = 0; j < message.pushPrefs.length; ++j)
                    object.pushPrefs[j] = $root.server.PushPref.toObject(message.pushPrefs[j], options);
            }
            return object;
        };

        /**
         * Converts this NotificationPrefs to JSON.
         * @function toJSON
         * @memberof server.NotificationPrefs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotificationPrefs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NotificationPrefs;
    })();

    server.Rerequest = (function() {

        /**
         * Properties of a Rerequest.
         * @memberof server
         * @interface IRerequest
         * @property {string|null} [id] Rerequest id
         * @property {Uint8Array|null} [identityKey] Rerequest identityKey
         * @property {number|Long|null} [signedPreKeyId] Rerequest signedPreKeyId
         * @property {number|Long|null} [oneTimePreKeyId] Rerequest oneTimePreKeyId
         * @property {Uint8Array|null} [sessionSetupEphemeralKey] Rerequest sessionSetupEphemeralKey
         * @property {Uint8Array|null} [messageEphemeralKey] Rerequest messageEphemeralKey
         * @property {server.Rerequest.ContentType|null} [contentType] Rerequest contentType
         */

        /**
         * Constructs a new Rerequest.
         * @memberof server
         * @classdesc Represents a Rerequest.
         * @implements IRerequest
         * @constructor
         * @param {server.IRerequest=} [properties] Properties to set
         */
        function Rerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rerequest id.
         * @member {string} id
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.id = "";

        /**
         * Rerequest identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.identityKey = $util.newBuffer([]);

        /**
         * Rerequest signedPreKeyId.
         * @member {number|Long} signedPreKeyId
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.signedPreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rerequest oneTimePreKeyId.
         * @member {number|Long} oneTimePreKeyId
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.oneTimePreKeyId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rerequest sessionSetupEphemeralKey.
         * @member {Uint8Array} sessionSetupEphemeralKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.sessionSetupEphemeralKey = $util.newBuffer([]);

        /**
         * Rerequest messageEphemeralKey.
         * @member {Uint8Array} messageEphemeralKey
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.messageEphemeralKey = $util.newBuffer([]);

        /**
         * Rerequest contentType.
         * @member {server.Rerequest.ContentType} contentType
         * @memberof server.Rerequest
         * @instance
         */
        Rerequest.prototype.contentType = 0;

        /**
         * Creates a new Rerequest instance using the specified properties.
         * @function create
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest=} [properties] Properties to set
         * @returns {server.Rerequest} Rerequest instance
         */
        Rerequest.create = function create(properties) {
            return new Rerequest(properties);
        };

        /**
         * Encodes the specified Rerequest message. Does not implicitly {@link server.Rerequest.verify|verify} messages.
         * @function encode
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest} message Rerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identityKey);
            if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.signedPreKeyId);
            if (message.oneTimePreKeyId != null && Object.hasOwnProperty.call(message, "oneTimePreKeyId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.oneTimePreKeyId);
            if (message.sessionSetupEphemeralKey != null && Object.hasOwnProperty.call(message, "sessionSetupEphemeralKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sessionSetupEphemeralKey);
            if (message.messageEphemeralKey != null && Object.hasOwnProperty.call(message, "messageEphemeralKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.messageEphemeralKey);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified Rerequest message, length delimited. Does not implicitly {@link server.Rerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Rerequest
         * @static
         * @param {server.IRerequest} message Rerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.Rerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Rerequest} Rerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Rerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.identityKey = reader.bytes();
                    break;
                case 3:
                    message.signedPreKeyId = reader.int64();
                    break;
                case 4:
                    message.oneTimePreKeyId = reader.int64();
                    break;
                case 5:
                    message.sessionSetupEphemeralKey = reader.bytes();
                    break;
                case 6:
                    message.messageEphemeralKey = reader.bytes();
                    break;
                case 7:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Rerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Rerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Rerequest} Rerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rerequest message.
         * @function verify
         * @memberof server.Rerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (!$util.isInteger(message.signedPreKeyId) && !(message.signedPreKeyId && $util.isInteger(message.signedPreKeyId.low) && $util.isInteger(message.signedPreKeyId.high)))
                    return "signedPreKeyId: integer|Long expected";
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (!$util.isInteger(message.oneTimePreKeyId) && !(message.oneTimePreKeyId && $util.isInteger(message.oneTimePreKeyId.low) && $util.isInteger(message.oneTimePreKeyId.high)))
                    return "oneTimePreKeyId: integer|Long expected";
            if (message.sessionSetupEphemeralKey != null && message.hasOwnProperty("sessionSetupEphemeralKey"))
                if (!(message.sessionSetupEphemeralKey && typeof message.sessionSetupEphemeralKey.length === "number" || $util.isString(message.sessionSetupEphemeralKey)))
                    return "sessionSetupEphemeralKey: buffer expected";
            if (message.messageEphemeralKey != null && message.hasOwnProperty("messageEphemeralKey"))
                if (!(message.messageEphemeralKey && typeof message.messageEphemeralKey.length === "number" || $util.isString(message.messageEphemeralKey)))
                    return "messageEphemeralKey: buffer expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Rerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Rerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Rerequest} Rerequest
         */
        Rerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Rerequest)
                return object;
            var message = new $root.server.Rerequest();
            if (object.id != null)
                message.id = String(object.id);
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedPreKeyId != null)
                if ($util.Long)
                    (message.signedPreKeyId = $util.Long.fromValue(object.signedPreKeyId)).unsigned = false;
                else if (typeof object.signedPreKeyId === "string")
                    message.signedPreKeyId = parseInt(object.signedPreKeyId, 10);
                else if (typeof object.signedPreKeyId === "number")
                    message.signedPreKeyId = object.signedPreKeyId;
                else if (typeof object.signedPreKeyId === "object")
                    message.signedPreKeyId = new $util.LongBits(object.signedPreKeyId.low >>> 0, object.signedPreKeyId.high >>> 0).toNumber();
            if (object.oneTimePreKeyId != null)
                if ($util.Long)
                    (message.oneTimePreKeyId = $util.Long.fromValue(object.oneTimePreKeyId)).unsigned = false;
                else if (typeof object.oneTimePreKeyId === "string")
                    message.oneTimePreKeyId = parseInt(object.oneTimePreKeyId, 10);
                else if (typeof object.oneTimePreKeyId === "number")
                    message.oneTimePreKeyId = object.oneTimePreKeyId;
                else if (typeof object.oneTimePreKeyId === "object")
                    message.oneTimePreKeyId = new $util.LongBits(object.oneTimePreKeyId.low >>> 0, object.oneTimePreKeyId.high >>> 0).toNumber();
            if (object.sessionSetupEphemeralKey != null)
                if (typeof object.sessionSetupEphemeralKey === "string")
                    $util.base64.decode(object.sessionSetupEphemeralKey, message.sessionSetupEphemeralKey = $util.newBuffer($util.base64.length(object.sessionSetupEphemeralKey)), 0);
                else if (object.sessionSetupEphemeralKey.length)
                    message.sessionSetupEphemeralKey = object.sessionSetupEphemeralKey;
            if (object.messageEphemeralKey != null)
                if (typeof object.messageEphemeralKey === "string")
                    $util.base64.decode(object.messageEphemeralKey, message.messageEphemeralKey = $util.newBuffer($util.base64.length(object.messageEphemeralKey)), 0);
                else if (object.messageEphemeralKey.length)
                    message.messageEphemeralKey = object.messageEphemeralKey;
            switch (object.contentType) {
            case "CHAT":
            case 0:
                message.contentType = 0;
                break;
            case "CALL":
            case 1:
                message.contentType = 1;
                break;
            case "GROUP_HISTORY":
            case 2:
                message.contentType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Rerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Rerequest
         * @static
         * @param {server.Rerequest} message Rerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.signedPreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.signedPreKeyId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oneTimePreKeyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oneTimePreKeyId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.sessionSetupEphemeralKey = "";
                else {
                    object.sessionSetupEphemeralKey = [];
                    if (options.bytes !== Array)
                        object.sessionSetupEphemeralKey = $util.newBuffer(object.sessionSetupEphemeralKey);
                }
                if (options.bytes === String)
                    object.messageEphemeralKey = "";
                else {
                    object.messageEphemeralKey = [];
                    if (options.bytes !== Array)
                        object.messageEphemeralKey = $util.newBuffer(object.messageEphemeralKey);
                }
                object.contentType = options.enums === String ? "CHAT" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (typeof message.signedPreKeyId === "number")
                    object.signedPreKeyId = options.longs === String ? String(message.signedPreKeyId) : message.signedPreKeyId;
                else
                    object.signedPreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.signedPreKeyId) : options.longs === Number ? new $util.LongBits(message.signedPreKeyId.low >>> 0, message.signedPreKeyId.high >>> 0).toNumber() : message.signedPreKeyId;
            if (message.oneTimePreKeyId != null && message.hasOwnProperty("oneTimePreKeyId"))
                if (typeof message.oneTimePreKeyId === "number")
                    object.oneTimePreKeyId = options.longs === String ? String(message.oneTimePreKeyId) : message.oneTimePreKeyId;
                else
                    object.oneTimePreKeyId = options.longs === String ? $util.Long.prototype.toString.call(message.oneTimePreKeyId) : options.longs === Number ? new $util.LongBits(message.oneTimePreKeyId.low >>> 0, message.oneTimePreKeyId.high >>> 0).toNumber() : message.oneTimePreKeyId;
            if (message.sessionSetupEphemeralKey != null && message.hasOwnProperty("sessionSetupEphemeralKey"))
                object.sessionSetupEphemeralKey = options.bytes === String ? $util.base64.encode(message.sessionSetupEphemeralKey, 0, message.sessionSetupEphemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionSetupEphemeralKey) : message.sessionSetupEphemeralKey;
            if (message.messageEphemeralKey != null && message.hasOwnProperty("messageEphemeralKey"))
                object.messageEphemeralKey = options.bytes === String ? $util.base64.encode(message.messageEphemeralKey, 0, message.messageEphemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageEphemeralKey) : message.messageEphemeralKey;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.Rerequest.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this Rerequest to JSON.
         * @function toJSON
         * @memberof server.Rerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ContentType enum.
         * @name server.Rerequest.ContentType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} CALL=1 CALL value
         * @property {number} GROUP_HISTORY=2 GROUP_HISTORY value
         */
        Rerequest.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "CALL"] = 1;
            values[valuesById[2] = "GROUP_HISTORY"] = 2;
            return values;
        })();

        return Rerequest;
    })();

    server.GroupFeedRerequest = (function() {

        /**
         * Properties of a GroupFeedRerequest.
         * @memberof server
         * @interface IGroupFeedRerequest
         * @property {string|null} [gid] GroupFeedRerequest gid
         * @property {string|null} [id] GroupFeedRerequest id
         * @property {server.GroupFeedRerequest.RerequestType|null} [rerequestType] GroupFeedRerequest rerequestType
         * @property {server.GroupFeedRerequest.ContentType|null} [contentType] GroupFeedRerequest contentType
         */

        /**
         * Constructs a new GroupFeedRerequest.
         * @memberof server
         * @classdesc Represents a GroupFeedRerequest.
         * @implements IGroupFeedRerequest
         * @constructor
         * @param {server.IGroupFeedRerequest=} [properties] Properties to set
         */
        function GroupFeedRerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupFeedRerequest gid.
         * @member {string} gid
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.gid = "";

        /**
         * GroupFeedRerequest id.
         * @member {string} id
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.id = "";

        /**
         * GroupFeedRerequest rerequestType.
         * @member {server.GroupFeedRerequest.RerequestType} rerequestType
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.rerequestType = 0;

        /**
         * GroupFeedRerequest contentType.
         * @member {server.GroupFeedRerequest.ContentType} contentType
         * @memberof server.GroupFeedRerequest
         * @instance
         */
        GroupFeedRerequest.prototype.contentType = 0;

        /**
         * Creates a new GroupFeedRerequest instance using the specified properties.
         * @function create
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest=} [properties] Properties to set
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest instance
         */
        GroupFeedRerequest.create = function create(properties) {
            return new GroupFeedRerequest(properties);
        };

        /**
         * Encodes the specified GroupFeedRerequest message. Does not implicitly {@link server.GroupFeedRerequest.verify|verify} messages.
         * @function encode
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest} message GroupFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedRerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.rerequestType != null && Object.hasOwnProperty.call(message, "rerequestType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rerequestType);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified GroupFeedRerequest message, length delimited. Does not implicitly {@link server.GroupFeedRerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.IGroupFeedRerequest} message GroupFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupFeedRerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupFeedRerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedRerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupFeedRerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.rerequestType = reader.int32();
                    break;
                case 4:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupFeedRerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupFeedRerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupFeedRerequest message.
         * @function verify
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupFeedRerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                switch (message.rerequestType) {
                default:
                    return "rerequestType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupFeedRerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupFeedRerequest} GroupFeedRerequest
         */
        GroupFeedRerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupFeedRerequest)
                return object;
            var message = new $root.server.GroupFeedRerequest();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.id != null)
                message.id = String(object.id);
            switch (object.rerequestType) {
            case "PAYLOAD":
            case 0:
                message.rerequestType = 0;
                break;
            case "SENDER_STATE":
            case 1:
                message.rerequestType = 1;
                break;
            }
            switch (object.contentType) {
            case "UNKNOWN":
            case 0:
                message.contentType = 0;
                break;
            case "POST":
            case 1:
                message.contentType = 1;
                break;
            case "COMMENT":
            case 2:
                message.contentType = 2;
                break;
            case "HISTORY_RESEND":
            case 3:
                message.contentType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupFeedRerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupFeedRerequest
         * @static
         * @param {server.GroupFeedRerequest} message GroupFeedRerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupFeedRerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.id = "";
                object.rerequestType = options.enums === String ? "PAYLOAD" : 0;
                object.contentType = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                object.rerequestType = options.enums === String ? $root.server.GroupFeedRerequest.RerequestType[message.rerequestType] : message.rerequestType;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.GroupFeedRerequest.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this GroupFeedRerequest to JSON.
         * @function toJSON
         * @memberof server.GroupFeedRerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupFeedRerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * RerequestType enum.
         * @name server.GroupFeedRerequest.RerequestType
         * @enum {number}
         * @property {number} PAYLOAD=0 PAYLOAD value
         * @property {number} SENDER_STATE=1 SENDER_STATE value
         */
        GroupFeedRerequest.RerequestType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PAYLOAD"] = 0;
            values[valuesById[1] = "SENDER_STATE"] = 1;
            return values;
        })();

        /**
         * ContentType enum.
         * @name server.GroupFeedRerequest.ContentType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} HISTORY_RESEND=3 HISTORY_RESEND value
         */
        GroupFeedRerequest.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[3] = "HISTORY_RESEND"] = 3;
            return values;
        })();

        return GroupFeedRerequest;
    })();

    server.HomeFeedRerequest = (function() {

        /**
         * Properties of a HomeFeedRerequest.
         * @memberof server
         * @interface IHomeFeedRerequest
         * @property {string|null} [id] HomeFeedRerequest id
         * @property {server.HomeFeedRerequest.RerequestType|null} [rerequestType] HomeFeedRerequest rerequestType
         */

        /**
         * Constructs a new HomeFeedRerequest.
         * @memberof server
         * @classdesc Represents a HomeFeedRerequest.
         * @implements IHomeFeedRerequest
         * @constructor
         * @param {server.IHomeFeedRerequest=} [properties] Properties to set
         */
        function HomeFeedRerequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HomeFeedRerequest id.
         * @member {string} id
         * @memberof server.HomeFeedRerequest
         * @instance
         */
        HomeFeedRerequest.prototype.id = "";

        /**
         * HomeFeedRerequest rerequestType.
         * @member {server.HomeFeedRerequest.RerequestType} rerequestType
         * @memberof server.HomeFeedRerequest
         * @instance
         */
        HomeFeedRerequest.prototype.rerequestType = 0;

        /**
         * Creates a new HomeFeedRerequest instance using the specified properties.
         * @function create
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest=} [properties] Properties to set
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest instance
         */
        HomeFeedRerequest.create = function create(properties) {
            return new HomeFeedRerequest(properties);
        };

        /**
         * Encodes the specified HomeFeedRerequest message. Does not implicitly {@link server.HomeFeedRerequest.verify|verify} messages.
         * @function encode
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest} message HomeFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeFeedRerequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.rerequestType != null && Object.hasOwnProperty.call(message, "rerequestType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rerequestType);
            return writer;
        };

        /**
         * Encodes the specified HomeFeedRerequest message, length delimited. Does not implicitly {@link server.HomeFeedRerequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.IHomeFeedRerequest} message HomeFeedRerequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HomeFeedRerequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HomeFeedRerequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeFeedRerequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HomeFeedRerequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.rerequestType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HomeFeedRerequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HomeFeedRerequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HomeFeedRerequest message.
         * @function verify
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HomeFeedRerequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                switch (message.rerequestType) {
                default:
                    return "rerequestType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a HomeFeedRerequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HomeFeedRerequest} HomeFeedRerequest
         */
        HomeFeedRerequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HomeFeedRerequest)
                return object;
            var message = new $root.server.HomeFeedRerequest();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.rerequestType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.rerequestType = 0;
                break;
            case "PAYLOAD":
            case 1:
                message.rerequestType = 1;
                break;
            case "SENDER_STATE":
            case 2:
                message.rerequestType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a HomeFeedRerequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HomeFeedRerequest
         * @static
         * @param {server.HomeFeedRerequest} message HomeFeedRerequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HomeFeedRerequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.rerequestType = options.enums === String ? "UNKNOWN_TYPE" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rerequestType != null && message.hasOwnProperty("rerequestType"))
                object.rerequestType = options.enums === String ? $root.server.HomeFeedRerequest.RerequestType[message.rerequestType] : message.rerequestType;
            return object;
        };

        /**
         * Converts this HomeFeedRerequest to JSON.
         * @function toJSON
         * @memberof server.HomeFeedRerequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HomeFeedRerequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * RerequestType enum.
         * @name server.HomeFeedRerequest.RerequestType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} PAYLOAD=1 PAYLOAD value
         * @property {number} SENDER_STATE=2 SENDER_STATE value
         */
        HomeFeedRerequest.RerequestType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "PAYLOAD"] = 1;
            values[valuesById[2] = "SENDER_STATE"] = 2;
            return values;
        })();

        return HomeFeedRerequest;
    })();

    server.SeenReceipt = (function() {

        /**
         * Properties of a SeenReceipt.
         * @memberof server
         * @interface ISeenReceipt
         * @property {string|null} [id] SeenReceipt id
         * @property {string|null} [threadId] SeenReceipt threadId
         * @property {number|Long|null} [timestamp] SeenReceipt timestamp
         */

        /**
         * Constructs a new SeenReceipt.
         * @memberof server
         * @classdesc Represents a SeenReceipt.
         * @implements ISeenReceipt
         * @constructor
         * @param {server.ISeenReceipt=} [properties] Properties to set
         */
        function SeenReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeenReceipt id.
         * @member {string} id
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.id = "";

        /**
         * SeenReceipt threadId.
         * @member {string} threadId
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.threadId = "";

        /**
         * SeenReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.SeenReceipt
         * @instance
         */
        SeenReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SeenReceipt instance using the specified properties.
         * @function create
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt=} [properties] Properties to set
         * @returns {server.SeenReceipt} SeenReceipt instance
         */
        SeenReceipt.create = function create(properties) {
            return new SeenReceipt(properties);
        };

        /**
         * Encodes the specified SeenReceipt message. Does not implicitly {@link server.SeenReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt} message SeenReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeenReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified SeenReceipt message, length delimited. Does not implicitly {@link server.SeenReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.SeenReceipt
         * @static
         * @param {server.ISeenReceipt} message SeenReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeenReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeenReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.SeenReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.SeenReceipt} SeenReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeenReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.SeenReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeenReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.SeenReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.SeenReceipt} SeenReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeenReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeenReceipt message.
         * @function verify
         * @memberof server.SeenReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeenReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a SeenReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.SeenReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.SeenReceipt} SeenReceipt
         */
        SeenReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.SeenReceipt)
                return object;
            var message = new $root.server.SeenReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SeenReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.SeenReceipt
         * @static
         * @param {server.SeenReceipt} message SeenReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SeenReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this SeenReceipt to JSON.
         * @function toJSON
         * @memberof server.SeenReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SeenReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SeenReceipt;
    })();

    server.DeliveryReceipt = (function() {

        /**
         * Properties of a DeliveryReceipt.
         * @memberof server
         * @interface IDeliveryReceipt
         * @property {string|null} [id] DeliveryReceipt id
         * @property {string|null} [threadId] DeliveryReceipt threadId
         * @property {number|Long|null} [timestamp] DeliveryReceipt timestamp
         */

        /**
         * Constructs a new DeliveryReceipt.
         * @memberof server
         * @classdesc Represents a DeliveryReceipt.
         * @implements IDeliveryReceipt
         * @constructor
         * @param {server.IDeliveryReceipt=} [properties] Properties to set
         */
        function DeliveryReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeliveryReceipt id.
         * @member {string} id
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.id = "";

        /**
         * DeliveryReceipt threadId.
         * @member {string} threadId
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.threadId = "";

        /**
         * DeliveryReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.DeliveryReceipt
         * @instance
         */
        DeliveryReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeliveryReceipt instance using the specified properties.
         * @function create
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt=} [properties] Properties to set
         * @returns {server.DeliveryReceipt} DeliveryReceipt instance
         */
        DeliveryReceipt.create = function create(properties) {
            return new DeliveryReceipt(properties);
        };

        /**
         * Encodes the specified DeliveryReceipt message. Does not implicitly {@link server.DeliveryReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt} message DeliveryReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeliveryReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified DeliveryReceipt message, length delimited. Does not implicitly {@link server.DeliveryReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.IDeliveryReceipt} message DeliveryReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeliveryReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeliveryReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeliveryReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeliveryReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeliveryReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeliveryReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeliveryReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeliveryReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeliveryReceipt message.
         * @function verify
         * @memberof server.DeliveryReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeliveryReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a DeliveryReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeliveryReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeliveryReceipt} DeliveryReceipt
         */
        DeliveryReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeliveryReceipt)
                return object;
            var message = new $root.server.DeliveryReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DeliveryReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeliveryReceipt
         * @static
         * @param {server.DeliveryReceipt} message DeliveryReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeliveryReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this DeliveryReceipt to JSON.
         * @function toJSON
         * @memberof server.DeliveryReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeliveryReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeliveryReceipt;
    })();

    server.PlayedReceipt = (function() {

        /**
         * Properties of a PlayedReceipt.
         * @memberof server
         * @interface IPlayedReceipt
         * @property {string|null} [id] PlayedReceipt id
         * @property {string|null} [threadId] PlayedReceipt threadId
         * @property {number|Long|null} [timestamp] PlayedReceipt timestamp
         */

        /**
         * Constructs a new PlayedReceipt.
         * @memberof server
         * @classdesc Represents a PlayedReceipt.
         * @implements IPlayedReceipt
         * @constructor
         * @param {server.IPlayedReceipt=} [properties] Properties to set
         */
        function PlayedReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayedReceipt id.
         * @member {string} id
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.id = "";

        /**
         * PlayedReceipt threadId.
         * @member {string} threadId
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.threadId = "";

        /**
         * PlayedReceipt timestamp.
         * @member {number|Long} timestamp
         * @memberof server.PlayedReceipt
         * @instance
         */
        PlayedReceipt.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PlayedReceipt instance using the specified properties.
         * @function create
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt=} [properties] Properties to set
         * @returns {server.PlayedReceipt} PlayedReceipt instance
         */
        PlayedReceipt.create = function create(properties) {
            return new PlayedReceipt(properties);
        };

        /**
         * Encodes the specified PlayedReceipt message. Does not implicitly {@link server.PlayedReceipt.verify|verify} messages.
         * @function encode
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt} message PlayedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayedReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.threadId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PlayedReceipt message, length delimited. Does not implicitly {@link server.PlayedReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.IPlayedReceipt} message PlayedReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayedReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayedReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof server.PlayedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PlayedReceipt} PlayedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayedReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PlayedReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.threadId = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayedReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PlayedReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PlayedReceipt} PlayedReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayedReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayedReceipt message.
         * @function verify
         * @memberof server.PlayedReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayedReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                if (!$util.isString(message.threadId))
                    return "threadId: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PlayedReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PlayedReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PlayedReceipt} PlayedReceipt
         */
        PlayedReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PlayedReceipt)
                return object;
            var message = new $root.server.PlayedReceipt();
            if (object.id != null)
                message.id = String(object.id);
            if (object.threadId != null)
                message.threadId = String(object.threadId);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PlayedReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PlayedReceipt
         * @static
         * @param {server.PlayedReceipt} message PlayedReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayedReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.threadId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.threadId != null && message.hasOwnProperty("threadId"))
                object.threadId = message.threadId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PlayedReceipt to JSON.
         * @function toJSON
         * @memberof server.PlayedReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayedReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayedReceipt;
    })();

    server.GroupChatRetract = (function() {

        /**
         * Properties of a GroupChatRetract.
         * @memberof server
         * @interface IGroupChatRetract
         * @property {string|null} [id] GroupChatRetract id
         * @property {string|null} [gid] GroupChatRetract gid
         */

        /**
         * Constructs a new GroupChatRetract.
         * @memberof server
         * @classdesc Represents a GroupChatRetract.
         * @implements IGroupChatRetract
         * @constructor
         * @param {server.IGroupChatRetract=} [properties] Properties to set
         */
        function GroupChatRetract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupChatRetract id.
         * @member {string} id
         * @memberof server.GroupChatRetract
         * @instance
         */
        GroupChatRetract.prototype.id = "";

        /**
         * GroupChatRetract gid.
         * @member {string} gid
         * @memberof server.GroupChatRetract
         * @instance
         */
        GroupChatRetract.prototype.gid = "";

        /**
         * Creates a new GroupChatRetract instance using the specified properties.
         * @function create
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract=} [properties] Properties to set
         * @returns {server.GroupChatRetract} GroupChatRetract instance
         */
        GroupChatRetract.create = function create(properties) {
            return new GroupChatRetract(properties);
        };

        /**
         * Encodes the specified GroupChatRetract message. Does not implicitly {@link server.GroupChatRetract.verify|verify} messages.
         * @function encode
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract} message GroupChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatRetract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gid);
            return writer;
        };

        /**
         * Encodes the specified GroupChatRetract message, length delimited. Does not implicitly {@link server.GroupChatRetract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.IGroupChatRetract} message GroupChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupChatRetract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupChatRetract message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupChatRetract} GroupChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatRetract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupChatRetract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.gid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupChatRetract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupChatRetract} GroupChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupChatRetract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupChatRetract message.
         * @function verify
         * @memberof server.GroupChatRetract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupChatRetract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            return null;
        };

        /**
         * Creates a GroupChatRetract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupChatRetract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupChatRetract} GroupChatRetract
         */
        GroupChatRetract.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupChatRetract)
                return object;
            var message = new $root.server.GroupChatRetract();
            if (object.id != null)
                message.id = String(object.id);
            if (object.gid != null)
                message.gid = String(object.gid);
            return message;
        };

        /**
         * Creates a plain object from a GroupChatRetract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupChatRetract
         * @static
         * @param {server.GroupChatRetract} message GroupChatRetract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupChatRetract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.gid = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            return object;
        };

        /**
         * Converts this GroupChatRetract to JSON.
         * @function toJSON
         * @memberof server.GroupChatRetract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupChatRetract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupChatRetract;
    })();

    server.ChatRetract = (function() {

        /**
         * Properties of a ChatRetract.
         * @memberof server
         * @interface IChatRetract
         * @property {string|null} [id] ChatRetract id
         */

        /**
         * Constructs a new ChatRetract.
         * @memberof server
         * @classdesc Represents a ChatRetract.
         * @implements IChatRetract
         * @constructor
         * @param {server.IChatRetract=} [properties] Properties to set
         */
        function ChatRetract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatRetract id.
         * @member {string} id
         * @memberof server.ChatRetract
         * @instance
         */
        ChatRetract.prototype.id = "";

        /**
         * Creates a new ChatRetract instance using the specified properties.
         * @function create
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract=} [properties] Properties to set
         * @returns {server.ChatRetract} ChatRetract instance
         */
        ChatRetract.create = function create(properties) {
            return new ChatRetract(properties);
        };

        /**
         * Encodes the specified ChatRetract message. Does not implicitly {@link server.ChatRetract.verify|verify} messages.
         * @function encode
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract} message ChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRetract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ChatRetract message, length delimited. Does not implicitly {@link server.ChatRetract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ChatRetract
         * @static
         * @param {server.IChatRetract} message ChatRetract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRetract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatRetract message from the specified reader or buffer.
         * @function decode
         * @memberof server.ChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ChatRetract} ChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRetract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ChatRetract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatRetract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ChatRetract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ChatRetract} ChatRetract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRetract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatRetract message.
         * @function verify
         * @memberof server.ChatRetract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatRetract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ChatRetract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ChatRetract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ChatRetract} ChatRetract
         */
        ChatRetract.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ChatRetract)
                return object;
            var message = new $root.server.ChatRetract();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ChatRetract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ChatRetract
         * @static
         * @param {server.ChatRetract} message ChatRetract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatRetract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ChatRetract to JSON.
         * @function toJSON
         * @memberof server.ChatRetract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatRetract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChatRetract;
    })();

    server.Prop = (function() {

        /**
         * Properties of a Prop.
         * @memberof server
         * @interface IProp
         * @property {string|null} [name] Prop name
         * @property {string|null} [value] Prop value
         */

        /**
         * Constructs a new Prop.
         * @memberof server
         * @classdesc Represents a Prop.
         * @implements IProp
         * @constructor
         * @param {server.IProp=} [properties] Properties to set
         */
        function Prop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Prop name.
         * @member {string} name
         * @memberof server.Prop
         * @instance
         */
        Prop.prototype.name = "";

        /**
         * Prop value.
         * @member {string} value
         * @memberof server.Prop
         * @instance
         */
        Prop.prototype.value = "";

        /**
         * Creates a new Prop instance using the specified properties.
         * @function create
         * @memberof server.Prop
         * @static
         * @param {server.IProp=} [properties] Properties to set
         * @returns {server.Prop} Prop instance
         */
        Prop.create = function create(properties) {
            return new Prop(properties);
        };

        /**
         * Encodes the specified Prop message. Does not implicitly {@link server.Prop.verify|verify} messages.
         * @function encode
         * @memberof server.Prop
         * @static
         * @param {server.IProp} message Prop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Prop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Prop message, length delimited. Does not implicitly {@link server.Prop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Prop
         * @static
         * @param {server.IProp} message Prop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Prop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Prop message from the specified reader or buffer.
         * @function decode
         * @memberof server.Prop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Prop} Prop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Prop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Prop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Prop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Prop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Prop} Prop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Prop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Prop message.
         * @function verify
         * @memberof server.Prop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Prop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Prop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Prop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Prop} Prop
         */
        Prop.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Prop)
                return object;
            var message = new $root.server.Prop();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Prop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Prop
         * @static
         * @param {server.Prop} message Prop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Prop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Prop to JSON.
         * @function toJSON
         * @memberof server.Prop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Prop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Prop;
    })();

    server.Props = (function() {

        /**
         * Properties of a Props.
         * @memberof server
         * @interface IProps
         * @property {Uint8Array|null} [hash] Props hash
         * @property {Array.<server.IProp>|null} [props] Props props
         */

        /**
         * Constructs a new Props.
         * @memberof server
         * @classdesc Represents a Props.
         * @implements IProps
         * @constructor
         * @param {server.IProps=} [properties] Properties to set
         */
        function Props(properties) {
            this.props = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Props hash.
         * @member {Uint8Array} hash
         * @memberof server.Props
         * @instance
         */
        Props.prototype.hash = $util.newBuffer([]);

        /**
         * Props props.
         * @member {Array.<server.IProp>} props
         * @memberof server.Props
         * @instance
         */
        Props.prototype.props = $util.emptyArray;

        /**
         * Creates a new Props instance using the specified properties.
         * @function create
         * @memberof server.Props
         * @static
         * @param {server.IProps=} [properties] Properties to set
         * @returns {server.Props} Props instance
         */
        Props.create = function create(properties) {
            return new Props(properties);
        };

        /**
         * Encodes the specified Props message. Does not implicitly {@link server.Props.verify|verify} messages.
         * @function encode
         * @memberof server.Props
         * @static
         * @param {server.IProps} message Props message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Props.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.props != null && message.props.length)
                for (var i = 0; i < message.props.length; ++i)
                    $root.server.Prop.encode(message.props[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Props message, length delimited. Does not implicitly {@link server.Props.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Props
         * @static
         * @param {server.IProps} message Props message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Props.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Props message from the specified reader or buffer.
         * @function decode
         * @memberof server.Props
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Props} Props
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Props.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Props();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.server.Prop.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Props message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Props
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Props} Props
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Props.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Props message.
         * @function verify
         * @memberof server.Props
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Props.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.props != null && message.hasOwnProperty("props")) {
                if (!Array.isArray(message.props))
                    return "props: array expected";
                for (var i = 0; i < message.props.length; ++i) {
                    var error = $root.server.Prop.verify(message.props[i]);
                    if (error)
                        return "props." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Props message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Props
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Props} Props
         */
        Props.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Props)
                return object;
            var message = new $root.server.Props();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.props) {
                if (!Array.isArray(object.props))
                    throw TypeError(".server.Props.props: array expected");
                message.props = [];
                for (var i = 0; i < object.props.length; ++i) {
                    if (typeof object.props[i] !== "object")
                        throw TypeError(".server.Props.props: object expected");
                    message.props[i] = $root.server.Prop.fromObject(object.props[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Props message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Props
         * @static
         * @param {server.Props} message Props
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Props.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.props = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.props && message.props.length) {
                object.props = [];
                for (var j = 0; j < message.props.length; ++j)
                    object.props[j] = $root.server.Prop.toObject(message.props[j], options);
            }
            return object;
        };

        /**
         * Converts this Props to JSON.
         * @function toJSON
         * @memberof server.Props
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Props.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Props;
    })();

    server.WhisperKeys = (function() {

        /**
         * Properties of a WhisperKeys.
         * @memberof server
         * @interface IWhisperKeys
         * @property {number|Long|null} [uid] WhisperKeys uid
         * @property {server.WhisperKeys.Action|null} [action] WhisperKeys action
         * @property {Uint8Array|null} [identityKey] WhisperKeys identityKey
         * @property {Uint8Array|null} [signedKey] WhisperKeys signedKey
         * @property {number|null} [otpKeyCount] WhisperKeys otpKeyCount
         * @property {Array.<Uint8Array>|null} [oneTimeKeys] WhisperKeys oneTimeKeys
         */

        /**
         * Constructs a new WhisperKeys.
         * @memberof server
         * @classdesc Represents a WhisperKeys.
         * @implements IWhisperKeys
         * @constructor
         * @param {server.IWhisperKeys=} [properties] Properties to set
         */
        function WhisperKeys(properties) {
            this.oneTimeKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperKeys uid.
         * @member {number|Long} uid
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WhisperKeys action.
         * @member {server.WhisperKeys.Action} action
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.action = 0;

        /**
         * WhisperKeys identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.identityKey = $util.newBuffer([]);

        /**
         * WhisperKeys signedKey.
         * @member {Uint8Array} signedKey
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.signedKey = $util.newBuffer([]);

        /**
         * WhisperKeys otpKeyCount.
         * @member {number} otpKeyCount
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.otpKeyCount = 0;

        /**
         * WhisperKeys oneTimeKeys.
         * @member {Array.<Uint8Array>} oneTimeKeys
         * @memberof server.WhisperKeys
         * @instance
         */
        WhisperKeys.prototype.oneTimeKeys = $util.emptyArray;

        /**
         * Creates a new WhisperKeys instance using the specified properties.
         * @function create
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys=} [properties] Properties to set
         * @returns {server.WhisperKeys} WhisperKeys instance
         */
        WhisperKeys.create = function create(properties) {
            return new WhisperKeys(properties);
        };

        /**
         * Encodes the specified WhisperKeys message. Does not implicitly {@link server.WhisperKeys.verify|verify} messages.
         * @function encode
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys} message WhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identityKey);
            if (message.signedKey != null && Object.hasOwnProperty.call(message, "signedKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signedKey);
            if (message.otpKeyCount != null && Object.hasOwnProperty.call(message, "otpKeyCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.otpKeyCount);
            if (message.oneTimeKeys != null && message.oneTimeKeys.length)
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.oneTimeKeys[i]);
            return writer;
        };

        /**
         * Encodes the specified WhisperKeys message, length delimited. Does not implicitly {@link server.WhisperKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WhisperKeys
         * @static
         * @param {server.IWhisperKeys} message WhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperKeys message from the specified reader or buffer.
         * @function decode
         * @memberof server.WhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WhisperKeys} WhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WhisperKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.action = reader.int32();
                    break;
                case 3:
                    message.identityKey = reader.bytes();
                    break;
                case 4:
                    message.signedKey = reader.bytes();
                    break;
                case 5:
                    message.otpKeyCount = reader.int32();
                    break;
                case 6:
                    if (!(message.oneTimeKeys && message.oneTimeKeys.length))
                        message.oneTimeKeys = [];
                    message.oneTimeKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WhisperKeys} WhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperKeys message.
         * @function verify
         * @memberof server.WhisperKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                if (!(message.signedKey && typeof message.signedKey.length === "number" || $util.isString(message.signedKey)))
                    return "signedKey: buffer expected";
            if (message.otpKeyCount != null && message.hasOwnProperty("otpKeyCount"))
                if (!$util.isInteger(message.otpKeyCount))
                    return "otpKeyCount: integer expected";
            if (message.oneTimeKeys != null && message.hasOwnProperty("oneTimeKeys")) {
                if (!Array.isArray(message.oneTimeKeys))
                    return "oneTimeKeys: array expected";
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    if (!(message.oneTimeKeys[i] && typeof message.oneTimeKeys[i].length === "number" || $util.isString(message.oneTimeKeys[i])))
                        return "oneTimeKeys: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a WhisperKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WhisperKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WhisperKeys} WhisperKeys
         */
        WhisperKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WhisperKeys)
                return object;
            var message = new $root.server.WhisperKeys();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            switch (object.action) {
            case "NORMAL":
            case 0:
                message.action = 0;
                break;
            case "ADD":
            case 1:
                message.action = 1;
                break;
            case "COUNT":
            case 2:
                message.action = 2;
                break;
            case "GET":
            case 3:
                message.action = 3;
                break;
            case "SET":
            case 4:
                message.action = 4;
                break;
            case "UPDATE":
            case 5:
                message.action = 5;
                break;
            }
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedKey != null)
                if (typeof object.signedKey === "string")
                    $util.base64.decode(object.signedKey, message.signedKey = $util.newBuffer($util.base64.length(object.signedKey)), 0);
                else if (object.signedKey.length)
                    message.signedKey = object.signedKey;
            if (object.otpKeyCount != null)
                message.otpKeyCount = object.otpKeyCount | 0;
            if (object.oneTimeKeys) {
                if (!Array.isArray(object.oneTimeKeys))
                    throw TypeError(".server.WhisperKeys.oneTimeKeys: array expected");
                message.oneTimeKeys = [];
                for (var i = 0; i < object.oneTimeKeys.length; ++i)
                    if (typeof object.oneTimeKeys[i] === "string")
                        $util.base64.decode(object.oneTimeKeys[i], message.oneTimeKeys[i] = $util.newBuffer($util.base64.length(object.oneTimeKeys[i])), 0);
                    else if (object.oneTimeKeys[i].length)
                        message.oneTimeKeys[i] = object.oneTimeKeys[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a WhisperKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WhisperKeys
         * @static
         * @param {server.WhisperKeys} message WhisperKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.oneTimeKeys = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.action = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.signedKey = "";
                else {
                    object.signedKey = [];
                    if (options.bytes !== Array)
                        object.signedKey = $util.newBuffer(object.signedKey);
                }
                object.otpKeyCount = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.server.WhisperKeys.Action[message.action] : message.action;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                object.signedKey = options.bytes === String ? $util.base64.encode(message.signedKey, 0, message.signedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedKey) : message.signedKey;
            if (message.otpKeyCount != null && message.hasOwnProperty("otpKeyCount"))
                object.otpKeyCount = message.otpKeyCount;
            if (message.oneTimeKeys && message.oneTimeKeys.length) {
                object.oneTimeKeys = [];
                for (var j = 0; j < message.oneTimeKeys.length; ++j)
                    object.oneTimeKeys[j] = options.bytes === String ? $util.base64.encode(message.oneTimeKeys[j], 0, message.oneTimeKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.oneTimeKeys[j]) : message.oneTimeKeys[j];
            }
            return object;
        };

        /**
         * Converts this WhisperKeys to JSON.
         * @function toJSON
         * @memberof server.WhisperKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Action enum.
         * @name server.WhisperKeys.Action
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} ADD=1 ADD value
         * @property {number} COUNT=2 COUNT value
         * @property {number} GET=3 GET value
         * @property {number} SET=4 SET value
         * @property {number} UPDATE=5 UPDATE value
         */
        WhisperKeys.Action = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "ADD"] = 1;
            values[valuesById[2] = "COUNT"] = 2;
            values[valuesById[3] = "GET"] = 3;
            values[valuesById[4] = "SET"] = 4;
            values[valuesById[5] = "UPDATE"] = 5;
            return values;
        })();

        return WhisperKeys;
    })();

    server.TruncWhisperKeys = (function() {

        /**
         * Properties of a TruncWhisperKeys.
         * @memberof server
         * @interface ITruncWhisperKeys
         * @property {number|Long|null} [uid] TruncWhisperKeys uid
         * @property {Uint8Array|null} [truncPublicIdentityKey] TruncWhisperKeys truncPublicIdentityKey
         */

        /**
         * Constructs a new TruncWhisperKeys.
         * @memberof server
         * @classdesc Represents a TruncWhisperKeys.
         * @implements ITruncWhisperKeys
         * @constructor
         * @param {server.ITruncWhisperKeys=} [properties] Properties to set
         */
        function TruncWhisperKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TruncWhisperKeys uid.
         * @member {number|Long} uid
         * @memberof server.TruncWhisperKeys
         * @instance
         */
        TruncWhisperKeys.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TruncWhisperKeys truncPublicIdentityKey.
         * @member {Uint8Array} truncPublicIdentityKey
         * @memberof server.TruncWhisperKeys
         * @instance
         */
        TruncWhisperKeys.prototype.truncPublicIdentityKey = $util.newBuffer([]);

        /**
         * Creates a new TruncWhisperKeys instance using the specified properties.
         * @function create
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys=} [properties] Properties to set
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys instance
         */
        TruncWhisperKeys.create = function create(properties) {
            return new TruncWhisperKeys(properties);
        };

        /**
         * Encodes the specified TruncWhisperKeys message. Does not implicitly {@link server.TruncWhisperKeys.verify|verify} messages.
         * @function encode
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys} message TruncWhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.truncPublicIdentityKey != null && Object.hasOwnProperty.call(message, "truncPublicIdentityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.truncPublicIdentityKey);
            return writer;
        };

        /**
         * Encodes the specified TruncWhisperKeys message, length delimited. Does not implicitly {@link server.TruncWhisperKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.ITruncWhisperKeys} message TruncWhisperKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TruncWhisperKeys message from the specified reader or buffer.
         * @function decode
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TruncWhisperKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.truncPublicIdentityKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TruncWhisperKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TruncWhisperKeys message.
         * @function verify
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TruncWhisperKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.truncPublicIdentityKey != null && message.hasOwnProperty("truncPublicIdentityKey"))
                if (!(message.truncPublicIdentityKey && typeof message.truncPublicIdentityKey.length === "number" || $util.isString(message.truncPublicIdentityKey)))
                    return "truncPublicIdentityKey: buffer expected";
            return null;
        };

        /**
         * Creates a TruncWhisperKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TruncWhisperKeys} TruncWhisperKeys
         */
        TruncWhisperKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TruncWhisperKeys)
                return object;
            var message = new $root.server.TruncWhisperKeys();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.truncPublicIdentityKey != null)
                if (typeof object.truncPublicIdentityKey === "string")
                    $util.base64.decode(object.truncPublicIdentityKey, message.truncPublicIdentityKey = $util.newBuffer($util.base64.length(object.truncPublicIdentityKey)), 0);
                else if (object.truncPublicIdentityKey.length)
                    message.truncPublicIdentityKey = object.truncPublicIdentityKey;
            return message;
        };

        /**
         * Creates a plain object from a TruncWhisperKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TruncWhisperKeys
         * @static
         * @param {server.TruncWhisperKeys} message TruncWhisperKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TruncWhisperKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.truncPublicIdentityKey = "";
                else {
                    object.truncPublicIdentityKey = [];
                    if (options.bytes !== Array)
                        object.truncPublicIdentityKey = $util.newBuffer(object.truncPublicIdentityKey);
                }
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.truncPublicIdentityKey != null && message.hasOwnProperty("truncPublicIdentityKey"))
                object.truncPublicIdentityKey = options.bytes === String ? $util.base64.encode(message.truncPublicIdentityKey, 0, message.truncPublicIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.truncPublicIdentityKey) : message.truncPublicIdentityKey;
            return object;
        };

        /**
         * Converts this TruncWhisperKeys to JSON.
         * @function toJSON
         * @memberof server.TruncWhisperKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TruncWhisperKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TruncWhisperKeys;
    })();

    server.WhisperKeysCollection = (function() {

        /**
         * Properties of a WhisperKeysCollection.
         * @memberof server
         * @interface IWhisperKeysCollection
         * @property {Array.<server.IWhisperKeys>|null} [collection] WhisperKeysCollection collection
         */

        /**
         * Constructs a new WhisperKeysCollection.
         * @memberof server
         * @classdesc Represents a WhisperKeysCollection.
         * @implements IWhisperKeysCollection
         * @constructor
         * @param {server.IWhisperKeysCollection=} [properties] Properties to set
         */
        function WhisperKeysCollection(properties) {
            this.collection = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperKeysCollection collection.
         * @member {Array.<server.IWhisperKeys>} collection
         * @memberof server.WhisperKeysCollection
         * @instance
         */
        WhisperKeysCollection.prototype.collection = $util.emptyArray;

        /**
         * Creates a new WhisperKeysCollection instance using the specified properties.
         * @function create
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection=} [properties] Properties to set
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection instance
         */
        WhisperKeysCollection.create = function create(properties) {
            return new WhisperKeysCollection(properties);
        };

        /**
         * Encodes the specified WhisperKeysCollection message. Does not implicitly {@link server.WhisperKeysCollection.verify|verify} messages.
         * @function encode
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection} message WhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeysCollection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.collection != null && message.collection.length)
                for (var i = 0; i < message.collection.length; ++i)
                    $root.server.WhisperKeys.encode(message.collection[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WhisperKeysCollection message, length delimited. Does not implicitly {@link server.WhisperKeysCollection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.IWhisperKeysCollection} message WhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperKeysCollection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperKeysCollection message from the specified reader or buffer.
         * @function decode
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeysCollection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WhisperKeysCollection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.collection && message.collection.length))
                        message.collection = [];
                    message.collection.push($root.server.WhisperKeys.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperKeysCollection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperKeysCollection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperKeysCollection message.
         * @function verify
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperKeysCollection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.collection != null && message.hasOwnProperty("collection")) {
                if (!Array.isArray(message.collection))
                    return "collection: array expected";
                for (var i = 0; i < message.collection.length; ++i) {
                    var error = $root.server.WhisperKeys.verify(message.collection[i]);
                    if (error)
                        return "collection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WhisperKeysCollection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WhisperKeysCollection} WhisperKeysCollection
         */
        WhisperKeysCollection.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WhisperKeysCollection)
                return object;
            var message = new $root.server.WhisperKeysCollection();
            if (object.collection) {
                if (!Array.isArray(object.collection))
                    throw TypeError(".server.WhisperKeysCollection.collection: array expected");
                message.collection = [];
                for (var i = 0; i < object.collection.length; ++i) {
                    if (typeof object.collection[i] !== "object")
                        throw TypeError(".server.WhisperKeysCollection.collection: object expected");
                    message.collection[i] = $root.server.WhisperKeys.fromObject(object.collection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WhisperKeysCollection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WhisperKeysCollection
         * @static
         * @param {server.WhisperKeysCollection} message WhisperKeysCollection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperKeysCollection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.collection = [];
            if (message.collection && message.collection.length) {
                object.collection = [];
                for (var j = 0; j < message.collection.length; ++j)
                    object.collection[j] = $root.server.WhisperKeys.toObject(message.collection[j], options);
            }
            return object;
        };

        /**
         * Converts this WhisperKeysCollection to JSON.
         * @function toJSON
         * @memberof server.WhisperKeysCollection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperKeysCollection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WhisperKeysCollection;
    })();

    server.TruncWhisperKeysCollection = (function() {

        /**
         * Properties of a TruncWhisperKeysCollection.
         * @memberof server
         * @interface ITruncWhisperKeysCollection
         * @property {Array.<server.ITruncWhisperKeys>|null} [collection] TruncWhisperKeysCollection collection
         */

        /**
         * Constructs a new TruncWhisperKeysCollection.
         * @memberof server
         * @classdesc Represents a TruncWhisperKeysCollection.
         * @implements ITruncWhisperKeysCollection
         * @constructor
         * @param {server.ITruncWhisperKeysCollection=} [properties] Properties to set
         */
        function TruncWhisperKeysCollection(properties) {
            this.collection = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TruncWhisperKeysCollection collection.
         * @member {Array.<server.ITruncWhisperKeys>} collection
         * @memberof server.TruncWhisperKeysCollection
         * @instance
         */
        TruncWhisperKeysCollection.prototype.collection = $util.emptyArray;

        /**
         * Creates a new TruncWhisperKeysCollection instance using the specified properties.
         * @function create
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection=} [properties] Properties to set
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection instance
         */
        TruncWhisperKeysCollection.create = function create(properties) {
            return new TruncWhisperKeysCollection(properties);
        };

        /**
         * Encodes the specified TruncWhisperKeysCollection message. Does not implicitly {@link server.TruncWhisperKeysCollection.verify|verify} messages.
         * @function encode
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection} message TruncWhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeysCollection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.collection != null && message.collection.length)
                for (var i = 0; i < message.collection.length; ++i)
                    $root.server.TruncWhisperKeys.encode(message.collection[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TruncWhisperKeysCollection message, length delimited. Does not implicitly {@link server.TruncWhisperKeysCollection.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.ITruncWhisperKeysCollection} message TruncWhisperKeysCollection message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TruncWhisperKeysCollection.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TruncWhisperKeysCollection message from the specified reader or buffer.
         * @function decode
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeysCollection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.TruncWhisperKeysCollection();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.collection && message.collection.length))
                        message.collection = [];
                    message.collection.push($root.server.TruncWhisperKeys.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TruncWhisperKeysCollection message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TruncWhisperKeysCollection.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TruncWhisperKeysCollection message.
         * @function verify
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TruncWhisperKeysCollection.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.collection != null && message.hasOwnProperty("collection")) {
                if (!Array.isArray(message.collection))
                    return "collection: array expected";
                for (var i = 0; i < message.collection.length; ++i) {
                    var error = $root.server.TruncWhisperKeys.verify(message.collection[i]);
                    if (error)
                        return "collection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TruncWhisperKeysCollection message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.TruncWhisperKeysCollection} TruncWhisperKeysCollection
         */
        TruncWhisperKeysCollection.fromObject = function fromObject(object) {
            if (object instanceof $root.server.TruncWhisperKeysCollection)
                return object;
            var message = new $root.server.TruncWhisperKeysCollection();
            if (object.collection) {
                if (!Array.isArray(object.collection))
                    throw TypeError(".server.TruncWhisperKeysCollection.collection: array expected");
                message.collection = [];
                for (var i = 0; i < object.collection.length; ++i) {
                    if (typeof object.collection[i] !== "object")
                        throw TypeError(".server.TruncWhisperKeysCollection.collection: object expected");
                    message.collection[i] = $root.server.TruncWhisperKeys.fromObject(object.collection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TruncWhisperKeysCollection message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.TruncWhisperKeysCollection
         * @static
         * @param {server.TruncWhisperKeysCollection} message TruncWhisperKeysCollection
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TruncWhisperKeysCollection.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.collection = [];
            if (message.collection && message.collection.length) {
                object.collection = [];
                for (var j = 0; j < message.collection.length; ++j)
                    object.collection[j] = $root.server.TruncWhisperKeys.toObject(message.collection[j], options);
            }
            return object;
        };

        /**
         * Converts this TruncWhisperKeysCollection to JSON.
         * @function toJSON
         * @memberof server.TruncWhisperKeysCollection
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TruncWhisperKeysCollection.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TruncWhisperKeysCollection;
    })();

    server.NoiseMessage = (function() {

        /**
         * Properties of a NoiseMessage.
         * @memberof server
         * @interface INoiseMessage
         * @property {server.NoiseMessage.MessageType|null} [messageType] NoiseMessage messageType
         * @property {Uint8Array|null} [content] NoiseMessage content
         */

        /**
         * Constructs a new NoiseMessage.
         * @memberof server
         * @classdesc Represents a NoiseMessage.
         * @implements INoiseMessage
         * @constructor
         * @param {server.INoiseMessage=} [properties] Properties to set
         */
        function NoiseMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoiseMessage messageType.
         * @member {server.NoiseMessage.MessageType} messageType
         * @memberof server.NoiseMessage
         * @instance
         */
        NoiseMessage.prototype.messageType = 0;

        /**
         * NoiseMessage content.
         * @member {Uint8Array} content
         * @memberof server.NoiseMessage
         * @instance
         */
        NoiseMessage.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new NoiseMessage instance using the specified properties.
         * @function create
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage=} [properties] Properties to set
         * @returns {server.NoiseMessage} NoiseMessage instance
         */
        NoiseMessage.create = function create(properties) {
            return new NoiseMessage(properties);
        };

        /**
         * Encodes the specified NoiseMessage message. Does not implicitly {@link server.NoiseMessage.verify|verify} messages.
         * @function encode
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage} message NoiseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && Object.hasOwnProperty.call(message, "messageType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified NoiseMessage message, length delimited. Does not implicitly {@link server.NoiseMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.NoiseMessage
         * @static
         * @param {server.INoiseMessage} message NoiseMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoiseMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoiseMessage message from the specified reader or buffer.
         * @function decode
         * @memberof server.NoiseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.NoiseMessage} NoiseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.NoiseMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.int32();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoiseMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.NoiseMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.NoiseMessage} NoiseMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoiseMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoiseMessage message.
         * @function verify
         * @memberof server.NoiseMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoiseMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                switch (message.messageType) {
                default:
                    return "messageType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a NoiseMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.NoiseMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.NoiseMessage} NoiseMessage
         */
        NoiseMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.server.NoiseMessage)
                return object;
            var message = new $root.server.NoiseMessage();
            switch (object.messageType) {
            case "XX_A":
            case 0:
                message.messageType = 0;
                break;
            case "XX_B":
            case 1:
                message.messageType = 1;
                break;
            case "XX_C":
            case 2:
                message.messageType = 2;
                break;
            case "IK_A":
            case 3:
                message.messageType = 3;
                break;
            case "IK_B":
            case 4:
                message.messageType = 4;
                break;
            case "XX_FALLBACK_A":
            case 5:
                message.messageType = 5;
                break;
            case "XX_FALLBACK_B":
            case 6:
                message.messageType = 6;
                break;
            }
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a NoiseMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.NoiseMessage
         * @static
         * @param {server.NoiseMessage} message NoiseMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoiseMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.messageType = options.enums === String ? "XX_A" : 0;
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = options.enums === String ? $root.server.NoiseMessage.MessageType[message.messageType] : message.messageType;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this NoiseMessage to JSON.
         * @function toJSON
         * @memberof server.NoiseMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoiseMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * MessageType enum.
         * @name server.NoiseMessage.MessageType
         * @enum {number}
         * @property {number} XX_A=0 XX_A value
         * @property {number} XX_B=1 XX_B value
         * @property {number} XX_C=2 XX_C value
         * @property {number} IK_A=3 IK_A value
         * @property {number} IK_B=4 IK_B value
         * @property {number} XX_FALLBACK_A=5 XX_FALLBACK_A value
         * @property {number} XX_FALLBACK_B=6 XX_FALLBACK_B value
         */
        NoiseMessage.MessageType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "XX_A"] = 0;
            values[valuesById[1] = "XX_B"] = 1;
            values[valuesById[2] = "XX_C"] = 2;
            values[valuesById[3] = "IK_A"] = 3;
            values[valuesById[4] = "IK_B"] = 4;
            values[valuesById[5] = "XX_FALLBACK_A"] = 5;
            values[valuesById[6] = "XX_FALLBACK_B"] = 6;
            return values;
        })();

        return NoiseMessage;
    })();

    server.DeleteAccount = (function() {

        /**
         * Properties of a DeleteAccount.
         * @memberof server
         * @interface IDeleteAccount
         * @property {string|null} [phone] DeleteAccount phone
         * @property {server.DeleteAccount.Reason|null} [reason] DeleteAccount reason
         * @property {string|null} [feedback] DeleteAccount feedback
         */

        /**
         * Constructs a new DeleteAccount.
         * @memberof server
         * @classdesc Represents a DeleteAccount.
         * @implements IDeleteAccount
         * @constructor
         * @param {server.IDeleteAccount=} [properties] Properties to set
         */
        function DeleteAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteAccount phone.
         * @member {string} phone
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.phone = "";

        /**
         * DeleteAccount reason.
         * @member {server.DeleteAccount.Reason} reason
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.reason = 0;

        /**
         * DeleteAccount feedback.
         * @member {string} feedback
         * @memberof server.DeleteAccount
         * @instance
         */
        DeleteAccount.prototype.feedback = "";

        /**
         * Creates a new DeleteAccount instance using the specified properties.
         * @function create
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount=} [properties] Properties to set
         * @returns {server.DeleteAccount} DeleteAccount instance
         */
        DeleteAccount.create = function create(properties) {
            return new DeleteAccount(properties);
        };

        /**
         * Encodes the specified DeleteAccount message. Does not implicitly {@link server.DeleteAccount.verify|verify} messages.
         * @function encode
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount} message DeleteAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            if (message.feedback != null && Object.hasOwnProperty.call(message, "feedback"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.feedback);
            return writer;
        };

        /**
         * Encodes the specified DeleteAccount message, length delimited. Does not implicitly {@link server.DeleteAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DeleteAccount
         * @static
         * @param {server.IDeleteAccount} message DeleteAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAccount message from the specified reader or buffer.
         * @function decode
         * @memberof server.DeleteAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DeleteAccount} DeleteAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DeleteAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.feedback = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DeleteAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DeleteAccount} DeleteAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAccount message.
         * @function verify
         * @memberof server.DeleteAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                    break;
                }
            if (message.feedback != null && message.hasOwnProperty("feedback"))
                if (!$util.isString(message.feedback))
                    return "feedback: string expected";
            return null;
        };

        /**
         * Creates a DeleteAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DeleteAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DeleteAccount} DeleteAccount
         */
        DeleteAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DeleteAccount)
                return object;
            var message = new $root.server.DeleteAccount();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.reason) {
            case "UNKNOWN_DELETE_REASON":
            case 0:
                message.reason = 0;
                break;
            }
            if (object.feedback != null)
                message.feedback = String(object.feedback);
            return message;
        };

        /**
         * Creates a plain object from a DeleteAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DeleteAccount
         * @static
         * @param {server.DeleteAccount} message DeleteAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.reason = options.enums === String ? "UNKNOWN_DELETE_REASON" : 0;
                object.feedback = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.DeleteAccount.Reason[message.reason] : message.reason;
            if (message.feedback != null && message.hasOwnProperty("feedback"))
                object.feedback = message.feedback;
            return object;
        };

        /**
         * Converts this DeleteAccount to JSON.
         * @function toJSON
         * @memberof server.DeleteAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Reason enum.
         * @name server.DeleteAccount.Reason
         * @enum {number}
         * @property {number} UNKNOWN_DELETE_REASON=0 UNKNOWN_DELETE_REASON value
         */
        DeleteAccount.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DELETE_REASON"] = 0;
            return values;
        })();

        return DeleteAccount;
    })();

    server.ExportData = (function() {

        /**
         * Properties of an ExportData.
         * @memberof server
         * @interface IExportData
         * @property {number|Long|null} [dataReadyTs] ExportData dataReadyTs
         * @property {server.ExportData.Status|null} [status] ExportData status
         * @property {string|null} [dataUrl] ExportData dataUrl
         * @property {number|Long|null} [availableUntilTs] ExportData availableUntilTs
         */

        /**
         * Constructs a new ExportData.
         * @memberof server
         * @classdesc Represents an ExportData.
         * @implements IExportData
         * @constructor
         * @param {server.IExportData=} [properties] Properties to set
         */
        function ExportData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExportData dataReadyTs.
         * @member {number|Long} dataReadyTs
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.dataReadyTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExportData status.
         * @member {server.ExportData.Status} status
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.status = 0;

        /**
         * ExportData dataUrl.
         * @member {string} dataUrl
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.dataUrl = "";

        /**
         * ExportData availableUntilTs.
         * @member {number|Long} availableUntilTs
         * @memberof server.ExportData
         * @instance
         */
        ExportData.prototype.availableUntilTs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExportData instance using the specified properties.
         * @function create
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData=} [properties] Properties to set
         * @returns {server.ExportData} ExportData instance
         */
        ExportData.create = function create(properties) {
            return new ExportData(properties);
        };

        /**
         * Encodes the specified ExportData message. Does not implicitly {@link server.ExportData.verify|verify} messages.
         * @function encode
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData} message ExportData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dataReadyTs != null && Object.hasOwnProperty.call(message, "dataReadyTs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dataReadyTs);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.dataUrl != null && Object.hasOwnProperty.call(message, "dataUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.dataUrl);
            if (message.availableUntilTs != null && Object.hasOwnProperty.call(message, "availableUntilTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.availableUntilTs);
            return writer;
        };

        /**
         * Encodes the specified ExportData message, length delimited. Does not implicitly {@link server.ExportData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ExportData
         * @static
         * @param {server.IExportData} message ExportData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportData message from the specified reader or buffer.
         * @function decode
         * @memberof server.ExportData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ExportData} ExportData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ExportData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dataReadyTs = reader.int64();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.dataUrl = reader.string();
                    break;
                case 4:
                    message.availableUntilTs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ExportData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ExportData} ExportData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportData message.
         * @function verify
         * @memberof server.ExportData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dataReadyTs != null && message.hasOwnProperty("dataReadyTs"))
                if (!$util.isInteger(message.dataReadyTs) && !(message.dataReadyTs && $util.isInteger(message.dataReadyTs.low) && $util.isInteger(message.dataReadyTs.high)))
                    return "dataReadyTs: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
                if (!$util.isString(message.dataUrl))
                    return "dataUrl: string expected";
            if (message.availableUntilTs != null && message.hasOwnProperty("availableUntilTs"))
                if (!$util.isInteger(message.availableUntilTs) && !(message.availableUntilTs && $util.isInteger(message.availableUntilTs.low) && $util.isInteger(message.availableUntilTs.high)))
                    return "availableUntilTs: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExportData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ExportData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ExportData} ExportData
         */
        ExportData.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ExportData)
                return object;
            var message = new $root.server.ExportData();
            if (object.dataReadyTs != null)
                if ($util.Long)
                    (message.dataReadyTs = $util.Long.fromValue(object.dataReadyTs)).unsigned = false;
                else if (typeof object.dataReadyTs === "string")
                    message.dataReadyTs = parseInt(object.dataReadyTs, 10);
                else if (typeof object.dataReadyTs === "number")
                    message.dataReadyTs = object.dataReadyTs;
                else if (typeof object.dataReadyTs === "object")
                    message.dataReadyTs = new $util.LongBits(object.dataReadyTs.low >>> 0, object.dataReadyTs.high >>> 0).toNumber();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "PENDING":
            case 1:
                message.status = 1;
                break;
            case "READY":
            case 2:
                message.status = 2;
                break;
            case "NOT_STARTED":
            case 3:
                message.status = 3;
                break;
            }
            if (object.dataUrl != null)
                message.dataUrl = String(object.dataUrl);
            if (object.availableUntilTs != null)
                if ($util.Long)
                    (message.availableUntilTs = $util.Long.fromValue(object.availableUntilTs)).unsigned = false;
                else if (typeof object.availableUntilTs === "string")
                    message.availableUntilTs = parseInt(object.availableUntilTs, 10);
                else if (typeof object.availableUntilTs === "number")
                    message.availableUntilTs = object.availableUntilTs;
                else if (typeof object.availableUntilTs === "object")
                    message.availableUntilTs = new $util.LongBits(object.availableUntilTs.low >>> 0, object.availableUntilTs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExportData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ExportData
         * @static
         * @param {server.ExportData} message ExportData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.dataReadyTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dataReadyTs = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.dataUrl = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.availableUntilTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.availableUntilTs = options.longs === String ? "0" : 0;
            }
            if (message.dataReadyTs != null && message.hasOwnProperty("dataReadyTs"))
                if (typeof message.dataReadyTs === "number")
                    object.dataReadyTs = options.longs === String ? String(message.dataReadyTs) : message.dataReadyTs;
                else
                    object.dataReadyTs = options.longs === String ? $util.Long.prototype.toString.call(message.dataReadyTs) : options.longs === Number ? new $util.LongBits(message.dataReadyTs.low >>> 0, message.dataReadyTs.high >>> 0).toNumber() : message.dataReadyTs;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.ExportData.Status[message.status] : message.status;
            if (message.dataUrl != null && message.hasOwnProperty("dataUrl"))
                object.dataUrl = message.dataUrl;
            if (message.availableUntilTs != null && message.hasOwnProperty("availableUntilTs"))
                if (typeof message.availableUntilTs === "number")
                    object.availableUntilTs = options.longs === String ? String(message.availableUntilTs) : message.availableUntilTs;
                else
                    object.availableUntilTs = options.longs === String ? $util.Long.prototype.toString.call(message.availableUntilTs) : options.longs === Number ? new $util.LongBits(message.availableUntilTs.low >>> 0, message.availableUntilTs.high >>> 0).toNumber() : message.availableUntilTs;
            return object;
        };

        /**
         * Converts this ExportData to JSON.
         * @function toJSON
         * @memberof server.ExportData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.ExportData.Status
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PENDING=1 PENDING value
         * @property {number} READY=2 READY value
         * @property {number} NOT_STARTED=3 NOT_STARTED value
         */
        ExportData.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "READY"] = 2;
            values[valuesById[3] = "NOT_STARTED"] = 3;
            return values;
        })();

        return ExportData;
    })();

    server.PushContent = (function() {

        /**
         * Properties of a PushContent.
         * @memberof server
         * @interface IPushContent
         * @property {Uint8Array|null} [certificate] PushContent certificate
         * @property {Uint8Array|null} [content] PushContent content
         */

        /**
         * Constructs a new PushContent.
         * @memberof server
         * @classdesc Represents a PushContent.
         * @implements IPushContent
         * @constructor
         * @param {server.IPushContent=} [properties] Properties to set
         */
        function PushContent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushContent certificate.
         * @member {Uint8Array} certificate
         * @memberof server.PushContent
         * @instance
         */
        PushContent.prototype.certificate = $util.newBuffer([]);

        /**
         * PushContent content.
         * @member {Uint8Array} content
         * @memberof server.PushContent
         * @instance
         */
        PushContent.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new PushContent instance using the specified properties.
         * @function create
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent=} [properties] Properties to set
         * @returns {server.PushContent} PushContent instance
         */
        PushContent.create = function create(properties) {
            return new PushContent(properties);
        };

        /**
         * Encodes the specified PushContent message. Does not implicitly {@link server.PushContent.verify|verify} messages.
         * @function encode
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent} message PushContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.certificate != null && Object.hasOwnProperty.call(message, "certificate"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified PushContent message, length delimited. Does not implicitly {@link server.PushContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushContent
         * @static
         * @param {server.IPushContent} message PushContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushContent message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushContent} PushContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushContent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.certificate = reader.bytes();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushContent} PushContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushContent message.
         * @function verify
         * @memberof server.PushContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                    return "certificate: buffer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a PushContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushContent} PushContent
         */
        PushContent.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushContent)
                return object;
            var message = new $root.server.PushContent();
            if (object.certificate != null)
                if (typeof object.certificate === "string")
                    $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                else if (object.certificate.length)
                    message.certificate = object.certificate;
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a PushContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushContent
         * @static
         * @param {server.PushContent} message PushContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.certificate = "";
                else {
                    object.certificate = [];
                    if (options.bytes !== Array)
                        object.certificate = $util.newBuffer(object.certificate);
                }
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this PushContent to JSON.
         * @function toJSON
         * @memberof server.PushContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushContent;
    })();

    server.InviteeNotice = (function() {

        /**
         * Properties of an InviteeNotice.
         * @memberof server
         * @interface IInviteeNotice
         * @property {Array.<server.IInviter>|null} [inviters] InviteeNotice inviters
         */

        /**
         * Constructs a new InviteeNotice.
         * @memberof server
         * @classdesc Represents an InviteeNotice.
         * @implements IInviteeNotice
         * @constructor
         * @param {server.IInviteeNotice=} [properties] Properties to set
         */
        function InviteeNotice(properties) {
            this.inviters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteeNotice inviters.
         * @member {Array.<server.IInviter>} inviters
         * @memberof server.InviteeNotice
         * @instance
         */
        InviteeNotice.prototype.inviters = $util.emptyArray;

        /**
         * Creates a new InviteeNotice instance using the specified properties.
         * @function create
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice=} [properties] Properties to set
         * @returns {server.InviteeNotice} InviteeNotice instance
         */
        InviteeNotice.create = function create(properties) {
            return new InviteeNotice(properties);
        };

        /**
         * Encodes the specified InviteeNotice message. Does not implicitly {@link server.InviteeNotice.verify|verify} messages.
         * @function encode
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice} message InviteeNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteeNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.inviters != null && message.inviters.length)
                for (var i = 0; i < message.inviters.length; ++i)
                    $root.server.Inviter.encode(message.inviters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InviteeNotice message, length delimited. Does not implicitly {@link server.InviteeNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.InviteeNotice
         * @static
         * @param {server.IInviteeNotice} message InviteeNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteeNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteeNotice message from the specified reader or buffer.
         * @function decode
         * @memberof server.InviteeNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.InviteeNotice} InviteeNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteeNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.InviteeNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.inviters && message.inviters.length))
                        message.inviters = [];
                    message.inviters.push($root.server.Inviter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteeNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.InviteeNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.InviteeNotice} InviteeNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteeNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteeNotice message.
         * @function verify
         * @memberof server.InviteeNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteeNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.inviters != null && message.hasOwnProperty("inviters")) {
                if (!Array.isArray(message.inviters))
                    return "inviters: array expected";
                for (var i = 0; i < message.inviters.length; ++i) {
                    var error = $root.server.Inviter.verify(message.inviters[i]);
                    if (error)
                        return "inviters." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InviteeNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.InviteeNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.InviteeNotice} InviteeNotice
         */
        InviteeNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.server.InviteeNotice)
                return object;
            var message = new $root.server.InviteeNotice();
            if (object.inviters) {
                if (!Array.isArray(object.inviters))
                    throw TypeError(".server.InviteeNotice.inviters: array expected");
                message.inviters = [];
                for (var i = 0; i < object.inviters.length; ++i) {
                    if (typeof object.inviters[i] !== "object")
                        throw TypeError(".server.InviteeNotice.inviters: object expected");
                    message.inviters[i] = $root.server.Inviter.fromObject(object.inviters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InviteeNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.InviteeNotice
         * @static
         * @param {server.InviteeNotice} message InviteeNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InviteeNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.inviters = [];
            if (message.inviters && message.inviters.length) {
                object.inviters = [];
                for (var j = 0; j < message.inviters.length; ++j)
                    object.inviters[j] = $root.server.Inviter.toObject(message.inviters[j], options);
            }
            return object;
        };

        /**
         * Converts this InviteeNotice to JSON.
         * @function toJSON
         * @memberof server.InviteeNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InviteeNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InviteeNotice;
    })();

    server.Inviter = (function() {

        /**
         * Properties of an Inviter.
         * @memberof server
         * @interface IInviter
         * @property {number|Long|null} [uid] Inviter uid
         * @property {string|null} [name] Inviter name
         * @property {string|null} [phone] Inviter phone
         * @property {number|Long|null} [timestamp] Inviter timestamp
         */

        /**
         * Constructs a new Inviter.
         * @memberof server
         * @classdesc Represents an Inviter.
         * @implements IInviter
         * @constructor
         * @param {server.IInviter=} [properties] Properties to set
         */
        function Inviter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Inviter uid.
         * @member {number|Long} uid
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Inviter name.
         * @member {string} name
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.name = "";

        /**
         * Inviter phone.
         * @member {string} phone
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.phone = "";

        /**
         * Inviter timestamp.
         * @member {number|Long} timestamp
         * @memberof server.Inviter
         * @instance
         */
        Inviter.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Inviter instance using the specified properties.
         * @function create
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter=} [properties] Properties to set
         * @returns {server.Inviter} Inviter instance
         */
        Inviter.create = function create(properties) {
            return new Inviter(properties);
        };

        /**
         * Encodes the specified Inviter message. Does not implicitly {@link server.Inviter.verify|verify} messages.
         * @function encode
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter} message Inviter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inviter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.phone);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Inviter message, length delimited. Does not implicitly {@link server.Inviter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Inviter
         * @static
         * @param {server.IInviter} message Inviter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inviter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Inviter message from the specified reader or buffer.
         * @function decode
         * @memberof server.Inviter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Inviter} Inviter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inviter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Inviter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.phone = reader.string();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Inviter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Inviter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Inviter} Inviter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inviter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Inviter message.
         * @function verify
         * @memberof server.Inviter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Inviter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates an Inviter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Inviter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Inviter} Inviter
         */
        Inviter.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Inviter)
                return object;
            var message = new $root.server.Inviter();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Inviter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Inviter
         * @static
         * @param {server.Inviter} message Inviter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Inviter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.phone = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Inviter to JSON.
         * @function toJSON
         * @memberof server.Inviter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Inviter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Inviter;
    })();

    server.IdentityKey = (function() {

        /**
         * Properties of an IdentityKey.
         * @memberof server
         * @interface IIdentityKey
         * @property {Uint8Array|null} [publicKey] IdentityKey publicKey
         */

        /**
         * Constructs a new IdentityKey.
         * @memberof server
         * @classdesc Represents an IdentityKey.
         * @implements IIdentityKey
         * @constructor
         * @param {server.IIdentityKey=} [properties] Properties to set
         */
        function IdentityKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof server.IdentityKey
         * @instance
         */
        IdentityKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityKey instance using the specified properties.
         * @function create
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey=} [properties] Properties to set
         * @returns {server.IdentityKey} IdentityKey instance
         */
        IdentityKey.create = function create(properties) {
            return new IdentityKey(properties);
        };

        /**
         * Encodes the specified IdentityKey message. Does not implicitly {@link server.IdentityKey.verify|verify} messages.
         * @function encode
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey} message IdentityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityKey message, length delimited. Does not implicitly {@link server.IdentityKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.IdentityKey
         * @static
         * @param {server.IIdentityKey} message IdentityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKey message from the specified reader or buffer.
         * @function decode
         * @memberof server.IdentityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.IdentityKey} IdentityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.IdentityKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.IdentityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.IdentityKey} IdentityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKey message.
         * @function verify
         * @memberof server.IdentityKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.IdentityKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.IdentityKey} IdentityKey
         */
        IdentityKey.fromObject = function fromObject(object) {
            if (object instanceof $root.server.IdentityKey)
                return object;
            var message = new $root.server.IdentityKey();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.IdentityKey
         * @static
         * @param {server.IdentityKey} message IdentityKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };

        /**
         * Converts this IdentityKey to JSON.
         * @function toJSON
         * @memberof server.IdentityKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKey;
    })();

    server.RequestLogs = (function() {

        /**
         * Properties of a RequestLogs.
         * @memberof server
         * @interface IRequestLogs
         * @property {number|Long|null} [timestamp] RequestLogs timestamp
         */

        /**
         * Constructs a new RequestLogs.
         * @memberof server
         * @classdesc Represents a RequestLogs.
         * @implements IRequestLogs
         * @constructor
         * @param {server.IRequestLogs=} [properties] Properties to set
         */
        function RequestLogs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestLogs timestamp.
         * @member {number|Long} timestamp
         * @memberof server.RequestLogs
         * @instance
         */
        RequestLogs.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RequestLogs instance using the specified properties.
         * @function create
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs=} [properties] Properties to set
         * @returns {server.RequestLogs} RequestLogs instance
         */
        RequestLogs.create = function create(properties) {
            return new RequestLogs(properties);
        };

        /**
         * Encodes the specified RequestLogs message. Does not implicitly {@link server.RequestLogs.verify|verify} messages.
         * @function encode
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs} message RequestLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLogs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified RequestLogs message, length delimited. Does not implicitly {@link server.RequestLogs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RequestLogs
         * @static
         * @param {server.IRequestLogs} message RequestLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLogs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestLogs message from the specified reader or buffer.
         * @function decode
         * @memberof server.RequestLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RequestLogs} RequestLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLogs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RequestLogs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestLogs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RequestLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RequestLogs} RequestLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLogs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestLogs message.
         * @function verify
         * @memberof server.RequestLogs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestLogs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a RequestLogs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RequestLogs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RequestLogs} RequestLogs
         */
        RequestLogs.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RequestLogs)
                return object;
            var message = new $root.server.RequestLogs();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RequestLogs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RequestLogs
         * @static
         * @param {server.RequestLogs} message RequestLogs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestLogs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this RequestLogs to JSON.
         * @function toJSON
         * @memberof server.RequestLogs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestLogs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestLogs;
    })();

    server.RegisterRequest = (function() {

        /**
         * Properties of a RegisterRequest.
         * @memberof server
         * @interface IRegisterRequest
         * @property {server.IOtpRequest|null} [otpRequest] RegisterRequest otpRequest
         * @property {server.IVerifyOtpRequest|null} [verifyRequest] RegisterRequest verifyRequest
         * @property {server.IHashcashRequest|null} [hashcashRequest] RegisterRequest hashcashRequest
         */

        /**
         * Constructs a new RegisterRequest.
         * @memberof server
         * @classdesc Represents a RegisterRequest.
         * @implements IRegisterRequest
         * @constructor
         * @param {server.IRegisterRequest=} [properties] Properties to set
         */
        function RegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterRequest otpRequest.
         * @member {server.IOtpRequest|null|undefined} otpRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.otpRequest = null;

        /**
         * RegisterRequest verifyRequest.
         * @member {server.IVerifyOtpRequest|null|undefined} verifyRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.verifyRequest = null;

        /**
         * RegisterRequest hashcashRequest.
         * @member {server.IHashcashRequest|null|undefined} hashcashRequest
         * @memberof server.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.hashcashRequest = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * RegisterRequest request.
         * @member {"otpRequest"|"verifyRequest"|"hashcashRequest"|undefined} request
         * @memberof server.RegisterRequest
         * @instance
         */
        Object.defineProperty(RegisterRequest.prototype, "request", {
            get: $util.oneOfGetter($oneOfFields = ["otpRequest", "verifyRequest", "hashcashRequest"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RegisterRequest instance using the specified properties.
         * @function create
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest=} [properties] Properties to set
         * @returns {server.RegisterRequest} RegisterRequest instance
         */
        RegisterRequest.create = function create(properties) {
            return new RegisterRequest(properties);
        };

        /**
         * Encodes the specified RegisterRequest message. Does not implicitly {@link server.RegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.otpRequest != null && Object.hasOwnProperty.call(message, "otpRequest"))
                $root.server.OtpRequest.encode(message.otpRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.verifyRequest != null && Object.hasOwnProperty.call(message, "verifyRequest"))
                $root.server.VerifyOtpRequest.encode(message.verifyRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hashcashRequest != null && Object.hasOwnProperty.call(message, "hashcashRequest"))
                $root.server.HashcashRequest.encode(message.hashcashRequest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterRequest message, length delimited. Does not implicitly {@link server.RegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RegisterRequest
         * @static
         * @param {server.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.otpRequest = $root.server.OtpRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.verifyRequest = $root.server.VerifyOtpRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hashcashRequest = $root.server.HashcashRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterRequest message.
         * @function verify
         * @memberof server.RegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.otpRequest != null && message.hasOwnProperty("otpRequest")) {
                properties.request = 1;
                {
                    var error = $root.server.OtpRequest.verify(message.otpRequest);
                    if (error)
                        return "otpRequest." + error;
                }
            }
            if (message.verifyRequest != null && message.hasOwnProperty("verifyRequest")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                {
                    var error = $root.server.VerifyOtpRequest.verify(message.verifyRequest);
                    if (error)
                        return "verifyRequest." + error;
                }
            }
            if (message.hashcashRequest != null && message.hasOwnProperty("hashcashRequest")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                {
                    var error = $root.server.HashcashRequest.verify(message.hashcashRequest);
                    if (error)
                        return "hashcashRequest." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RegisterRequest} RegisterRequest
         */
        RegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RegisterRequest)
                return object;
            var message = new $root.server.RegisterRequest();
            if (object.otpRequest != null) {
                if (typeof object.otpRequest !== "object")
                    throw TypeError(".server.RegisterRequest.otpRequest: object expected");
                message.otpRequest = $root.server.OtpRequest.fromObject(object.otpRequest);
            }
            if (object.verifyRequest != null) {
                if (typeof object.verifyRequest !== "object")
                    throw TypeError(".server.RegisterRequest.verifyRequest: object expected");
                message.verifyRequest = $root.server.VerifyOtpRequest.fromObject(object.verifyRequest);
            }
            if (object.hashcashRequest != null) {
                if (typeof object.hashcashRequest !== "object")
                    throw TypeError(".server.RegisterRequest.hashcashRequest: object expected");
                message.hashcashRequest = $root.server.HashcashRequest.fromObject(object.hashcashRequest);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RegisterRequest
         * @static
         * @param {server.RegisterRequest} message RegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.otpRequest != null && message.hasOwnProperty("otpRequest")) {
                object.otpRequest = $root.server.OtpRequest.toObject(message.otpRequest, options);
                if (options.oneofs)
                    object.request = "otpRequest";
            }
            if (message.verifyRequest != null && message.hasOwnProperty("verifyRequest")) {
                object.verifyRequest = $root.server.VerifyOtpRequest.toObject(message.verifyRequest, options);
                if (options.oneofs)
                    object.request = "verifyRequest";
            }
            if (message.hashcashRequest != null && message.hasOwnProperty("hashcashRequest")) {
                object.hashcashRequest = $root.server.HashcashRequest.toObject(message.hashcashRequest, options);
                if (options.oneofs)
                    object.request = "hashcashRequest";
            }
            return object;
        };

        /**
         * Converts this RegisterRequest to JSON.
         * @function toJSON
         * @memberof server.RegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterRequest;
    })();

    server.RegisterResponse = (function() {

        /**
         * Properties of a RegisterResponse.
         * @memberof server
         * @interface IRegisterResponse
         * @property {server.IOtpResponse|null} [otpResponse] RegisterResponse otpResponse
         * @property {server.IVerifyOtpResponse|null} [verifyResponse] RegisterResponse verifyResponse
         * @property {server.IHashcashResponse|null} [hashcashResponse] RegisterResponse hashcashResponse
         */

        /**
         * Constructs a new RegisterResponse.
         * @memberof server
         * @classdesc Represents a RegisterResponse.
         * @implements IRegisterResponse
         * @constructor
         * @param {server.IRegisterResponse=} [properties] Properties to set
         */
        function RegisterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterResponse otpResponse.
         * @member {server.IOtpResponse|null|undefined} otpResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.otpResponse = null;

        /**
         * RegisterResponse verifyResponse.
         * @member {server.IVerifyOtpResponse|null|undefined} verifyResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.verifyResponse = null;

        /**
         * RegisterResponse hashcashResponse.
         * @member {server.IHashcashResponse|null|undefined} hashcashResponse
         * @memberof server.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.hashcashResponse = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * RegisterResponse response.
         * @member {"otpResponse"|"verifyResponse"|"hashcashResponse"|undefined} response
         * @memberof server.RegisterResponse
         * @instance
         */
        Object.defineProperty(RegisterResponse.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["otpResponse", "verifyResponse", "hashcashResponse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RegisterResponse instance using the specified properties.
         * @function create
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse=} [properties] Properties to set
         * @returns {server.RegisterResponse} RegisterResponse instance
         */
        RegisterResponse.create = function create(properties) {
            return new RegisterResponse(properties);
        };

        /**
         * Encodes the specified RegisterResponse message. Does not implicitly {@link server.RegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.otpResponse != null && Object.hasOwnProperty.call(message, "otpResponse"))
                $root.server.OtpResponse.encode(message.otpResponse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.verifyResponse != null && Object.hasOwnProperty.call(message, "verifyResponse"))
                $root.server.VerifyOtpResponse.encode(message.verifyResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hashcashResponse != null && Object.hasOwnProperty.call(message, "hashcashResponse"))
                $root.server.HashcashResponse.encode(message.hashcashResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterResponse message, length delimited. Does not implicitly {@link server.RegisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.RegisterResponse
         * @static
         * @param {server.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.RegisterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.otpResponse = $root.server.OtpResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.verifyResponse = $root.server.VerifyOtpResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hashcashResponse = $root.server.HashcashResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterResponse message.
         * @function verify
         * @memberof server.RegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.otpResponse != null && message.hasOwnProperty("otpResponse")) {
                properties.response = 1;
                {
                    var error = $root.server.OtpResponse.verify(message.otpResponse);
                    if (error)
                        return "otpResponse." + error;
                }
            }
            if (message.verifyResponse != null && message.hasOwnProperty("verifyResponse")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                {
                    var error = $root.server.VerifyOtpResponse.verify(message.verifyResponse);
                    if (error)
                        return "verifyResponse." + error;
                }
            }
            if (message.hashcashResponse != null && message.hasOwnProperty("hashcashResponse")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                {
                    var error = $root.server.HashcashResponse.verify(message.hashcashResponse);
                    if (error)
                        return "hashcashResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.RegisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.RegisterResponse} RegisterResponse
         */
        RegisterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.RegisterResponse)
                return object;
            var message = new $root.server.RegisterResponse();
            if (object.otpResponse != null) {
                if (typeof object.otpResponse !== "object")
                    throw TypeError(".server.RegisterResponse.otpResponse: object expected");
                message.otpResponse = $root.server.OtpResponse.fromObject(object.otpResponse);
            }
            if (object.verifyResponse != null) {
                if (typeof object.verifyResponse !== "object")
                    throw TypeError(".server.RegisterResponse.verifyResponse: object expected");
                message.verifyResponse = $root.server.VerifyOtpResponse.fromObject(object.verifyResponse);
            }
            if (object.hashcashResponse != null) {
                if (typeof object.hashcashResponse !== "object")
                    throw TypeError(".server.RegisterResponse.hashcashResponse: object expected");
                message.hashcashResponse = $root.server.HashcashResponse.fromObject(object.hashcashResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.RegisterResponse
         * @static
         * @param {server.RegisterResponse} message RegisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.otpResponse != null && message.hasOwnProperty("otpResponse")) {
                object.otpResponse = $root.server.OtpResponse.toObject(message.otpResponse, options);
                if (options.oneofs)
                    object.response = "otpResponse";
            }
            if (message.verifyResponse != null && message.hasOwnProperty("verifyResponse")) {
                object.verifyResponse = $root.server.VerifyOtpResponse.toObject(message.verifyResponse, options);
                if (options.oneofs)
                    object.response = "verifyResponse";
            }
            if (message.hashcashResponse != null && message.hasOwnProperty("hashcashResponse")) {
                object.hashcashResponse = $root.server.HashcashResponse.toObject(message.hashcashResponse, options);
                if (options.oneofs)
                    object.response = "hashcashResponse";
            }
            return object;
        };

        /**
         * Converts this RegisterResponse to JSON.
         * @function toJSON
         * @memberof server.RegisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterResponse;
    })();

    server.HashcashRequest = (function() {

        /**
         * Properties of a HashcashRequest.
         * @memberof server
         * @interface IHashcashRequest
         * @property {string|null} [countryCode] HashcashRequest countryCode
         */

        /**
         * Constructs a new HashcashRequest.
         * @memberof server
         * @classdesc Represents a HashcashRequest.
         * @implements IHashcashRequest
         * @constructor
         * @param {server.IHashcashRequest=} [properties] Properties to set
         */
        function HashcashRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashcashRequest countryCode.
         * @member {string} countryCode
         * @memberof server.HashcashRequest
         * @instance
         */
        HashcashRequest.prototype.countryCode = "";

        /**
         * Creates a new HashcashRequest instance using the specified properties.
         * @function create
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest=} [properties] Properties to set
         * @returns {server.HashcashRequest} HashcashRequest instance
         */
        HashcashRequest.create = function create(properties) {
            return new HashcashRequest(properties);
        };

        /**
         * Encodes the specified HashcashRequest message. Does not implicitly {@link server.HashcashRequest.verify|verify} messages.
         * @function encode
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest} message HashcashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.countryCode);
            return writer;
        };

        /**
         * Encodes the specified HashcashRequest message, length delimited. Does not implicitly {@link server.HashcashRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HashcashRequest
         * @static
         * @param {server.IHashcashRequest} message HashcashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashcashRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.HashcashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HashcashRequest} HashcashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HashcashRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.countryCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashcashRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HashcashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HashcashRequest} HashcashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashcashRequest message.
         * @function verify
         * @memberof server.HashcashRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashcashRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isString(message.countryCode))
                    return "countryCode: string expected";
            return null;
        };

        /**
         * Creates a HashcashRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HashcashRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HashcashRequest} HashcashRequest
         */
        HashcashRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HashcashRequest)
                return object;
            var message = new $root.server.HashcashRequest();
            if (object.countryCode != null)
                message.countryCode = String(object.countryCode);
            return message;
        };

        /**
         * Creates a plain object from a HashcashRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HashcashRequest
         * @static
         * @param {server.HashcashRequest} message HashcashRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashcashRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.countryCode = "";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            return object;
        };

        /**
         * Converts this HashcashRequest to JSON.
         * @function toJSON
         * @memberof server.HashcashRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashcashRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashcashRequest;
    })();

    server.HashcashResponse = (function() {

        /**
         * Properties of a HashcashResponse.
         * @memberof server
         * @interface IHashcashResponse
         * @property {string|null} [hashcashChallenge] HashcashResponse hashcashChallenge
         */

        /**
         * Constructs a new HashcashResponse.
         * @memberof server
         * @classdesc Represents a HashcashResponse.
         * @implements IHashcashResponse
         * @constructor
         * @param {server.IHashcashResponse=} [properties] Properties to set
         */
        function HashcashResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashcashResponse hashcashChallenge.
         * @member {string} hashcashChallenge
         * @memberof server.HashcashResponse
         * @instance
         */
        HashcashResponse.prototype.hashcashChallenge = "";

        /**
         * Creates a new HashcashResponse instance using the specified properties.
         * @function create
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse=} [properties] Properties to set
         * @returns {server.HashcashResponse} HashcashResponse instance
         */
        HashcashResponse.create = function create(properties) {
            return new HashcashResponse(properties);
        };

        /**
         * Encodes the specified HashcashResponse message. Does not implicitly {@link server.HashcashResponse.verify|verify} messages.
         * @function encode
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse} message HashcashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashcashChallenge != null && Object.hasOwnProperty.call(message, "hashcashChallenge"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hashcashChallenge);
            return writer;
        };

        /**
         * Encodes the specified HashcashResponse message, length delimited. Does not implicitly {@link server.HashcashResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.HashcashResponse
         * @static
         * @param {server.IHashcashResponse} message HashcashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashcashResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashcashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.HashcashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.HashcashResponse} HashcashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.HashcashResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashcashChallenge = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashcashResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.HashcashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.HashcashResponse} HashcashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashcashResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashcashResponse message.
         * @function verify
         * @memberof server.HashcashResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashcashResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashcashChallenge != null && message.hasOwnProperty("hashcashChallenge"))
                if (!$util.isString(message.hashcashChallenge))
                    return "hashcashChallenge: string expected";
            return null;
        };

        /**
         * Creates a HashcashResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.HashcashResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.HashcashResponse} HashcashResponse
         */
        HashcashResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.HashcashResponse)
                return object;
            var message = new $root.server.HashcashResponse();
            if (object.hashcashChallenge != null)
                message.hashcashChallenge = String(object.hashcashChallenge);
            return message;
        };

        /**
         * Creates a plain object from a HashcashResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.HashcashResponse
         * @static
         * @param {server.HashcashResponse} message HashcashResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashcashResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.hashcashChallenge = "";
            if (message.hashcashChallenge != null && message.hasOwnProperty("hashcashChallenge"))
                object.hashcashChallenge = message.hashcashChallenge;
            return object;
        };

        /**
         * Converts this HashcashResponse to JSON.
         * @function toJSON
         * @memberof server.HashcashResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashcashResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashcashResponse;
    })();

    server.OtpRequest = (function() {

        /**
         * Properties of an OtpRequest.
         * @memberof server
         * @interface IOtpRequest
         * @property {string|null} [phone] OtpRequest phone
         * @property {server.OtpRequest.Method|null} [method] OtpRequest method
         * @property {string|null} [langId] OtpRequest langId
         * @property {string|null} [groupInviteToken] OtpRequest groupInviteToken
         * @property {string|null} [userAgent] OtpRequest userAgent
         * @property {string|null} [hashcashSolution] OtpRequest hashcashSolution
         * @property {number|Long|null} [hashcashSolutionTimeTakenMs] OtpRequest hashcashSolutionTimeTakenMs
         */

        /**
         * Constructs a new OtpRequest.
         * @memberof server
         * @classdesc Represents an OtpRequest.
         * @implements IOtpRequest
         * @constructor
         * @param {server.IOtpRequest=} [properties] Properties to set
         */
        function OtpRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OtpRequest phone.
         * @member {string} phone
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.phone = "";

        /**
         * OtpRequest method.
         * @member {server.OtpRequest.Method} method
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.method = 0;

        /**
         * OtpRequest langId.
         * @member {string} langId
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.langId = "";

        /**
         * OtpRequest groupInviteToken.
         * @member {string} groupInviteToken
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.groupInviteToken = "";

        /**
         * OtpRequest userAgent.
         * @member {string} userAgent
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.userAgent = "";

        /**
         * OtpRequest hashcashSolution.
         * @member {string} hashcashSolution
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.hashcashSolution = "";

        /**
         * OtpRequest hashcashSolutionTimeTakenMs.
         * @member {number|Long} hashcashSolutionTimeTakenMs
         * @memberof server.OtpRequest
         * @instance
         */
        OtpRequest.prototype.hashcashSolutionTimeTakenMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OtpRequest instance using the specified properties.
         * @function create
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest=} [properties] Properties to set
         * @returns {server.OtpRequest} OtpRequest instance
         */
        OtpRequest.create = function create(properties) {
            return new OtpRequest(properties);
        };

        /**
         * Encodes the specified OtpRequest message. Does not implicitly {@link server.OtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest} message OtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
            if (message.langId != null && Object.hasOwnProperty.call(message, "langId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.langId);
            if (message.groupInviteToken != null && Object.hasOwnProperty.call(message, "groupInviteToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupInviteToken);
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.userAgent);
            if (message.hashcashSolution != null && Object.hasOwnProperty.call(message, "hashcashSolution"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.hashcashSolution);
            if (message.hashcashSolutionTimeTakenMs != null && Object.hasOwnProperty.call(message, "hashcashSolutionTimeTakenMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.hashcashSolutionTimeTakenMs);
            return writer;
        };

        /**
         * Encodes the specified OtpRequest message, length delimited. Does not implicitly {@link server.OtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OtpRequest
         * @static
         * @param {server.IOtpRequest} message OtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.OtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OtpRequest} OtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                case 3:
                    message.langId = reader.string();
                    break;
                case 4:
                    message.groupInviteToken = reader.string();
                    break;
                case 5:
                    message.userAgent = reader.string();
                    break;
                case 6:
                    message.hashcashSolution = reader.string();
                    break;
                case 7:
                    message.hashcashSolutionTimeTakenMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OtpRequest} OtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OtpRequest message.
         * @function verify
         * @memberof server.OtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.langId != null && message.hasOwnProperty("langId"))
                if (!$util.isString(message.langId))
                    return "langId: string expected";
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                if (!$util.isString(message.groupInviteToken))
                    return "groupInviteToken: string expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                if (!$util.isString(message.hashcashSolution))
                    return "hashcashSolution: string expected";
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (!$util.isInteger(message.hashcashSolutionTimeTakenMs) && !(message.hashcashSolutionTimeTakenMs && $util.isInteger(message.hashcashSolutionTimeTakenMs.low) && $util.isInteger(message.hashcashSolutionTimeTakenMs.high)))
                    return "hashcashSolutionTimeTakenMs: integer|Long expected";
            return null;
        };

        /**
         * Creates an OtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OtpRequest} OtpRequest
         */
        OtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OtpRequest)
                return object;
            var message = new $root.server.OtpRequest();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.method) {
            case "SMS":
            case 0:
                message.method = 0;
                break;
            case "VOICE_CALL":
            case 1:
                message.method = 1;
                break;
            }
            if (object.langId != null)
                message.langId = String(object.langId);
            if (object.groupInviteToken != null)
                message.groupInviteToken = String(object.groupInviteToken);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.hashcashSolution != null)
                message.hashcashSolution = String(object.hashcashSolution);
            if (object.hashcashSolutionTimeTakenMs != null)
                if ($util.Long)
                    (message.hashcashSolutionTimeTakenMs = $util.Long.fromValue(object.hashcashSolutionTimeTakenMs)).unsigned = false;
                else if (typeof object.hashcashSolutionTimeTakenMs === "string")
                    message.hashcashSolutionTimeTakenMs = parseInt(object.hashcashSolutionTimeTakenMs, 10);
                else if (typeof object.hashcashSolutionTimeTakenMs === "number")
                    message.hashcashSolutionTimeTakenMs = object.hashcashSolutionTimeTakenMs;
                else if (typeof object.hashcashSolutionTimeTakenMs === "object")
                    message.hashcashSolutionTimeTakenMs = new $util.LongBits(object.hashcashSolutionTimeTakenMs.low >>> 0, object.hashcashSolutionTimeTakenMs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OtpRequest
         * @static
         * @param {server.OtpRequest} message OtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.method = options.enums === String ? "SMS" : 0;
                object.langId = "";
                object.groupInviteToken = "";
                object.userAgent = "";
                object.hashcashSolution = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? "0" : 0;
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.server.OtpRequest.Method[message.method] : message.method;
            if (message.langId != null && message.hasOwnProperty("langId"))
                object.langId = message.langId;
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                object.groupInviteToken = message.groupInviteToken;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.hashcashSolution != null && message.hasOwnProperty("hashcashSolution"))
                object.hashcashSolution = message.hashcashSolution;
            if (message.hashcashSolutionTimeTakenMs != null && message.hasOwnProperty("hashcashSolutionTimeTakenMs"))
                if (typeof message.hashcashSolutionTimeTakenMs === "number")
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? String(message.hashcashSolutionTimeTakenMs) : message.hashcashSolutionTimeTakenMs;
                else
                    object.hashcashSolutionTimeTakenMs = options.longs === String ? $util.Long.prototype.toString.call(message.hashcashSolutionTimeTakenMs) : options.longs === Number ? new $util.LongBits(message.hashcashSolutionTimeTakenMs.low >>> 0, message.hashcashSolutionTimeTakenMs.high >>> 0).toNumber() : message.hashcashSolutionTimeTakenMs;
            return object;
        };

        /**
         * Converts this OtpRequest to JSON.
         * @function toJSON
         * @memberof server.OtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Method enum.
         * @name server.OtpRequest.Method
         * @enum {number}
         * @property {number} SMS=0 SMS value
         * @property {number} VOICE_CALL=1 VOICE_CALL value
         */
        OtpRequest.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SMS"] = 0;
            values[valuesById[1] = "VOICE_CALL"] = 1;
            return values;
        })();

        return OtpRequest;
    })();

    server.OtpResponse = (function() {

        /**
         * Properties of an OtpResponse.
         * @memberof server
         * @interface IOtpResponse
         * @property {string|null} [phone] OtpResponse phone
         * @property {server.OtpResponse.Result|null} [result] OtpResponse result
         * @property {server.OtpResponse.Reason|null} [reason] OtpResponse reason
         * @property {number|Long|null} [retryAfterSecs] OtpResponse retryAfterSecs
         */

        /**
         * Constructs a new OtpResponse.
         * @memberof server
         * @classdesc Represents an OtpResponse.
         * @implements IOtpResponse
         * @constructor
         * @param {server.IOtpResponse=} [properties] Properties to set
         */
        function OtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OtpResponse phone.
         * @member {string} phone
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.phone = "";

        /**
         * OtpResponse result.
         * @member {server.OtpResponse.Result} result
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.result = 0;

        /**
         * OtpResponse reason.
         * @member {server.OtpResponse.Reason} reason
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.reason = 0;

        /**
         * OtpResponse retryAfterSecs.
         * @member {number|Long} retryAfterSecs
         * @memberof server.OtpResponse
         * @instance
         */
        OtpResponse.prototype.retryAfterSecs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OtpResponse instance using the specified properties.
         * @function create
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse=} [properties] Properties to set
         * @returns {server.OtpResponse} OtpResponse instance
         */
        OtpResponse.create = function create(properties) {
            return new OtpResponse(properties);
        };

        /**
         * Encodes the specified OtpResponse message. Does not implicitly {@link server.OtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse} message OtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.reason);
            if (message.retryAfterSecs != null && Object.hasOwnProperty.call(message, "retryAfterSecs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.retryAfterSecs);
            return writer;
        };

        /**
         * Encodes the specified OtpResponse message, length delimited. Does not implicitly {@link server.OtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.OtpResponse
         * @static
         * @param {server.IOtpResponse} message OtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.OtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.OtpResponse} OtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.OtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.result = reader.int32();
                    break;
                case 3:
                    message.reason = reader.int32();
                    break;
                case 4:
                    message.retryAfterSecs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.OtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.OtpResponse} OtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OtpResponse message.
         * @function verify
         * @memberof server.OtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (!$util.isInteger(message.retryAfterSecs) && !(message.retryAfterSecs && $util.isInteger(message.retryAfterSecs.low) && $util.isInteger(message.retryAfterSecs.high)))
                    return "retryAfterSecs: integer|Long expected";
            return null;
        };

        /**
         * Creates an OtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.OtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.OtpResponse} OtpResponse
         */
        OtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.OtpResponse)
                return object;
            var message = new $root.server.OtpResponse();
            if (object.phone != null)
                message.phone = String(object.phone);
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_PHONE_NUMBER":
            case 1:
                message.reason = 1;
                break;
            case "INVALID_CLIENT_VERSION":
            case 2:
                message.reason = 2;
                break;
            case "BAD_METHOD":
            case 3:
                message.reason = 3;
                break;
            case "OTP_FAIL":
            case 4:
                message.reason = 4;
                break;
            case "NOT_INVITED":
            case 5:
                message.reason = 5;
                break;
            case "INVALID_GROUP_INVITE_TOKEN":
            case 6:
                message.reason = 6;
                break;
            case "RETRIED_TOO_SOON":
            case 7:
                message.reason = 7;
                break;
            case "BAD_REQUEST":
            case 8:
                message.reason = 8;
                break;
            case "INTERNAL_SERVER_ERROR":
            case 9:
                message.reason = 9;
                break;
            case "INVALID_HASHCASH_NONCE":
            case 10:
                message.reason = 10;
                break;
            case "WRONG_HASHCASH_SOLUTION":
            case 11:
                message.reason = 11;
                break;
            }
            if (object.retryAfterSecs != null)
                if ($util.Long)
                    (message.retryAfterSecs = $util.Long.fromValue(object.retryAfterSecs)).unsigned = false;
                else if (typeof object.retryAfterSecs === "string")
                    message.retryAfterSecs = parseInt(object.retryAfterSecs, 10);
                else if (typeof object.retryAfterSecs === "number")
                    message.retryAfterSecs = object.retryAfterSecs;
                else if (typeof object.retryAfterSecs === "object")
                    message.retryAfterSecs = new $util.LongBits(object.retryAfterSecs.low >>> 0, object.retryAfterSecs.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.OtpResponse
         * @static
         * @param {server.OtpResponse} message OtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.retryAfterSecs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.retryAfterSecs = options.longs === String ? "0" : 0;
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.OtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.OtpResponse.Reason[message.reason] : message.reason;
            if (message.retryAfterSecs != null && message.hasOwnProperty("retryAfterSecs"))
                if (typeof message.retryAfterSecs === "number")
                    object.retryAfterSecs = options.longs === String ? String(message.retryAfterSecs) : message.retryAfterSecs;
                else
                    object.retryAfterSecs = options.longs === String ? $util.Long.prototype.toString.call(message.retryAfterSecs) : options.longs === Number ? new $util.LongBits(message.retryAfterSecs.low >>> 0, message.retryAfterSecs.high >>> 0).toNumber() : message.retryAfterSecs;
            return object;
        };

        /**
         * Converts this OtpResponse to JSON.
         * @function toJSON
         * @memberof server.OtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.OtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        OtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.OtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_PHONE_NUMBER=1 INVALID_PHONE_NUMBER value
         * @property {number} INVALID_CLIENT_VERSION=2 INVALID_CLIENT_VERSION value
         * @property {number} BAD_METHOD=3 BAD_METHOD value
         * @property {number} OTP_FAIL=4 OTP_FAIL value
         * @property {number} NOT_INVITED=5 NOT_INVITED value
         * @property {number} INVALID_GROUP_INVITE_TOKEN=6 INVALID_GROUP_INVITE_TOKEN value
         * @property {number} RETRIED_TOO_SOON=7 RETRIED_TOO_SOON value
         * @property {number} BAD_REQUEST=8 BAD_REQUEST value
         * @property {number} INTERNAL_SERVER_ERROR=9 INTERNAL_SERVER_ERROR value
         * @property {number} INVALID_HASHCASH_NONCE=10 INVALID_HASHCASH_NONCE value
         * @property {number} WRONG_HASHCASH_SOLUTION=11 WRONG_HASHCASH_SOLUTION value
         */
        OtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_PHONE_NUMBER"] = 1;
            values[valuesById[2] = "INVALID_CLIENT_VERSION"] = 2;
            values[valuesById[3] = "BAD_METHOD"] = 3;
            values[valuesById[4] = "OTP_FAIL"] = 4;
            values[valuesById[5] = "NOT_INVITED"] = 5;
            values[valuesById[6] = "INVALID_GROUP_INVITE_TOKEN"] = 6;
            values[valuesById[7] = "RETRIED_TOO_SOON"] = 7;
            values[valuesById[8] = "BAD_REQUEST"] = 8;
            values[valuesById[9] = "INTERNAL_SERVER_ERROR"] = 9;
            values[valuesById[10] = "INVALID_HASHCASH_NONCE"] = 10;
            values[valuesById[11] = "WRONG_HASHCASH_SOLUTION"] = 11;
            return values;
        })();

        return OtpResponse;
    })();

    server.VerifyOtpRequest = (function() {

        /**
         * Properties of a VerifyOtpRequest.
         * @memberof server
         * @interface IVerifyOtpRequest
         * @property {string|null} [phone] VerifyOtpRequest phone
         * @property {string|null} [code] VerifyOtpRequest code
         * @property {string|null} [name] VerifyOtpRequest name
         * @property {Uint8Array|null} [staticKey] VerifyOtpRequest staticKey
         * @property {Uint8Array|null} [signedPhrase] VerifyOtpRequest signedPhrase
         * @property {Uint8Array|null} [identityKey] VerifyOtpRequest identityKey
         * @property {Uint8Array|null} [signedKey] VerifyOtpRequest signedKey
         * @property {Array.<Uint8Array>|null} [oneTimeKeys] VerifyOtpRequest oneTimeKeys
         * @property {string|null} [groupInviteToken] VerifyOtpRequest groupInviteToken
         * @property {server.IPushRegister|null} [pushRegister] VerifyOtpRequest pushRegister
         * @property {string|null} [userAgent] VerifyOtpRequest userAgent
         */

        /**
         * Constructs a new VerifyOtpRequest.
         * @memberof server
         * @classdesc Represents a VerifyOtpRequest.
         * @implements IVerifyOtpRequest
         * @constructor
         * @param {server.IVerifyOtpRequest=} [properties] Properties to set
         */
        function VerifyOtpRequest(properties) {
            this.oneTimeKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyOtpRequest phone.
         * @member {string} phone
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.phone = "";

        /**
         * VerifyOtpRequest code.
         * @member {string} code
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.code = "";

        /**
         * VerifyOtpRequest name.
         * @member {string} name
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.name = "";

        /**
         * VerifyOtpRequest staticKey.
         * @member {Uint8Array} staticKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.staticKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest signedPhrase.
         * @member {Uint8Array} signedPhrase
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.signedPhrase = $util.newBuffer([]);

        /**
         * VerifyOtpRequest identityKey.
         * @member {Uint8Array} identityKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.identityKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest signedKey.
         * @member {Uint8Array} signedKey
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.signedKey = $util.newBuffer([]);

        /**
         * VerifyOtpRequest oneTimeKeys.
         * @member {Array.<Uint8Array>} oneTimeKeys
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.oneTimeKeys = $util.emptyArray;

        /**
         * VerifyOtpRequest groupInviteToken.
         * @member {string} groupInviteToken
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.groupInviteToken = "";

        /**
         * VerifyOtpRequest pushRegister.
         * @member {server.IPushRegister|null|undefined} pushRegister
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.pushRegister = null;

        /**
         * VerifyOtpRequest userAgent.
         * @member {string} userAgent
         * @memberof server.VerifyOtpRequest
         * @instance
         */
        VerifyOtpRequest.prototype.userAgent = "";

        /**
         * Creates a new VerifyOtpRequest instance using the specified properties.
         * @function create
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest=} [properties] Properties to set
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest instance
         */
        VerifyOtpRequest.create = function create(properties) {
            return new VerifyOtpRequest(properties);
        };

        /**
         * Encodes the specified VerifyOtpRequest message. Does not implicitly {@link server.VerifyOtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest} message VerifyOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.staticKey != null && Object.hasOwnProperty.call(message, "staticKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.staticKey);
            if (message.signedPhrase != null && Object.hasOwnProperty.call(message, "signedPhrase"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signedPhrase);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.identityKey);
            if (message.signedKey != null && Object.hasOwnProperty.call(message, "signedKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signedKey);
            if (message.oneTimeKeys != null && message.oneTimeKeys.length)
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.oneTimeKeys[i]);
            if (message.groupInviteToken != null && Object.hasOwnProperty.call(message, "groupInviteToken"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.groupInviteToken);
            if (message.pushRegister != null && Object.hasOwnProperty.call(message, "pushRegister"))
                $root.server.PushRegister.encode(message.pushRegister, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.userAgent != null && Object.hasOwnProperty.call(message, "userAgent"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.userAgent);
            return writer;
        };

        /**
         * Encodes the specified VerifyOtpRequest message, length delimited. Does not implicitly {@link server.VerifyOtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.IVerifyOtpRequest} message VerifyOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyOtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.VerifyOtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.code = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.staticKey = reader.bytes();
                    break;
                case 5:
                    message.signedPhrase = reader.bytes();
                    break;
                case 6:
                    message.identityKey = reader.bytes();
                    break;
                case 7:
                    message.signedKey = reader.bytes();
                    break;
                case 8:
                    if (!(message.oneTimeKeys && message.oneTimeKeys.length))
                        message.oneTimeKeys = [];
                    message.oneTimeKeys.push(reader.bytes());
                    break;
                case 9:
                    message.groupInviteToken = reader.string();
                    break;
                case 10:
                    message.pushRegister = $root.server.PushRegister.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.userAgent = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyOtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyOtpRequest message.
         * @function verify
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyOtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                if (!(message.staticKey && typeof message.staticKey.length === "number" || $util.isString(message.staticKey)))
                    return "staticKey: buffer expected";
            if (message.signedPhrase != null && message.hasOwnProperty("signedPhrase"))
                if (!(message.signedPhrase && typeof message.signedPhrase.length === "number" || $util.isString(message.signedPhrase)))
                    return "signedPhrase: buffer expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                if (!(message.signedKey && typeof message.signedKey.length === "number" || $util.isString(message.signedKey)))
                    return "signedKey: buffer expected";
            if (message.oneTimeKeys != null && message.hasOwnProperty("oneTimeKeys")) {
                if (!Array.isArray(message.oneTimeKeys))
                    return "oneTimeKeys: array expected";
                for (var i = 0; i < message.oneTimeKeys.length; ++i)
                    if (!(message.oneTimeKeys[i] && typeof message.oneTimeKeys[i].length === "number" || $util.isString(message.oneTimeKeys[i])))
                        return "oneTimeKeys: buffer[] expected";
            }
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                if (!$util.isString(message.groupInviteToken))
                    return "groupInviteToken: string expected";
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister")) {
                var error = $root.server.PushRegister.verify(message.pushRegister);
                if (error)
                    return "pushRegister." + error;
            }
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            return null;
        };

        /**
         * Creates a VerifyOtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.VerifyOtpRequest} VerifyOtpRequest
         */
        VerifyOtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.VerifyOtpRequest)
                return object;
            var message = new $root.server.VerifyOtpRequest();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.staticKey != null)
                if (typeof object.staticKey === "string")
                    $util.base64.decode(object.staticKey, message.staticKey = $util.newBuffer($util.base64.length(object.staticKey)), 0);
                else if (object.staticKey.length)
                    message.staticKey = object.staticKey;
            if (object.signedPhrase != null)
                if (typeof object.signedPhrase === "string")
                    $util.base64.decode(object.signedPhrase, message.signedPhrase = $util.newBuffer($util.base64.length(object.signedPhrase)), 0);
                else if (object.signedPhrase.length)
                    message.signedPhrase = object.signedPhrase;
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.signedKey != null)
                if (typeof object.signedKey === "string")
                    $util.base64.decode(object.signedKey, message.signedKey = $util.newBuffer($util.base64.length(object.signedKey)), 0);
                else if (object.signedKey.length)
                    message.signedKey = object.signedKey;
            if (object.oneTimeKeys) {
                if (!Array.isArray(object.oneTimeKeys))
                    throw TypeError(".server.VerifyOtpRequest.oneTimeKeys: array expected");
                message.oneTimeKeys = [];
                for (var i = 0; i < object.oneTimeKeys.length; ++i)
                    if (typeof object.oneTimeKeys[i] === "string")
                        $util.base64.decode(object.oneTimeKeys[i], message.oneTimeKeys[i] = $util.newBuffer($util.base64.length(object.oneTimeKeys[i])), 0);
                    else if (object.oneTimeKeys[i].length)
                        message.oneTimeKeys[i] = object.oneTimeKeys[i];
            }
            if (object.groupInviteToken != null)
                message.groupInviteToken = String(object.groupInviteToken);
            if (object.pushRegister != null) {
                if (typeof object.pushRegister !== "object")
                    throw TypeError(".server.VerifyOtpRequest.pushRegister: object expected");
                message.pushRegister = $root.server.PushRegister.fromObject(object.pushRegister);
            }
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            return message;
        };

        /**
         * Creates a plain object from a VerifyOtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.VerifyOtpRequest
         * @static
         * @param {server.VerifyOtpRequest} message VerifyOtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyOtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.oneTimeKeys = [];
            if (options.defaults) {
                object.phone = "";
                object.code = "";
                object.name = "";
                if (options.bytes === String)
                    object.staticKey = "";
                else {
                    object.staticKey = [];
                    if (options.bytes !== Array)
                        object.staticKey = $util.newBuffer(object.staticKey);
                }
                if (options.bytes === String)
                    object.signedPhrase = "";
                else {
                    object.signedPhrase = [];
                    if (options.bytes !== Array)
                        object.signedPhrase = $util.newBuffer(object.signedPhrase);
                }
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.signedKey = "";
                else {
                    object.signedKey = [];
                    if (options.bytes !== Array)
                        object.signedKey = $util.newBuffer(object.signedKey);
                }
                object.groupInviteToken = "";
                object.pushRegister = null;
                object.userAgent = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.staticKey != null && message.hasOwnProperty("staticKey"))
                object.staticKey = options.bytes === String ? $util.base64.encode(message.staticKey, 0, message.staticKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.staticKey) : message.staticKey;
            if (message.signedPhrase != null && message.hasOwnProperty("signedPhrase"))
                object.signedPhrase = options.bytes === String ? $util.base64.encode(message.signedPhrase, 0, message.signedPhrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedPhrase) : message.signedPhrase;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.signedKey != null && message.hasOwnProperty("signedKey"))
                object.signedKey = options.bytes === String ? $util.base64.encode(message.signedKey, 0, message.signedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedKey) : message.signedKey;
            if (message.oneTimeKeys && message.oneTimeKeys.length) {
                object.oneTimeKeys = [];
                for (var j = 0; j < message.oneTimeKeys.length; ++j)
                    object.oneTimeKeys[j] = options.bytes === String ? $util.base64.encode(message.oneTimeKeys[j], 0, message.oneTimeKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.oneTimeKeys[j]) : message.oneTimeKeys[j];
            }
            if (message.groupInviteToken != null && message.hasOwnProperty("groupInviteToken"))
                object.groupInviteToken = message.groupInviteToken;
            if (message.pushRegister != null && message.hasOwnProperty("pushRegister"))
                object.pushRegister = $root.server.PushRegister.toObject(message.pushRegister, options);
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            return object;
        };

        /**
         * Converts this VerifyOtpRequest to JSON.
         * @function toJSON
         * @memberof server.VerifyOtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyOtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyOtpRequest;
    })();

    server.VerifyOtpResponse = (function() {

        /**
         * Properties of a VerifyOtpResponse.
         * @memberof server
         * @interface IVerifyOtpResponse
         * @property {string|null} [phone] VerifyOtpResponse phone
         * @property {number|Long|null} [uid] VerifyOtpResponse uid
         * @property {string|null} [name] VerifyOtpResponse name
         * @property {server.VerifyOtpResponse.Result|null} [result] VerifyOtpResponse result
         * @property {server.VerifyOtpResponse.Reason|null} [reason] VerifyOtpResponse reason
         * @property {string|null} [groupInviteResult] VerifyOtpResponse groupInviteResult
         */

        /**
         * Constructs a new VerifyOtpResponse.
         * @memberof server
         * @classdesc Represents a VerifyOtpResponse.
         * @implements IVerifyOtpResponse
         * @constructor
         * @param {server.IVerifyOtpResponse=} [properties] Properties to set
         */
        function VerifyOtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VerifyOtpResponse phone.
         * @member {string} phone
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.phone = "";

        /**
         * VerifyOtpResponse uid.
         * @member {number|Long} uid
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VerifyOtpResponse name.
         * @member {string} name
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.name = "";

        /**
         * VerifyOtpResponse result.
         * @member {server.VerifyOtpResponse.Result} result
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.result = 0;

        /**
         * VerifyOtpResponse reason.
         * @member {server.VerifyOtpResponse.Reason} reason
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.reason = 0;

        /**
         * VerifyOtpResponse groupInviteResult.
         * @member {string} groupInviteResult
         * @memberof server.VerifyOtpResponse
         * @instance
         */
        VerifyOtpResponse.prototype.groupInviteResult = "";

        /**
         * Creates a new VerifyOtpResponse instance using the specified properties.
         * @function create
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse=} [properties] Properties to set
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse instance
         */
        VerifyOtpResponse.create = function create(properties) {
            return new VerifyOtpResponse(properties);
        };

        /**
         * Encodes the specified VerifyOtpResponse message. Does not implicitly {@link server.VerifyOtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse} message VerifyOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.phone);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.reason);
            if (message.groupInviteResult != null && Object.hasOwnProperty.call(message, "groupInviteResult"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.groupInviteResult);
            return writer;
        };

        /**
         * Encodes the specified VerifyOtpResponse message, length delimited. Does not implicitly {@link server.VerifyOtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.IVerifyOtpResponse} message VerifyOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyOtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyOtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.VerifyOtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.uid = reader.int64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.result = reader.int32();
                    break;
                case 5:
                    message.reason = reader.int32();
                    break;
                case 6:
                    message.groupInviteResult = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyOtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyOtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyOtpResponse message.
         * @function verify
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyOtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                    break;
                }
            if (message.groupInviteResult != null && message.hasOwnProperty("groupInviteResult"))
                if (!$util.isString(message.groupInviteResult))
                    return "groupInviteResult: string expected";
            return null;
        };

        /**
         * Creates a VerifyOtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.VerifyOtpResponse} VerifyOtpResponse
         */
        VerifyOtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.VerifyOtpResponse)
                return object;
            var message = new $root.server.VerifyOtpResponse();
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "INVALID_PHONE_NUMBER":
            case 1:
                message.reason = 1;
                break;
            case "INVALID_CLIENT_VERSION":
            case 2:
                message.reason = 2;
                break;
            case "WRONG_SMS_CODE":
            case 3:
                message.reason = 3;
                break;
            case "MISSING_PHONE":
            case 4:
                message.reason = 4;
                break;
            case "MISSING_CODE":
            case 5:
                message.reason = 5;
                break;
            case "MISSING_NAME":
            case 6:
                message.reason = 6;
                break;
            case "INVALID_NAME":
            case 7:
                message.reason = 7;
                break;
            case "MISSING_IDENTITY_KEY":
            case 8:
                message.reason = 8;
                break;
            case "MISSING_SIGNED_KEY":
            case 9:
                message.reason = 9;
                break;
            case "MISSING_ONE_TIME_KEYS":
            case 10:
                message.reason = 10;
                break;
            case "BAD_BASE64_KEY":
            case 11:
                message.reason = 11;
                break;
            case "INVALID_ONE_TIME_KEYS":
            case 12:
                message.reason = 12;
                break;
            case "TOO_FEW_ONE_TIME_KEYS":
            case 13:
                message.reason = 13;
                break;
            case "TOO_MANY_ONE_TIME_KEYS":
            case 14:
                message.reason = 14;
                break;
            case "TOO_BIG_IDENTITY_KEY":
            case 15:
                message.reason = 15;
                break;
            case "TOO_BIG_SIGNED_KEY":
            case 16:
                message.reason = 16;
                break;
            case "TOO_BIG_ONE_TIME_KEYS":
            case 17:
                message.reason = 17;
                break;
            case "INVALID_S_ED_PUB":
            case 18:
                message.reason = 18;
                break;
            case "INVALID_SIGNED_PHRASE":
            case 19:
                message.reason = 19;
                break;
            case "UNABLE_TO_OPEN_SIGNED_PHRASE":
            case 20:
                message.reason = 20;
                break;
            case "BAD_REQUEST":
            case 21:
                message.reason = 21;
                break;
            case "INTERNAL_SERVER_ERROR":
            case 22:
                message.reason = 22;
                break;
            }
            if (object.groupInviteResult != null)
                message.groupInviteResult = String(object.groupInviteResult);
            return message;
        };

        /**
         * Creates a plain object from a VerifyOtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.VerifyOtpResponse
         * @static
         * @param {server.VerifyOtpResponse} message VerifyOtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyOtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phone = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
                object.groupInviteResult = "";
            }
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.VerifyOtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.VerifyOtpResponse.Reason[message.reason] : message.reason;
            if (message.groupInviteResult != null && message.hasOwnProperty("groupInviteResult"))
                object.groupInviteResult = message.groupInviteResult;
            return object;
        };

        /**
         * Converts this VerifyOtpResponse to JSON.
         * @function toJSON
         * @memberof server.VerifyOtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyOtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.VerifyOtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        VerifyOtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.VerifyOtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} INVALID_PHONE_NUMBER=1 INVALID_PHONE_NUMBER value
         * @property {number} INVALID_CLIENT_VERSION=2 INVALID_CLIENT_VERSION value
         * @property {number} WRONG_SMS_CODE=3 WRONG_SMS_CODE value
         * @property {number} MISSING_PHONE=4 MISSING_PHONE value
         * @property {number} MISSING_CODE=5 MISSING_CODE value
         * @property {number} MISSING_NAME=6 MISSING_NAME value
         * @property {number} INVALID_NAME=7 INVALID_NAME value
         * @property {number} MISSING_IDENTITY_KEY=8 MISSING_IDENTITY_KEY value
         * @property {number} MISSING_SIGNED_KEY=9 MISSING_SIGNED_KEY value
         * @property {number} MISSING_ONE_TIME_KEYS=10 MISSING_ONE_TIME_KEYS value
         * @property {number} BAD_BASE64_KEY=11 BAD_BASE64_KEY value
         * @property {number} INVALID_ONE_TIME_KEYS=12 INVALID_ONE_TIME_KEYS value
         * @property {number} TOO_FEW_ONE_TIME_KEYS=13 TOO_FEW_ONE_TIME_KEYS value
         * @property {number} TOO_MANY_ONE_TIME_KEYS=14 TOO_MANY_ONE_TIME_KEYS value
         * @property {number} TOO_BIG_IDENTITY_KEY=15 TOO_BIG_IDENTITY_KEY value
         * @property {number} TOO_BIG_SIGNED_KEY=16 TOO_BIG_SIGNED_KEY value
         * @property {number} TOO_BIG_ONE_TIME_KEYS=17 TOO_BIG_ONE_TIME_KEYS value
         * @property {number} INVALID_S_ED_PUB=18 INVALID_S_ED_PUB value
         * @property {number} INVALID_SIGNED_PHRASE=19 INVALID_SIGNED_PHRASE value
         * @property {number} UNABLE_TO_OPEN_SIGNED_PHRASE=20 UNABLE_TO_OPEN_SIGNED_PHRASE value
         * @property {number} BAD_REQUEST=21 BAD_REQUEST value
         * @property {number} INTERNAL_SERVER_ERROR=22 INTERNAL_SERVER_ERROR value
         */
        VerifyOtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "INVALID_PHONE_NUMBER"] = 1;
            values[valuesById[2] = "INVALID_CLIENT_VERSION"] = 2;
            values[valuesById[3] = "WRONG_SMS_CODE"] = 3;
            values[valuesById[4] = "MISSING_PHONE"] = 4;
            values[valuesById[5] = "MISSING_CODE"] = 5;
            values[valuesById[6] = "MISSING_NAME"] = 6;
            values[valuesById[7] = "INVALID_NAME"] = 7;
            values[valuesById[8] = "MISSING_IDENTITY_KEY"] = 8;
            values[valuesById[9] = "MISSING_SIGNED_KEY"] = 9;
            values[valuesById[10] = "MISSING_ONE_TIME_KEYS"] = 10;
            values[valuesById[11] = "BAD_BASE64_KEY"] = 11;
            values[valuesById[12] = "INVALID_ONE_TIME_KEYS"] = 12;
            values[valuesById[13] = "TOO_FEW_ONE_TIME_KEYS"] = 13;
            values[valuesById[14] = "TOO_MANY_ONE_TIME_KEYS"] = 14;
            values[valuesById[15] = "TOO_BIG_IDENTITY_KEY"] = 15;
            values[valuesById[16] = "TOO_BIG_SIGNED_KEY"] = 16;
            values[valuesById[17] = "TOO_BIG_ONE_TIME_KEYS"] = 17;
            values[valuesById[18] = "INVALID_S_ED_PUB"] = 18;
            values[valuesById[19] = "INVALID_SIGNED_PHRASE"] = 19;
            values[valuesById[20] = "UNABLE_TO_OPEN_SIGNED_PHRASE"] = 20;
            values[valuesById[21] = "BAD_REQUEST"] = 21;
            values[valuesById[22] = "INTERNAL_SERVER_ERROR"] = 22;
            return values;
        })();

        return VerifyOtpResponse;
    })();

    server.ClientOtpRequest = (function() {

        /**
         * Properties of a ClientOtpRequest.
         * @memberof server
         * @interface IClientOtpRequest
         * @property {server.ClientOtpRequest.Method|null} [method] ClientOtpRequest method
         * @property {string|null} [phone] ClientOtpRequest phone
         * @property {string|null} [content] ClientOtpRequest content
         */

        /**
         * Constructs a new ClientOtpRequest.
         * @memberof server
         * @classdesc Represents a ClientOtpRequest.
         * @implements IClientOtpRequest
         * @constructor
         * @param {server.IClientOtpRequest=} [properties] Properties to set
         */
        function ClientOtpRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientOtpRequest method.
         * @member {server.ClientOtpRequest.Method} method
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.method = 0;

        /**
         * ClientOtpRequest phone.
         * @member {string} phone
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.phone = "";

        /**
         * ClientOtpRequest content.
         * @member {string} content
         * @memberof server.ClientOtpRequest
         * @instance
         */
        ClientOtpRequest.prototype.content = "";

        /**
         * Creates a new ClientOtpRequest instance using the specified properties.
         * @function create
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest=} [properties] Properties to set
         * @returns {server.ClientOtpRequest} ClientOtpRequest instance
         */
        ClientOtpRequest.create = function create(properties) {
            return new ClientOtpRequest(properties);
        };

        /**
         * Encodes the specified ClientOtpRequest message. Does not implicitly {@link server.ClientOtpRequest.verify|verify} messages.
         * @function encode
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest} message ClientOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
            if (message.phone != null && Object.hasOwnProperty.call(message, "phone"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phone);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
            return writer;
        };

        /**
         * Encodes the specified ClientOtpRequest message, length delimited. Does not implicitly {@link server.ClientOtpRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.IClientOtpRequest} message ClientOtpRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientOtpRequest message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientOtpRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.method = reader.int32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                case 3:
                    message.content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientOtpRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientOtpRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientOtpRequest message.
         * @function verify
         * @memberof server.ClientOtpRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientOtpRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.phone != null && message.hasOwnProperty("phone"))
                if (!$util.isString(message.phone))
                    return "phone: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            return null;
        };

        /**
         * Creates a ClientOtpRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientOtpRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientOtpRequest} ClientOtpRequest
         */
        ClientOtpRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientOtpRequest)
                return object;
            var message = new $root.server.ClientOtpRequest();
            switch (object.method) {
            case "SMS":
            case 0:
                message.method = 0;
                break;
            case "VOICE_CALL":
            case 1:
                message.method = 1;
                break;
            }
            if (object.phone != null)
                message.phone = String(object.phone);
            if (object.content != null)
                message.content = String(object.content);
            return message;
        };

        /**
         * Creates a plain object from a ClientOtpRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientOtpRequest
         * @static
         * @param {server.ClientOtpRequest} message ClientOtpRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientOtpRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.method = options.enums === String ? "SMS" : 0;
                object.phone = "";
                object.content = "";
            }
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.server.ClientOtpRequest.Method[message.method] : message.method;
            if (message.phone != null && message.hasOwnProperty("phone"))
                object.phone = message.phone;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            return object;
        };

        /**
         * Converts this ClientOtpRequest to JSON.
         * @function toJSON
         * @memberof server.ClientOtpRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientOtpRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Method enum.
         * @name server.ClientOtpRequest.Method
         * @enum {number}
         * @property {number} SMS=0 SMS value
         * @property {number} VOICE_CALL=1 VOICE_CALL value
         */
        ClientOtpRequest.Method = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SMS"] = 0;
            values[valuesById[1] = "VOICE_CALL"] = 1;
            return values;
        })();

        return ClientOtpRequest;
    })();

    server.ClientOtpResponse = (function() {

        /**
         * Properties of a ClientOtpResponse.
         * @memberof server
         * @interface IClientOtpResponse
         * @property {server.ClientOtpResponse.Result|null} [result] ClientOtpResponse result
         * @property {server.ClientOtpResponse.Reason|null} [reason] ClientOtpResponse reason
         */

        /**
         * Constructs a new ClientOtpResponse.
         * @memberof server
         * @classdesc Represents a ClientOtpResponse.
         * @implements IClientOtpResponse
         * @constructor
         * @param {server.IClientOtpResponse=} [properties] Properties to set
         */
        function ClientOtpResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientOtpResponse result.
         * @member {server.ClientOtpResponse.Result} result
         * @memberof server.ClientOtpResponse
         * @instance
         */
        ClientOtpResponse.prototype.result = 0;

        /**
         * ClientOtpResponse reason.
         * @member {server.ClientOtpResponse.Reason} reason
         * @memberof server.ClientOtpResponse
         * @instance
         */
        ClientOtpResponse.prototype.reason = 0;

        /**
         * Creates a new ClientOtpResponse instance using the specified properties.
         * @function create
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse=} [properties] Properties to set
         * @returns {server.ClientOtpResponse} ClientOtpResponse instance
         */
        ClientOtpResponse.create = function create(properties) {
            return new ClientOtpResponse(properties);
        };

        /**
         * Encodes the specified ClientOtpResponse message. Does not implicitly {@link server.ClientOtpResponse.verify|verify} messages.
         * @function encode
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse} message ClientOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ClientOtpResponse message, length delimited. Does not implicitly {@link server.ClientOtpResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.IClientOtpResponse} message ClientOtpResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientOtpResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientOtpResponse message from the specified reader or buffer.
         * @function decode
         * @memberof server.ClientOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.ClientOtpResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientOtpResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.ClientOtpResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientOtpResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientOtpResponse message.
         * @function verify
         * @memberof server.ClientOtpResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientOtpResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a ClientOtpResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.ClientOtpResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.ClientOtpResponse} ClientOtpResponse
         */
        ClientOtpResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.server.ClientOtpResponse)
                return object;
            var message = new $root.server.ClientOtpResponse();
            switch (object.result) {
            case "UNKNOWN_RESULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "FAILURE":
            case 2:
                message.result = 2;
                break;
            }
            switch (object.reason) {
            case "UNKNOWN_REASON":
            case 0:
                message.reason = 0;
                break;
            case "SETUP_ISSUE":
            case 1:
                message.reason = 1;
                break;
            case "PERMISSION_ISSUE":
            case 2:
                message.reason = 2;
                break;
            case "FORMATTING_ISSUE":
            case 3:
                message.reason = 3;
                break;
            case "NETWORKING_ISSUE":
            case 4:
                message.reason = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientOtpResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.ClientOtpResponse
         * @static
         * @param {server.ClientOtpResponse} message ClientOtpResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientOtpResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_RESULT" : 0;
                object.reason = options.enums === String ? "UNKNOWN_REASON" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.ClientOtpResponse.Result[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.server.ClientOtpResponse.Reason[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this ClientOtpResponse to JSON.
         * @function toJSON
         * @memberof server.ClientOtpResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientOtpResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name server.ClientOtpResponse.Result
         * @enum {number}
         * @property {number} UNKNOWN_RESULT=0 UNKNOWN_RESULT value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        ClientOtpResponse.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_RESULT"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @name server.ClientOtpResponse.Reason
         * @enum {number}
         * @property {number} UNKNOWN_REASON=0 UNKNOWN_REASON value
         * @property {number} SETUP_ISSUE=1 SETUP_ISSUE value
         * @property {number} PERMISSION_ISSUE=2 PERMISSION_ISSUE value
         * @property {number} FORMATTING_ISSUE=3 FORMATTING_ISSUE value
         * @property {number} NETWORKING_ISSUE=4 NETWORKING_ISSUE value
         */
        ClientOtpResponse.Reason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_REASON"] = 0;
            values[valuesById[1] = "SETUP_ISSUE"] = 1;
            values[valuesById[2] = "PERMISSION_ISSUE"] = 2;
            values[valuesById[3] = "FORMATTING_ISSUE"] = 3;
            values[valuesById[4] = "NETWORKING_ISSUE"] = 4;
            return values;
        })();

        return ClientOtpResponse;
    })();

    server.WakeUp = (function() {

        /**
         * Properties of a WakeUp.
         * @memberof server
         * @interface IWakeUp
         */

        /**
         * Constructs a new WakeUp.
         * @memberof server
         * @classdesc Represents a WakeUp.
         * @implements IWakeUp
         * @constructor
         * @param {server.IWakeUp=} [properties] Properties to set
         */
        function WakeUp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WakeUp instance using the specified properties.
         * @function create
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp=} [properties] Properties to set
         * @returns {server.WakeUp} WakeUp instance
         */
        WakeUp.create = function create(properties) {
            return new WakeUp(properties);
        };

        /**
         * Encodes the specified WakeUp message. Does not implicitly {@link server.WakeUp.verify|verify} messages.
         * @function encode
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp} message WakeUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WakeUp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WakeUp message, length delimited. Does not implicitly {@link server.WakeUp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.WakeUp
         * @static
         * @param {server.IWakeUp} message WakeUp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WakeUp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WakeUp message from the specified reader or buffer.
         * @function decode
         * @memberof server.WakeUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.WakeUp} WakeUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WakeUp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.WakeUp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WakeUp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.WakeUp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.WakeUp} WakeUp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WakeUp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WakeUp message.
         * @function verify
         * @memberof server.WakeUp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WakeUp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WakeUp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.WakeUp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.WakeUp} WakeUp
         */
        WakeUp.fromObject = function fromObject(object) {
            if (object instanceof $root.server.WakeUp)
                return object;
            return new $root.server.WakeUp();
        };

        /**
         * Creates a plain object from a WakeUp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.WakeUp
         * @static
         * @param {server.WakeUp} message WakeUp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WakeUp.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WakeUp to JSON.
         * @function toJSON
         * @memberof server.WakeUp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WakeUp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WakeUp;
    })();

    server.MarketingAlert = (function() {

        /**
         * Properties of a MarketingAlert.
         * @memberof server
         * @interface IMarketingAlert
         * @property {server.MarketingAlert.Type|null} [type] MarketingAlert type
         */

        /**
         * Constructs a new MarketingAlert.
         * @memberof server
         * @classdesc Represents a MarketingAlert.
         * @implements IMarketingAlert
         * @constructor
         * @param {server.IMarketingAlert=} [properties] Properties to set
         */
        function MarketingAlert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MarketingAlert type.
         * @member {server.MarketingAlert.Type} type
         * @memberof server.MarketingAlert
         * @instance
         */
        MarketingAlert.prototype.type = 0;

        /**
         * Creates a new MarketingAlert instance using the specified properties.
         * @function create
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert=} [properties] Properties to set
         * @returns {server.MarketingAlert} MarketingAlert instance
         */
        MarketingAlert.create = function create(properties) {
            return new MarketingAlert(properties);
        };

        /**
         * Encodes the specified MarketingAlert message. Does not implicitly {@link server.MarketingAlert.verify|verify} messages.
         * @function encode
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert} message MarketingAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketingAlert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified MarketingAlert message, length delimited. Does not implicitly {@link server.MarketingAlert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MarketingAlert
         * @static
         * @param {server.IMarketingAlert} message MarketingAlert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MarketingAlert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MarketingAlert message from the specified reader or buffer.
         * @function decode
         * @memberof server.MarketingAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MarketingAlert} MarketingAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketingAlert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MarketingAlert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MarketingAlert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MarketingAlert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MarketingAlert} MarketingAlert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MarketingAlert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MarketingAlert message.
         * @function verify
         * @memberof server.MarketingAlert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MarketingAlert.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a MarketingAlert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MarketingAlert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MarketingAlert} MarketingAlert
         */
        MarketingAlert.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MarketingAlert)
                return object;
            var message = new $root.server.MarketingAlert();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "INVITE_FRIENDS":
            case 1:
                message.type = 1;
                break;
            case "SHARE_POST":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MarketingAlert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MarketingAlert
         * @static
         * @param {server.MarketingAlert} message MarketingAlert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MarketingAlert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNKNOWN" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MarketingAlert.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this MarketingAlert to JSON.
         * @function toJSON
         * @memberof server.MarketingAlert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MarketingAlert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MarketingAlert.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INVITE_FRIENDS=1 INVITE_FRIENDS value
         * @property {number} SHARE_POST=2 SHARE_POST value
         */
        MarketingAlert.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INVITE_FRIENDS"] = 1;
            values[valuesById[2] = "SHARE_POST"] = 2;
            return values;
        })();

        return MarketingAlert;
    })();

    server.EventData = (function() {

        /**
         * Properties of an EventData.
         * @memberof server
         * @interface IEventData
         * @property {number|Long|null} [uid] EventData uid
         * @property {server.Platform|null} [platform] EventData platform
         * @property {string|null} [version] EventData version
         * @property {number|Long|null} [timestampMs] EventData timestampMs
         * @property {string|null} [cc] EventData cc
         * @property {server.IMediaUpload|null} [mediaUpload] EventData mediaUpload
         * @property {server.IMediaDownload|null} [mediaDownload] EventData mediaDownload
         * @property {server.IMediaComposeLoad|null} [mediaComposeLoad] EventData mediaComposeLoad
         * @property {server.IPushReceived|null} [pushReceived] EventData pushReceived
         * @property {server.IDecryptionReport|null} [decryptionReport] EventData decryptionReport
         * @property {server.IPermissions|null} [permissions] EventData permissions
         * @property {server.IMediaObjectDownload|null} [mediaObjectDownload] EventData mediaObjectDownload
         * @property {server.IGroupDecryptionReport|null} [groupDecryptionReport] EventData groupDecryptionReport
         * @property {server.ICall|null} [call] EventData call
         * @property {server.IFabAction|null} [fabAction] EventData fabAction
         * @property {server.IGroupHistoryReport|null} [groupHistoryReport] EventData groupHistoryReport
         */

        /**
         * Constructs a new EventData.
         * @memberof server
         * @classdesc Represents an EventData.
         * @implements IEventData
         * @constructor
         * @param {server.IEventData=} [properties] Properties to set
         */
        function EventData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventData uid.
         * @member {number|Long} uid
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventData platform.
         * @member {server.Platform} platform
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.platform = 0;

        /**
         * EventData version.
         * @member {string} version
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.version = "";

        /**
         * EventData timestampMs.
         * @member {number|Long} timestampMs
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EventData cc.
         * @member {string} cc
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.cc = "";

        /**
         * EventData mediaUpload.
         * @member {server.IMediaUpload|null|undefined} mediaUpload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaUpload = null;

        /**
         * EventData mediaDownload.
         * @member {server.IMediaDownload|null|undefined} mediaDownload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaDownload = null;

        /**
         * EventData mediaComposeLoad.
         * @member {server.IMediaComposeLoad|null|undefined} mediaComposeLoad
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaComposeLoad = null;

        /**
         * EventData pushReceived.
         * @member {server.IPushReceived|null|undefined} pushReceived
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.pushReceived = null;

        /**
         * EventData decryptionReport.
         * @member {server.IDecryptionReport|null|undefined} decryptionReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.decryptionReport = null;

        /**
         * EventData permissions.
         * @member {server.IPermissions|null|undefined} permissions
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.permissions = null;

        /**
         * EventData mediaObjectDownload.
         * @member {server.IMediaObjectDownload|null|undefined} mediaObjectDownload
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.mediaObjectDownload = null;

        /**
         * EventData groupDecryptionReport.
         * @member {server.IGroupDecryptionReport|null|undefined} groupDecryptionReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.groupDecryptionReport = null;

        /**
         * EventData call.
         * @member {server.ICall|null|undefined} call
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.call = null;

        /**
         * EventData fabAction.
         * @member {server.IFabAction|null|undefined} fabAction
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.fabAction = null;

        /**
         * EventData groupHistoryReport.
         * @member {server.IGroupHistoryReport|null|undefined} groupHistoryReport
         * @memberof server.EventData
         * @instance
         */
        EventData.prototype.groupHistoryReport = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * EventData edata.
         * @member {"mediaUpload"|"mediaDownload"|"mediaComposeLoad"|"pushReceived"|"decryptionReport"|"permissions"|"mediaObjectDownload"|"groupDecryptionReport"|"call"|"fabAction"|"groupHistoryReport"|undefined} edata
         * @memberof server.EventData
         * @instance
         */
        Object.defineProperty(EventData.prototype, "edata", {
            get: $util.oneOfGetter($oneOfFields = ["mediaUpload", "mediaDownload", "mediaComposeLoad", "pushReceived", "decryptionReport", "permissions", "mediaObjectDownload", "groupDecryptionReport", "call", "fabAction", "groupHistoryReport"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EventData instance using the specified properties.
         * @function create
         * @memberof server.EventData
         * @static
         * @param {server.IEventData=} [properties] Properties to set
         * @returns {server.EventData} EventData instance
         */
        EventData.create = function create(properties) {
            return new EventData(properties);
        };

        /**
         * Encodes the specified EventData message. Does not implicitly {@link server.EventData.verify|verify} messages.
         * @function encode
         * @memberof server.EventData
         * @static
         * @param {server.IEventData} message EventData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uid);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.platform);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
            if (message.timestampMs != null && Object.hasOwnProperty.call(message, "timestampMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestampMs);
            if (message.cc != null && Object.hasOwnProperty.call(message, "cc"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.cc);
            if (message.mediaUpload != null && Object.hasOwnProperty.call(message, "mediaUpload"))
                $root.server.MediaUpload.encode(message.mediaUpload, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.mediaDownload != null && Object.hasOwnProperty.call(message, "mediaDownload"))
                $root.server.MediaDownload.encode(message.mediaDownload, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.mediaComposeLoad != null && Object.hasOwnProperty.call(message, "mediaComposeLoad"))
                $root.server.MediaComposeLoad.encode(message.mediaComposeLoad, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.pushReceived != null && Object.hasOwnProperty.call(message, "pushReceived"))
                $root.server.PushReceived.encode(message.pushReceived, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.decryptionReport != null && Object.hasOwnProperty.call(message, "decryptionReport"))
                $root.server.DecryptionReport.encode(message.decryptionReport, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.permissions != null && Object.hasOwnProperty.call(message, "permissions"))
                $root.server.Permissions.encode(message.permissions, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.mediaObjectDownload != null && Object.hasOwnProperty.call(message, "mediaObjectDownload"))
                $root.server.MediaObjectDownload.encode(message.mediaObjectDownload, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.groupDecryptionReport != null && Object.hasOwnProperty.call(message, "groupDecryptionReport"))
                $root.server.GroupDecryptionReport.encode(message.groupDecryptionReport, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                $root.server.Call.encode(message.call, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.fabAction != null && Object.hasOwnProperty.call(message, "fabAction"))
                $root.server.FabAction.encode(message.fabAction, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.groupHistoryReport != null && Object.hasOwnProperty.call(message, "groupHistoryReport"))
                $root.server.GroupHistoryReport.encode(message.groupHistoryReport, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EventData message, length delimited. Does not implicitly {@link server.EventData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.EventData
         * @static
         * @param {server.IEventData} message EventData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventData message from the specified reader or buffer.
         * @function decode
         * @memberof server.EventData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.EventData} EventData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.EventData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.uint64();
                    break;
                case 2:
                    message.platform = reader.int32();
                    break;
                case 3:
                    message.version = reader.string();
                    break;
                case 4:
                    message.timestampMs = reader.uint64();
                    break;
                case 5:
                    message.cc = reader.string();
                    break;
                case 10:
                    message.mediaUpload = $root.server.MediaUpload.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.mediaDownload = $root.server.MediaDownload.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.mediaComposeLoad = $root.server.MediaComposeLoad.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.pushReceived = $root.server.PushReceived.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.decryptionReport = $root.server.DecryptionReport.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.permissions = $root.server.Permissions.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.mediaObjectDownload = $root.server.MediaObjectDownload.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.groupDecryptionReport = $root.server.GroupDecryptionReport.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.call = $root.server.Call.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.fabAction = $root.server.FabAction.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.groupHistoryReport = $root.server.GroupHistoryReport.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.EventData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.EventData} EventData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventData message.
         * @function verify
         * @memberof server.EventData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                    return "timestampMs: integer|Long expected";
            if (message.cc != null && message.hasOwnProperty("cc"))
                if (!$util.isString(message.cc))
                    return "cc: string expected";
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload")) {
                properties.edata = 1;
                {
                    var error = $root.server.MediaUpload.verify(message.mediaUpload);
                    if (error)
                        return "mediaUpload." + error;
                }
            }
            if (message.mediaDownload != null && message.hasOwnProperty("mediaDownload")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaDownload.verify(message.mediaDownload);
                    if (error)
                        return "mediaDownload." + error;
                }
            }
            if (message.mediaComposeLoad != null && message.hasOwnProperty("mediaComposeLoad")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaComposeLoad.verify(message.mediaComposeLoad);
                    if (error)
                        return "mediaComposeLoad." + error;
                }
            }
            if (message.pushReceived != null && message.hasOwnProperty("pushReceived")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.PushReceived.verify(message.pushReceived);
                    if (error)
                        return "pushReceived." + error;
                }
            }
            if (message.decryptionReport != null && message.hasOwnProperty("decryptionReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.DecryptionReport.verify(message.decryptionReport);
                    if (error)
                        return "decryptionReport." + error;
                }
            }
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.Permissions.verify(message.permissions);
                    if (error)
                        return "permissions." + error;
                }
            }
            if (message.mediaObjectDownload != null && message.hasOwnProperty("mediaObjectDownload")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.MediaObjectDownload.verify(message.mediaObjectDownload);
                    if (error)
                        return "mediaObjectDownload." + error;
                }
            }
            if (message.groupDecryptionReport != null && message.hasOwnProperty("groupDecryptionReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.GroupDecryptionReport.verify(message.groupDecryptionReport);
                    if (error)
                        return "groupDecryptionReport." + error;
                }
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.Call.verify(message.call);
                    if (error)
                        return "call." + error;
                }
            }
            if (message.fabAction != null && message.hasOwnProperty("fabAction")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.FabAction.verify(message.fabAction);
                    if (error)
                        return "fabAction." + error;
                }
            }
            if (message.groupHistoryReport != null && message.hasOwnProperty("groupHistoryReport")) {
                if (properties.edata === 1)
                    return "edata: multiple values";
                properties.edata = 1;
                {
                    var error = $root.server.GroupHistoryReport.verify(message.groupHistoryReport);
                    if (error)
                        return "groupHistoryReport." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EventData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.EventData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.EventData} EventData
         */
        EventData.fromObject = function fromObject(object) {
            if (object instanceof $root.server.EventData)
                return object;
            var message = new $root.server.EventData();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = true;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber(true);
            switch (object.platform) {
            case "UNKNOWN":
            case 0:
                message.platform = 0;
                break;
            case "IOS":
            case 1:
                message.platform = 1;
                break;
            case "ANDROID":
            case 2:
                message.platform = 2;
                break;
            }
            if (object.version != null)
                message.version = String(object.version);
            if (object.timestampMs != null)
                if ($util.Long)
                    (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = true;
                else if (typeof object.timestampMs === "string")
                    message.timestampMs = parseInt(object.timestampMs, 10);
                else if (typeof object.timestampMs === "number")
                    message.timestampMs = object.timestampMs;
                else if (typeof object.timestampMs === "object")
                    message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber(true);
            if (object.cc != null)
                message.cc = String(object.cc);
            if (object.mediaUpload != null) {
                if (typeof object.mediaUpload !== "object")
                    throw TypeError(".server.EventData.mediaUpload: object expected");
                message.mediaUpload = $root.server.MediaUpload.fromObject(object.mediaUpload);
            }
            if (object.mediaDownload != null) {
                if (typeof object.mediaDownload !== "object")
                    throw TypeError(".server.EventData.mediaDownload: object expected");
                message.mediaDownload = $root.server.MediaDownload.fromObject(object.mediaDownload);
            }
            if (object.mediaComposeLoad != null) {
                if (typeof object.mediaComposeLoad !== "object")
                    throw TypeError(".server.EventData.mediaComposeLoad: object expected");
                message.mediaComposeLoad = $root.server.MediaComposeLoad.fromObject(object.mediaComposeLoad);
            }
            if (object.pushReceived != null) {
                if (typeof object.pushReceived !== "object")
                    throw TypeError(".server.EventData.pushReceived: object expected");
                message.pushReceived = $root.server.PushReceived.fromObject(object.pushReceived);
            }
            if (object.decryptionReport != null) {
                if (typeof object.decryptionReport !== "object")
                    throw TypeError(".server.EventData.decryptionReport: object expected");
                message.decryptionReport = $root.server.DecryptionReport.fromObject(object.decryptionReport);
            }
            if (object.permissions != null) {
                if (typeof object.permissions !== "object")
                    throw TypeError(".server.EventData.permissions: object expected");
                message.permissions = $root.server.Permissions.fromObject(object.permissions);
            }
            if (object.mediaObjectDownload != null) {
                if (typeof object.mediaObjectDownload !== "object")
                    throw TypeError(".server.EventData.mediaObjectDownload: object expected");
                message.mediaObjectDownload = $root.server.MediaObjectDownload.fromObject(object.mediaObjectDownload);
            }
            if (object.groupDecryptionReport != null) {
                if (typeof object.groupDecryptionReport !== "object")
                    throw TypeError(".server.EventData.groupDecryptionReport: object expected");
                message.groupDecryptionReport = $root.server.GroupDecryptionReport.fromObject(object.groupDecryptionReport);
            }
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".server.EventData.call: object expected");
                message.call = $root.server.Call.fromObject(object.call);
            }
            if (object.fabAction != null) {
                if (typeof object.fabAction !== "object")
                    throw TypeError(".server.EventData.fabAction: object expected");
                message.fabAction = $root.server.FabAction.fromObject(object.fabAction);
            }
            if (object.groupHistoryReport != null) {
                if (typeof object.groupHistoryReport !== "object")
                    throw TypeError(".server.EventData.groupHistoryReport: object expected");
                message.groupHistoryReport = $root.server.GroupHistoryReport.fromObject(object.groupHistoryReport);
            }
            return message;
        };

        /**
         * Creates a plain object from an EventData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.EventData
         * @static
         * @param {server.EventData} message EventData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.platform = options.enums === String ? "UNKNOWN" : 0;
                object.version = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestampMs = options.longs === String ? "0" : 0;
                object.cc = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber(true) : message.uid;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.server.Platform[message.platform] : message.platform;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                if (typeof message.timestampMs === "number")
                    object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                else
                    object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber(true) : message.timestampMs;
            if (message.cc != null && message.hasOwnProperty("cc"))
                object.cc = message.cc;
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload")) {
                object.mediaUpload = $root.server.MediaUpload.toObject(message.mediaUpload, options);
                if (options.oneofs)
                    object.edata = "mediaUpload";
            }
            if (message.mediaDownload != null && message.hasOwnProperty("mediaDownload")) {
                object.mediaDownload = $root.server.MediaDownload.toObject(message.mediaDownload, options);
                if (options.oneofs)
                    object.edata = "mediaDownload";
            }
            if (message.mediaComposeLoad != null && message.hasOwnProperty("mediaComposeLoad")) {
                object.mediaComposeLoad = $root.server.MediaComposeLoad.toObject(message.mediaComposeLoad, options);
                if (options.oneofs)
                    object.edata = "mediaComposeLoad";
            }
            if (message.pushReceived != null && message.hasOwnProperty("pushReceived")) {
                object.pushReceived = $root.server.PushReceived.toObject(message.pushReceived, options);
                if (options.oneofs)
                    object.edata = "pushReceived";
            }
            if (message.decryptionReport != null && message.hasOwnProperty("decryptionReport")) {
                object.decryptionReport = $root.server.DecryptionReport.toObject(message.decryptionReport, options);
                if (options.oneofs)
                    object.edata = "decryptionReport";
            }
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                object.permissions = $root.server.Permissions.toObject(message.permissions, options);
                if (options.oneofs)
                    object.edata = "permissions";
            }
            if (message.mediaObjectDownload != null && message.hasOwnProperty("mediaObjectDownload")) {
                object.mediaObjectDownload = $root.server.MediaObjectDownload.toObject(message.mediaObjectDownload, options);
                if (options.oneofs)
                    object.edata = "mediaObjectDownload";
            }
            if (message.groupDecryptionReport != null && message.hasOwnProperty("groupDecryptionReport")) {
                object.groupDecryptionReport = $root.server.GroupDecryptionReport.toObject(message.groupDecryptionReport, options);
                if (options.oneofs)
                    object.edata = "groupDecryptionReport";
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                object.call = $root.server.Call.toObject(message.call, options);
                if (options.oneofs)
                    object.edata = "call";
            }
            if (message.fabAction != null && message.hasOwnProperty("fabAction")) {
                object.fabAction = $root.server.FabAction.toObject(message.fabAction, options);
                if (options.oneofs)
                    object.edata = "fabAction";
            }
            if (message.groupHistoryReport != null && message.hasOwnProperty("groupHistoryReport")) {
                object.groupHistoryReport = $root.server.GroupHistoryReport.toObject(message.groupHistoryReport, options);
                if (options.oneofs)
                    object.edata = "groupHistoryReport";
            }
            return object;
        };

        /**
         * Converts this EventData to JSON.
         * @function toJSON
         * @memberof server.EventData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventData;
    })();

    /**
     * Platform enum.
     * @name server.Platform
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} IOS=1 IOS value
     * @property {number} ANDROID=2 ANDROID value
     */
    server.Platform = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "IOS"] = 1;
        values[valuesById[2] = "ANDROID"] = 2;
        return values;
    })();

    server.MediaObjectDownload = (function() {

        /**
         * Properties of a MediaObjectDownload.
         * @memberof server
         * @interface IMediaObjectDownload
         * @property {string|null} [id] MediaObjectDownload id
         * @property {number|Long|null} [index] MediaObjectDownload index
         * @property {server.MediaObjectDownload.Type|null} [type] MediaObjectDownload type
         * @property {server.MediaObjectDownload.MediaType|null} [mediaType] MediaObjectDownload mediaType
         * @property {number|Long|null} [durationMs] MediaObjectDownload durationMs
         * @property {number|Long|null} [size] MediaObjectDownload size
         * @property {number|Long|null} [progressBytes] MediaObjectDownload progressBytes
         * @property {server.MediaObjectDownload.Cdn|null} [cdn] MediaObjectDownload cdn
         * @property {string|null} [cdnPop] MediaObjectDownload cdnPop
         * @property {string|null} [cdnId] MediaObjectDownload cdnId
         * @property {server.MediaObjectDownload.CdnCache|null} [cdnCache] MediaObjectDownload cdnCache
         * @property {server.MediaObjectDownload.Status|null} [status] MediaObjectDownload status
         * @property {number|Long|null} [retryCount] MediaObjectDownload retryCount
         */

        /**
         * Constructs a new MediaObjectDownload.
         * @memberof server
         * @classdesc Represents a MediaObjectDownload.
         * @implements IMediaObjectDownload
         * @constructor
         * @param {server.IMediaObjectDownload=} [properties] Properties to set
         */
        function MediaObjectDownload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaObjectDownload id.
         * @member {string} id
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.id = "";

        /**
         * MediaObjectDownload index.
         * @member {number|Long} index
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload type.
         * @member {server.MediaObjectDownload.Type} type
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.type = 0;

        /**
         * MediaObjectDownload mediaType.
         * @member {server.MediaObjectDownload.MediaType} mediaType
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.mediaType = 0;

        /**
         * MediaObjectDownload durationMs.
         * @member {number|Long} durationMs
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.durationMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload size.
         * @member {number|Long} size
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload progressBytes.
         * @member {number|Long} progressBytes
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.progressBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MediaObjectDownload cdn.
         * @member {server.MediaObjectDownload.Cdn} cdn
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdn = 0;

        /**
         * MediaObjectDownload cdnPop.
         * @member {string} cdnPop
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnPop = "";

        /**
         * MediaObjectDownload cdnId.
         * @member {string} cdnId
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnId = "";

        /**
         * MediaObjectDownload cdnCache.
         * @member {server.MediaObjectDownload.CdnCache} cdnCache
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.cdnCache = 0;

        /**
         * MediaObjectDownload status.
         * @member {server.MediaObjectDownload.Status} status
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.status = 0;

        /**
         * MediaObjectDownload retryCount.
         * @member {number|Long} retryCount
         * @memberof server.MediaObjectDownload
         * @instance
         */
        MediaObjectDownload.prototype.retryCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new MediaObjectDownload instance using the specified properties.
         * @function create
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload=} [properties] Properties to set
         * @returns {server.MediaObjectDownload} MediaObjectDownload instance
         */
        MediaObjectDownload.create = function create(properties) {
            return new MediaObjectDownload(properties);
        };

        /**
         * Encodes the specified MediaObjectDownload message. Does not implicitly {@link server.MediaObjectDownload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload} message MediaObjectDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaObjectDownload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mediaType);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.durationMs);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.size);
            if (message.progressBytes != null && Object.hasOwnProperty.call(message, "progressBytes"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.progressBytes);
            if (message.cdn != null && Object.hasOwnProperty.call(message, "cdn"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.cdn);
            if (message.cdnPop != null && Object.hasOwnProperty.call(message, "cdnPop"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.cdnPop);
            if (message.cdnId != null && Object.hasOwnProperty.call(message, "cdnId"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.cdnId);
            if (message.cdnCache != null && Object.hasOwnProperty.call(message, "cdnCache"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.cdnCache);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaObjectDownload message, length delimited. Does not implicitly {@link server.MediaObjectDownload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.IMediaObjectDownload} message MediaObjectDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaObjectDownload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaObjectDownload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaObjectDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaObjectDownload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaObjectDownload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.index = reader.uint64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.mediaType = reader.int32();
                    break;
                case 5:
                    message.durationMs = reader.uint64();
                    break;
                case 6:
                    message.size = reader.uint64();
                    break;
                case 7:
                    message.progressBytes = reader.uint64();
                    break;
                case 8:
                    message.cdn = reader.int32();
                    break;
                case 9:
                    message.cdnPop = reader.string();
                    break;
                case 10:
                    message.cdnId = reader.string();
                    break;
                case 11:
                    message.cdnCache = reader.int32();
                    break;
                case 12:
                    message.status = reader.int32();
                    break;
                case 13:
                    message.retryCount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaObjectDownload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaObjectDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaObjectDownload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaObjectDownload message.
         * @function verify
         * @memberof server.MediaObjectDownload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaObjectDownload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))
                    return "durationMs: integer|Long expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                    return "size: integer|Long expected";
            if (message.progressBytes != null && message.hasOwnProperty("progressBytes"))
                if (!$util.isInteger(message.progressBytes) && !(message.progressBytes && $util.isInteger(message.progressBytes.low) && $util.isInteger(message.progressBytes.high)))
                    return "progressBytes: integer|Long expected";
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                switch (message.cdn) {
                default:
                    return "cdn: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.cdnPop != null && message.hasOwnProperty("cdnPop"))
                if (!$util.isString(message.cdnPop))
                    return "cdnPop: string expected";
            if (message.cdnId != null && message.hasOwnProperty("cdnId"))
                if (!$util.isString(message.cdnId))
                    return "cdnId: string expected";
            if (message.cdnCache != null && message.hasOwnProperty("cdnCache"))
                switch (message.cdnCache) {
                default:
                    return "cdnCache: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount) && !(message.retryCount && $util.isInteger(message.retryCount.low) && $util.isInteger(message.retryCount.high)))
                    return "retryCount: integer|Long expected";
            return null;
        };

        /**
         * Creates a MediaObjectDownload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaObjectDownload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaObjectDownload} MediaObjectDownload
         */
        MediaObjectDownload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaObjectDownload)
                return object;
            var message = new $root.server.MediaObjectDownload();
            if (object.id != null)
                message.id = String(object.id);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            switch (object.mediaType) {
            case "PHOTO":
            case 0:
                message.mediaType = 0;
                break;
            case "VIDEO":
            case 1:
                message.mediaType = 1;
                break;
            case "AUDIO":
            case 2:
                message.mediaType = 2;
                break;
            }
            if (object.durationMs != null)
                if ($util.Long)
                    (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = true;
                else if (typeof object.durationMs === "string")
                    message.durationMs = parseInt(object.durationMs, 10);
                else if (typeof object.durationMs === "number")
                    message.durationMs = object.durationMs;
                else if (typeof object.durationMs === "object")
                    message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber(true);
            if (object.size != null)
                if ($util.Long)
                    (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                else if (typeof object.size === "string")
                    message.size = parseInt(object.size, 10);
                else if (typeof object.size === "number")
                    message.size = object.size;
                else if (typeof object.size === "object")
                    message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
            if (object.progressBytes != null)
                if ($util.Long)
                    (message.progressBytes = $util.Long.fromValue(object.progressBytes)).unsigned = true;
                else if (typeof object.progressBytes === "string")
                    message.progressBytes = parseInt(object.progressBytes, 10);
                else if (typeof object.progressBytes === "number")
                    message.progressBytes = object.progressBytes;
                else if (typeof object.progressBytes === "object")
                    message.progressBytes = new $util.LongBits(object.progressBytes.low >>> 0, object.progressBytes.high >>> 0).toNumber(true);
            switch (object.cdn) {
            case "UNKNOWN_CDN":
            case 0:
                message.cdn = 0;
                break;
            case "CLOUDFRONT":
            case 1:
                message.cdn = 1;
                break;
            }
            if (object.cdnPop != null)
                message.cdnPop = String(object.cdnPop);
            if (object.cdnId != null)
                message.cdnId = String(object.cdnId);
            switch (object.cdnCache) {
            case "UNKNOWN_CACHE":
            case 0:
                message.cdnCache = 0;
                break;
            case "HIT":
            case 1:
                message.cdnCache = 1;
                break;
            case "MISS":
            case 2:
                message.cdnCache = 2;
                break;
            case "REFRESH_HIT":
            case 3:
                message.cdnCache = 3;
                break;
            case "REFRESH_MISS":
            case 4:
                message.cdnCache = 4;
                break;
            }
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                if ($util.Long)
                    (message.retryCount = $util.Long.fromValue(object.retryCount)).unsigned = true;
                else if (typeof object.retryCount === "string")
                    message.retryCount = parseInt(object.retryCount, 10);
                else if (typeof object.retryCount === "number")
                    message.retryCount = object.retryCount;
                else if (typeof object.retryCount === "object")
                    message.retryCount = new $util.LongBits(object.retryCount.low >>> 0, object.retryCount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a MediaObjectDownload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaObjectDownload
         * @static
         * @param {server.MediaObjectDownload} message MediaObjectDownload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaObjectDownload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "POST" : 0;
                object.mediaType = options.enums === String ? "PHOTO" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.durationMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.durationMs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.size = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.progressBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.progressBytes = options.longs === String ? "0" : 0;
                object.cdn = options.enums === String ? "UNKNOWN_CDN" : 0;
                object.cdnPop = "";
                object.cdnId = "";
                object.cdnCache = options.enums === String ? "UNKNOWN_CACHE" : 0;
                object.status = options.enums === String ? "OK" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.retryCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.retryCount = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaObjectDownload.Type[message.type] : message.type;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.server.MediaObjectDownload.MediaType[message.mediaType] : message.mediaType;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (typeof message.durationMs === "number")
                    object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;
                else
                    object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber(true) : message.durationMs;
            if (message.size != null && message.hasOwnProperty("size"))
                if (typeof message.size === "number")
                    object.size = options.longs === String ? String(message.size) : message.size;
                else
                    object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
            if (message.progressBytes != null && message.hasOwnProperty("progressBytes"))
                if (typeof message.progressBytes === "number")
                    object.progressBytes = options.longs === String ? String(message.progressBytes) : message.progressBytes;
                else
                    object.progressBytes = options.longs === String ? $util.Long.prototype.toString.call(message.progressBytes) : options.longs === Number ? new $util.LongBits(message.progressBytes.low >>> 0, message.progressBytes.high >>> 0).toNumber(true) : message.progressBytes;
            if (message.cdn != null && message.hasOwnProperty("cdn"))
                object.cdn = options.enums === String ? $root.server.MediaObjectDownload.Cdn[message.cdn] : message.cdn;
            if (message.cdnPop != null && message.hasOwnProperty("cdnPop"))
                object.cdnPop = message.cdnPop;
            if (message.cdnId != null && message.hasOwnProperty("cdnId"))
                object.cdnId = message.cdnId;
            if (message.cdnCache != null && message.hasOwnProperty("cdnCache"))
                object.cdnCache = options.enums === String ? $root.server.MediaObjectDownload.CdnCache[message.cdnCache] : message.cdnCache;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaObjectDownload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (typeof message.retryCount === "number")
                    object.retryCount = options.longs === String ? String(message.retryCount) : message.retryCount;
                else
                    object.retryCount = options.longs === String ? $util.Long.prototype.toString.call(message.retryCount) : options.longs === Number ? new $util.LongBits(message.retryCount.low >>> 0, message.retryCount.high >>> 0).toNumber(true) : message.retryCount;
            return object;
        };

        /**
         * Converts this MediaObjectDownload to JSON.
         * @function toJSON
         * @memberof server.MediaObjectDownload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaObjectDownload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaObjectDownload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaObjectDownload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * MediaType enum.
         * @name server.MediaObjectDownload.MediaType
         * @enum {number}
         * @property {number} PHOTO=0 PHOTO value
         * @property {number} VIDEO=1 VIDEO value
         * @property {number} AUDIO=2 AUDIO value
         */
        MediaObjectDownload.MediaType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PHOTO"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            values[valuesById[2] = "AUDIO"] = 2;
            return values;
        })();

        /**
         * Cdn enum.
         * @name server.MediaObjectDownload.Cdn
         * @enum {number}
         * @property {number} UNKNOWN_CDN=0 UNKNOWN_CDN value
         * @property {number} CLOUDFRONT=1 CLOUDFRONT value
         */
        MediaObjectDownload.Cdn = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CDN"] = 0;
            values[valuesById[1] = "CLOUDFRONT"] = 1;
            return values;
        })();

        /**
         * CdnCache enum.
         * @name server.MediaObjectDownload.CdnCache
         * @enum {number}
         * @property {number} UNKNOWN_CACHE=0 UNKNOWN_CACHE value
         * @property {number} HIT=1 HIT value
         * @property {number} MISS=2 MISS value
         * @property {number} REFRESH_HIT=3 REFRESH_HIT value
         * @property {number} REFRESH_MISS=4 REFRESH_MISS value
         */
        MediaObjectDownload.CdnCache = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CACHE"] = 0;
            values[valuesById[1] = "HIT"] = 1;
            values[valuesById[2] = "MISS"] = 2;
            values[valuesById[3] = "REFRESH_HIT"] = 3;
            values[valuesById[4] = "REFRESH_MISS"] = 4;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaObjectDownload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaObjectDownload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaObjectDownload;
    })();

    server.MediaUpload = (function() {

        /**
         * Properties of a MediaUpload.
         * @memberof server
         * @interface IMediaUpload
         * @property {string|null} [id] MediaUpload id
         * @property {server.MediaUpload.Type|null} [type] MediaUpload type
         * @property {number|null} [durationMs] MediaUpload durationMs
         * @property {number|null} [numPhotos] MediaUpload numPhotos
         * @property {number|null} [numVideos] MediaUpload numVideos
         * @property {number|null} [totalSize] MediaUpload totalSize
         * @property {server.MediaUpload.Status|null} [status] MediaUpload status
         * @property {number|null} [retryCount] MediaUpload retryCount
         */

        /**
         * Constructs a new MediaUpload.
         * @memberof server
         * @classdesc Represents a MediaUpload.
         * @implements IMediaUpload
         * @constructor
         * @param {server.IMediaUpload=} [properties] Properties to set
         */
        function MediaUpload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaUpload id.
         * @member {string} id
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.id = "";

        /**
         * MediaUpload type.
         * @member {server.MediaUpload.Type} type
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.type = 0;

        /**
         * MediaUpload durationMs.
         * @member {number} durationMs
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.durationMs = 0;

        /**
         * MediaUpload numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.numPhotos = 0;

        /**
         * MediaUpload numVideos.
         * @member {number} numVideos
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.numVideos = 0;

        /**
         * MediaUpload totalSize.
         * @member {number} totalSize
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.totalSize = 0;

        /**
         * MediaUpload status.
         * @member {server.MediaUpload.Status} status
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.status = 0;

        /**
         * MediaUpload retryCount.
         * @member {number} retryCount
         * @memberof server.MediaUpload
         * @instance
         */
        MediaUpload.prototype.retryCount = 0;

        /**
         * Creates a new MediaUpload instance using the specified properties.
         * @function create
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload=} [properties] Properties to set
         * @returns {server.MediaUpload} MediaUpload instance
         */
        MediaUpload.create = function create(properties) {
            return new MediaUpload(properties);
        };

        /**
         * Encodes the specified MediaUpload message. Does not implicitly {@link server.MediaUpload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload} message MediaUpload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUpload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.totalSize);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaUpload message, length delimited. Does not implicitly {@link server.MediaUpload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaUpload
         * @static
         * @param {server.IMediaUpload} message MediaUpload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaUpload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaUpload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaUpload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaUpload} MediaUpload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUpload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaUpload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.durationMs = reader.uint32();
                    break;
                case 4:
                    message.numPhotos = reader.uint32();
                    break;
                case 5:
                    message.numVideos = reader.uint32();
                    break;
                case 6:
                    message.totalSize = reader.uint32();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.retryCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaUpload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaUpload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaUpload} MediaUpload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaUpload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaUpload message.
         * @function verify
         * @memberof server.MediaUpload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaUpload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            return null;
        };

        /**
         * Creates a MediaUpload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaUpload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaUpload} MediaUpload
         */
        MediaUpload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaUpload)
                return object;
            var message = new $root.server.MediaUpload();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaUpload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaUpload
         * @static
         * @param {server.MediaUpload} message MediaUpload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaUpload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "POST" : 0;
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
                object.status = options.enums === String ? "OK" : 0;
                object.retryCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaUpload.Type[message.type] : message.type;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaUpload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            return object;
        };

        /**
         * Converts this MediaUpload to JSON.
         * @function toJSON
         * @memberof server.MediaUpload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaUpload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaUpload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaUpload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaUpload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaUpload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaUpload;
    })();

    server.MediaDownload = (function() {

        /**
         * Properties of a MediaDownload.
         * @memberof server
         * @interface IMediaDownload
         * @property {string|null} [id] MediaDownload id
         * @property {server.MediaDownload.Type|null} [type] MediaDownload type
         * @property {number|null} [durationMs] MediaDownload durationMs
         * @property {number|null} [numPhotos] MediaDownload numPhotos
         * @property {number|null} [numVideos] MediaDownload numVideos
         * @property {number|null} [totalSize] MediaDownload totalSize
         * @property {server.MediaDownload.Status|null} [status] MediaDownload status
         * @property {number|null} [retryCount] MediaDownload retryCount
         */

        /**
         * Constructs a new MediaDownload.
         * @memberof server
         * @classdesc Represents a MediaDownload.
         * @implements IMediaDownload
         * @constructor
         * @param {server.IMediaDownload=} [properties] Properties to set
         */
        function MediaDownload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaDownload id.
         * @member {string} id
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.id = "";

        /**
         * MediaDownload type.
         * @member {server.MediaDownload.Type} type
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.type = 0;

        /**
         * MediaDownload durationMs.
         * @member {number} durationMs
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.durationMs = 0;

        /**
         * MediaDownload numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.numPhotos = 0;

        /**
         * MediaDownload numVideos.
         * @member {number} numVideos
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.numVideos = 0;

        /**
         * MediaDownload totalSize.
         * @member {number} totalSize
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.totalSize = 0;

        /**
         * MediaDownload status.
         * @member {server.MediaDownload.Status} status
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.status = 0;

        /**
         * MediaDownload retryCount.
         * @member {number} retryCount
         * @memberof server.MediaDownload
         * @instance
         */
        MediaDownload.prototype.retryCount = 0;

        /**
         * Creates a new MediaDownload instance using the specified properties.
         * @function create
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload=} [properties] Properties to set
         * @returns {server.MediaDownload} MediaDownload instance
         */
        MediaDownload.create = function create(properties) {
            return new MediaDownload(properties);
        };

        /**
         * Encodes the specified MediaDownload message. Does not implicitly {@link server.MediaDownload.verify|verify} messages.
         * @function encode
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload} message MediaDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaDownload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.totalSize);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
            if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.retryCount);
            return writer;
        };

        /**
         * Encodes the specified MediaDownload message, length delimited. Does not implicitly {@link server.MediaDownload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaDownload
         * @static
         * @param {server.IMediaDownload} message MediaDownload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaDownload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaDownload message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaDownload} MediaDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaDownload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaDownload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.durationMs = reader.uint32();
                    break;
                case 4:
                    message.numPhotos = reader.uint32();
                    break;
                case 5:
                    message.numVideos = reader.uint32();
                    break;
                case 6:
                    message.totalSize = reader.uint32();
                    break;
                case 7:
                    message.status = reader.int32();
                    break;
                case 8:
                    message.retryCount = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaDownload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaDownload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaDownload} MediaDownload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaDownload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaDownload message.
         * @function verify
         * @memberof server.MediaDownload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaDownload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                if (!$util.isInteger(message.retryCount))
                    return "retryCount: integer expected";
            return null;
        };

        /**
         * Creates a MediaDownload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaDownload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaDownload} MediaDownload
         */
        MediaDownload.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaDownload)
                return object;
            var message = new $root.server.MediaDownload();
            if (object.id != null)
                message.id = String(object.id);
            switch (object.type) {
            case "POST":
            case 0:
                message.type = 0;
                break;
            case "MESSAGE":
            case 1:
                message.type = 1;
                break;
            case "COMMENT":
            case 2:
                message.type = 2;
                break;
            }
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            switch (object.status) {
            case "OK":
            case 0:
                message.status = 0;
                break;
            case "FAIL":
            case 1:
                message.status = 1;
                break;
            }
            if (object.retryCount != null)
                message.retryCount = object.retryCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaDownload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaDownload
         * @static
         * @param {server.MediaDownload} message MediaDownload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaDownload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.type = options.enums === String ? "POST" : 0;
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
                object.status = options.enums === String ? "OK" : 0;
                object.retryCount = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.MediaDownload.Type[message.type] : message.type;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.MediaDownload.Status[message.status] : message.status;
            if (message.retryCount != null && message.hasOwnProperty("retryCount"))
                object.retryCount = message.retryCount;
            return object;
        };

        /**
         * Converts this MediaDownload to JSON.
         * @function toJSON
         * @memberof server.MediaDownload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaDownload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.MediaDownload.Type
         * @enum {number}
         * @property {number} POST=0 POST value
         * @property {number} MESSAGE=1 MESSAGE value
         * @property {number} COMMENT=2 COMMENT value
         */
        MediaDownload.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POST"] = 0;
            values[valuesById[1] = "MESSAGE"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            return values;
        })();

        /**
         * Status enum.
         * @name server.MediaDownload.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        MediaDownload.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        return MediaDownload;
    })();

    server.MediaComposeLoad = (function() {

        /**
         * Properties of a MediaComposeLoad.
         * @memberof server
         * @interface IMediaComposeLoad
         * @property {number|null} [durationMs] MediaComposeLoad durationMs
         * @property {number|null} [numPhotos] MediaComposeLoad numPhotos
         * @property {number|null} [numVideos] MediaComposeLoad numVideos
         * @property {number|null} [totalSize] MediaComposeLoad totalSize
         */

        /**
         * Constructs a new MediaComposeLoad.
         * @memberof server
         * @classdesc Represents a MediaComposeLoad.
         * @implements IMediaComposeLoad
         * @constructor
         * @param {server.IMediaComposeLoad=} [properties] Properties to set
         */
        function MediaComposeLoad(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MediaComposeLoad durationMs.
         * @member {number} durationMs
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.durationMs = 0;

        /**
         * MediaComposeLoad numPhotos.
         * @member {number} numPhotos
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.numPhotos = 0;

        /**
         * MediaComposeLoad numVideos.
         * @member {number} numVideos
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.numVideos = 0;

        /**
         * MediaComposeLoad totalSize.
         * @member {number} totalSize
         * @memberof server.MediaComposeLoad
         * @instance
         */
        MediaComposeLoad.prototype.totalSize = 0;

        /**
         * Creates a new MediaComposeLoad instance using the specified properties.
         * @function create
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad=} [properties] Properties to set
         * @returns {server.MediaComposeLoad} MediaComposeLoad instance
         */
        MediaComposeLoad.create = function create(properties) {
            return new MediaComposeLoad(properties);
        };

        /**
         * Encodes the specified MediaComposeLoad message. Does not implicitly {@link server.MediaComposeLoad.verify|verify} messages.
         * @function encode
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad} message MediaComposeLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaComposeLoad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.durationMs);
            if (message.numPhotos != null && Object.hasOwnProperty.call(message, "numPhotos"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numPhotos);
            if (message.numVideos != null && Object.hasOwnProperty.call(message, "numVideos"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numVideos);
            if (message.totalSize != null && Object.hasOwnProperty.call(message, "totalSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.totalSize);
            return writer;
        };

        /**
         * Encodes the specified MediaComposeLoad message, length delimited. Does not implicitly {@link server.MediaComposeLoad.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.IMediaComposeLoad} message MediaComposeLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MediaComposeLoad.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MediaComposeLoad message from the specified reader or buffer.
         * @function decode
         * @memberof server.MediaComposeLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaComposeLoad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.MediaComposeLoad();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.durationMs = reader.uint32();
                    break;
                case 2:
                    message.numPhotos = reader.uint32();
                    break;
                case 3:
                    message.numVideos = reader.uint32();
                    break;
                case 4:
                    message.totalSize = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MediaComposeLoad message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.MediaComposeLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MediaComposeLoad.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MediaComposeLoad message.
         * @function verify
         * @memberof server.MediaComposeLoad
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MediaComposeLoad.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs))
                    return "durationMs: integer expected";
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                if (!$util.isInteger(message.numPhotos))
                    return "numPhotos: integer expected";
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                if (!$util.isInteger(message.numVideos))
                    return "numVideos: integer expected";
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                if (!$util.isInteger(message.totalSize))
                    return "totalSize: integer expected";
            return null;
        };

        /**
         * Creates a MediaComposeLoad message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.MediaComposeLoad
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.MediaComposeLoad} MediaComposeLoad
         */
        MediaComposeLoad.fromObject = function fromObject(object) {
            if (object instanceof $root.server.MediaComposeLoad)
                return object;
            var message = new $root.server.MediaComposeLoad();
            if (object.durationMs != null)
                message.durationMs = object.durationMs >>> 0;
            if (object.numPhotos != null)
                message.numPhotos = object.numPhotos >>> 0;
            if (object.numVideos != null)
                message.numVideos = object.numVideos >>> 0;
            if (object.totalSize != null)
                message.totalSize = object.totalSize >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MediaComposeLoad message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.MediaComposeLoad
         * @static
         * @param {server.MediaComposeLoad} message MediaComposeLoad
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MediaComposeLoad.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.durationMs = 0;
                object.numPhotos = 0;
                object.numVideos = 0;
                object.totalSize = 0;
            }
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                object.durationMs = message.durationMs;
            if (message.numPhotos != null && message.hasOwnProperty("numPhotos"))
                object.numPhotos = message.numPhotos;
            if (message.numVideos != null && message.hasOwnProperty("numVideos"))
                object.numVideos = message.numVideos;
            if (message.totalSize != null && message.hasOwnProperty("totalSize"))
                object.totalSize = message.totalSize;
            return object;
        };

        /**
         * Converts this MediaComposeLoad to JSON.
         * @function toJSON
         * @memberof server.MediaComposeLoad
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MediaComposeLoad.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MediaComposeLoad;
    })();

    server.PushReceived = (function() {

        /**
         * Properties of a PushReceived.
         * @memberof server
         * @interface IPushReceived
         * @property {string|null} [id] PushReceived id
         * @property {number|Long|null} [clientTimestamp] PushReceived clientTimestamp
         */

        /**
         * Constructs a new PushReceived.
         * @memberof server
         * @classdesc Represents a PushReceived.
         * @implements IPushReceived
         * @constructor
         * @param {server.IPushReceived=} [properties] Properties to set
         */
        function PushReceived(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReceived id.
         * @member {string} id
         * @memberof server.PushReceived
         * @instance
         */
        PushReceived.prototype.id = "";

        /**
         * PushReceived clientTimestamp.
         * @member {number|Long} clientTimestamp
         * @memberof server.PushReceived
         * @instance
         */
        PushReceived.prototype.clientTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PushReceived instance using the specified properties.
         * @function create
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived=} [properties] Properties to set
         * @returns {server.PushReceived} PushReceived instance
         */
        PushReceived.create = function create(properties) {
            return new PushReceived(properties);
        };

        /**
         * Encodes the specified PushReceived message. Does not implicitly {@link server.PushReceived.verify|verify} messages.
         * @function encode
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived} message PushReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReceived.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.clientTimestamp != null && Object.hasOwnProperty.call(message, "clientTimestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clientTimestamp);
            return writer;
        };

        /**
         * Encodes the specified PushReceived message, length delimited. Does not implicitly {@link server.PushReceived.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.PushReceived
         * @static
         * @param {server.IPushReceived} message PushReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReceived.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushReceived message from the specified reader or buffer.
         * @function decode
         * @memberof server.PushReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.PushReceived} PushReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReceived.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.PushReceived();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.clientTimestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushReceived message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.PushReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.PushReceived} PushReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReceived.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushReceived message.
         * @function verify
         * @memberof server.PushReceived
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushReceived.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (!$util.isInteger(message.clientTimestamp) && !(message.clientTimestamp && $util.isInteger(message.clientTimestamp.low) && $util.isInteger(message.clientTimestamp.high)))
                    return "clientTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PushReceived message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.PushReceived
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.PushReceived} PushReceived
         */
        PushReceived.fromObject = function fromObject(object) {
            if (object instanceof $root.server.PushReceived)
                return object;
            var message = new $root.server.PushReceived();
            if (object.id != null)
                message.id = String(object.id);
            if (object.clientTimestamp != null)
                if ($util.Long)
                    (message.clientTimestamp = $util.Long.fromValue(object.clientTimestamp)).unsigned = true;
                else if (typeof object.clientTimestamp === "string")
                    message.clientTimestamp = parseInt(object.clientTimestamp, 10);
                else if (typeof object.clientTimestamp === "number")
                    message.clientTimestamp = object.clientTimestamp;
                else if (typeof object.clientTimestamp === "object")
                    message.clientTimestamp = new $util.LongBits(object.clientTimestamp.low >>> 0, object.clientTimestamp.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a PushReceived message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.PushReceived
         * @static
         * @param {server.PushReceived} message PushReceived
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushReceived.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.clientTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.clientTimestamp != null && message.hasOwnProperty("clientTimestamp"))
                if (typeof message.clientTimestamp === "number")
                    object.clientTimestamp = options.longs === String ? String(message.clientTimestamp) : message.clientTimestamp;
                else
                    object.clientTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.clientTimestamp) : options.longs === Number ? new $util.LongBits(message.clientTimestamp.low >>> 0, message.clientTimestamp.high >>> 0).toNumber(true) : message.clientTimestamp;
            return object;
        };

        /**
         * Converts this PushReceived to JSON.
         * @function toJSON
         * @memberof server.PushReceived
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushReceived.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushReceived;
    })();

    server.DecryptionReport = (function() {

        /**
         * Properties of a DecryptionReport.
         * @memberof server
         * @interface IDecryptionReport
         * @property {server.DecryptionReport.Status|null} [result] DecryptionReport result
         * @property {string|null} [reason] DecryptionReport reason
         * @property {string|null} [msgId] DecryptionReport msgId
         * @property {string|null} [originalVersion] DecryptionReport originalVersion
         * @property {server.Platform|null} [senderPlatform] DecryptionReport senderPlatform
         * @property {string|null} [senderVersion] DecryptionReport senderVersion
         * @property {number|null} [rerequestCount] DecryptionReport rerequestCount
         * @property {number|null} [timeTakenS] DecryptionReport timeTakenS
         * @property {boolean|null} [isSilent] DecryptionReport isSilent
         * @property {server.DecryptionReport.ContentType|null} [contentType] DecryptionReport contentType
         */

        /**
         * Constructs a new DecryptionReport.
         * @memberof server
         * @classdesc Represents a DecryptionReport.
         * @implements IDecryptionReport
         * @constructor
         * @param {server.IDecryptionReport=} [properties] Properties to set
         */
        function DecryptionReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecryptionReport result.
         * @member {server.DecryptionReport.Status} result
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.result = 0;

        /**
         * DecryptionReport reason.
         * @member {string} reason
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.reason = "";

        /**
         * DecryptionReport msgId.
         * @member {string} msgId
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.msgId = "";

        /**
         * DecryptionReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.originalVersion = "";

        /**
         * DecryptionReport senderPlatform.
         * @member {server.Platform} senderPlatform
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.senderPlatform = 0;

        /**
         * DecryptionReport senderVersion.
         * @member {string} senderVersion
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.senderVersion = "";

        /**
         * DecryptionReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.rerequestCount = 0;

        /**
         * DecryptionReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.timeTakenS = 0;

        /**
         * DecryptionReport isSilent.
         * @member {boolean} isSilent
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.isSilent = false;

        /**
         * DecryptionReport contentType.
         * @member {server.DecryptionReport.ContentType} contentType
         * @memberof server.DecryptionReport
         * @instance
         */
        DecryptionReport.prototype.contentType = 0;

        /**
         * Creates a new DecryptionReport instance using the specified properties.
         * @function create
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport=} [properties] Properties to set
         * @returns {server.DecryptionReport} DecryptionReport instance
         */
        DecryptionReport.create = function create(properties) {
            return new DecryptionReport(properties);
        };

        /**
         * Encodes the specified DecryptionReport message. Does not implicitly {@link server.DecryptionReport.verify|verify} messages.
         * @function encode
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport} message DecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecryptionReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            if (message.msgId != null && Object.hasOwnProperty.call(message, "msgId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgId);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.originalVersion);
            if (message.senderPlatform != null && Object.hasOwnProperty.call(message, "senderPlatform"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.senderPlatform);
            if (message.senderVersion != null && Object.hasOwnProperty.call(message, "senderVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.senderVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeTakenS);
            if (message.isSilent != null && Object.hasOwnProperty.call(message, "isSilent"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSilent);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.contentType);
            return writer;
        };

        /**
         * Encodes the specified DecryptionReport message, length delimited. Does not implicitly {@link server.DecryptionReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.DecryptionReport
         * @static
         * @param {server.IDecryptionReport} message DecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecryptionReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecryptionReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.DecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.DecryptionReport} DecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecryptionReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.DecryptionReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.msgId = reader.string();
                    break;
                case 4:
                    message.originalVersion = reader.string();
                    break;
                case 5:
                    message.senderPlatform = reader.int32();
                    break;
                case 6:
                    message.senderVersion = reader.string();
                    break;
                case 7:
                    message.rerequestCount = reader.uint32();
                    break;
                case 8:
                    message.timeTakenS = reader.uint32();
                    break;
                case 9:
                    message.isSilent = reader.bool();
                    break;
                case 10:
                    message.contentType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DecryptionReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.DecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.DecryptionReport} DecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecryptionReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecryptionReport message.
         * @function verify
         * @memberof server.DecryptionReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecryptionReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                if (!$util.isString(message.msgId))
                    return "msgId: string expected";
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                switch (message.senderPlatform) {
                default:
                    return "senderPlatform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                if (!$util.isString(message.senderVersion))
                    return "senderVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.isSilent != null && message.hasOwnProperty("isSilent"))
                if (typeof message.isSilent !== "boolean")
                    return "isSilent: boolean expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a DecryptionReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.DecryptionReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.DecryptionReport} DecryptionReport
         */
        DecryptionReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.DecryptionReport)
                return object;
            var message = new $root.server.DecryptionReport();
            switch (object.result) {
            case "OK":
            case 0:
                message.result = 0;
                break;
            case "FAIL":
            case 1:
                message.result = 1;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.msgId != null)
                message.msgId = String(object.msgId);
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            switch (object.senderPlatform) {
            case "UNKNOWN":
            case 0:
                message.senderPlatform = 0;
                break;
            case "IOS":
            case 1:
                message.senderPlatform = 1;
                break;
            case "ANDROID":
            case 2:
                message.senderPlatform = 2;
                break;
            }
            if (object.senderVersion != null)
                message.senderVersion = String(object.senderVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            if (object.isSilent != null)
                message.isSilent = Boolean(object.isSilent);
            switch (object.contentType) {
            case "CHAT":
            case 0:
                message.contentType = 0;
                break;
            case "GROUP_HISTORY":
            case 1:
                message.contentType = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DecryptionReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.DecryptionReport
         * @static
         * @param {server.DecryptionReport} message DecryptionReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecryptionReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "OK" : 0;
                object.reason = "";
                object.msgId = "";
                object.originalVersion = "";
                object.senderPlatform = options.enums === String ? "UNKNOWN" : 0;
                object.senderVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.isSilent = false;
                object.contentType = options.enums === String ? "CHAT" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.DecryptionReport.Status[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.msgId != null && message.hasOwnProperty("msgId"))
                object.msgId = message.msgId;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                object.senderPlatform = options.enums === String ? $root.server.Platform[message.senderPlatform] : message.senderPlatform;
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                object.senderVersion = message.senderVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.isSilent != null && message.hasOwnProperty("isSilent"))
                object.isSilent = message.isSilent;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.server.DecryptionReport.ContentType[message.contentType] : message.contentType;
            return object;
        };

        /**
         * Converts this DecryptionReport to JSON.
         * @function toJSON
         * @memberof server.DecryptionReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecryptionReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.DecryptionReport.Status
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} FAIL=1 FAIL value
         */
        DecryptionReport.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            return values;
        })();

        /**
         * ContentType enum.
         * @name server.DecryptionReport.ContentType
         * @enum {number}
         * @property {number} CHAT=0 CHAT value
         * @property {number} GROUP_HISTORY=1 GROUP_HISTORY value
         */
        DecryptionReport.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CHAT"] = 0;
            values[valuesById[1] = "GROUP_HISTORY"] = 1;
            return values;
        })();

        return DecryptionReport;
    })();

    server.GroupDecryptionReport = (function() {

        /**
         * Properties of a GroupDecryptionReport.
         * @memberof server
         * @interface IGroupDecryptionReport
         * @property {server.GroupDecryptionReport.Status|null} [result] GroupDecryptionReport result
         * @property {string|null} [reason] GroupDecryptionReport reason
         * @property {string|null} [contentId] GroupDecryptionReport contentId
         * @property {string|null} [gid] GroupDecryptionReport gid
         * @property {server.GroupDecryptionReport.ItemType|null} [itemType] GroupDecryptionReport itemType
         * @property {string|null} [originalVersion] GroupDecryptionReport originalVersion
         * @property {number|null} [rerequestCount] GroupDecryptionReport rerequestCount
         * @property {number|null} [timeTakenS] GroupDecryptionReport timeTakenS
         * @property {server.Platform|null} [senderPlatform] GroupDecryptionReport senderPlatform
         * @property {string|null} [senderVersion] GroupDecryptionReport senderVersion
         * @property {server.GroupDecryptionReport.Schedule|null} [schedule] GroupDecryptionReport schedule
         */

        /**
         * Constructs a new GroupDecryptionReport.
         * @memberof server
         * @classdesc Represents a GroupDecryptionReport.
         * @implements IGroupDecryptionReport
         * @constructor
         * @param {server.IGroupDecryptionReport=} [properties] Properties to set
         */
        function GroupDecryptionReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupDecryptionReport result.
         * @member {server.GroupDecryptionReport.Status} result
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.result = 0;

        /**
         * GroupDecryptionReport reason.
         * @member {string} reason
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.reason = "";

        /**
         * GroupDecryptionReport contentId.
         * @member {string} contentId
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.contentId = "";

        /**
         * GroupDecryptionReport gid.
         * @member {string} gid
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.gid = "";

        /**
         * GroupDecryptionReport itemType.
         * @member {server.GroupDecryptionReport.ItemType} itemType
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.itemType = 0;

        /**
         * GroupDecryptionReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.originalVersion = "";

        /**
         * GroupDecryptionReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.rerequestCount = 0;

        /**
         * GroupDecryptionReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.timeTakenS = 0;

        /**
         * GroupDecryptionReport senderPlatform.
         * @member {server.Platform} senderPlatform
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.senderPlatform = 0;

        /**
         * GroupDecryptionReport senderVersion.
         * @member {string} senderVersion
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.senderVersion = "";

        /**
         * GroupDecryptionReport schedule.
         * @member {server.GroupDecryptionReport.Schedule} schedule
         * @memberof server.GroupDecryptionReport
         * @instance
         */
        GroupDecryptionReport.prototype.schedule = 0;

        /**
         * Creates a new GroupDecryptionReport instance using the specified properties.
         * @function create
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport=} [properties] Properties to set
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport instance
         */
        GroupDecryptionReport.create = function create(properties) {
            return new GroupDecryptionReport(properties);
        };

        /**
         * Encodes the specified GroupDecryptionReport message. Does not implicitly {@link server.GroupDecryptionReport.verify|verify} messages.
         * @function encode
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport} message GroupDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDecryptionReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
            if (message.contentId != null && Object.hasOwnProperty.call(message, "contentId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.contentId);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.gid);
            if (message.itemType != null && Object.hasOwnProperty.call(message, "itemType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.itemType);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.originalVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeTakenS);
            if (message.senderPlatform != null && Object.hasOwnProperty.call(message, "senderPlatform"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.senderPlatform);
            if (message.senderVersion != null && Object.hasOwnProperty.call(message, "senderVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.senderVersion);
            if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.schedule);
            return writer;
        };

        /**
         * Encodes the specified GroupDecryptionReport message, length delimited. Does not implicitly {@link server.GroupDecryptionReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.IGroupDecryptionReport} message GroupDecryptionReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupDecryptionReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupDecryptionReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDecryptionReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupDecryptionReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.contentId = reader.string();
                    break;
                case 4:
                    message.gid = reader.string();
                    break;
                case 5:
                    message.itemType = reader.int32();
                    break;
                case 6:
                    message.originalVersion = reader.string();
                    break;
                case 7:
                    message.rerequestCount = reader.uint32();
                    break;
                case 8:
                    message.timeTakenS = reader.uint32();
                    break;
                case 9:
                    message.senderPlatform = reader.int32();
                    break;
                case 10:
                    message.senderVersion = reader.string();
                    break;
                case 11:
                    message.schedule = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupDecryptionReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupDecryptionReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupDecryptionReport message.
         * @function verify
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupDecryptionReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                if (!$util.isString(message.contentId))
                    return "contentId: string expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                switch (message.itemType) {
                default:
                    return "itemType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                switch (message.senderPlatform) {
                default:
                    return "senderPlatform: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                if (!$util.isString(message.senderVersion))
                    return "senderVersion: string expected";
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                switch (message.schedule) {
                default:
                    return "schedule: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupDecryptionReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupDecryptionReport} GroupDecryptionReport
         */
        GroupDecryptionReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupDecryptionReport)
                return object;
            var message = new $root.server.GroupDecryptionReport();
            switch (object.result) {
            case "UNKNOWN_STATUS":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "FAIL":
            case 2:
                message.result = 2;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.contentId != null)
                message.contentId = String(object.contentId);
            if (object.gid != null)
                message.gid = String(object.gid);
            switch (object.itemType) {
            case "UNKNOWN_TYPE":
            case 0:
                message.itemType = 0;
                break;
            case "POST":
            case 1:
                message.itemType = 1;
                break;
            case "COMMENT":
            case 2:
                message.itemType = 2;
                break;
            case "HISTORY_RESEND":
            case 3:
                message.itemType = 3;
                break;
            }
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            switch (object.senderPlatform) {
            case "UNKNOWN":
            case 0:
                message.senderPlatform = 0;
                break;
            case "IOS":
            case 1:
                message.senderPlatform = 1;
                break;
            case "ANDROID":
            case 2:
                message.senderPlatform = 2;
                break;
            }
            if (object.senderVersion != null)
                message.senderVersion = String(object.senderVersion);
            switch (object.schedule) {
            case "DAILY":
            case 0:
                message.schedule = 0;
                break;
            case "RESULT_BASED":
            case 1:
                message.schedule = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupDecryptionReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupDecryptionReport
         * @static
         * @param {server.GroupDecryptionReport} message GroupDecryptionReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupDecryptionReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "UNKNOWN_STATUS" : 0;
                object.reason = "";
                object.contentId = "";
                object.gid = "";
                object.itemType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.originalVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.senderPlatform = options.enums === String ? "UNKNOWN" : 0;
                object.senderVersion = "";
                object.schedule = options.enums === String ? "DAILY" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.server.GroupDecryptionReport.Status[message.result] : message.result;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.contentId != null && message.hasOwnProperty("contentId"))
                object.contentId = message.contentId;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                object.itemType = options.enums === String ? $root.server.GroupDecryptionReport.ItemType[message.itemType] : message.itemType;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.senderPlatform != null && message.hasOwnProperty("senderPlatform"))
                object.senderPlatform = options.enums === String ? $root.server.Platform[message.senderPlatform] : message.senderPlatform;
            if (message.senderVersion != null && message.hasOwnProperty("senderVersion"))
                object.senderVersion = message.senderVersion;
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                object.schedule = options.enums === String ? $root.server.GroupDecryptionReport.Schedule[message.schedule] : message.schedule;
            return object;
        };

        /**
         * Converts this GroupDecryptionReport to JSON.
         * @function toJSON
         * @memberof server.GroupDecryptionReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupDecryptionReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name server.GroupDecryptionReport.Status
         * @enum {number}
         * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
         * @property {number} OK=1 OK value
         * @property {number} FAIL=2 FAIL value
         */
        GroupDecryptionReport.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "FAIL"] = 2;
            return values;
        })();

        /**
         * ItemType enum.
         * @name server.GroupDecryptionReport.ItemType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} POST=1 POST value
         * @property {number} COMMENT=2 COMMENT value
         * @property {number} HISTORY_RESEND=3 HISTORY_RESEND value
         */
        GroupDecryptionReport.ItemType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "POST"] = 1;
            values[valuesById[2] = "COMMENT"] = 2;
            values[valuesById[3] = "HISTORY_RESEND"] = 3;
            return values;
        })();

        /**
         * Schedule enum.
         * @name server.GroupDecryptionReport.Schedule
         * @enum {number}
         * @property {number} DAILY=0 DAILY value
         * @property {number} RESULT_BASED=1 RESULT_BASED value
         */
        GroupDecryptionReport.Schedule = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DAILY"] = 0;
            values[valuesById[1] = "RESULT_BASED"] = 1;
            return values;
        })();

        return GroupDecryptionReport;
    })();

    server.GroupHistoryReport = (function() {

        /**
         * Properties of a GroupHistoryReport.
         * @memberof server
         * @interface IGroupHistoryReport
         * @property {string|null} [gid] GroupHistoryReport gid
         * @property {number|null} [numExpected] GroupHistoryReport numExpected
         * @property {number|null} [numDecrypted] GroupHistoryReport numDecrypted
         * @property {string|null} [originalVersion] GroupHistoryReport originalVersion
         * @property {number|null} [rerequestCount] GroupHistoryReport rerequestCount
         * @property {number|null} [timeTakenS] GroupHistoryReport timeTakenS
         * @property {server.GroupHistoryReport.Schedule|null} [schedule] GroupHistoryReport schedule
         */

        /**
         * Constructs a new GroupHistoryReport.
         * @memberof server
         * @classdesc Represents a GroupHistoryReport.
         * @implements IGroupHistoryReport
         * @constructor
         * @param {server.IGroupHistoryReport=} [properties] Properties to set
         */
        function GroupHistoryReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupHistoryReport gid.
         * @member {string} gid
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.gid = "";

        /**
         * GroupHistoryReport numExpected.
         * @member {number} numExpected
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.numExpected = 0;

        /**
         * GroupHistoryReport numDecrypted.
         * @member {number} numDecrypted
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.numDecrypted = 0;

        /**
         * GroupHistoryReport originalVersion.
         * @member {string} originalVersion
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.originalVersion = "";

        /**
         * GroupHistoryReport rerequestCount.
         * @member {number} rerequestCount
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.rerequestCount = 0;

        /**
         * GroupHistoryReport timeTakenS.
         * @member {number} timeTakenS
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.timeTakenS = 0;

        /**
         * GroupHistoryReport schedule.
         * @member {server.GroupHistoryReport.Schedule} schedule
         * @memberof server.GroupHistoryReport
         * @instance
         */
        GroupHistoryReport.prototype.schedule = 0;

        /**
         * Creates a new GroupHistoryReport instance using the specified properties.
         * @function create
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport=} [properties] Properties to set
         * @returns {server.GroupHistoryReport} GroupHistoryReport instance
         */
        GroupHistoryReport.create = function create(properties) {
            return new GroupHistoryReport(properties);
        };

        /**
         * Encodes the specified GroupHistoryReport message. Does not implicitly {@link server.GroupHistoryReport.verify|verify} messages.
         * @function encode
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport} message GroupHistoryReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupHistoryReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gid);
            if (message.numExpected != null && Object.hasOwnProperty.call(message, "numExpected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numExpected);
            if (message.numDecrypted != null && Object.hasOwnProperty.call(message, "numDecrypted"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numDecrypted);
            if (message.originalVersion != null && Object.hasOwnProperty.call(message, "originalVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.originalVersion);
            if (message.rerequestCount != null && Object.hasOwnProperty.call(message, "rerequestCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.rerequestCount);
            if (message.timeTakenS != null && Object.hasOwnProperty.call(message, "timeTakenS"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.timeTakenS);
            if (message.schedule != null && Object.hasOwnProperty.call(message, "schedule"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.schedule);
            return writer;
        };

        /**
         * Encodes the specified GroupHistoryReport message, length delimited. Does not implicitly {@link server.GroupHistoryReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.IGroupHistoryReport} message GroupHistoryReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupHistoryReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupHistoryReport message from the specified reader or buffer.
         * @function decode
         * @memberof server.GroupHistoryReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupHistoryReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.GroupHistoryReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gid = reader.string();
                    break;
                case 2:
                    message.numExpected = reader.uint32();
                    break;
                case 3:
                    message.numDecrypted = reader.uint32();
                    break;
                case 4:
                    message.originalVersion = reader.string();
                    break;
                case 5:
                    message.rerequestCount = reader.uint32();
                    break;
                case 6:
                    message.timeTakenS = reader.uint32();
                    break;
                case 7:
                    message.schedule = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupHistoryReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.GroupHistoryReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupHistoryReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupHistoryReport message.
         * @function verify
         * @memberof server.GroupHistoryReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupHistoryReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            if (message.numExpected != null && message.hasOwnProperty("numExpected"))
                if (!$util.isInteger(message.numExpected))
                    return "numExpected: integer expected";
            if (message.numDecrypted != null && message.hasOwnProperty("numDecrypted"))
                if (!$util.isInteger(message.numDecrypted))
                    return "numDecrypted: integer expected";
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                if (!$util.isString(message.originalVersion))
                    return "originalVersion: string expected";
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                if (!$util.isInteger(message.rerequestCount))
                    return "rerequestCount: integer expected";
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                if (!$util.isInteger(message.timeTakenS))
                    return "timeTakenS: integer expected";
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                switch (message.schedule) {
                default:
                    return "schedule: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a GroupHistoryReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.GroupHistoryReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.GroupHistoryReport} GroupHistoryReport
         */
        GroupHistoryReport.fromObject = function fromObject(object) {
            if (object instanceof $root.server.GroupHistoryReport)
                return object;
            var message = new $root.server.GroupHistoryReport();
            if (object.gid != null)
                message.gid = String(object.gid);
            if (object.numExpected != null)
                message.numExpected = object.numExpected >>> 0;
            if (object.numDecrypted != null)
                message.numDecrypted = object.numDecrypted >>> 0;
            if (object.originalVersion != null)
                message.originalVersion = String(object.originalVersion);
            if (object.rerequestCount != null)
                message.rerequestCount = object.rerequestCount >>> 0;
            if (object.timeTakenS != null)
                message.timeTakenS = object.timeTakenS >>> 0;
            switch (object.schedule) {
            case "DAILY":
            case 0:
                message.schedule = 0;
                break;
            case "RESULT_BASED":
            case 1:
                message.schedule = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupHistoryReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.GroupHistoryReport
         * @static
         * @param {server.GroupHistoryReport} message GroupHistoryReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupHistoryReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = "";
                object.numExpected = 0;
                object.numDecrypted = 0;
                object.originalVersion = "";
                object.rerequestCount = 0;
                object.timeTakenS = 0;
                object.schedule = options.enums === String ? "DAILY" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.numExpected != null && message.hasOwnProperty("numExpected"))
                object.numExpected = message.numExpected;
            if (message.numDecrypted != null && message.hasOwnProperty("numDecrypted"))
                object.numDecrypted = message.numDecrypted;
            if (message.originalVersion != null && message.hasOwnProperty("originalVersion"))
                object.originalVersion = message.originalVersion;
            if (message.rerequestCount != null && message.hasOwnProperty("rerequestCount"))
                object.rerequestCount = message.rerequestCount;
            if (message.timeTakenS != null && message.hasOwnProperty("timeTakenS"))
                object.timeTakenS = message.timeTakenS;
            if (message.schedule != null && message.hasOwnProperty("schedule"))
                object.schedule = options.enums === String ? $root.server.GroupHistoryReport.Schedule[message.schedule] : message.schedule;
            return object;
        };

        /**
         * Converts this GroupHistoryReport to JSON.
         * @function toJSON
         * @memberof server.GroupHistoryReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupHistoryReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Schedule enum.
         * @name server.GroupHistoryReport.Schedule
         * @enum {number}
         * @property {number} DAILY=0 DAILY value
         * @property {number} RESULT_BASED=1 RESULT_BASED value
         */
        GroupHistoryReport.Schedule = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DAILY"] = 0;
            values[valuesById[1] = "RESULT_BASED"] = 1;
            return values;
        })();

        return GroupHistoryReport;
    })();

    server.Permissions = (function() {

        /**
         * Properties of a Permissions.
         * @memberof server
         * @interface IPermissions
         * @property {server.Permissions.Type|null} [type] Permissions type
         * @property {server.Permissions.Status|null} [status] Permissions status
         */

        /**
         * Constructs a new Permissions.
         * @memberof server
         * @classdesc Represents a Permissions.
         * @implements IPermissions
         * @constructor
         * @param {server.IPermissions=} [properties] Properties to set
         */
        function Permissions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Permissions type.
         * @member {server.Permissions.Type} type
         * @memberof server.Permissions
         * @instance
         */
        Permissions.prototype.type = 0;

        /**
         * Permissions status.
         * @member {server.Permissions.Status} status
         * @memberof server.Permissions
         * @instance
         */
        Permissions.prototype.status = 0;

        /**
         * Creates a new Permissions instance using the specified properties.
         * @function create
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions=} [properties] Properties to set
         * @returns {server.Permissions} Permissions instance
         */
        Permissions.create = function create(properties) {
            return new Permissions(properties);
        };

        /**
         * Encodes the specified Permissions message. Does not implicitly {@link server.Permissions.verify|verify} messages.
         * @function encode
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified Permissions message, length delimited. Does not implicitly {@link server.Permissions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Permissions
         * @static
         * @param {server.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer.
         * @function decode
         * @memberof server.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Permissions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Permissions message.
         * @function verify
         * @memberof server.Permissions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Permissions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Permissions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Permissions} Permissions
         */
        Permissions.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Permissions)
                return object;
            var message = new $root.server.Permissions();
            switch (object.type) {
            case "CONTACTS":
            case 0:
                message.type = 0;
                break;
            case "NOTIFICATIONS":
            case 1:
                message.type = 1;
                break;
            }
            switch (object.status) {
            case "ALLOWED":
            case 0:
                message.status = 0;
                break;
            case "DENIED":
            case 1:
                message.status = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Permissions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Permissions
         * @static
         * @param {server.Permissions} message Permissions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Permissions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "CONTACTS" : 0;
                object.status = options.enums === String ? "ALLOWED" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Permissions.Type[message.type] : message.type;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.server.Permissions.Status[message.status] : message.status;
            return object;
        };

        /**
         * Converts this Permissions to JSON.
         * @function toJSON
         * @memberof server.Permissions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Permissions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name server.Permissions.Type
         * @enum {number}
         * @property {number} CONTACTS=0 CONTACTS value
         * @property {number} NOTIFICATIONS=1 NOTIFICATIONS value
         */
        Permissions.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONTACTS"] = 0;
            values[valuesById[1] = "NOTIFICATIONS"] = 1;
            return values;
        })();

        /**
         * Status enum.
         * @name server.Permissions.Status
         * @enum {number}
         * @property {number} ALLOWED=0 ALLOWED value
         * @property {number} DENIED=1 DENIED value
         */
        Permissions.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALLOWED"] = 0;
            values[valuesById[1] = "DENIED"] = 1;
            return values;
        })();

        return Permissions;
    })();

    server.Call = (function() {

        /**
         * Properties of a Call.
         * @memberof server
         * @interface ICall
         * @property {string|null} [callId] Call callId
         * @property {number|Long|null} [peerUid] Call peerUid
         * @property {server.Call.CallType|null} [type] Call type
         * @property {server.Call.CallDirection|null} [direction] Call direction
         * @property {boolean|null} [answered] Call answered
         * @property {boolean|null} [connected] Call connected
         * @property {number|Long|null} [durationMs] Call durationMs
         * @property {string|null} [endCallReason] Call endCallReason
         * @property {boolean|null} [localEndCall] Call localEndCall
         * @property {server.Call.NetworkType|null} [networkType] Call networkType
         * @property {string|null} [webrtcStats] Call webrtcStats
         */

        /**
         * Constructs a new Call.
         * @memberof server
         * @classdesc Represents a Call.
         * @implements ICall
         * @constructor
         * @param {server.ICall=} [properties] Properties to set
         */
        function Call(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Call callId.
         * @member {string} callId
         * @memberof server.Call
         * @instance
         */
        Call.prototype.callId = "";

        /**
         * Call peerUid.
         * @member {number|Long} peerUid
         * @memberof server.Call
         * @instance
         */
        Call.prototype.peerUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Call type.
         * @member {server.Call.CallType} type
         * @memberof server.Call
         * @instance
         */
        Call.prototype.type = 0;

        /**
         * Call direction.
         * @member {server.Call.CallDirection} direction
         * @memberof server.Call
         * @instance
         */
        Call.prototype.direction = 0;

        /**
         * Call answered.
         * @member {boolean} answered
         * @memberof server.Call
         * @instance
         */
        Call.prototype.answered = false;

        /**
         * Call connected.
         * @member {boolean} connected
         * @memberof server.Call
         * @instance
         */
        Call.prototype.connected = false;

        /**
         * Call durationMs.
         * @member {number|Long} durationMs
         * @memberof server.Call
         * @instance
         */
        Call.prototype.durationMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Call endCallReason.
         * @member {string} endCallReason
         * @memberof server.Call
         * @instance
         */
        Call.prototype.endCallReason = "";

        /**
         * Call localEndCall.
         * @member {boolean} localEndCall
         * @memberof server.Call
         * @instance
         */
        Call.prototype.localEndCall = false;

        /**
         * Call networkType.
         * @member {server.Call.NetworkType} networkType
         * @memberof server.Call
         * @instance
         */
        Call.prototype.networkType = 0;

        /**
         * Call webrtcStats.
         * @member {string} webrtcStats
         * @memberof server.Call
         * @instance
         */
        Call.prototype.webrtcStats = "";

        /**
         * Creates a new Call instance using the specified properties.
         * @function create
         * @memberof server.Call
         * @static
         * @param {server.ICall=} [properties] Properties to set
         * @returns {server.Call} Call instance
         */
        Call.create = function create(properties) {
            return new Call(properties);
        };

        /**
         * Encodes the specified Call message. Does not implicitly {@link server.Call.verify|verify} messages.
         * @function encode
         * @memberof server.Call
         * @static
         * @param {server.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callId != null && Object.hasOwnProperty.call(message, "callId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.callId);
            if (message.peerUid != null && Object.hasOwnProperty.call(message, "peerUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.peerUid);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.direction);
            if (message.answered != null && Object.hasOwnProperty.call(message, "answered"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.answered);
            if (message.connected != null && Object.hasOwnProperty.call(message, "connected"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connected);
            if (message.durationMs != null && Object.hasOwnProperty.call(message, "durationMs"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.durationMs);
            if (message.endCallReason != null && Object.hasOwnProperty.call(message, "endCallReason"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.endCallReason);
            if (message.localEndCall != null && Object.hasOwnProperty.call(message, "localEndCall"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.localEndCall);
            if (message.networkType != null && Object.hasOwnProperty.call(message, "networkType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.networkType);
            if (message.webrtcStats != null && Object.hasOwnProperty.call(message, "webrtcStats"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.webrtcStats);
            return writer;
        };

        /**
         * Encodes the specified Call message, length delimited. Does not implicitly {@link server.Call.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.Call
         * @static
         * @param {server.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Call message from the specified reader or buffer.
         * @function decode
         * @memberof server.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.Call();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callId = reader.string();
                    break;
                case 2:
                    message.peerUid = reader.uint64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.direction = reader.int32();
                    break;
                case 5:
                    message.answered = reader.bool();
                    break;
                case 6:
                    message.connected = reader.bool();
                    break;
                case 7:
                    message.durationMs = reader.uint64();
                    break;
                case 9:
                    message.endCallReason = reader.string();
                    break;
                case 10:
                    message.localEndCall = reader.bool();
                    break;
                case 11:
                    message.networkType = reader.int32();
                    break;
                case 20:
                    message.webrtcStats = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Call message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Call message.
         * @function verify
         * @memberof server.Call
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Call.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callId != null && message.hasOwnProperty("callId"))
                if (!$util.isString(message.callId))
                    return "callId: string expected";
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (!$util.isInteger(message.peerUid) && !(message.peerUid && $util.isInteger(message.peerUid.low) && $util.isInteger(message.peerUid.high)))
                    return "peerUid: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.direction != null && message.hasOwnProperty("direction"))
                switch (message.direction) {
                default:
                    return "direction: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.answered != null && message.hasOwnProperty("answered"))
                if (typeof message.answered !== "boolean")
                    return "answered: boolean expected";
            if (message.connected != null && message.hasOwnProperty("connected"))
                if (typeof message.connected !== "boolean")
                    return "connected: boolean expected";
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))
                    return "durationMs: integer|Long expected";
            if (message.endCallReason != null && message.hasOwnProperty("endCallReason"))
                if (!$util.isString(message.endCallReason))
                    return "endCallReason: string expected";
            if (message.localEndCall != null && message.hasOwnProperty("localEndCall"))
                if (typeof message.localEndCall !== "boolean")
                    return "localEndCall: boolean expected";
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                switch (message.networkType) {
                default:
                    return "networkType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.webrtcStats != null && message.hasOwnProperty("webrtcStats"))
                if (!$util.isString(message.webrtcStats))
                    return "webrtcStats: string expected";
            return null;
        };

        /**
         * Creates a Call message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.Call
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.Call} Call
         */
        Call.fromObject = function fromObject(object) {
            if (object instanceof $root.server.Call)
                return object;
            var message = new $root.server.Call();
            if (object.callId != null)
                message.callId = String(object.callId);
            if (object.peerUid != null)
                if ($util.Long)
                    (message.peerUid = $util.Long.fromValue(object.peerUid)).unsigned = true;
                else if (typeof object.peerUid === "string")
                    message.peerUid = parseInt(object.peerUid, 10);
                else if (typeof object.peerUid === "number")
                    message.peerUid = object.peerUid;
                else if (typeof object.peerUid === "object")
                    message.peerUid = new $util.LongBits(object.peerUid.low >>> 0, object.peerUid.high >>> 0).toNumber(true);
            switch (object.type) {
            case "UNKNOWN_TYPE":
            case 0:
                message.type = 0;
                break;
            case "AUDIO":
            case 1:
                message.type = 1;
                break;
            case "VIDEO":
            case 2:
                message.type = 2;
                break;
            }
            switch (object.direction) {
            case "UNKNOWN_DIRECTION":
            case 0:
                message.direction = 0;
                break;
            case "OUTGOING":
            case 1:
                message.direction = 1;
                break;
            case "INCOMING":
            case 2:
                message.direction = 2;
                break;
            }
            if (object.answered != null)
                message.answered = Boolean(object.answered);
            if (object.connected != null)
                message.connected = Boolean(object.connected);
            if (object.durationMs != null)
                if ($util.Long)
                    (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = true;
                else if (typeof object.durationMs === "string")
                    message.durationMs = parseInt(object.durationMs, 10);
                else if (typeof object.durationMs === "number")
                    message.durationMs = object.durationMs;
                else if (typeof object.durationMs === "object")
                    message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber(true);
            if (object.endCallReason != null)
                message.endCallReason = String(object.endCallReason);
            if (object.localEndCall != null)
                message.localEndCall = Boolean(object.localEndCall);
            switch (object.networkType) {
            case "UNKNOWN_NETWORK":
            case 0:
                message.networkType = 0;
                break;
            case "WIFI":
            case 1:
                message.networkType = 1;
                break;
            case "CELLULAR":
            case 2:
                message.networkType = 2;
                break;
            }
            if (object.webrtcStats != null)
                message.webrtcStats = String(object.webrtcStats);
            return message;
        };

        /**
         * Creates a plain object from a Call message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.Call
         * @static
         * @param {server.Call} message Call
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Call.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.callId = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.peerUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.peerUid = options.longs === String ? "0" : 0;
                object.type = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.direction = options.enums === String ? "UNKNOWN_DIRECTION" : 0;
                object.answered = false;
                object.connected = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.durationMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.durationMs = options.longs === String ? "0" : 0;
                object.endCallReason = "";
                object.localEndCall = false;
                object.networkType = options.enums === String ? "UNKNOWN_NETWORK" : 0;
                object.webrtcStats = "";
            }
            if (message.callId != null && message.hasOwnProperty("callId"))
                object.callId = message.callId;
            if (message.peerUid != null && message.hasOwnProperty("peerUid"))
                if (typeof message.peerUid === "number")
                    object.peerUid = options.longs === String ? String(message.peerUid) : message.peerUid;
                else
                    object.peerUid = options.longs === String ? $util.Long.prototype.toString.call(message.peerUid) : options.longs === Number ? new $util.LongBits(message.peerUid.low >>> 0, message.peerUid.high >>> 0).toNumber(true) : message.peerUid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.Call.CallType[message.type] : message.type;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = options.enums === String ? $root.server.Call.CallDirection[message.direction] : message.direction;
            if (message.answered != null && message.hasOwnProperty("answered"))
                object.answered = message.answered;
            if (message.connected != null && message.hasOwnProperty("connected"))
                object.connected = message.connected;
            if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                if (typeof message.durationMs === "number")
                    object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;
                else
                    object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber(true) : message.durationMs;
            if (message.endCallReason != null && message.hasOwnProperty("endCallReason"))
                object.endCallReason = message.endCallReason;
            if (message.localEndCall != null && message.hasOwnProperty("localEndCall"))
                object.localEndCall = message.localEndCall;
            if (message.networkType != null && message.hasOwnProperty("networkType"))
                object.networkType = options.enums === String ? $root.server.Call.NetworkType[message.networkType] : message.networkType;
            if (message.webrtcStats != null && message.hasOwnProperty("webrtcStats"))
                object.webrtcStats = message.webrtcStats;
            return object;
        };

        /**
         * Converts this Call to JSON.
         * @function toJSON
         * @memberof server.Call
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Call.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * CallType enum.
         * @name server.Call.CallType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} AUDIO=1 AUDIO value
         * @property {number} VIDEO=2 VIDEO value
         */
        Call.CallType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "AUDIO"] = 1;
            values[valuesById[2] = "VIDEO"] = 2;
            return values;
        })();

        /**
         * CallDirection enum.
         * @name server.Call.CallDirection
         * @enum {number}
         * @property {number} UNKNOWN_DIRECTION=0 UNKNOWN_DIRECTION value
         * @property {number} OUTGOING=1 OUTGOING value
         * @property {number} INCOMING=2 INCOMING value
         */
        Call.CallDirection = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DIRECTION"] = 0;
            values[valuesById[1] = "OUTGOING"] = 1;
            values[valuesById[2] = "INCOMING"] = 2;
            return values;
        })();

        /**
         * NetworkType enum.
         * @name server.Call.NetworkType
         * @enum {number}
         * @property {number} UNKNOWN_NETWORK=0 UNKNOWN_NETWORK value
         * @property {number} WIFI=1 WIFI value
         * @property {number} CELLULAR=2 CELLULAR value
         */
        Call.NetworkType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_NETWORK"] = 0;
            values[valuesById[1] = "WIFI"] = 1;
            values[valuesById[2] = "CELLULAR"] = 2;
            return values;
        })();

        return Call;
    })();

    server.FabAction = (function() {

        /**
         * Properties of a FabAction.
         * @memberof server
         * @interface IFabAction
         * @property {server.FabAction.FabActionType|null} [type] FabAction type
         */

        /**
         * Constructs a new FabAction.
         * @memberof server
         * @classdesc Represents a FabAction.
         * @implements IFabAction
         * @constructor
         * @param {server.IFabAction=} [properties] Properties to set
         */
        function FabAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FabAction type.
         * @member {server.FabAction.FabActionType} type
         * @memberof server.FabAction
         * @instance
         */
        FabAction.prototype.type = 0;

        /**
         * Creates a new FabAction instance using the specified properties.
         * @function create
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction=} [properties] Properties to set
         * @returns {server.FabAction} FabAction instance
         */
        FabAction.create = function create(properties) {
            return new FabAction(properties);
        };

        /**
         * Encodes the specified FabAction message. Does not implicitly {@link server.FabAction.verify|verify} messages.
         * @function encode
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction} message FabAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FabAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified FabAction message, length delimited. Does not implicitly {@link server.FabAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof server.FabAction
         * @static
         * @param {server.IFabAction} message FabAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FabAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FabAction message from the specified reader or buffer.
         * @function decode
         * @memberof server.FabAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {server.FabAction} FabAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FabAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.server.FabAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FabAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof server.FabAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {server.FabAction} FabAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FabAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FabAction message.
         * @function verify
         * @memberof server.FabAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FabAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a FabAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof server.FabAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {server.FabAction} FabAction
         */
        FabAction.fromObject = function fromObject(object) {
            if (object instanceof $root.server.FabAction)
                return object;
            var message = new $root.server.FabAction();
            switch (object.type) {
            case "UNKNOWN_TYPE":
            case 0:
                message.type = 0;
                break;
            case "GALLERY":
            case 1:
                message.type = 1;
                break;
            case "AUDIO":
            case 2:
                message.type = 2;
                break;
            case "TEXT":
            case 3:
                message.type = 3;
                break;
            case "CAMERA":
            case 4:
                message.type = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FabAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof server.FabAction
         * @static
         * @param {server.FabAction} message FabAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FabAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "UNKNOWN_TYPE" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.server.FabAction.FabActionType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this FabAction to JSON.
         * @function toJSON
         * @memberof server.FabAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FabAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * FabActionType enum.
         * @name server.FabAction.FabActionType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} GALLERY=1 GALLERY value
         * @property {number} AUDIO=2 AUDIO value
         * @property {number} TEXT=3 TEXT value
         * @property {number} CAMERA=4 CAMERA value
         */
        FabAction.FabActionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "GALLERY"] = 1;
            values[valuesById[2] = "AUDIO"] = 2;
            values[valuesById[3] = "TEXT"] = 3;
            values[valuesById[4] = "CAMERA"] = 4;
            return values;
        })();

        return FabAction;
    })();

    return server;
})();

module.exports = $root;
